; Dimension Variablesdim obc1 as obcommdim b1 as buttondim t1 as textboxdim l1 as listboxdim tbr as comboboxdim cp as comboboxdim tdb as comboboxdim tsb as comboboxdim b2 as buttondim tl as longdim tw as integerdim tb as bytedim ts as stringdim tmr as timerOBMain.CREATEconstruct t1,10,10,200,20construct b1,10,40,200,20b1.text="Send"construct l1,220,10,170,270construct tbr,10,70,180,180tbr.text="9600"tbr.additem "1200"tbr.additem "2400"tbr.additem "4800"tbr.additem "9600"tbr.additem "19200"construct cp,10,100,180,180cp.text="NOPARITY"cp.additem "NOPARITY"cp.additem "ODDPARITY"cp.additem "EVENPARITY"cp.additem "MARKPARITY"cp.additem "SPACEPARITY"construct tdb,10,130,180,180tdb.text="8"tdb.additem "7"tdb.additem "8"construct tsb,10,160,180,180tsb.text="ONESTOPBIT"tsb.additem "TWOSTOPBITS"construct b2,10,190,180,20b2.text="Setup"b1.tooltip="Send"b1.tooltip="Setup"obc1.portname="COM1"obc1.baudrate=9600obc1.parity=NOPARITYobc1.databits=8obc1.stopbits=ONESTOPBITobc1.opent1.text=hex(STATUS)gosub getdcbEND EVENTb1.commandobc1.output=t1.textend eventb2.commandobc1.closets=tbr.textobc1.baudrate=val(ts)ts=cp.textselect case ts	case "NOPARITY"		tb=0	case "ODDPARITY"		tb=1	case "EVENPARITY"		tb=2	case "MARKPARITY"		tb=3	case "SPACEPARITY"		tb=4end selectobc1.parity=tbts=tdb.textobc1.databits=val(ts)if tsb.text="ONESTOPBIT" then	obc1.stopbits=0else	obc1.stopbits=2endifobc1.openl1.cleargosub getdcbend eventgetdcb:mov edi,obc1+!HandleOffsmov eax,[edi]mov [tl],eaxts="Handle=$"+hex(tl)l1.additem tsmov edi,obc1mov eax, dword [obc1+!DCBlengthOffs]mov [tl],eaxts="DCBlength="+str(tl)l1.additem tsmov eax, dword [obc1+!BaudRateOffs]mov [tl],eaxts="BaudRate="+str(tl)l1.additem tsmov eax, dword [obc1+!fBits]mov [tl],eaxts="fBits=$"+hex(tl)l1.additem tsmov ax, word [obc1+!wReservedOffs]mov [tw],axts="wReserved="+str(tw)l1.additem tsmov ax, word [obc1+!XonLimOffs]mov [tw],axts="XonLim="+str(tw)l1.additem tsmov ax, word [obc1+!XoffLimOffs]mov [tw],axts="XoffLim="+str(tw)l1.additem tsmov al, byte [obc1+!ByteSizeOffs]mov [tb],alts="ByteSize="+str(tb)l1.additem tsmov al, byte [obc1+!ParityOffs]mov [tb],alts="Parity="+str(tb)l1.additem tsmov al, byte [obc1+!StopBitsOffs]mov [tb],alts="StopBits="+str(tb)l1.additem tsmov al, byte [obc1+!XonCharOffs]mov [tb],alts="XonChar=$"+hex(tb)l1.additem tsmov al, byte [obc1+!XoffCharOffs]mov [tb],alts="XoffChar=$"+hex(tb)l1.additem tsmov al, byte [obc1+!ErrorCharOffs]mov [tb],alts="ErrorChar="+str(tb)l1.additem tsmov al, byte [obc1+!EofCharOffs]mov [tb],alts="EofChar="+str(tb)l1.additem tsmov al, byte [obc1+!EvtCharOffs]mov [tb],alts="EvtChar="+str(tb)l1.additem tsmov ax, word [obc1+!wReserved1Offs]mov [tw],axts="wReserved1="+str(tw)l1.additem tsreturn