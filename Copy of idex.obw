; OmniBasic Copyright 1995-2006 Innomation Systems, Inc.; All Rights Reserved;; This source file is provided for educational, documentary, and porting; purposes only. The recipient agrees to hold this information in strict; confidence. The recipient agrees to these terms by accepting this software; source code. Violations may result in criminal and/or civil penalties under; the copyright and trade secret laws of the United States of America.; Edition History; 10-19-02 OmniBasic release 1.44 as base for adaptation; 11-16-02 Began conversion to x86 asm; 01-22-05 Converted to IDE$exok; ************************************ IDE DIM's Here ********************************************MACRO DestroyWindow	USEIMPORT DestroyWindow	invoke DestroyWindow,[~1] END MACRODIM EditPopUp AS MENUDIM FormPopUp AS MENUDIM EventPopUp AS MENUDIM GridSizePopUp AS MENUDIM GridColorPopUp AS MENUDIM GripColorPopUp AS MENUdim dbgwin as formdim grid as ragriddim controlndx AS textboxdim controlptr AS textboxdim controlcount AS textboxdim controlname AS textboxdim controlptrsafe AS textboxdim controlndxlbl AS statictextdim controlptrlbl AS statictextdim controlcountlbl AS statictextdim controlnamelbl AS statictextdim controlptrsafelbl AS statictextdim refresh as button;dim codecomp as listboxTYPE PuppetData PuppetHandle AS LONG PuppetID AS LONG PuppetOwner AS LONG PuppetArray AS LONG PuppetLeft AS LONG PuppetTop AS LONG PuppetWidth AS LONG PuppetHeight AS LONG PuppetBackColor AS LONG PuppetForeColor AS LONG PuppetType AS LONG PuppetStatus AS LONG PuppetFont AS LONG PuppetOwnerParent AS LONG PuppethwndCombo AS LONG PuppethwndItem AS LONG PuppethwndList AS LONG PuppetIcon AS LONG PuppetControlType AS LONG PuppetStyle AS LONG PuppetExStyle AS LONG PuppetText AS STRING*32 PuppetName AS STRING*32 PuppetImage AS STRING*32END TYPECONST ControlTableSize=500DIM ControlArray(ControlTableSize) AS PuppetData;Spider ConstantsCONST Belly=1CONST NW=2CONST N=3CONST NE=4CONST W=5CONST E=6CONST SW=7CONST S=8CONST SE=9DIM ControlID AS LONGDIM PuppetIDDispenser(ControlTableSize) AS BOOLEANDIM ControlNdx AS LONG; For lookupsDIM ControlPtr AS LONG; For referencesDIM ControlPtrSafe AS LONGDIM PlacePtr AS LONGDIM ControlCount AS LONGDIM ControlNdxHi AS LONGDIM ControlFound AS BOOLEANDIM MoveControl AS BOOLEANDIM DrawRect AS BOOLEANDIM PlacePart AS BOOLEANDIM SnapToGrid AS BOOLEANDIM ShowGrid AS BOOLEANDIM SizeControl AS BOOLEANDIM ComboFlag AS BOOLEANDIM CaptureEnable AS BOOLEANDIM GridSize AS LONGDIM GridColor AS LONGDIM SizeSel AS LONGDIM ControlName AS STRING*32DIM ControlNameSafe AS STRING*32DIM OwnerName AS STRING*32DIM OwnerPtr AS LONGDIM CurrentFormPtr AS LONGDIM CurrentFormName AS STRING*32DIM LastControl AS LONGDIM OverControl AS LONGDIM TempStyle AS LONGDIM TempExStyle AS LONGDIM TempHandle AS LONGDIM TempOwner AS LONGDIM TempOwnerParent AS LONGDIM TempControlType AS LONGDIM TempLeft AS LONGDIM TempTop AS LONGDIM TempWidth AS LONGDIM TempHeight AS LONGDIM ChildOffsX AS LONGDIM ChildOffsY AS LONGDIM SpiderLeft AS LONGDIM SpiderTop AS LONGDIM SpiderWidth AS LONGDIM SpiderHeight AS LONGDIM SpiderRight AS LONGDIM SpiderBottom AS LONGDIM ControlLeft AS LONGDIM ControlTop AS LONGDIM ControlRight AS LONGDIM ControlBottom AS LONGDIM MouseOffsX AS LONGDIM MouseOffsY AS LONGDIM CleanCtr AS LONGDIM EventMenuCount AS LONGDIM Timer1 AS TIMERDIM Timer2 AS TIMERDIM Timer3 AS TIMERDIM Timer5 AS TIMERDIM MouseDown AS BOOLEANDIM RBDown AS BOOLEANDIM XOffset AS LONGDIM YOffset AS LONGDIM Spider(9) AS STATICTEXTDIM SpiderNdx AS LONGDIM SpiderPtr AS LONGDIM SpiderPlaced AS BOOLEANDIM SpiderFound AS BOOLEANDIM CursorSafe AS CURSORDIM NewWindow AS TOOLWINDOWDIM NewWindowConstructed AS BOOLEANDIM ProjectButton AS BUTTONDIM WindowPgmButton AS BUTTONDIM ConsolePgmButton AS BUTTONDIM DLLButton AS BUTTONDIM ControlButton AS BUTTONDIM CancelButton AS BUTTONDIM GotoWindow AS TOOLWINDOWDIM GotoWindowConstructed AS BOOLEANDIM GotoText AS TEXTBOXDIM GotoButton AS BUTTONDIM ScratchPadWindow AS TOOLWINDOWDIM ScratchPadWindowConstructed AS BOOLEANDIM ScratchPadText AS TEXTBOXDIM FindWindow AS TOOLWINDOWDIM FindWindowConstructed AS BOOLEANDIM FindWindowActive AS BOOLEANDIM UpDown AS FRAMEDIM UpButton AS RADIOBUTTONDIM DownButton AS RADIOBUTTONDIM MatchWholeWord AS CHECKBOXDIM MatchCase AS CHECKBOXDIM FindNext AS BUTTONDIM Cancel AS BUTTONDIM FindText AS TEXTBOXDIM FindWhat AS STATICTEXTDIM FindReplaceWindow AS TOOLWINDOWDIM FRWindowConstructed AS BOOLEANDIM FRWindowActive AS BOOLEANDIM FRMatchWholeWord AS CHECKBOXDIM FRMatchCase AS CHECKBOXDIM FRFindNext AS BUTTONDIM FRReplace AS BUTTONDIM FRReplaceAll AS BUTTONDIM FRCancel AS BUTTONDIM FRFindText AS TEXTBOXDIM FRReplaceText AS TEXTBOXDIM FRFindWhat AS STATICTEXTDIM FRReplaceWith AS STATICTEXTDIM Button(23) AS BUTTONDIM EventCombo1 AS COMBOBOXDIM EventCombo2 AS COMBOBOXDIM QuickFind AS TEXTBOXDIM QuickFindPrev AS BUTTONDIM QuickFindNext AS BUTTONDIM sbParts(6) AS LONGDIM GraphicConstructed AS BOOLEANDIM ToolBox AS FORMDIM ToolButton(40) AS BUTTONDIM FormCombo AS COMBOBOXDIM ControlCombo AS COMBOBOXDIM NudgePosButton(8) AS BUTTONDIM NudgeSizeButton(8) AS BUTTONDIM PropGrid AS RAGRIDDIM StyleGrid AS RAGRIDDIM ExStyleGrid AS RAGRIDDIM FormWindow AS FORMDIM MinMaxFlag AS BOOLEANDIM FormWindowConstructed AS BOOLEANDIM StyleGridRow AS LONGDIM ExStyleGridRow AS LONGDIM UnDoFlag AS BOOLEANDIM ReDoFlag AS BOOLEANDim lf As LOGFONTDim lRet AS LONGDim szFont AS STRINGDIM szRegs AS STRING*1000DIM szAsmInst AS STRING*1000DIM szBasicInst AS STRING*1000DIM szGUIInst AS STRING*1000DIM szGUIProps AS STRING*1000DIM szGUIProps2 AS STRING*1000DIM szMasm AS STRING*1000DIM szFcns AS STRING*1000DIM szDataType AS STRING*1000DIM LF1 AS LOGFONTDIM Font1 AS FONTDIM GridFont AS FONTDIM OmniIcon AS ICONDIM ToolBitmap AS BITMAPDIM ToolIcon AS ICONDIM FormBMP AS BITMAPDIM ButtonBMP AS BITMAPDIM StaticTextBMP AS BITMAPDIM FrameBMP AS BITMAPDIM SliderBMP AS BITMAPDIM TextBoxBMP AS BITMAPDIM ComboBoxBMP AS BITMAPDIM ListBoxBMP AS BITMAPDIM RadioButtonBMP AS BITMAPDIM CheckBoxBMP AS BITMAPDIM ProgressBarBMP AS BITMAPDIM CalendarBMP AS BITMAPDIM TabFolderBMP AS BITMAPDIM SpinnerBMP AS BITMAPDIM StatusBarBMP AS BITMAPDIM HeaderBMP AS BITMAPDIM AnimateBMP AS BITMAPDIM RichEditBMP AS BITMAPDIM RAEditBMP AS BITMAPDIM RAGridBMP AS BITMAPDIM ListViewBMP AS BITMAPDIM ToolBarBMP AS BITMAPDIM TreeViewBMP AS BITMAPDIM DateTimePickBMP AS BITMAPDIM ImageBMP AS BITMAPDIM DrawProgressBMP AS BITMAPDIM NewBMP AS BITMAPDIM OpenBMP AS BITMAPDIM SaveBMP AS BITMAPDIM SaveAsBMP AS BITMAPDIM PrintBMP AS BITMAPDIM ToolBMP AS BITMAPDIM EditBMP AS BITMAPDIM UndoBMP AS BITMAPDIM RedoBMP AS BITMAPDIM DeleteBMP AS BITMAPDIM CutBMP AS BITMAPDIM CopyBMP AS BITMAPDIM PasteBMP AS BITMAPDIM GotoBMP AS BITMAPDIM FindBMP AS BITMAPDIM ReplaceBMP AS BITMAPDIM CompileToExeBMP AS BITMAPDIM CompileToAsmBMP AS BITMAPDIM CompileForErrBMP AS BITMAPDIM CompileForDebugBMP AS BITMAPDIM SymbolsBMP AS BITMAPDIM UnusedSymBMP AS BITMAPDIM RunBMP AS BITMAPDIM HelpBMP AS BITMAPDIM QFindNextBMP AS BITMAPDIM QFindPrevBMP AS BITMAPDIM font AS FONTDIM RAFont(3) AS FONTDIM Edit AS RAEDITDIM SymbolGrid AS RAGRIDDIM BackGround AS STATICTEXTDIM StatusBar AS STATUSBARDIM ToolBar AS TOOLBARDIM FileName AS STRINGDIM BMPFileName AS STRINGDIM SaveFileName AS STRINGDIM FileFilter AS TEXTDIM BMPFileFilter AS TEXTDIM Extension AS STRING*4DIM InitDir AS STRINGDIM BMPInitDir AS STRINGDIM Changed AS BOOLEANDIM BasicAsm AS BOOLEANDIM TempBool AS BOOLEANDIM TextMode AS BOOLEANDIM ToolView AS BOOLEANDIM PropView AS BOOLEANDIM StyleView AS BOOLEANDIM ShowSymbols AS BOOLEANDIM FindStr AS STRINGDIM SelectStr AS STRINGDIM ReplaceStr AS STRINGDIM FontStr AS STRINGDIM RGB AS LONGDIM row AS LONGDIM col AS LONGDIM StatusBarSafe1 AS STRING*32DIM StatusBarSafe2 AS STRING*32DIM StatusBarSafe3 AS STRING*32DIM StatusBarSafe4 AS STRING*32DIM StatusBarSafe5 AS STRING*32;*********************************** Compiler Macros, DIM's, CONST's etc *************************; MACROSMACRO GenConstCONST ~2=~3CONST ptr~2=~3-99OutBuf="!~1_~2 equ ~3"GOSUB OutUninitDataENDMACROMACRO IncArrayNdxGOSUB IncrArrayNdxENDMACROMACRO DecArrayNdxGOSUB DecrArrayNdxENDMACROMACRO GenEquateCONST ~1=~2OutBuf="~1 equ ~2"GOSUB OutDeclareENDMACROMACRO IncExpNdxINCR ExpNdxExpLen=ExpNdxENDMACROMACRO CommaRetGOSUB GetCommaErrRetENDMACROMACRO CommaMainGOSUB GetCommaErrMainENDMACROMACRO ColonRetGOSUB GetColonErrRetENDMACROMACRO ColonMainGOSUB GetColonErrMainENDMACROMACRO EqualRetGOSUB GetEqualErrRetENDMACROMACRO EqualMainGOSUB GetEqualErrMainENDMACROMACRO MakeLongIF LAND(TDataMod,PointerBit)=PointerBit THEN	TDataType=LONGVAREND IFENDMACROMACRO ErrRetIF ErrNo<>0 THEN	RETURNEND IFENDMACROMACRO ErrMainIF ErrNo<>0 THEN MainLoopENDMACROMACRO ErrGUIIF GUIFlag=FALSE THEN GUIFatalENDMACROENUM 1 ErrUDSym ErrIVSNam ErrTypMis ErrIVExp ErrSyntax ErrDupSym ErrSymFul ErrUDFcn ErrIVType ErrIVMod ErrMacArg ErrIVDir ErrDupMac ErrEndStr ErrMacNst ErrMacBuf ErrIVMac ErrEndm ErrUBCon ErrNDeep ErrDecFcn ErrIVParm ErrParam ErrCpxExp ErrIVFunc ErrTmpUse ErrParen ErrFcn ErrIVTarg ErrFSNest ErrTblArr ErrEndFcn ErrArrSub ErrEndProc ErrEndTbl ErrTblArgs ErrFcnArgs ErrTypeFcn ErrDupEvent ErrIVProp ErrEndEvent ErrOpRange ErrTextArray ErrTextDefined ErrTextNotDefined ErrEndTask ErrEndSub ErrExitEvent ErrExitProc ErrExitTask ErrExitSub ErrExitSeg ErrEndSeg ErrSegInSeg ErrDeviceEND ENUMENUM 0 COMPVAR BOOLVAR BYTEVAR WORDVAR LONGVAR FLOATVAR STRINGVAR LABELVAR MACROVAR OPER FCN PROC TYPE VOIDX COMPLEX BUFFER LABELPTR TEXT OBCOMM TIMEDIF QUADVAREND ENUMENUM 0 NONE FILE DEVICE FONT ICON CURSOR BITMAP HANDLE MENU TASK PIPEEND ENUMCONST STYLE=1CONST EXSTYLE=2ENUM 1 STDCTL COMCTL CUSCTL DLLCTL TIMCTL OCXCTLEND ENUM; Must keep this ENUM in sync with ImportLibTableENUM 1ptrkernel32ptruser32ptrgdiptrcomctlptrcomdlgptrshellptradvapiptrwinmmptrmsvcrtptrcsmdllptrricheditptrimagelibEND ENUM; Must keep this ENUM in sync with ImportFcnTableENUM 1ptrBeepptrSetThreadPriorityptrSleepptrCreateThreadptrSuspendThreadptrResumeThreadptrClearCommErrorptrCloseHandleptrCreateDirectoryptrCreateFileptrCreatePipeptrCreateProcessptrDeleteFileptrExitProcessptrGetCommandLineptrGetCurrentProcessptrGetCurrentDirectoryptrGetFileSizeptrGetFileTypeptrGetFullPathNameptrGetLastErrorptrGetModuleHandleptrGetStdHandleptrGetTickCountptrGetSystemTimeptrGetLocalTimeptrGetDateFormatptrGetTimeFormatptrFileTimeToSystemTimeptrSystemTimeToFileTimeptrLoadLibraryptrReadConsoleptrReadFileptrRemoveDirectoryptrSetCurrentDirectoryptrSetCommMaskptrGetCommStateptrSetCommStateptrSetFilePointerptrSetEndOfFileptrVirtualAllocptrVirtualFreeptrWinExecptrWriteConsoleptrWriteFileptrAppendMenuptrBeginPaintptrEndPaintptrGetDCptrGetFocusptrReleaseDCptrCallWindowProcptrCheckDlgButtonptrCheckMenuItemptrCheckRadioButtonptrChildWindowFromPointptrCreateIconFromResourceptrCreateMenuptrCreatePopupMenuptrCreateWindowExptrDefWindowProcptrDeleteMenuptrDestroyWindowptrDispatchMessageptrDrawMenuBarptrEnableMenuItemptrEnableWindowptrFlashWindowptrGetAncestorptrGetClientRectptrGetComboBoxInfoptrGetCursorPosptrSetCursorPosptrGetCursorptrSetCursorptrGetMessageptrGetActiveWindowptrGetParentptrGetWindowRectptrIsIconicptrHiliteMenuItemptrInvalidateRectptrInsertMenuptrInsertMenuItemptrIsWindowEnabledptrIsWindowVisibleptrKillTimerptrLoadCursorptrLoadIconptrLoadImageptrLoadMenuptrMessageBoxptrModifyMenuptrPostMessageptrMoveWindowptrPostQuitMessageptrRedrawWindowptrRegisterClassptrRegisterWindowMessageptrReleaseCaptureptrRemoveMenuptrScreenToClientptrSendMessageptrSetCaptureptrSetClassLongptrSetFocusptrSetMenuptrSetMenuItemBitmapsptrSetTimerptrGetWindowLongptrSetWindowLongptrSetWindowPosptrShowWindowptrUpdateWindowptrTrackPopupMenuExptrTranslateMessageptrCreateCompatibleDCptrCreateDIBSectionptrCreateFontIndirectptrCreateSolidBrushptrDeleteObjectptrGetPixelptrSetPixelptrGetBkColorptrSetBkColorptrSetBkModeptrGetStockObjectptrSetTextColorptrInitCommonControlsExptrTrackMouseEventptrChooseFontptrChooseColorptrGetOpenFileNameptrGetSaveFileNameptrFindTextptrReplaceTextptrDragAcceptFilesptrShellExecuteptrShellNotifyIconptrRegCreateKeyExptrRegCloseKeyptrsndPlaySoundptrabsptratolptrltoaptrprintfptrputsptrsprintfptrsystemptrCSMGetDriveHandleptrCSMDriveStatusptrCSMReadBlockptrCSMReleaseDriveHandleptrCSMWriteBlockptrCreateTextServicesptrBitmapFromFileptrBitmapFromMemoryptrBitmapFromPictureptrBitmapFromResourceEND ENUMCONST ArrayBit=$0001CONST PointerBit=$0002CONST ConstBit=$0004CONST MultiBit=$0008CONST MemberBit=$0010CONST VectorBit=$0020CONST TempBit=$0040CONST DataBit=$0080CONST ReDimBit=$0100CONST UsrFcnBit=$0200CONST CalledBit=$0400CONST SubClassedBit=$0800CONST DateTimeBit=$1000CONST TextDefinedBit=$2000CONST LogFontBit=$4000CONST InitDataBit=$8000CONST TmpVec=$60CONST ArrayMsk=$fffeCONST evActivateUsed=0CONST evCommandUsed=1CONST evMouseDownUsed=2CONST evSpareUsed=3CONST evLButtonDownUsed=4CONST evLButtonUpUsed=5CONST evScrollUsed=6CONST evSysCommandUsed=7CONST evKeyDownUsed=8CONST evKeyUpUsed=9CONST evClickUsed=10CONST evChangeUsed=11CONST evSelectUsed=12CONST evCreateUsed=13CONST evResizeUsed=14CONST evMoveUsed=15CONST evMouseActivateUsed=16CONST evPaintUsed=17CONST evSpareUsed=18CONST evMouseMoveUsed=19CONST evMouseWheelUsed=20CONST evDestroyUsed=21CONST evDblClickUsed=22CONST evRButtonDownUsed=23CONST evRButtonUpUsed=24CONST evContextMenuUsed=25CONST evKeyStruckUsed=26CONST evReserved3Used=27CONST evReserved4Used=28CONST evReserved5Used=29CONST evReserved6Used=30CONST evReserved7Used=31CONST evNotify1Used=32CONST evNotify2Used=33CONST evNotify3Used=34CONST evNotify4Used=35CONST evNotify5Used=36CONST evNotify6Used=37CONST evNotify7Used=38CONST evNotify8Used=39CONST evNotify9Used=40CONST evNotify10Used=41CONST evNotify11Used=42CONST evNotify12Used=43CONST evNotify13Used=44CONST evNotify14Used=45CONST evNotify15Used=46CONST evNotify16Used=47CONST evNotify17Used=48CONST evNotify18Used=49CONST evNotify19Used=50CONST evNotify20Used=51CONST evNotify21Used=52CONST evNotify22Used=53CONST evNotify23Used=54CONST evNotify24Used=55CONST evNotify25Used=56CONST evNotify260Used=57CONST evNotify271Used=58CONST evNotify28Used=59CONST evNotify29Used=60CONST evNotify30Used=61CONST evNotify31Used=62CONST evNotify32Used=63CONST NULLClass=0CONST INTClass=1CONST STRClass=2CONST ARRClass=3CONST CPXClass=4CONST FLTClass=5CONST BOOLClass=6CONST OBJClass=7CONST FRMClass=8CONST LBLClass=9CONST TTypRelOp=1CONST TTypPunct=2CONST TTypMath=3CONST TTypQuote=4CONST TTypSym=5CONST TTypInt=6CONST TTypHex=7CONST TTypParen=8CONST TTypMisc=9CONST TTypFloat=10CONST TTypOct=11CONST TTypBin=12CONST PTArrOpn=3CONST PTArrCls=4CONST PTFcnOpn=5CONST PTFcnCls=6CONST PTCpxOpn=24CONST PTFCpxCls=25CONST NumTemps=15CONST OBQUOTE=$22CONST LabelResolved=$ffCONST LabelUnresolved=0CONST _BufSize=1000CONST MacBufSiz=50000CONST ExpTabSiz=300CONST UserSym=304;  set to first user symbol in PreDefinedCONST SymTabSiz=4000; Asm Constants and VariablesTYPE IconData	idReserved AS INTEGER	idType AS INTEGER	idCount AS INTEGER	bWidth AS BYTE	bHeight AS BYTE	bColorCount AS BYTE	bReserved AS BYTE	wPlanes AS INTEGER	wBitCount AS INTEGER	dwBytesInRes AS LONG	dwImageOffset AS LONGEND TYPEDIM IconDir AS IconDataDIM ErrLineNum AS LONGDIM TextFound AS BOOLEANDIM ResourceFlag AS BOOLEANDIM ExportFlag AS BOOLEANDIM IconCursorFlag AS BOOLEANDIM DeferFlag AS BOOLEANDIM ediUsed AS BOOLEANDIM ExclamationOK AS BOOLEANDIM DataLabel AS BOOLEANDIM CmpOpFlag AS BOOLEANDIM HasSubscript AS BOOLEANDIM FindReplaceFlag AS BYTEDIM ByteArray(1) AS BYTE VECTORDIM MenuOp AS BYTEDIM FindReplace AS BYTEDIM OpenSave AS BYTEDIM TConst AS BYTEDIM D0Const AS BYTEDIM D1Const AS BYTEDIM FormExStyle AS STRING*100DIM ObjectCtr AS LONGDIM EnumVal AS LONGDIM EnumStep AS LONGDIM MenuIDNum AS LONGDIM TConstVal AS LONGDIM D0ConstVal AS LONGDIM D1ConstVal AS LONGDIM StartTime AS LONGDIM GUITempName AS STRING*28DIM GUIDataType AS INTEGERDIM GUITargetFlag AS BYTE;//DIM GUIObjFlag AS BYTE;//DIM GUIArrayFlag AS BYTEDIM TextFlag AS BYTEDIM ParentFlag AS BYTEDIM NotifyCode AS LONGDIM DescOffs AS LONGDIM SrcLineMod AS LONGDIM StyleCode AS LONGDIM TempStyleStr AS STRING*10DIM TempExStyleStr AS STRING*100DIM ObjectParent AS STRING*32DIM ObjectParentName AS STRING*30DIM HandleName AS STRING*28DIM ObjectType AS LONGDIM ObjectTypeSafe AS LONGDIM IgnoreRightParen AS BYTEDIM FcnTypes(8) AS BYTEDIM EndSegFlag AS BOOLEANDIM SegFlag AS BOOLEANDIM SubFlag AS BOOLEANDIM TaskFlag AS BOOLEANDIM ProcFlag AS BOOLEANDIM FcnFlag AS BOOLEANDIM ProcFcnFlag AS BOOLEANDIM EventFlag AS BOOLEANDIM ProcFcn AS BYTEDIM InitTrue AS BYTEDIM HasFcn AS BYTEDIM SimpleCmp AS BYTEDIM ComplexCmp AS BYTEDIM PathIsVector AS BYTEDIM RepeatFlag AS BYTEDIM RepeatCnt AS LONGDIM ArrayDetail AS LONGDIM ArrayDataType AS INTEGERDIM CpxArrayOffset AS LONGDIM OpSizeStr AS STRING*16DIM ForDataType AS INTEGERDIM D1Cleared AS BYTEDIM TableNdx AS LONGDIM TableTypeNdx AS LONGDIM TableName AS STRING*28DIM TableElements AS LONGDIM TableCounter AS LONGDIM CommaCounter AS LONGDIM ObjectDetail AS LONGDIM ObjectArray AS LONGDIM ObjectName AS STRING*28DIM ObjectNameSafe AS STRING*28DIM MenuWindowName AS STRING*28DIM MenuBarName AS STRING*28DIM MenuTitleName AS STRING*28DIM MenuItemName AS STRING*28DIM I AS LONGDIM J AS LONGDIM PI AS LONGDIM PTempInt AS LONGDIM FirstValidChar AS BOOLEANDIM InFlag AS BOOLEANDIM ChildFlag AS BOOLEANDIM CreateObjectFlag AS BOOLEANDIM FilBufSiz AS LONGDIM FilBufAdr AS LONGDIM ANSIArgCtr AS LONGDIM ObjType AS BYTEDIM ObjClass AS LONGDIM TempObjClass AS LONGDIM ObjSubClass AS LONGDIM GUIFlag AS BOOLEANDIM SubClassFlag AS BOOLEANDIM GUITargetSymNdx AS LONGDIM AsmOutFlag AS BOOLEANDIM DLLFlag AS BOOLEANDIM FloatFlag AS BYTEDIM ExpFlag AS BOOLEANDIM SubCtr AS BYTEDIM SubCtrSaf AS BYTEDIM MultiFlag AS BYTEDIM SubValue(3) AS LONGDIM SubValSaf(3) AS LONGDIM PrintPathFlag AS BYTEDIM Comment AS STRING*64DIM StatFlag AS BYTEDIM LopCtrNum AS LONGDIM LastSym AS LONGDIM LastKey AS LONGDIM LastImportFcn AS LONGDIM LastImportLib AS LONGDIM LastObj AS LONGDIM StartFlag AS BOOLEANDIM DataFlag AS BOOLEANDIM SelectFlag AS BOOLEANDIM CaseFlag AS BOOLEANDIM CaseElseFlag AS BOOLEANDIM CaseToFlag AS BOOLEANDIM XBufSize AS LONGDIM B AS STRING*10DIM BufRWFlg AS BYTEDIM NewLine AS BYTEDIM Fmt AS STRING*79DIM StringNum AS LONGDIM VectorFlag AS BYTEDIM VectorName AS STRING*28DIM DtaRegNum AS BYTEDIM LoopVars(100) AS STRING*28DIM LopVarNdx AS LONGDIM FcnName AS STRING*28DIM FcnDataMod AS LONGDIM FcnSymNdx AS LONGDIM NumArgs AS BYTEDIM TFcnArgs AS LONGDIM FloatOK AS BYTEDIM OneDot AS BYTEDIM LastExpression AS LONGDIM NoGen AS BOOLEANDIM OptNdx AS LONGDIM Opt AS STRING*1DIM CondValid AS BYTEDIM CondOp1 AS LONGDIM CondOp2 AS LONGDIM GenFlag(20) AS BYTEDIM GFNdx AS LONGDIM AddInst AS STRING*5DIM DecInc AS STRING*3DIM ArgStr AS STRING*28DIM VarSize AS LONGDIM SetMask AS BYTEDIM ArrayBase AS BYTEDIM TmpMax AS BYTEDIM TmpVecMax AS BYTEDIM FTmpMax AS BYTEDIM ChrTmpMax AS BYTEDIM StrTmpMax AS BYTEDIM PrintFlag AS BYTEDIM TabFlag AS BYTEDIM DevFlag AS BYTEDIM LastStmt AS STRING*8DIM FcnCode AS BYTEDIM OpenMode AS BYTEDIM DiskIO AS BYTEDIM FileIO AS BYTEDIM ReadFlag AS BYTEDIM AndOrFlag AS BYTEDIM CompFlag AS BYTEDIM Promote AS BYTEDIM Demote AS BYTEDIM DataOp AS BYTEDIM MathOp AS BYTEDIM LdRegName AS STRING*16DIM Reg0Name AS STRING*16DIM Reg1Name AS STRING*16DIM _DataType AS STRING*16DIM DWSafe AS STRING*3DIM D0Loaded AS BYTEDIM Target AS BYTEDIM TmpUse AS LONGDIM TmpVecUse AS LONGDIM FTmpUse AS LONGDIM ChrTmpUse AS LONGDIM StrTmpUse AS LONGDIM Op1Class AS BYTEDIM Operator AS BYTEDIM Op2Class AS BYTEDIM OpClass AS BYTEDIM Op1Type AS BYTEDIM Op1Mod AS LONGDIM Op1Detail AS LONGDIM Op2Type AS BYTEDIM Op2Mod AS LONGDIM Op2Detail AS LONGDIM Op1Name AS STRING*42DIM Op2Name AS STRING*42DIM SwitchClass AS BYTEDIM Op1DataSize AS LONGDIM Op2DataSize AS LONGDIM LNFlag AS BYTEDIM VarName AS STRING*28DIM BufName AS STRING*28DIM BufDataSize AS LONGDIM PathVar AS STRING*42DIM PathName AS STRING*28DIM ToSubFlag AS BYTEDIM ToSub AS STRING*5DIM DigDec AS BYTEDIM TFcnDataType AS BYTEDIM FcnSpec AS BYTEDIM JmpArgs AS LONGDIM TimerNum AS LONGDIM SegNum AS LONGDIM LabelNum AS LONGDIM OELabelNum AS LONGDIM SCLabelNum AS LONGDIM GUILabelNum AS LONGDIM TableNum AS LONGDIM ObjectID AS LONGDIM ProcNum AS LONGDIM InterceptProcNum AS LONGTYPE ConStruct	TermLabel AS LONG	ContLabel AS LONG	LoopName AS STRING*28	ConType AS BYTE	ConLine AS LONG	LoopVec AS LONG	LoopLabel AS LONG	NoStep AS BYTE	ImmTo AS BYTE	ImmToVal AS STRING*10	ImmStep AS BYTE	ImmStepVal AS STRING*10	NegImmStep AS BYTEEND TYPEDIM ConStk(40) AS ConStructDIM ConStkPtr AS LONGDIM StatusFile AS FILEDIM InpFile(20) AS FILEDIM InpFilPtr AS LONGDIM DeclareFile AS FILEDIM CodeFile AS FILEDIM PreCodeFile AS FILEDIM DataFile AS FILEDIM DimFile AS FILEDIM DescFile AS FILEDIM InitFile AS FILEDIM FunctionFile AS FILEDIM ImportFile AS FILEDIM ExportFile AS FILEDIM ResourceFile AS FILEDIM BitMapFile AS FILEDIM ImageFile AS FILEDIM OutFile AS FILEDIM RawData AS STRING*1DIM LastRawData AS STRING*1DIM TempStr AS STRING*_BufSizeDIM FcnOp1Nam AS STRING*28DIM FcnOp2Nam AS STRING*28DIM TempName AS STRING*28DIM ToolButtonNdx AS LONGDIM DbgCtr AS LONGDIM TempInt AS LONGDIM TempInt2 AS LONGDIM TempLabel AS LABELDIM TempLabel2 AS LABELDIM StringLength AS LONGDIM TempByte AS STRING*1DIM ErrNo AS LONGDIM NextByte AS STRING*1DIM AsciiByte AS BYTEDIM Konstant AS LONGDIM StringCnt AS LONGDIM StringLen AS LONGDIM LoopNum AS LONGTYPE Symbol	SymName AS STRING*28	DataType AS INTEGER	SubType AS INTEGER	DataMod AS LONG	Detail AS LONG	DataAddr AS LONG	DataSize AS LONG	ArrayDim1 AS LONG	ArrayDim2 AS LONG	ArrayDim3 AS LONG	GUIEvents AS LONG	GUINotifyEvents AS LONG	ArrayDims AS BYTE	Misc AS BYTE	FcnDataType AS BYTE	FcnArgs AS BYTE	UseCount AS BYTEEND TYPEDIM SymTable(SymTabSiz) AS SymbolDIM SymTableKey(SymTabSiz) AS LONGTYPE KeyData	KeyCheckWord AS LONG	KeyName AS STRING*25	KeyLabel AS LABELEND TYPETYPE ObjData	ObjCheckWord AS LONG	ObjSource AS LONG	ObjName AS STRING*32	ObjTypeName AS STRING*32	ObjExStyle AS STRING*32	ObjPropTable AS LABEL	ObjStyleTable AS LABEL	ObjEventTable AS LABELEND TYPETYPE PropData	PropName AS STRING*32	PropGet AS LABEL	PropSet AS LABEL	PropDataType AS INTEGER	PropValid AS BOOLEANEND TYPEDIM PropArray(1) AS PropData VECTORDIM PropValidTable(15) AS BOOLEANTYPE StyleData	StyleName AS STRING*32	StyleValue AS LONG	StyleType AS BYTE	StyleDefault AS BOOLEANEND TYPEDIM StyleArray(1) AS StyleData VECTORTYPE EventData	EVType AS STRING*32	EVStatusBit AS LONG	EVDescOffs AS LONG	EVNotify AS LONGEND TYPEDIM EventArray(1) AS EventData VECTORTYPE ImportFcnData	ImportLibUseNdx AS BYTE	ImportFcnAlias AS STRING*28	ImportFcnName AS STRING*28	ImportFcnUse AS BOOLEAN	ImportFcnLastUsed AS BOOLEANEND TYPETYPE ImportLibData	ImportLibAlias AS STRING*28	ImportLibName AS STRING*28	ImportLibUse AS BOOLEAN	ImportLibLastUsed AS BOOLEANEND TYPE; Use FlagsDIM UseReadFile AS BOOLEANDIM UseWriteFile AS BOOLEANDIM UseWriteOBComm AS BOOLEANDIM UseSetStrConst AS BOOLEANDIM UseTrmStr AS BOOLEANDIM UsePrtUsing AS BOOLEANDIM UseData AS BOOLEANDIM UseMovStr AS BOOLEANDIM UseCmpStr AS BOOLEANDIM UseStrLen AS BOOLEANDIM UseSubStr AS BOOLEANDIM UseMidStr AS BOOLEANDIM UseRightStr AS BOOLEANDIM UseClrConv AS BOOLEANDIM UseAtoD AS BOOLEANDIM UseAtoL AS BOOLEANDIM UseNumScan AS BOOLEANDIM UseZLtoH AS BOOLEANDIM UseZLtoA AS BOOLEANDIM UseLtoA AS BOOLEANDIM UseDtoA AS BOOLEANDIM UseLtoH AS BOOLEANDIM UsePrintStr AS BOOLEANDIM UsePrintTab AS BOOLEANDIM UseInpData AS BOOLEANDIM UseBtoA AS BOOLEANDIM UseLCase AS BOOLEANDIM UseUCase AS BOOLEANDIM UseTailStr AS BOOLEANDIM UseSetRightBottom AS BOOLEANDIM RichEdLibUsed AS BOOLEANDIM RAEditLibUsed AS BOOLEANDIM RAGridLibUsed AS BOOLEANDIM CsmdllLibUsed AS BOOLEANDIM DrawProgressLibUsed AS BOOLEANDIM ImageLibUsed AS BOOLEANDIM SprShtLibUsed AS BOOLEANDIM ButtonExLibUsed AS BOOLEANDIM UMFlag AS BYTEDIM CVTemp AS LONGDIM CVOp AS STRING*2DIM NeedComma AS BYTEDIM MacExFlag AS BYTEDIM MacBuf(MacBufSiz) AS BYTEDIM MacDefNdx AS LONGDIM MacExNdx AS LONGDIM MacTblPtr AS LONGDIM MacArgBuf(16) AS STRING*100DIM MacArgPtr AS LONGDIM MaxArgNum AS BYTEDIM PoolCtr AS LONGDIM SymNdx AS LONGDIM SymNdxSaf AS LONGDIM DataSymNdx AS LONGDIM SymType AS STRING*32DIM SimpleOp AS STRING*8DIM SimpleStructOp AS STRING*8DIM ArraySize AS LONGDIM ForNdx AS LONGDIM DataTemp AS BYTEDIM TSymName AS STRING*28DIM VSymName AS STRING*28DIM TDataType AS INTEGERDIM AliasDataType AS INTEGERDIM TSubType AS INTEGERDIM TblDataType AS INTEGERDIM TDataMod AS LONGDIM VDataMod AS LONGDIM TDetail AS LONGDIM VDetail AS LONGDIM TDataAddr AS LONGDIM VDataAddr AS LONGDIM TDataSize AS LONGDIM TArrayDims AS BYTEDIM TArrayDim1 AS LONGDIM TArrayDim2 AS LONGDIM TArrayDim2Safe AS LONGDIM TArrayDim3 AS LONGDIM TGUIEvents AS LONGDIM TGUINotifyEvents AS LONGDIM ExpTable(ExpTabSiz) AS LONGDIM TypePtr AS LONGDIM TypeFlag AS BYTEDIM AliasFlag AS BYTEDIM LastEntry AS SymbolDIM SymTemp AS SymbolDIM SrcLine AS STRING*_BufSizeDIM SrcLineSaf AS STRING*_BufSizeDIM OutBuf AS STRING*_BufSizeDIM TokenBuf AS STRING*_BufSizeDIM ExpEnd AS BYTEDIM TokenLen AS LONGDIM ExpLen AS LONGDIM LastGroup AS BYTEDIM TokenType AS BYTEDIM LastByte AS BYTEDIM IsOperator AS BYTEDIM WasOperator AS BYTEDIM TokenSaf AS STRING*_BufSizeDIM RootSym AS STRING*29DIM Subscript(3) AS STRING*28DIM SubscrErr AS BYTEDIM KeyWord AS STRING*29DIM KeyNdx AS LONGDIM ObjNdx AS LONGDIM SymbolSaf AS STRING*29DIM NumberOK AS BYTEDIM HexOK AS BYTEDIM SymbolOK AS BYTEDIM IntOK AS BYTEDIM DimFlag AS BYTEDIM DimOK AS BYTEDIM GetBaseFlag AS BOOLEANDIM GetPutFlag AS BOOLEANDIM BldOffsFlag AS BOOLEANDIM BasicLineCtr AS LONGDIM AsmLineCtr AS LONGDIM QuoteFlag AS BYTEDIM EscSeq AS BYTEDIM ParenStk(100) AS BYTEDIM ParenCnt AS BYTEDIM FcnCtr AS BYTEDIM AECtr AS BYTEDIM LevelCnt AS BYTEDIM SymFull AS BYTEDIM SymFound AS BOOLEANDIM ErrCnt AS LONGDIM VarBytRem AS LONGDIM TypeBytes AS LONGDIM TypeVars AS LONGDIM TypeNdx AS LONGDIM LabelFlag AS BYTEDIM DMTemp AS BYTEDIM DMVector AS BYTEDIM DMMember AS BYTEDIM DMMulti AS BYTEDIM DMConst AS BYTEDIM DMAddr AS BYTEDIM DMArray AS BYTEDIM DMReDim AS BYTEDIM DMSubClassed AS BYTEDIM EndFound AS BYTEDIM AsmFileName AS STRINGDIM BareFileName AS STRINGDIM UseFilNam AS STRINGDIM Ctr1 AS LONGDIM Ctr2 AS LONGDIM Ctr3 AS LONGDIM WhiteSpaceCtr AS LONGDIM SrcNdx AS LONGDIM EndNdx AS LONGDIM SrcNdxCpy AS LONGDIM SrcNdxSaf AS LONGDIM ExpEndSaf AS BYTEDIM NumberNdx AS LONGDIM ValidNdx AS LONGDIM LabNdx AS LONGDIM ExpNdx AS LONGDIM ExpLeft AS LONGDIM ExpRight AS LONGDIM PType AS LONG; OBComm Control Block StructureCONST !DCBlengthOffs=0; rd 1CONST !BaudRateOffs=4; rd 1CONST !fBitsOffs=8; rd 1	CONST !fBinaryBit=0	CONST !fParityBit=1	CONST !fOutxCtsFlowBit=2	CONST !fOutxDsrFlowBit=3	CONST !fDtrControlLoBit=4	CONST !fDtrControlHiBit=5	CONST !fDsrSensitivityBit=6	CONST !fTXContinueOnXoffBit=7	CONST !fOutXBit=8	CONST !fInXBit=9	CONST !fErrorCharBit=10	CONST !fNullBit=11	CONST !fRtsControlLoBit=12	CONST !fRtsControlHiBit=13	CONST !fAbortOnErrorBit=14CONST !wReservedOffs=12; rw 1CONST !XonLimOffs=14; rw 1CONST !XoffLimOffs=16; rw 1CONST !ByteSizeOffs=18; rb 1CONST !ParityOffs=19;  rb 1CONST !StopBitsOffs=20; rb 1CONST !XonCharOffs=21; rb 1CONST !XoffCharOffs=22; rb 1CONST !ErrorCharOffs=23; rb 1CONST !EofCharOffs=24; rb 1CONST !EvtCharOffs=25; rb 1CONST !wReserved1Offs=26; rw 1CONST !HandleOffs=28; rd 1CONST !StatusOffs=32; rd 1CONST !ArrayOffs=36; rd 1CONST !CommReserved1Offs=40; rb 1CONST !CommReserved2Offs=41; rb 1CONST !CommReserved3Offs=42; rb 1CONST !CommReserved4Offs=43; rb 1CONST !UserBaudRateOffs=44; rd 1CONST !UserParityOffs=48; rb 1CONST !UserByteSizeOffs=49; rb 1CONST !UserStopBitsOffs=50; rb 1CONST !UserRTSOffs=51; rb 1CONST !UserDSRCheckOffs=52; rb 1CONST !UserParityCheckOffs=53; rb 1CONST !UserDTROffs=54; rb 1CONST !UserCTSCheckOffs=55; rb 1CONST !PortNameOffs=56; rb 32CONST !CommStatusOffs=88; rd 1CONST !cbInQueOffs=92; rd 1CONST !cbOutQueOffs=96; rd 1;Object Descriptor StructureCONST HandleOffs=0CONST IDOffs=4CONST OwnerOffs=8CONST ArrayOffs=12CONST LeftOffs=16CONST TopOffs=20CONST RightOffs=24CONST BottomOffs=28CONST BackColorOffs=32CONST ForeColorOffs=36CONST TypeOffs=40CONST StatusOffs=44CONST evActivateOffs=48CONST evCommandOffs=52CONST evMouseActivateOffs=56CONST evPaintOffs=60CONST HDCOffs=64CONST evMouseMoveOffs=68CONST evMouseWheelOffs=72CONST evScrollOffs=76CONST evCreateOffs=80CONST evDestroy=84CONST evKeyDownOffs=88CONST evKeyUpOffs=92CONST evDblClickOffs=96CONST cdDblClickOffs=100CONST evClickOffs=104CONST cdClickOffs=108CONST evChangeOffs=112CONST cdChangeOffs=116CONST evSelectOffs=120CONST cdSelectOffs=124CONST evNotify1Offs=128CONST cdNotify1Offs=132CONST evNotify2Offs=136CONST cdNotify2Offs=140CONST evNotify3Offs=144CONST cdNotify3Offs=148CONST evNotify4Offs=152CONST cdNotify4Offs=156CONST evNotify5Offs=160CONST cdNotify5Offs=164CONST evNotify6Offs=168CONST cdNotify6Offs=172CONST evNotify7Offs=176CONST cdNotify7Offs=180CONST evNotify8Offs=184CONST cdNotify8Offs=188CONST evNotify9Offs=192CONST cdNotify9Offs=196CONST evNotify10Offs=200CONST cdNotify10Offs=204CONST evNotify11Offs=208CONST cdNotify11Offs=212CONST evNotify12Offs=216CONST cdNotify12Offs=220CONST evNotify13Offs=224CONST cdNotify13Offs=228CONST evNotify14Offs=232CONST cdNotify14Offs=236CONST evNotify15Offs=240CONST cdNotify15Offs=244CONST evNotify16Offs=248CONST cdNotify16Offs=252CONST evNotify17Offs=256CONST cdNotify17Offs=260CONST evNotify18Offs=264CONST cdNotify18Offs=268CONST evNotify19Offs=272CONST cdNotify19Offs=276CONST evNotify20Offs=280CONST cdNotify20Offs=284CONST evNotify21Offs=288CONST cdNotify21Offs=292CONST evNotify22Offs=296CONST cdNotify22Offs=300CONST evNotify23Offs=304CONST cdNotify23Offs=308CONST evNotify24Offs=312CONST cdNotify24Offs=316CONST evNotify25Offs=320CONST cdNotify25Offs=324CONST evNotify26Offs=328CONST cdNotify26Offs=332CONST evNotify27Offs=336CONST cdNotify27Offs=340CONST evNotify28Offs=344CONST cdNotify28Offs=348CONST evNotify29Offs=352CONST cdNotify29Offs=356CONST evNotify30Offs=360CONST cdNotify30Offs=364CONST evNotify31Offs=368CONST cdNotify31Offs=372CONST evNotify32Offs=376CONST cdNotify32Offs=380CONST evSysCommandOffs=384CONST evResizeOffs=388CONST evMoveOffs=392CONST evLButtonDownOffs=396CONST evLButtonUpOffs=400CONST evRButtonDownOffs=404CONST evRButtonUpOffs=408CONST CursorOffs=412CONST evContextMenuOffs=416CONST evKeyStruckOffs=420CONST evReserved3Offs=424CONST evReserved4Offs=428CONST evReserved5Offs=432CONST evReserved6Offs=436CONST evReserved7Offs=440CONST Reserved1Offs=444CONST Reserved2Offs=448CONST Reserved3Offs=452CONST Reserved4Offs=456CONST Reserved5Offs=460CONST Reserved6Offs=464CONST Reserved7Offs=468CONST Reserved8Offs=472CONST OldProcOffs=476CONST WidthOffs=480CONST HeightOffs=484CONST ControlBrushOffs=488CONST InterceptSafeOffs=492CONST InterceptProcOffs=496CONST StyleOffs=500CONST Extra2Offs=504CONST DoNotUseOffs=508CONST TTcbSizeOffs=512CONST TTuFlagsOffs=516CONST TThwndOffs=520CONST TTuIDOffs=524CONST TTRectLeftOffs=528CONST TTRectTopOffs=532CONST TTRectRightOffs=536CONST TTRectBottomOffs=540CONST TThinstOffs=544CONST TTlpszTextOffs=548CONST TTlparamOffs=552CONST TTTextOffs=556CONST NextOffs=656;******************************************* IDE Code Starts Here ********************************OBMain.CREATEBasicAsm=TRUETextMode=TRUEToolView=TRUEPropView=TRUEStyleView=TRUEGraphicConstructed=FALSEPOPUPMENU EventPopUp	RESERVEITEMS evmnu1,20END MENUPOPUPMENU GridSizePopUp	MENUITEM gsmnu5,"5"	MENUITEM gsmnu10,"10"	MENUITEM gsmnu15,"15"	MENUITEM gsmnu20,"20"	MENUITEM gsmnu25,"25"	MENUITEM gsmnu30,"30"	MENUITEM gsmnu35,"35"	MENUITEM gsmnu40,"40"	MENUITEM gsmnu45,"45"	MENUITEM gsmnu50,"50"END MENUCHECKMENUITEM GridSizePopUp,gsmnu10,TRUEPOPUPMENU GridColorPopUp	MENUITEM gcmnuBlack,"Black"	MENUITEM gcmnuWhite,"White"	MENUITEM gcmnuRed,"Red"	MENUITEM gcmnuGreen,"Green"	MENUITEM gcmnuBlue,"Blue"	MENUITEM gcmnuYellow,"Yellow"	MENUITEM gcmnuMagenta,"Magenta"	MENUITEM gcmnuDkRed,"DkRed"	MENUITEM gcmnuDkGreen,"DkGreen"	MENUITEM gcmnuDkBlue,"DkBlue"END MENUCHECKMENUITEM GridColorPopUp,gcmnuBlack,TRUEPOPUPMENU GripColorPopUp	MENUITEM gpcmnuBlack,"Black"	MENUITEM gpcmnuWhite,"White"	MENUITEM gpcmnuRed,"Red"	MENUITEM gpcmnuGreen,"Green"	MENUITEM gpcmnuBlue,"Blue"	MENUITEM gpcmnuYellow,"Yellow"	MENUITEM gpcmnuMagenta,"Magenta"	MENUITEM gpcmnuDkRed,"DkRed"	MENUITEM gpcmnuDkGreen,"DkGreen"	MENUITEM gpcmnuDkBlue,"DkBlue"END MENUCHECKMENUITEM GripColorPopUp,gpcmnuBlack,TRUEPOPUPMENU FormPopUp	MENUITEM fwmnuCut,"Cut"	MENUITEM fwmnuCopy,"Copy"	MENUITEM fwmnuPaste,"Paste"	MENUSEPARATOR	MENUITEM fwmnuDelete,"Delete"	MENUSEPARATOR	MENUITEM fwmnuShowGrid,"Show Grid"	MENUITEM fwmnuSnapToGrid,"Snap To Grid"	SUBMENU GridSizePopUp,"Grid Size"	SUBMENU GridColorPopUp,"Grid Color"	MENUSEPARATOR	SUBMENU GripColorPopUp,"Grip Color"	MENUSEPARATOR	MENUITEM fwmnuBringToFront,"Bring To front"	MENUITEM fwmnuSendToBack,"Send To Back"	MENUSEPARATOR	SUBMENU EventPopUp,"Events"	MENUSEPARATOR	MENUITEM fwmnuViewCode,"View Code"END MENUPOPUPMENU EditPopUp	MENUITEM emnuUnDo,"Undo"	MENUITEM emnuReDo,"Redo",	MENUSEPARATOR	MENUITEM emnuDelete,"Delete"	MENUITEM emnuCut,"Cut"	MENUITEM emnuCopy,"Copy"	MENUITEM emnuPaste,"Paste"	MENUSEPARATOR	MENUITEM emnuSelectAll,"Select All",	MENUSEPARATOR	MENUITEM emnuGotoLine,"Goto Line"	MENUITEM emnuGotoTop,"Goto Top"	MENUITEM emnuGotoBottom,"Goto Bottom"	MENUSEPARATOR	MENUITEM emnuFind,"Find"	MENUITEM emnuReplace,"Replace"	MENUSEPARATOR	MENUITEM emnuViewObject,"View Objects"END MENUBEGIN MENU OBMain	MENUBAR MainMenu		MENUTITLE FileMenu,"File"			MENUITEM mnuNew,"New"			MENUITEM mnuOpen,"Open"			MENUITEM mnuSave,"Save"			MENUITEM mnuSaveAs,"Save As"			MENUSEPARATOR			MENUITEM mnuPrint,"Print"			MENUSEPARATOR			MENUITEM mnuExit,"Exit"		MENUTITLE EditMenu,"Edit"			MENUITEM mnuUnDo,"Undo"			MENUITEM mnuReDo,"Redo",			MENUSEPARATOR			MENUITEM mnuDelete,"Delete"			MENUITEM mnuCut,"Cut"			MENUITEM mnuCopy,"Copy"			MENUITEM mnuPaste,"Paste"			MENUSEPARATOR			MENUITEM mnuSelectAll,"Select All",			MENUSEPARATOR			MENUITEM mnuGotoLine,"Goto Line"			MENUSEPARATOR			MENUITEM mnuFind,"Find"			MENUITEM mnuReplace,"Replace"		MENUTITLE ViewMenu,"View"			MENUITEM mnuToolBox,"ToolBox"			MENUITEM mnuPropertyBox,"PropertyBox"			MENUITEM mnuStyleBox,"StyleView"		MENUTITLE OptionMenu,"Option"			MENUITEM mnuPreferences,"Preferences"			MENUSEPARATOR			MENUITEM mnuFont,"Font"		MENUTITLE ColorMenu,"Colors"			MENUITEM mnuStatement,"Statements"			MENUSEPARATOR			MENUITEM mnuFunctions,"Functions"			MENUSEPARATOR			MENUITEM mnuRegisters,"Registers"			MENUSEPARATOR			MENUITEM mnuAsm,"Asm"			MENUSEPARATOR			MENUITEM mnuDataType,"DataType"		MENUTITLE CompileMenu,"Compile"			MENUITEM mnuCompile,"Compile To EXE"			MENUITEM mnuAssemble,"Compile To .ASM"			MENUITEM mnuTestCompile,"Compile Errors"			MENUSEPARATOR			MENUITEM mnuRun,"Run"		MENUTITLE DebugMenu,"Debug"			MENUITEM mnuStart,"Start"			MENUITEM mnuStop,"Stop"			MENUITEM mnuStep,"Step"			MENUITEM mnuEnd,"End"		MENUTITLE HelpMenu,"Help"			MENUITEM mnuHelp,"Help"			MENUSEPARATOR			MENUITEM mnuAbout,"About"							END MENUENABLEMENUITEM MainMenu,mnuSave,FALSESETPOSITION OBMain,0,0,1024,740CREATE StatusBar,0,0,0,0sbParts(1)=0sbParts(2)=100sbParts(3)=200sbParts(4)=300sbParts(5)=400sbParts(6)=500StatusBar.SETPARTS 6,sbParts;CREATE ToolBar,0,0,0,0CREATE Edit,0,50,1015,622Edit.ENABLED=FALSE;create codecomp,200,200,100,100;codecomp.backcolor=$ff0000CREATE BackGround,0,42,1015,630BackGround.VISIBLE=FALSEBackGround.BACKCOLOR=$b0a080CREATE EventCombo1,0,25,505,400EventCombo1.ENABLED=FALSECREATE EventCombo2,510,25,505,400EventCombo2.ENABLED=FALSECREATE QuickFind,810,0,205,20CREATE QuickFindNext,760,0,20,20,VISIBLE+CHILD+BITMAPQuickFindNext.ENABLED=FALSECREATE QFindNextBMP,OBCQFindNext.bmpQuickFindNext.BITMAP=QFindNextBMPCREATE QuickFindPrev,785,0,20,20,VISIBLE+CHILD+BITMAPQuickFindPrev.ENABLED=FALSECREATE QFindPrevBMP,OBCQFindPrev.bmpQuickFindPrev.BITMAP=QFindPrevBMPlf.lfHeight=-12lf.lfFaceName="Courier New"CREATE RAFont(1),lflf.lfItalic=1CREATE RAFont(2),lflf.lfHeight=-10lf.lfFaceName="Terminal"lf.lfItalic=0CREATE RAFont(3),lfEdit.setfont RAFontszRegs="AH AL AX BH BL BP BX CH CL CR0 CR2 CR3 CS CX DH DI DL DR0 DR1 DR2 DR3 DR6 DR7 DS DX EAX EBP EBX ECX EDI EDX ES ESI ESP FS GS MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7 SI SP SS ST TR3 TR4 TR5 TR6 TR7 XMM0 XMM1 XMM2 XMM3"Edit.sethilitewords szRegs,$0080ffszGUIInst="MINIMIZED TASK SUSPENDTASK RESUMETASK PASSEVENT GETDATETIME TIMEADD SETDEFAULTCURSOR SETSTOCKCURSOR SETCURSOR LOADIMAGE LOADICON LOADCURSOR CHECKMENUITEM HILITEMENUITEM SETMENUITEMBITMAPS PRINTDIALOG PAGEDIALOG FONTDIALOG COLORDIALOG REPLACEDIALOG SHOW DESTROY SETCAPTURE RELEASECAPTURE GETCURSORPOSITION SCREENTOCLIENT GETWINDOWRECT MENUBAR MENUTITLE MENUITEM MENUSEPARATOR TRAPCOLORCHANGEEVENT SETPOSITION SETFOCUS FIND SETSTYLE MSGBOX WARNINGBOX INFOBOX QUESTIONBOX ERRORBOX ENABLEMENUITEM FINDDIALOG OPENDIALOG SAVEDIALOG APPENDMENUITEM DELETEMENUITEM EXIT"Edit.sethilitewords szGUIInst,$ff;szGUIProps="ADDRESS INTERCEPTON INTERCEPTOFF ID VISIBLE ENABLED TOP WIDTH HEIGHT BOTTOM BACKCOLOR ICON FLASHWINDOW RESIZE FLAT 3D MOVE MOUSEMOVE LBUTTONDOWN LBUTTONUP RBUTTONDOWN RBUTTONUP BACKCOLOR FORECOLOR FONT ICON COMMAND ADDITEM ADDITEMSORTED INSERTITEM CLEAR SELITEM TOPITEM SELTEXT ITEMCOUNT CHANGE SCROLL AUTOTICKS BOTH ENABLESELRANGE FIXEDLENGTH NOTICKS NOTHUMB VERT VALUE CHECKED INTERVAL STOP LINE LOADFILE SETDIVIDERLINE SAVEFILE TEXTCOLOR SELBACKCOLOR SELTEXTCOLOR COMMENTCOLOR STRINGCOLOR OPERATORCOLOR HILITE1COLOR HILITE2COLOR HILITE3COLOR SELBARCOLOR SELBARPENCOLOR LINENUMCOLOR SETFONT GRIDCOLOR HEADERTEXT ADDROW ADDCOL DELETEROW INSERTROW MOVEROW HEADERHEIGHT ROWHEIGHT GRIDCLEAR COMBOCLEAR SORT CLICK HEADERCLICK BUTTONCLICK CHECKCLICK IMAGECLICK BEFORESELCHANGE AFTERSELCHANGE BEFOREEDIT AFTEREDIT USERCONVERT DROPPED SELECTALL SETSEL GETSEL INSERTTEXT APPENDTEXT REPLACETEXT REPLACESEL CURSORPOS";Edit.SETHILITEWORDS szGUIProps,$ffszGUIProps2=" CREATE CUT COPY PASTE UNDO REDO"Edit.SETHILITEWORDS szGUIProps2,$ffszAsmInst="DB DW DD DF RB RW RD RF EQU ALIGN EQU INVOKE CINVOKE AAA AAD AAM AAS ADC ADD AND CALL CBW CLC CLD CLI CMC CMP CMPS CMPSB CMPSW CWD DAS DEC DIV DAA ESC HLT IDIV IMUL IN INC INT INTO IRET JA JAE JB JBE JC JCXZ JE JG JGE JL JLE JMP JNA JNAE JNB JNBE JNC JNE JNG JNGE JNL JNLE JNO JNP JNS JNZ JO JP JPE JPO JS JZ LAHF LDS LEA LES LODS LODSB LODSW LOOP LOOPE LOOPEW LOOPNE LOOPNEW LOOPNZ LOOPNZW LOOPW LOOPZ LOOPZW MOV MOVS MOVSB MOVSW MUL NEG NOP NOT OR OUT POP POPF PUSH PUSHF RCL RCR RET RETF RETN ROL ROR SAHF SAL SAR SBB SCAS SCASB SCASW SETE SHL SHR STC STD STI STOS STOSB STOSW SUB TEST WAIT XCHG XLAT XLATB XOR"Edit.sethilitewords szAsmInst,$FFszBasicInst="READCARD WRITECARD USEIMPORT IMPORTFUNCTION EXPORTFUNCTION SHOWPOPUP POPUPMENU SUBMENU RESERVEITEMS TEXTBLOCK ENDTEXT MAKELOWER MAKEUPPER SWAP PROGRAM PROC FCN DECLARE CALL CHDIR MKDIR RMDIR INCLUDE FREEZE DIGITS SETVEC REDIM ENDWXIT DECIMAL EXCHANGE BEEP BUFREAD BUFWRITE BASE SHELL FPRINT FINPUT UNTIL REPEAT BUFFER REM WHILE OPEN OUTPUT APPEND SCRATCH UPDATE GET PUT READ INPUT SEEK EVENT TRUE FALSE AS GOTO GOSUB FOR TO END IF PRINT ELSE IF THEN BEGIN LOOP END DATA TABLE SELECT CASE DIM TYPE LET CONST MACRO ENDMACRO INCR DECR NEXT RESTORE TEXT WRITE RETURN CLOSE AND DELETE ON ERROR OR ENUM SEG RUN"Edit.sethilitewords szBasicInst,$FFszFcns="TABLESIZE TAIL UCASE LCASE TIMEDIFF GETTICKCOUNT RND OCT BIN RCR RCL SAR SAL SUBSTR BITSET BITCLR BITCHG ROR ROL SHR SHL BITTST CHKWORD HEX LOG10 LOG ATN ACS ASN TAN COS SIN INT SQR FILPOS LOF TRIM FVAL IVAL SIZE INDEX NOT LNOT EOF LAND LOR LXOR LEN STR VAL ADDR MID LEFT RIGHT ABS MOD CHR ASC NOT BUFADR BUFSIZ TAB"Edit.sethilitewords szFcns,$FF00FFszDataType="RAEDIT RAGRID TOOLWINDOW LISTVIEW HANDLE BITMAP CURSOR ICON FONT DEVICE MENU PIPE FILE BYTE INTEGER LONG FLOAT LABEL POINTER VECTOR DATETIME ALIAS BOOLEAN STRING WORD DWORD BUTTON FORM COMBOBOX LISTBOX TEXTBOX STATICBOX STATICTEXT CHECKBOX FRAME RADIOBUTTON SLIDER STATUSBAR SCROLLBAR PROGRESSBAR ANIMATE BUTTONEX OBCOMM DRAWPROGRESS IMAGE DATETIMEPICK TOOLBAR SPINNER CALENDAR HEADER TREEVIEW TABFOLDER RICHEDIT ICONBUTTON STATICICON TIMEOUT"Edit.sethilitewords szDataType,$808000Edit.backcolor=$ffffffEdit.linenumcolor=$0000a0SaveFileName=""EditfChanged=0StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSEInitDir="C:\nb"FileFilter="OB Project",0,"*.obp",0,"OB Window",0,"*.obw",0,"OB Console",0,"*.obc",0,"Assembler",0,"*.asm",0,"OB DLL",0,"*.obd",0,"OB Library",0,"*.obl",0,"OB Object",0,"*.obo",0,"All Files",0,"*.*",0,0TempStr=ProgramName+"    [Untitled]" OBMain.TEXT=TempStrFileName="Untitled"Edit.SETFOCUSCREATE Button(1),5,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(1).TOOLTIP="New"CREATE Button(2),30,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(2).TOOLTIP="Open"CREATE Button(3),55,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(3).TOOLTIP="Save"CREATE Button(4),80,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(4).TOOLTIP="Save As"CREATE Button(5),105,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(5).TOOLTIP="Print"CREATE Button(6),135,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(6).TOOLTIP="Graphic"CREATE Button(7),165,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(7).TOOLTIP="Undo"CREATE Button(8),190,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(8).TOOLTIP="Redo"CREATE Button(9),215,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(9).TOOLTIP="Delete"CREATE Button(10),240,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(10).TOOLTIP="Cut"CREATE Button(11),265,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(11).TOOLTIP="Copy"CREATE Button(12),290,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(12).TOOLTIP="Paste"CREATE Button(13),315,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(13).TOOLTIP="Goto Line"CREATE Button(14),340,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(14).TOOLTIP="Find"CREATE Button(15),365,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(15).TOOLTIP="Replace"CREATE Button(16),395,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(16).TOOLTIP="Compile To .Exe"CREATE Button(17),420,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(17).TOOLTIP="Compile To .Asm"CREATE Button(18),445,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(18).TOOLTIP="Compile For Errors"CREATE Button(19),470,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(19).TOOLTIP="Compile For Debug"CREATE Button(20),500,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(20).TOOLTIP="Symbol Table"CREATE Button(21),525,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(21).TOOLTIP="Unused"CREATE Button(22),550,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(22).TOOLTIP="Run Program"CREATE Button(23),575,0,20,20,VISIBLE+CHILD+BITMAP+FLATButton(23).TOOLTIP="Help"LF1.lfHeight=10LF1.lfFaceName="MS Sans Serif"CREATE Font1,LF1Button(3).ENABLED=FALSEButton(6).ENABLED=FALSEButton(7).ENABLED=FALSEButton(8).ENABLED=FALSEENABLEMENUITEM EditPopUp,emnuViewObject,FALSECREATE OmniIcon,ColrefOBMain.ICON=OmniIconCREATE NewBMP,OBCNew.bmpSETMENUITEMBITMAPS FileMenu,mnuNew,NewBMP,NewBMPButton(1).BITMAP=NewBMPCREATE OpenBMP,OBCOpen.bmpSETMENUITEMBITMAPS FileMenu,mnuOpen,OpenBMP,OpenBMPButton(2).BITMAP=OpenBMPCREATE SaveBMP,OBCSave1.bmpSETMENUITEMBITMAPS FileMenu,mnuSave,SaveBMP,SaveBMPButton(3).BITMAP=SaveBMPCREATE SaveAsBMP,OBCSave2.bmpSETMENUITEMBITMAPS FileMenu,mnuSaveAs,SaveAsBMP,SaveAsBMPButton(4).BITMAP=SaveAsBMPCREATE PrintBMP,OBCPrint.bmpButton(5).BITMAP=PrintBMPCREATE ToolBMP,OBCTool.bmpCREATE EditBMP,OBCEdit.bmpButton(6).BITMAP=ToolBMPCREATE UndoBMP,OBCUndo.bmpButton(7).BITMAP=UndoBMPCREATE RedoBMP,OBCRedo.bmpButton(8).BITMAP=RedoBMPCREATE DeleteBMP,OBCDelete.bmpButton(9).BITMAP=DeleteBMPCREATE CutBMP,OBCCut.bmpButton(10).BITMAP=CutBMPCREATE CopyBMP,OBCCopy.bmpButton(11).BITMAP=CopyBMPCREATE PasteBMP,OBCPaste.bmpButton(12).BITMAP=PasteBMPCREATE  GotoBMP,OBCGoto.bmpButton(13).BITMAP=GotoBMPCREATE FindBMP,OBCFind.bmpButton(14).BITMAP=FindBMPCREATE ReplaceBMP,OBCReplace.bmpButton(15).BITMAP=ReplaceBMPCREATE CompileToExeBMP,OBCCompExe.bmpButton(16).BITMAP=CompileToExeBMP;CREATE CompileToAsmIcon,asmicon;Button(17).ICON=CompileToAsmIcon;CREATE CompileForErrIcon,prop0;Button(18).ICON=CompileForErrIconCREATE CompileForDebugBMP,OBCDebug.bmpButton(19).BITMAP=CompileForDebugBMP;CREATE SymbolsIcon,qrlist;Button(20).ICON=SymbolsIcon;CREATE UnusedSymIcon,question;Button(21).ICON=UnusedSymIconCREATE RunBMP,OBCRun.bmpButton(22).BITMAP=RunBMPCREATE HelpBMP,OBCHelp.bmpButton(23).BITMAP=HelpBMPLF1.lfHeight=10LF1.lfFaceName="MS Sans Serif"CREATE Font1,LF1FormWindowConstructed=FALSEMinMaxFlag=TRUECaptureEnable=TRUEControlCount=0LastControl=0ShowGrid=TRUECHECKMENUITEM FormPopUp,fwmnuShowGrid,TRUESnapToGrid=TRUECHECKMENUITEM FormPopUp,fwmnuSnapToGrid,TRUEGridSize=10GridColor=0EventMenuCount=0lf.lfHeight=-9lf.lfFaceName="Verdana"CREATE GridFont,lfEND EVENTMENU.commandIF MenuID>=evmnu1 AND MenuID<=evmnu1+19 THEN; FormPopUp Event	GOSUB FindEvent	RETURNEND IFSELECT CASE MenuID	CASE mnuNew		GOSUB NewCmd	CASE mnuOpen		GOSUB OpenCmd	CASE mnuSave		GOSUB SaveCmd	CASE mnuSaveAs		GOSUB SaveAsCmd	CASE mnuPrint	CASE mnuExit		IF Changed=TRUE THEN			TempName=SaveFileName+" Not Saved"			TempStr="Save?"			WARNINGBOX TempName,TempStr,MB_YESNOCANCEL			IF STATUS=IDYES THEN				IF FileName="Untitled" THEN					GOSUB SaveAs					IF STATUS=0 THEN						RETURN					END IF					GOTO Quit				ELSE					SETDEFAULTCURSOR					Edit.SAVEFILE SaveFileName					ENABLEMENUITEM MainMenu,mnuSave,FALSE					Button(3).ENABLED=FALSE					StatusBarSafe5="Not Changed"					StatusBar.SETTEXT 5,StatusBarSafe5					Changed=FALSE					GOTO Quit				END IF			ELSE				IF STATUS=IDNO THEN					GOTO Quit				ELSE					RETURN				END IF			END IF		END IF		GOTO Quit	CASE mnuUnDo		Edit.UNDO	CASE mnuReDo		Edit.REDO	CASE mnuCut		Edit.CUT	CASE mnuCopy		Edit.COPY	CASE mnuPaste		Edit.PASTE	CASE mnuSelectAll		Edit.SELECTALL	CASE mnuGotoLine		GOSUB GotoLine		GotoText.SETFOCUS	CASE mnuFind		GOSUB GetFindDialog	CASE mnuReplace		GOSUB GetFindReplaceDialog	CASE mnuPreferences			CASE mnuToolBox	CASE mnuPropertyBox	CASE mnuStyleBox	CASE mnuFont		FONTDIALOG FontStr	CASE mnuStatement		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szBasicInst,RGB		Edit.sethilitewords szGUIInst,RGB		Edit.visible=false		Edit.visible=true	CASE mnuFunctions		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szFcns,RGB		Edit.visible=false		Edit.visible=true	CASE mnuRegisters		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szRegs,RGB		Edit.visible=false		Edit.visible=true	CASE mnuAsm		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szAsmInst,RGB		Edit.visible=false		Edit.visible=true	CASE mnuDataType		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szDataType,RGB		Edit.visible=false		Edit.visible=true	CASE mnuCompile		GOSUB CompileToExe	CASE mnuAssemble		GOSUB CompileToAsm	CASE mnuTestCompile		GOSUB TestCompile	CASE mnuStart	CASE mnuStop	CASE mnuStep	CASE mnuEnd	CASE mnuHelp	CASE mnuAbout		CASE fwmnuShowGrid		IF ShowGrid=FALSE THEN			CHECKMENUITEM FormPopUp,fwmnuShowGrid,TRUE			FormWindow.VISIBLE=FALSE			FormWindow.VISIBLE=TRUE			GOSUB PaintGrid			GOSUB RedrawParts		ELSE			CHECKMENUITEM FormPopUp,fwmnuShowGrid,FALSE			FormWindow.VISIBLE=FALSE			FormWindow.VISIBLE=TRUE			GOSUB PaintGrid			GOSUB RedrawParts		END IF		ShowGrid=NOT(ShowGrid)	CASE fwmnuSnapToGrid		IF SnapToGrid=FALSE THEN			CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,TRUE			StatusBar.SETTEXT 5,"Snap On"		ELSE			CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,FALSE			StatusBar.SETTEXT 5,"Snap Off"		END IF		SnapToGrid=NOT(SnapToGrid)	CASE fwmnuDelete		GOSUB DeleteControl	CASE fwmnuViewCode		GOSUB Button6Pressed			CASE emnuUnDo		Edit.UNDO	CASE emnuReDo		Edit.REDO	CASE emnuCut		Edit.CUT	CASE emnuCopy		Edit.COPY	CASE emnuPaste		Edit.PASTE	CASE emnuSelectAll		Edit.SELECTALL	CASE emnuGotoLine		GOSUB GotoLine		GotoText.SETFOCUS	CASE emnuGotoTop		Edit.GOTO 1		Edit.SETFOCUS	CASE emnuGotoBottom		Edit.GOTO EditnLines		Edit.SETFOCUS	CASE emnuFind		GOSUB GetFindDialog	CASE emnuReplace		GOSUB GetFindReplaceDialog	CASE emnuViewObject		GOSUB Button6Pressed	CASE fwmnuBringToFront		TempHandle=ControlArray(ControlPtr).PuppetHandle		invoke SetWindowPos,[TempHandle],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE		invoke InvalidateRect,[TempHandle],NULL,TRUE		GOSUB ShowSpiderLegs	CASE fwmnuSendToBack		TempHandle=ControlArray(ControlPtr).PuppetHandle		invoke SetWindowPos,[TempHandle],HWND_BOTTOM,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE		invoke InvalidateRect,[TempHandle],NULL,TRUE	CASE gsmnu5		TempInt=5		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu5,TRUE		GOSUB SetGridSize	CASE gsmnu10		TempInt=10		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu10,TRUE		GOSUB SetGridSize	CASE gsmnu15		TempInt=15		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu15,TRUE		GOSUB SetGridSize	CASE gsmnu20		TempInt=20		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu20,TRUE		GOSUB SetGridSize	CASE gsmnu25		TempInt=25		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu25,TRUE		GOSUB SetGridSize	CASE gsmnu30		TempInt=30		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu30,TRUE		GOSUB SetGridSize	CASE gsmnu35		TempInt=35		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu35,TRUE		GOSUB SetGridSize	CASE gsmnu40		TempInt=40		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu40,TRUE		GOSUB SetGridSize	CASE gsmnu45		TempInt=45		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu45,TRUE		GOSUB SetGridSize	CASE gsmnu50		TempInt=50		GOSUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu50,TRUE		GOSUB SetGridSize	CASE gcmnuBlack		TempInt=$000000		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuBlack,TRUE		GOSUB SetGridColor	CASE gcmnuWhite		TempInt=$ffffff		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuWhite,TRUE		GOSUB SetGridColor	CASE gcmnuRed		TempInt=$0000ff		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuRed,TRUE		GOSUB SetGridColor	CASE gcmnuGreen		TempInt=$00ff00		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuGreen,TRUE		GOSUB SetGridColor	CASE gcmnuBlue		TempInt=$ff0000		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuBlue,TRUE		GOSUB SetGridColor	CASE gcmnuYellow		TempInt=$00ffff		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuYellow,TRUE		GOSUB SetGridColor	CASE gcmnuMagenta		TempInt=$ff00ff		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuMagenta,TRUE		GOSUB SetGridColor	CASE gcmnuDkRed		TempInt=$0000c0		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuDkRed,TRUE		GOSUB SetGridColor	CASE gcmnuDkGreen		TempInt=$00c000		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuDkGreen,TRUE		GOSUB SetGridColor	CASE gcmnuDkBlue		TempInt=$c00000		GOSUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuDkBlue,TRUE		GOSUB SetGridColor	CASE gpcmnuBlack		TempInt=$000000		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuBlack,TRUE		GOSUB SetGripColor	CASE gpcmnuWhite		TempInt=$ffffff		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuWhite,TRUE		GOSUB SetGripColor	CASE gpcmnuRed		TempInt=$0000ff		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuRed,TRUE		GOSUB SetGripColor	CASE gpcmnuGreen		TempInt=$00ff00		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuGreen,TRUE		GOSUB SetGripColor	CASE gpcmnuBlue		TempInt=$ff0000		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuBlue,TRUE		GOSUB SetGripColor	CASE gpcmnuYellow		TempInt=$00ffff		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuYellow,TRUE		GOSUB SetGripColor	CASE gpcmnuMagenta		TempInt=$ff00ff		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuMagenta,TRUE		GOSUB SetGripColor	CASE gpcmnuDkRed		TempInt=$0000c0		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuDkRed,TRUE		GOSUB SetGripColor	CASE gpcmnuDkGreen		TempInt=$00c000		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuDkGreen,TRUE		GOSUB SetGripColor	CASE gpcmnuDkBlue		TempInt=$c00000		GOSUB UnCheckGripColor		CHECKMENUITEM GripColorPopUp,gpcmnuDkBlue,TRUE		GOSUB SetGripColorEND SELECTEND EVENTSaveAs:FileName=SaveFileNameSAVEDIALOG FileName,FileFilter,InitDirIF STATUS<>0 THEN	Edit.EMPTYUNDOBUFFER	Edit.SAVEFILE FileName	SaveFileName=FileName	BareFileName=LEFT(FileName,LEN(FileName)-4)	Extension=RIGHT(FileName,4)	TempStr=ProgramName+"     ["+FileName+"]"	OBMain.TEXT=TempStrEND IFRETURNEdit.CHANGE;codecomp.bringtofront;invoke SendMessage,[!Edit],REM_GETWORD,256,[TempStr];OBMain.text=TempStrStatusBarSafe1="Line "+STR(EditLine)StatusBar.SETTEXT 1,StatusBarSafe1StatusBarSafe2="Column "+STR(EditcpLine)StatusBar.SETTEXT 2,StatusBarSafe2StatusBarSafe3=STR(EditnLines)+" Lines"StatusBar.SETTEXT 3,StatusBarSafe3StatusBarSafe4="Edit Text"StatusBar.SETTEXT 4,StatusBarSafe4IF EditfChanged<>0 THEN	StatusBarSafe5="Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=TRUE	;// ENABLEMENUITEMMainMenu,mnuSave,TRUE	Button(3).ENABLED=TRUEEND IFIF Edit.CANUNDO=TRUE THEN	;// ENABLEMENUITEMMainMenu,mnuUnDo,TRUE	Button(7).ENABLED=TRUEELSE	;// ENABLEMENUITEMMainMenu,mnuUnDo,FALSE	Button(7).ENABLED=FALSE	StatusBarSafe5="Not Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=FALSE	;// ENABLEMENUITEMMainMenu,mnuSave,FALSE	Button(3).ENABLED=FALSEEND IFIF Edit.CANREDO=TRUE THEN	;// ENABLEMENUITEMMainMenu,mnuReDo,TRUE	Button(8).ENABLED=TRUEELSE	;// ENABLEMENUITEMMainMenu,mnuReDo,FALSE	Button(8).ENABLED=FALSEEND IF;IF Edit.CANPASTE=TRUE THEN;	;// ENABLEMENUITEMMainMenu,mnuPaste;ELSE;	DISABLEMENUITEM MainMenu,mnuPaste;END IFEND EVENTGotoText.CHANGETempStr=GotoText.TEXTIF LEN(TempStr)=0 THEN	GotoButton.ENABLED=FALSEELSE	GotoButton.ENABLED=TRUEEND IFEND EVENTGotoButton.COMMANDTempStr=GotoText.TEXTTempInt=VAL(TempStr)Edit.GOTO TempIntGotoText.TEXT=""GotoWindow.VISIBLE=FALSEEND EVENTGotoWindow.SYSTEMGotoWindow.VISIBLE=FALSEEND EVENTScratchPadWindow.SYSTEMScratchPadWindow.VISIBLE=FALSEEND EVENTButton.COMMANDSELECT CASE ArrayIndex	CASE 1		GOSUB NewCmd	CASE 2		GOSUB OpenCmd	CASE 3		GOSUB SaveCmd	CASE 4		GOSUB SaveAsCmd	CASE 5	CASE 6		GOSUB Button6Pressed	CASE 7		Edit.UNDO	CASE 8		Edit.REDO	CASE 9					CASE 10		Edit.CUT		CASE 11		Edit.COPY		CASE 12		Edit.PASTE		CASE 13		GOSUB GotoLine		GotoText.SETFOCUS	CASE 14		GOSUB GetFindDialog	CASE 15		GOSUB GetFindReplaceDialog			CASE 16		GOSUB CompileToExe		GOSUB PostCompile		CASE 17		GOSUB CompileToAsm		GOSUB PostCompile		CASE 18		GOSUB TestCompile		GOSUB PostCompile		CASE 19		;Edit.APPENDTEXT "Havis"		;OBMain.text=TempStr	CASE 20		IF ShowSymbols=TRUE THEN			ShowSymbols=FALSE			DESTROY SymbolGrid			Edit.ENABLED=TRUE			EventCombo1.ENABLED=TRUE			EventCombo2.ENABLED=TRUE		ELSE			IF UserSym>=LastSym THEN				SETDEFAULTCURSOR				WARNINGBOX "Symbol Table","No Symbols In Table",MB_OK				RETURN			END IF			ShowSymbols=TRUE			Edit.ENABLED=FALSE			EventCombo1.ENABLED=FALSE			EventCombo2.ENABLED=FALSE			CREATE SymbolGrid,0,42,1015,630			SymbolGrid.FONT=GridFont			SymbolGrid.BACKCOLOR=$800000			SymbolGrid.FORECOLOR=$ffffff			SymbolGrid.HEADERHEIGHT=18			SymbolGrid.ROWHEIGHT=15			SymbolGrid.ADDCOL TEXT,35,"#",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,165,"Symbol Name",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,70,"DataType",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,35,"Sub",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Modifer",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Detail",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Addr",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Size",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Dim1",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Dim2",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Dim3",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Events",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Notify",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,28,"Dim",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,25,"Msc",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,25,"Fdt",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,25,"Arg",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,35,"Use",CENTER,LEFT,31			FOR I=UserSym TO LastSym				J=I-UserSym+1				SymbolGrid.ADDROW				TempStr=STR(J)				GOSUB FormatNumber4				SymbolGrid.TEXT(J,1)=TempStr				TempStr=SymTable(I).SymName				SymbolGrid.TEXT(J,2)=TempStr				TempInt=SymTable(I).DataType				GOSUB GetDataType				SymbolGrid.TEXT(J,3)=TempStr				TempStr=HEX(SymTable(I).SubType)				GOSUB FormatNumber4				SymbolGrid.TEXT(J,4)=TempStr				TempStr=HEX(SymTable(I).DataMod)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,5)=TempStr				TempStr=HEX(SymTable(I).Detail)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,6)=TempStr				TempStr=HEX(SymTable(I).DataAddr)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,7)=TempStr				TempStr=HEX(SymTable(I).DataSize)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,8)=TempStr				TempStr=HEX(SymTable(I).ArrayDim1)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,9)=TempStr				TempStr=HEX(SymTable(I).ArrayDim2)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,10)=TempStr				TempStr=HEX(SymTable(I).ArrayDim3)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,11)=TempStr				TempStr=HEX(SymTable(I).GUIEvents)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,12)=TempStr				TempStr=HEX(SymTable(I).GUINotifyEvents)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,13)=TempStr				TempStr=HEX(SymTable(I).ArrayDims)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,14)=TempStr				TempStr=HEX(SymTable(I).Misc)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,15)=TempStr				TempStr=HEX(SymTable(I).FcnDataType)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,16)=TempStr				TempStr=HEX(SymTable(I).FcnArgs)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,17)=TempStr				TempStr=STR(SymTable(I).UseCount)				GOSUB FormatNumber4				;TempStr="0000"				SymbolGrid.TEXT(J,18)=TempStr			NEXT I		END IF		CASE 21		GOSUB ScratchPad	CASE 22		LAUNCH BareFileName	CASE 23		; Help button		launch "DIRECTX.CHM"END SELECTEND EVENTButton6Pressed:IF TextMode=TRUE THEN	StatusBar.SETTEXT 1,""	StatusBar.SETTEXT 2,""	StatusBar.SETTEXT 3,""	StatusBar.SETTEXT 4,""	StatusBar.SETTEXT 5,"Snap On"	FOR I=1 TO 23		IF I<>3 AND I<>6 AND I<>7 AND I<>8 THEN			Button(I).ENABLED=FALSE		END IF	NEXT I	IF Button(7).ENABLED=TRUE THEN		UnDoFlag=TRUE	ELSE		UnDoFlag=FALSE	END IF	Button(7).ENABLED=FALSE	IF Button(8).ENABLED=TRUE THEN		ReDoFlag=TRUE	ELSE		ReDoFlag=FALSE	END IF	Button(8).ENABLED=FALSE	;// ENABLEMENUITEMMainMenu,mnuExit,FALSE	IF GraphicConstructed=FALSE THEN		CREATE dbgwin,0,740,1024,255 child		CREATE refresh,10,5,80,20 in dbgwin		refresh.text="Refresh"		CREATE controlndx,100,5,80,20 in dbgwin		CREATE controlptr,180,5,80,20 in dbgwin		CREATE controlcount,270,5,80,20 in dbgwin		CREATE controlname,360,5,80,20 in dbgwin		CREATE controlptrsafe,440,5,80,20 in dbgwin		CREATE controlndxlbl,95,30,85,20 in dbgwin		controlndxlbl.text="ControlNdx"		CREATE controlptrlbl,175,30,85,20 in dbgwin		controlptrlbl.text="ControlPtr"		CREATE controlcountlbl,265,30,85,20 in dbgwin		controlcountlbl.text="ControlCount"		CREATE controlnamelbl,355,30,85,20 in dbgwin		controlnamelbl.text="ControlName"		CREATE controlptrsafelbl,440,30,80,20 in dbgwin		controlptrsafelbl.text="PtrSafe"		CREATE grid,0,50,1015,200 in dbgwin		grid.addcol LONG,35,"#",LEFT,LEFT,31		grid.addcol LONG,115,"Handle",LEFT,LEFT,31		grid.addcol LONG,50,"ID",LEFT,LEFT,31		grid.addcol LONG,50,"Owner",LEFT,LEFT,31		grid.addcol LONG,50,"Array",LEFT,LEFT,31		grid.addcol LONG,50,"Left",LEFT,LEFT,31		grid.addcol LONG,50,"Top",LEFT,LEFT,31		grid.addcol LONG,50,"Width",LEFT,LEFT,31		grid.addcol LONG,50,"Height",LEFT,LEFT,31		grid.addcol LONG,50,"BColor",LEFT,LEFT,31		grid.addcol LONG,50,"FColor",LEFT,LEFT,31		grid.addcol LONG,50,"Type",LEFT,LEFT,31		grid.addcol LONG,50,"Status",LEFT,LEFT,31		grid.addcol LONG,50,"Font",LEFT,LEFT,31		grid.addcol LONG,50,"Icon",LEFT,LEFT,31		grid.addcol TEXT,100,"Text",LEFT,LEFT,31		grid.addcol TEXT,100,"Name",LEFT,LEFT,31		grid.HEADERHEIGHT=21						CREATE ToolBox,3,85,300,631 CHILD		ToolBox.TEXT="Toolbox"		ToolBox.VISIBLE=FALSE		CREATE ToolButton(1),10,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(1).TOOLTIP="Form"		CREATE FormBMP,OBTForm.bmp		ToolButton(1).BITMAP=FormBMP		CREATE ToolButton(2),45,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(2).TOOLTIP="ToolWindow"		ToolButton(2).BITMAP=FormBMP		CREATE ToolButton(3),80,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(3).TOOLTIP="Button"		CREATE ButtonBMP,OBTButton.bmp		ToolButton(3).BITMAP=ButtonBMP		CREATE ToolButton(4),115,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(4).TOOLTIP="StaticText"		CREATE StaticTextBMP,OBTStaticText.bmp		ToolButton(4).BITMAP=StaticTextBMP		CREATE ToolButton(5),150,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(5).TOOLTIP="Frame"		CREATE FrameBMP,OBTFrame.bmp		ToolButton(5).BITMap=FrameBMP		CREATE ToolButton(6),185,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(6).TOOLTIP="Slider"		CREATE SliderBMP,OBTSlider.bmp		ToolButton(6).BITMAP=SliderBMP		CREATE ToolButton(7),220,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(7).TOOLTIP="TextBox"		CREATE TextBoxBMP,OBTTextBox.bmp		ToolButton(7).BITMAP=TextBoxBMP		CREATE ToolButton(8),255,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(8).TOOLTIP="ComboBox"		CREATE ComboBoxBMP,OBTComboBox.bmp		ToolButton(8).BITMAP=ComboBoxBMP		CREATE ToolButton(9),10,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(9).TOOLTIP="ListBox"		CREATE ListBoxBMP,OBTListBox.bmp		ToolButton(9).BITMAP=ListBoxBMP		CREATE ToolButton(10),45,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(10).TOOLTIP="RadioButton"		CREATE RadioButtonBMP,OBTRadioButton.bmp		ToolButton(10).BITMAP=RadioButtonBMP		CREATE ToolButton(11),80,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(11).TOOLTIP="CheckBox"		CREATE CheckBoxBMP,OBTCheckBox.bmp		ToolButton(11).BITMAP=CheckBoxBMP		CREATE ToolButton(12),115,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(12).TOOLTIP="ProgressBar"		CREATE ProgressBarBMP,OBTProgressBar.bmp		ToolButton(12).BITMAP=ProgressBarBMP		CREATE ToolButton(13),150,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(13).TOOLTIP="Calendar"		CREATE CalendarBMP,OBTCalendar.bmp		ToolButton(13).BITMAP=CalendarBMP		CREATE ToolButton(14),185,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(14).TOOLTIP="TabFolder"		CREATE TabFolderBMP,OBTTabFolder.bmp		ToolButton(14).BITMAP=TabFolderBMP		CREATE ToolButton(15),220,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE SpinnerBMP,OBTVScroll.bmp		ToolButton(15).BITMAP=SpinnerBMP		CREATE ToolButton(16),255,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(16).TOOLTIP="Statusbar"		CREATE StatusBarBMP,OBTStatusBar.bmp		ToolButton(16).BITMAP=StatusBarBMP		CREATE ToolButton(17),10,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE HeaderBMP,OBTHeader.bmp		ToolButton(17).BITMAP=HeaderBMP		CREATE ToolButton(18),45,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE AnimateBMP,OBTAnimate.bmp		ToolButton(18).BITMAP=AnimateBMP		CREATE ToolButton(19),80,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE RichEditBMP,OBTRichEdit.bmp		ToolButton(19).BITMAP=RichEditBMP		CREATE ToolButton(20),115,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(20).TOOLTIP="RAEdit"		CREATE RAEditBMP,OBTRAEdit.bmp		ToolButton(20).BITMAP=RAEditBMP		CREATE ToolButton(21),150,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(21).TOOLTIP="RAGrid"		CREATE RAGridBMP,OBTGrid.bmp		ToolButton(21).BITMAP=RAGridBMP		CREATE ToolButton(22),185,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(22).TOOLTIP="ListView"		CREATE ListViewBMP,OBTListView.bmp		ToolButton(22).BITMAP=ListViewBMP		CREATE ToolButton(23),220,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(23).TOOLTIP="ToolBar"		CREATE ToolBarBMP,OBTToolBar.bmp		ToolButton(23).BITMAP=ToolBarBMP		CREATE ToolButton(24),255,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(24).TOOLTIP="TreeView"		CREATE TreeViewBMP,OBTTreeView.bmp		ToolButton(24).BITMAP=TreeViewBMP		CREATE ToolButton(25),10,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(25).TOOLTIP="DateTimePick"		CREATE DateTimePickBMP,OBTDateTimePick.bmp		ToolButton(25).BITMAP=DateTimePickBMP		CREATE ToolButton(26),45,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(26).TOOLTIP="Image"		CREATE ImageBMP,OBTImage.bmp		ToolButton(26).BITMAP=ImageBMP		CREATE ToolButton(27),80,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(27).TOOLTIP="DrawProgress"		CREATE DrawProgressBMP,OBTDrawProgress.bmp		ToolButton(27).BITMAP=DrawProgressBMP		;CREATE ToolButton(28),0,166,98,18,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		;ToolButton(28).TEXT=""		;CREATE ToolButton(29),98,166,98,18,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		;ToolButton(29).TEXT=""		;CREATE ToolButton(30),196,166,98,18,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		;ToolButton(30).TEXT=""		CREATE FormCombo,0,184,265,160 IN ToolBox		CREATE ControlCombo,0,210,265,160 IN ToolBox		CREATE NudgePosButton(1),267,184,8,8 IN ToolBox		CREATE NudgePosButton(2),275,184,8,8 IN ToolBox		CREATE NudgePosButton(3),283,184,8,8 IN ToolBox		CREATE NudgePosButton(4),267,192,8,8 IN ToolBox		CREATE NudgePosButton(5),283,192,8,8 IN ToolBox		CREATE NudgePosButton(6),267,200,8,8 IN ToolBox		CREATE NudgePosButton(7),275,200,8,8 IN ToolBox		CREATE NudgePosButton(8),283,200,8,8 IN ToolBox		CREATE NudgeSizeButton(1),267,210,8,8 IN ToolBox		CREATE NudgeSizeButton(2),275,210,8,8 IN ToolBox		CREATE NudgeSizeButton(3),283,210,8,8 IN ToolBox		CREATE NudgeSizeButton(4),267,218,8,8 IN ToolBox		CREATE NudgeSizeButton(5),283,218,8,8 IN ToolBox		CREATE NudgeSizeButton(6),267,226,8,8 IN ToolBox		CREATE NudgeSizeButton(7),275,226,8,8 IN ToolBox		CREATE NudgeSizeButton(8),283,226,8,8 IN ToolBox		CREATE PropGrid,0,236,295,185 IN ToolBox		PropGrid.FONT=GridFont		PropGrid.HEADERHEIGHT=18		PropGrid.ROWHEIGHT=15		PropGrid.ADDCOL TEXT,100,"Property",CENTER,LEFT,31		PropGrid.ADDCOL TEXT,156,"Value",CENTER,LEFT,31		PropGrid.ADDCOL BUTTON,18,"",CENTER,CENTER,31		CREATE StyleGrid,0,421,295,185 IN ToolBox		StyleGrid.FONT=GridFont		StyleGrid.HEADERHEIGHT=18		StyleGrid.ROWHEIGHT=15		StyleGrid.ADDCOL TEXT,114,"Style",CENTER,LEFT,31		StyleGrid.ADDCOL CHECK,60,"On/Off",CENTER,CENTER,31		StyleGrid.ADDCOL TEXT,100,"Value",CENTER,LEFT,31		CREATE ExStyleGrid,0,421,295,185 IN ToolBox		ExStyleGrid.FONT=GridFont		ExStyleGrid.HEADERHEIGHT=18		ExStyleGrid.ROWHEIGHT=15		ExStyleGrid.ADDCOL TEXT,114,"ExStyle",CENTER,LEFT,31		ExStyleGrid.ADDCOL CHECK,60,"On/Off",CENTER,CENTER,31		ExStyleGrid.ADDCOL TEXT,100,"Value",CENTER,LEFT,31		ExStyleGrid.VISIBLE=FALSE		ToolButtonNdx=1		FormWindow.VISIBLE=FALSE		GraphicConstructed=TRUE		ToolButtonNdx=1		PlacePart=TRUE		GOSUB PopulateToolBox		GOSUB ToolButtonAction		PlacePart=FALSE	ELSE		BackGround.VISIBLE=TRUE		ToolBox.VISIBLE=TRUE		FormWindow.VISIBLE=TRUE	END IF	TextMode=FALSE	FindWindow.VISIBLE=FALSE	FindReplaceWindow.VISIBLE=FALSE	Edit.VISIBLE=FALSE	QuickFindPrev.VISIBLE=FALSE	QuickFindNext.VISIBLE=FALSE	QuickFind.VISIBLE=FALSE	EventCombo1.VISIBLE=FALSE	EventCombo2.VISIBLE=FALSE	GotoWindow.VISIBLE=FALSE	ScratchPadWindow.VISIBLE=FALSE	BackGround.VISIBLE=TRUE	IF ToolView=TRUE THEN		ToolBox.VISIBLE=TRUE	END IF	FormWindow.VISIBLE=TRUE	StatusBarSafe4="Edit Objects"	StatusBar.SETTEXT 4,StatusBarSafe4	Button(6).BITMAP=EditBMPELSE	StatusBar.SETTEXT 1,StatusBarSafe1	StatusBar.SETTEXT 2,StatusBarSafe2	StatusBar.SETTEXT 3,StatusBarSafe3	StatusBar.SETTEXT 4,StatusBarSafe4	StatusBar.SETTEXT 5,StatusBarSafe5	FOR I=1 TO 22		IF I<>3 AND I<>6 AND I<>7 AND I<>8 THEN			Button(I).ENABLED=TRUE		END IF		NEXT I	IF UnDoFlag=TRUE THEN		Button(7).ENABLED=TRUE	ELSE						Button(7).ENABLED=FALSE	END IF	IF ReDoFlag=TRUE THEN		Button(8).ENABLED=TRUE	ELSE		Button(8).ENABLED=FALSE	END IF	;// ENABLEMENUITEMMainMenu,mnuExit,TRUE	TextMode=TRUE	IF FindWindowActive THEN		FindWindow.VISIBLE=TRUE	END IF	IF FRWindowActive THEN		FindReplaceWindow.VISIBLE=TRUE	END IF	Edit.VISIBLE=TRUE	QuickFindPrev.VISIBLE=TRUE	QuickFindNext.VISIBLE=TRUE	QuickFind.VISIBLE=TRUE	EventCombo1.VISIBLE=TRUE	EventCombo2.VISIBLE=TRUE	BackGround.VISIBLE=FALSE	ToolBox.VISIBLE=FALSE	FormWindow.VISIBLE=FALSE	StatusBarSafe4="Edit Text"	StatusBar.SETTEXT 4,StatusBarSafe4	Button(6).BITMAP=ToolBMPEND IFRETURNGotoLine:IF GotoWindowConstructed=FALSE THEN	CREATE GotoWindow,100,100,110,90 APPWINDOW CHILD	GotoWindow.TEXT="Goto Line"	GotoWindowConstructed=TRUE	CREATE GotoText,10,10,80,20 IN GotoWindow	GotoText.INTERCEPTON	CREATE GotoButton,10,40,80,20 IN GotoWindow	GotoButton.TEXT="Goto Line"ELSE	GotoWindow.VISIBLE=TRUEEND IFGotoText.SETFOCUSGotoButton.ENABLED=FALSERETURNGotoText.INTERCEPTIF wmsg=$102 THEN	IF wparam=$0d THEN		GOSUB GotoButton_COMMAND	END IFEND IFPASSEVENTEND EVENTScratchPad:IF ScratchPadWindowConstructed=FALSE THEN	CREATE ScratchPadWindow,400,100,400,300 APPWINDOW CHILD	ScratchPadWindow.TEXT="ScratchPad"	ScratchPadWindowConstructed=TRUE	CREATE ScratchPadText,0,0,398,290,default+multiline+autovscroll+autohscroll IN ScratchPadWindowELSE	ScratchPadWindow.VISIBLE=TRUEEND IFScratchPadText.SETFOCUSRETURNFormWindow.SYSTEM; Do NothingEND EVENTToolBox.RESIZE;SETPOSITION ToolBox,3,85,300,155END EVENTTABLE ImportLibTable AS ImportLibData "kernel32","kernel32.dll",FALSE,FALSE "user32","User32.dll",FALSE,FALSE "gdi","GDI32.DLL",FALSE,FALSE "comctl","COMCTL32.DLL",FALSE,FALSE "comdlg","COMDLG32.DLL",FALSE,FALSE "shell","SHELL32.DLL",FALSE,FALSE "advapi","ADVAPI32.DLL",FALSE,FALSE "winmm","WINMM.DLL",FALSE,FALSE "msvcrt","msvcrt.dll",FALSE,FALSE "csmdll","csmdll.dll",FALSE,FALSE "richedit","RichEd20.dll",FALSE,FALSE "imagelib","ImageLib.dll",FALSE,FALSEEND TABLETABLE ImportFcnTable AS ImportFcnData ptrkernel32,"Beep","Beep",FALSE,FALSE ptrkernel32,"SetThreadPriority","SetThreadPriority",FALSE,FALSE ptrkernel32,"Sleep","Sleep",FALSE,FALSE ptrkernel32,"CreateThread","CreateThread",FALSE,FALSE ptrkernel32,"SuspendThread","SuspendThread",FALSE,FALSE ptrkernel32,"ResumeThread","ResumeThread",FALSE,FALSE ptrkernel32,"ClearCommError","ClearCommError",FALSE,FALSE ptrkernel32,"CloseHandle","CloseHandle",FALSE,FALSE ptrkernel32,"CreateDirectory","CreateDirectoryA",FALSE,FALSE ptrkernel32,"CreateFile","CreateFileA",FALSE,FALSE ptrkernel32,"CreatePipe","CreatePipe",FALSE,FALSE ptrkernel32,"CreateProcess","CreateProcessA",FALSE,FALSE ptrkernel32,"DeleteFile","DeleteFileA",FALSE,FALSE ptrkernel32,"ExitProcess","ExitProcess",FALSE,FALSE ptrkernel32,"GetCommandLine","GetCommandLineA",FALSE,FALSE ptrkernel32,"GetCurrentProcess","GetCurrentProcess",FALSE,FALSE ptrkernel32,"GetCurrentDirectory","GetCurrentDirectoryA",FALSE,FALSE ptrkernel32,"GetFileSize","GetFileSize",FALSE,FALSE ptrkernel32,"GetFileType","GetFileType",FALSE,FALSE ptrkernel32,"GetFullPathName","GetFullPathNameA",FALSE,FALSE ptrkernel32,"GetLastError","GetLastError",FALSE,FALSE ptrkernel32,"GetModuleHandle","GetModuleHandleA",FALSE,FALSE ptrkernel32,"GetStdHandle","GetStdHandle",FALSE,FALSE ptrkernel32,"GetTickCount","GetTickCount",FALSE,FALSE ptrkernel32,"GetSystemTime","GetSystemTime",FALSE,FALSE ptrkernel32,"GetLocalTime","GetLocalTime",FALSE,FALSE ptrkernel32,"GetDateFormat","GetDateFormatA",FALSE,FALSE ptrkernel32,"GetTimeFormat","GetTimeFormatA",FALSE,FALSE ptrkernel32,"FileTimeToSystemTime","FileTimeToSystemTime",FALSE,FALSE ptrkernel32,"SystemTimeToFileTime","SystemTimeToFileTime",FALSE,FALSE ptrkernel32,"LoadLibrary","LoadLibraryA",FALSE,FALSE ptrkernel32,"ReadConsole","ReadConsoleA",FALSE,FALSE ptrkernel32,"ReadFile","ReadFile",FALSE,FALSE ptrkernel32,"RemoveDirectory","RemoveDirectoryA",FALSE,FALSE ptrkernel32,"SetCurrentDirectory","SetCurrentDirectoryA",FALSE,FALSE ptrkernel32,"SetCommMask","SetCommMask",FALSE,FALSE ptrkernel32,"GetCommState","GetCommState",FALSE,FALSE ptrkernel32,"SetCommState","SetCommState",FALSE,FALSE ptrkernel32,"SetFilePointer","SetFilePointer",FALSE,FALSE ptrkernel32,"SetEndOfFile","SetEndOfFile",FALSE,FALSE ptrkernel32,"VirtualAlloc","VirtualAlloc",FALSE,FALSE ptrkernel32,"VirtualFree","VirtualFree",FALSE,FALSE ptrkernel32,"WinExec","WinExec",FALSE,FALSE ptrkernel32,"WriteConsole","WriteConsoleA",FALSE,FALSE ptrkernel32,"WriteFile","WriteFile",FALSE,FALSE ptruser32,"AppendMenu","AppendMenuA",FALSE,FALSE ptruser32,"BeginPaint","BeginPaint",FALSE,FALSE ptruser32,"EndPaint","EndPaint",FALSE,FALSE ptruser32,"GetDC","GetDC",FALSE,FALSE ptruser32,"GetFocus","GetFocus",FALSE,FALSE ptruser32,"ReleaseDC","ReleaseDC",FALSE,FALSE ptruser32,"CallWindowProc","CallWindowProcA",FALSE,FALSE ptruser32,"CheckDlgButton","CheckDlgButton",FALSE,FALSE ptruser32,"CheckMenuItem","CheckMenuItem",FALSE,FALSE ptruser32,"CheckRadioButton","CheckRadioButton",FALSE,FALSE ptruser32,"ChildWindowFromPoint","ChildWindowFromPoint",FALSE,FALSE ptruser32,"CreateIconFromResource","CreateIconFromResource",FALSE,FALSE ptruser32,"CreateMenu","CreateMenu",FALSE,FALSE ptruser32,"CreatePopupMenu","CreatePopupMenu",FALSE,FALSE ptruser32,"CreateWindowEx","CreateWindowExA",FALSE,FALSE ptruser32,"DefWindowProc","DefWindowProcA",FALSE,FALSE ptruser32,"DeleteMenu","DeleteMenu",FALSE,FALSE ptruser32,"DestroyWindow","DestroyWindow",FALSE,FALSE ptruser32,"DispatchMessage","DispatchMessageA",FALSE,FALSE ptruser32,"DrawMenuBar","DrawMenuBar",FALSE,FALSE ptruser32,"EnableMenuItem","EnableMenuItem",FALSE,FALSE ptruser32,"EnableWindow","EnableWindow",FALSE,FALSE ptruser32,"FlashWindow","FlashWindow",FALSE,FALSE ptruser32,"GetAncestor","GetAncestor",FALSE,FALSE ptruser32,"GetClientRect","GetClientRect",FALSE,FALSE ptruser32,"GetComboBoxInfo","GetComboBoxInfo",FALSE,FALSE ptruser32,"GetCursorPos","GetCursorPos",FALSE,FALSE ptruser32,"SetCursorPos","SetCursorPos",FALSE,FALSE ptruser32,"GetCursor","GetCursor",FALSE,FALSE ptruser32,"SetCursor","SetCursor",FALSE,FALSE ptruser32,"GetMessage","GetMessageA",FALSE,FALSE ptruser32,"GetActiveWindow","GetActiveWindow",FALSE,FALSE ptruser32,"GetParent","GetParent",FALSE,FALSE ptruser32,"GetWindowRect","GetWindowRect",FALSE,FALSE ptruser32,"IsIconic","IsIconic",FALSE,FALSE ptruser32,"HiliteMenuItem","HiliteMenuItem",FALSE,FALSE ptruser32,"InvalidateRect","InvalidateRect",FALSE,FALSE ptruser32,"InsertMenu","InsertMenuA",FALSE,FALSE ptruser32,"InsertMenuItem","InsertMenuItemA",FALSE,FALSE ptruser32,"IsWindowEnabled","IsWindowEnabled",FALSE,FALSE ptruser32,"IsWindowVisible","IsWindowVisible",FALSE,FALSE ptruser32,"KillTimer","KillTimer",FALSE,FALSE ptruser32,"LoadCursor","LoadCursorA",FALSE,FALSE ptruser32,"LoadIcon","LoadIconA",FALSE,FALSE ptruser32,"LoadImage","LoadImageA",FALSE,FALSE ptruser32,"LoadMenu","LoadMenuA",FALSE,FALSE ptruser32,"MessageBox","MessageBoxA",FALSE,FALSE ptruser32,"ModifyMenu","ModifyMenuA",FALSE,FALSE ptruser32,"PostMessage","PostMessageA",FALSE,FALSE ptruser32,"MoveWindow","MoveWindow",FALSE,FALSE ptruser32,"PostQuitMessage","PostQuitMessage",FALSE,FALSE ptruser32,"RedrawWindow","RedrawWindow",FALSE,FALSE ptruser32,"RegisterClass","RegisterClassA",FALSE,FALSE ptruser32,"RegisterWindowMessage","RegisterWindowMessageA",FALSE,FALSE ptruser32,"ReleaseCapture","ReleaseCapture",FALSE,FALSE ptruser32,"RemoveMenu","RemoveMenu",FALSE,FALSE ptruser32,"ScreenToClient","ScreenToClient",FALSE,FALSE ptruser32,"SendMessage","SendMessageA",FALSE,FALSE ptruser32,"SetCapture","SetCapture",FALSE,FALSE ptruser32,"SetClassLong","SetClassLongA",FALSE,FALSE ptruser32,"SetFocus","SetFocus",FALSE,FALSE ptruser32,"SetMenu","SetMenu",FALSE,FALSE ptruser32,"SetMenuItemBitmaps","SetMenuItemBitmaps",FALSE,FALSE ptruser32,"SetTimer","SetTimer",FALSE,FALSE ptruser32,"GetWindowLong","GetWindowLongA",FALSE,FALSE ptruser32,"SetWindowLong","SetWindowLongA",FALSE,FALSE ptruser32,"SetWindowPos","SetWindowPos",FALSE,FALSE ptruser32,"ShowWindow","ShowWindow",FALSE,FALSE ptruser32,"UpdateWindow","UpdateWindow",FALSE,FALSE ptruser32,"TrackPopupMenuEx","TrackPopupMenuEx",FALSE,FALSE ptruser32,"TranslateMessage","TranslateMessage",FALSE,FALSE ptrgdi,"CreateCompatibleDC","CreateCompatibleDC",FALSE,FALSE ptrgdi,"CreateDIBSection","CreateDIBSection",FALSE,FALSE ptrgdi,"CreateFontIndirect","CreateFontIndirectA",FALSE,FALSE ptrgdi,"CreateSolidBrush","CreateSolidBrush",FALSE,FALSE ptrgdi,"DeleteObject","DeleteObject",FALSE,FALSE ptrgdi,"GetPixel","GetPixel",FALSE,FALSE ptrgdi,"SetPixel","SetPixel",FALSE,FALSE ptrgdi,"GetBkColor","GetBkColor",FALSE,FALSE ptrgdi,"SetBkColor","SetBkColor",FALSE,FALSE ptrgdi,"SetBkMode","SetBkMode",FALSE,FALSE ptrgdi,"GetStockObject","GetStockObject",FALSE,FALSE ptrgdi,"SetTextColor","SetTextColor",FALSE,FALSE ptrcomctl,"InitCommonControlsEx","InitCommonControlsEx",FALSE,FALSE ptrcomctl,"TrackMouseEvent","_TrackMouseEvent",FALSE,FALSE ptrcomdlg,"ChooseFont","ChooseFontA",FALSE,FALSE ptrcomdlg,"ChooseColor","ChooseColorA",FALSE,FALSE ptrcomdlg,"GetOpenFileName","GetOpenFileNameA",FALSE,FALSE ptrcomdlg,"GetSaveFileName","GetSaveFileNameA",FALSE,FALSE ptrcomdlg,"FindText","FindTextA",FALSE,FALSE ptrcomdlg,"ReplaceText","ReplaceTextA",FALSE,FALSE ptrshell,"DragAcceptFiles","DragAcceptFiles",FALSE,FALSE ptrshell,"ShellExecute","ShellExecuteA",FALSE,FALSE ptrshell,"ShellNotifyIcon","Shell_NotifyIcon",FALSE,FALSE ptradvapi,"RegCreateKeyEx","RegCreateKeyExA",FALSE,FALSE ptradvapi,"RegCloseKey","RegCloseKey",FALSE,FALSE ptrwinmm,"sndPlaySound","sndPlaySoundA",FALSE,FALSE ptrmsvcrt,"abs","abs",FALSE,FALSE ptrmsvcrt,"atol","atol",FALSE,FALSE ptrmsvcrt,"ltoa","_ltoa",FALSE,FALSE ptrmsvcrt,"printf","printf",FALSE,FALSE ptrmsvcrt,"puts","puts",FALSE,FALSE ptrmsvcrt,"sprintf","sprintf",FALSE,FALSE ptrmsvcrt,"system","system",FALSE,FALSE ptrcsmdll,"CSMGetDriveHandle","CSMGetDriveHandle",FALSE,FALSE ptrcsmdll,"CSMDriveStatus","CSMDriveStatus",FALSE,FALSE ptrcsmdll,"CSMReadBlock","CSMReadBlock",FALSE,FALSE ptrcsmdll,"CSMReleaseDriveHandle","CSMReleaseDriveHandle",FALSE,FALSE ptrcsmdll,"CSMWriteBlock","CSMWriteBlock",FALSE,FALSE ptrrichedit,"CreateTextServices","CreateTextServices",FALSE,FALSE ptrimagelib,"BitmapFromFile","BitmapFromFile",FALSE,FALSE ptrimagelib,"BitmapFromMemory","BitmapFromMemory",FALSE,FALSE ptrimagelib,"BitmapFromPicture","BitmapFromPicture",FALSE,FALSE ptrimagelib,"BitmapFromResource","BitmapFromResource",FALSE,FALSEEND TABLETABLE FormPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,FALSE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psFormBackColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,TRUE "TOOLTIP",pgBad,psBad,LONGVAR,FALSE "icon",pgBad,psIcon,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "flashwindow",pgBad,psFlashWindow,BOOLVAR,FALSE "minimized",pgMinimized,psBad,BOOLVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE FormStyleTable AS StyleData "base",$10000000,STYLE,FALSE "default",$10cf0000,STYLE,FALSE "iconicpopup",$c0000000,STYLE,FALSE "popup",$80000000,STYLE,FALSE "child",$40000000,STYLE,FALSE "minimize",$20000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "disabled",$08000000,STYLE,FALSE "clipsiblings",$04000000,STYLE,FALSE "clipchildren",$02000000,STYLE,FALSE "maximize",$01000000,STYLE,FALSE "border",$00800000,STYLE,FALSE "dlgframe",$00400000,STYLE,FALSE "vscroll",$00200000,STYLE,FALSE "hscroll",$00100000,STYLE,FALSE "sysmenu",$00080000,STYLE,TRUE "thickframe",$00040000,STYLE,TRUE "minimizebox",$00020000,STYLE,TRUE "maximizebox",$00010000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "toolwindow",$00000080,EXSTYLE,FALSE "appwindow",$00040000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE FormEventTable AS EventData "create",evCreateUsed,evCreateOffs,0 "system",evSysCommandUsed,evSysCommandOffs,0 "resize",evResizeUsed,evResizeOffs,0 "move",evMoveUsed,evMoveOffs,0 "mousemove",evMouseMoveUsed,evMouseMoveOffs,0 "lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0 "lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0 "rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0 "rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0 "paint",evPaintUsed,evPaintOffs,0 "keystruck"evKeyStruckUsed,evKeyStruckOffs,0 "%",0,0,0END TABLETABLE ToolWindowPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,FALSE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psFormBackColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,TRUE "TOOLTIP",pgBad,psBad,LONGVAR,FALSE "icon",pgBad,psIcon,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "flashwindow",pgBad,psFlashWindow,BOOLVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ToolWindowStyleTable AS StyleData "base",$00000000,STYLE,FALSE "default",$10000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ToolWindowEventTable AS EventData "create",evCreateUsed,evCreateOffs,0 "system",evSysCommandUsed,evSysCommandOffs,0 "resize",evResizeUsed,evResizeOffs,0 "move",evMoveUsed,evMoveOffs,0 "mousemove",evMouseMoveUsed,evMouseMoveOffs,0 "lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0 "lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0 "rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0 "rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0 "%",0,0,0END TABLETABLE ButtonPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "BACKCOLOR",pgBad,psBad,LONGVAR,FALSE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,TRUE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "icon",pgBad,psButtonIcon,LONGVAR,TRUE "bitmap",pgBad,psButtonBitmap,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "pushed",pgBad,psPushed,BOOLVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ButtonStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "defpushbutton",$00000001,STYLE,TRUE "left",$00000100,STYLE,FALSE "right",$00000200,STYLE,FALSE "top",$00000400,STYLE,FALSE "bottom",$00000800,STYLE,FALSE "icon",$00000040,STYLE,FALSE "bitmap",$00000080,STYLE,FALSE "flat",$00008000,STYLE,FALSE "multiline",$00002000,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ButtonEventTable AS EventData "command",evCommandUsed,evCommandOffs,0  "%",0,0,0 "lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0 "lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0 "rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0 "rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0 "%",0,0,0END TABLETABLE StaticIconPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,TRUE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "icon",pgBad,psSTIcon,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE StaticIconStyleTable AS StyleData "base",$50000103,STYLE,FALSE "default",$50000303,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "icon",$00000003,STYLE,TRUE "centerimage",$00000200,STYLE,TRUE "notify",$00000100,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE StaticIconEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE ComboBoxPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "finditem",pfComboFindItem,pfComboFindItem,LONGVAR,TRUE "replaceitem",pfComboReplaceItem,pfComboReplaceItem,LONGVAR,TRUE "deleteitem",pfComboDeleteItem,pfComboDeleteItem,LONGVAR,FALSE "additem",pfComboAddItem,pfComboAddItem,LONGVAR,FALSE "additemsorted",pfComboAddSorted,pfComboAddSorted,LONGVAR,FALSE "insertitem",pfComboInsertItem,pfComboInsertItem,LONGVAR,FALSE "clear",pfComboClear,pfComboClear,LONGVAR,FALSE "selitem",pgComboBoxSelItem,psComboBoxSelItem,LONGVAR,FALSE "topitem",pgComboBoxTopItem,psComboBoxTopItem,LONGVAR,FALSE "seltext",pgComboBoxSelText,psBad,STRINGVAR,FALSE "itemcount",pgComboBoxItemCount,psBad,LONGVAR,FALSE "dropped",pgDropped,psDropped,BOOLVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "hilite",pgBad,psHiliteComboText,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ComboBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50200102,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "vscroll",$00200000,STYLE,TRUE "simple",$00000001,STYLE,FALSE "dropdown",$00000002,STYLE,TRUE "autohscroll",$00000040,STYLE,FALSE "oemconvert",$00000080,STYLE,FALSE "sort",$00000100,STYLE,TRUE "uppercase",$00002000,STYLE,FALSE "lowercase",$00204000,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,TRUE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ComboBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "change",evChangeUsed,evChangeOffs,5 "select",evSelectUsed,evSelectOffs,9 "scroll",evScrollUsed,evScrollOffs,0 "%",0,0,0END TABLETABLE TextBoxPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "setsel",pfSetSel,pfSetSel,LONGVAR,FALSE "selectall",pfSelectAll,pfSelectAll,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TextBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "center",$00000001,STYLE,FALSE "right",$00000002,STYLE,FALSE "multiline",$00000004,STYLE,FALSE "uppercase",$00000008,STYLE,FALSE "lowercase",$00000010,STYLE,FALSE "password",$00000020,STYLE,FALSE "autovscroll",$00000040,STYLE,FALSE "autohscroll",$00000080,STYLE,FALSE "nohidesel",$00000100,STYLE,FALSE "oemconvert",$00000400,STYLE,FALSE "readonly",$00000800,STYLE,FALSE "wantreturn",$00001000,STYLE,FALSE "number",$00002000,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,TRUE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE TextBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "change",evChangeUsed,evChangeOffs,$300 "%",0,0,0END TABLETABLE FramePropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "TOOLTIP",pgBad,psBad,LONGVAR,FALSE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE FrameStyleTable AS StyleData "base",$50000007,STYLE,FALSE "default",$50000007,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "groupbox",$00000007,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE FrameEventTable AS EventData "%",0,0,0END TABLETABLE ListBoxPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgListBoxText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "finditem",pfListBoxFindItem,pfListBoxFindItem,LONGVAR,TRUE "replaceitem",pfListBoxReplaceItem,pfListBoxReplaceItem,LONGVAR,TRUE "deleteitem",pfListBoxDeleteItem,pfListBoxDeleteItem,LONGVAR,FALSE "additem",pfListBoxAddItem,pfListBoxAddItem,LONGVAR,FALSE "additemsorted",pfListBoxAddSorted,pfListBoxAddSorted,LONGVAR,FALSE "insertitem",pfListBoxInsertItem,pfListBoxInsertItem,LONGVAR,FALSE "clear",pfListBoxClear,pfListBoxClear,LONGVAR,FALSE "selitem",pgListBoxSelItem,psListBoxSelItem,LONGVAR,FALSE "topitem",pgListBoxTopItem,psListBoxTopItem,LONGVAR,FALSE "seltext",pgListBoxSelText,psBad,STRINGVAR,FALSE "itemcount",pgListBoxItemCount,psBad,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ListBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50a00003,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "sort",$00000002,STYLE,TRUE "vscroll",$00200000,STYLE,TRUE "hscroll",$00100000,STYLE,FALSE "border",$0080000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,TRUE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ListBoxEventTable AS EventData "select",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE SliderPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "value",pgSliderValue,psSliderValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE SliderStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000100,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "autoticks",$00000001,STYLE,TRUE "both",$00000008,STYLE,FALSE "enableselrange"$00000020,STYLE,FALSE "fixedlength",$00000040,STYLE,FALSE "noticks",$00000010,STYLE,FALSE "nothumb",$00000080,STYLE,FALSE "vert",$00000002,STYLE,FALSE "left",$00000004,STYLE,FALSE "tooltips"$00000100,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE SliderEventTable AS EventData "scroll",evScrollUsed,evScrollOffs,0 "%",0,0,0END TABLETABLE SpinnerPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBad,psBackColor,LONGVAR,TRUE "forecolor",pgBad,psBad,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE SpinnerStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE SpinnerEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE ProgressBarPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "value",pgProgressBarValue,psProgressBarValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ProgressBarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "smooth",$00000001,STYLE,TRUE "vertical",$00000004,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ProgressBarEventTable AS EventData "%",0,0,0END TABLETABLE DrawProgressPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psDPBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgBad,psDPText,STRINGVAR,FALSE "font",pgBad,psDPFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "value",pgBad,psDPValue,LONGVAR,FALSE "maxvalue",pgBad,psDPMaxValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE DrawProgressStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000004,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify"$00000100,STYLE,FALSE "center",$00000010,STYLE,FALSE "red",$00000001,STYLE,FALSE "green",$00000002,STYLE,FALSE "text",$00000004,STYLE,FALSE "percent",$00000008,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE DrawProgressEventTable AS EventData "%",0,0,0END TABLETABLE ButtonExPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psButtonExBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psButtonExForeColor,LONGVAR,TRUE "text",pgBad,psText,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,FALSE "bitmap",pgBad,psButtonExBitmap,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psButtonExStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ButtonExStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ButtonExEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE ScrollBarPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "init",pgBad,psBad,LONGVAR,FALSE "bitmap",pgBad,psBad,LONGVAR,FALSE "value",pgProgressBarValue,psProgressBarValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ScrollBarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ScrollBarEventTable AS EventData "scroll",evScrollUsed,evScrollOffs,0 "%",0,0,0END TABLETABLE DateTimePickPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "init",pgBad,psBad,LONGVAR,FALSE "value",pgBad,psBad,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE DateTimePickStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE DateTimePickEventTable AS EventData "%",0,0,0END TABLETABLE AnimatePropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "init",pgBad,psBad,LONGVAR,FALSE "value",pgProgressBarValue,psProgressBarValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE AnimateStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE AnimateEventTable AS EventData "%",0,0,0END TABLETABLE CalendarPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE CalendarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE CalendarEventTable AS EventData "%",0,0,0END TABLETABLE HeaderPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE HeaderStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE HeaderEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE TreeViewPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgForeColor,psForeColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TreeViewStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE TreeViewEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE TabFolderPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pfSetTabText,pfSetTabText,LONGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "insertitem",pfInsertTabItem,pfInsertTabItem,LONGVAR,FALSE "deleteitem",pfDeleteTabItem,pfDeleteTabItem,LONGVAR,FALSE "select",pgTabSelect,psTabSelect,LONGVAR,FALSE "setitemsize",pfSetItemSize,pfSetItemSize,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TabFolderStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000400,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "bottom",$00000002,STYLE,FALSE "forceiconleft",$00000010,STYLE,FALSE "forcelabelleft",$00000020,STYLE,FALSE "vertical",$00000080,STYLE,FALSE "buttons",$00000100,STYLE,FALSE "multiline",$00000200,STYLE,FALSE "fixedwidth",$00000400,STYLE,TRUE "raggedright",$00000800,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE TabFolderEventTable AS EventData "change",evNotify1Used,0,$fffffffe "%",0,0,0END TABLETABLE ToolBarPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ToolBarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ToolBarEventTable AS EventData "%",0,0,0END TABLETABLE StatusBarPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgForeColor,psForeColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "setparts",pfSetParts,pfSetParts,LONGVAR,FALSE "settext",pfSetSBText,pfSetSBText,LONGVAR,FALSE "seticon",pfSetSBIcon,pfSetSBIcon,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE StatusBarStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000810,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "sizegrip",$00000010,STYLE,TRUE "tooltips",$00000800,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE StatusBarEventTable AS EventData "%",0,0,0END TABLETABLE CheckBoxPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "checked",pgChecked,psChecked,BOOLVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE CheckBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000003,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "autocheckbox"$00000003,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE CheckBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE RadioButtonPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "checked",pgChecked,psChecked,BOOLVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RadioButtonStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000009,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "autoradiobutton",$00000009,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE RadioButtonEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE TimerPropTable AS PropData "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TimerStyleTable AS StyleData "%",0,0,FALSEEND TABLETABLE TimerEventTable AS EventData "%",0,0,0END TABLETABLE RichEditPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psRichEditBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "line",pgLine,psBad,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RichEditStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50300104,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "multiline",$00000004,STYLE,TRUE "vscroll",$00200000,STYLE,TRUE "hscroll",$00100000,STYLE,TRUE "nohidesel",$00000100,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE RichEditEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE RAEditPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBad,psRAEditBCKCOLOR,LONGVAR,TRUE "FORCOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "seltext",pgSelText,psBad,STRINGVAR,FALSE "line",pgLine,psBad,STRINGVAR,FALSE "loadfile",pfRAEditLoadFile,pfRAEditLoadFile,LONGVAR,FALSE "savefile",pfRAEditSaveFile,pfRAEditSaveFile,LONGVAR,FALSE "goto",pfRAEditGoto,pfRAEditGoto,LONGVAR,FALSE "cursorpos",pgCursorPos,psCursorPos,LONGVAR,FALSE "selectall",pfSelectAll,pfSelectAll,LONGVAR,FALSE "setsel",pfSetSel,pfSetSel,LONGVAR,FALSE "getsel",pfGetSel,pfGetSel,LONGVAR,FALSE "inserttext",pfInsertText,pfInsertText,LONGVAR,FALSE "replacesel",pfReplaceSel,pfReplaceSel,LONGVAR,FALSE "appendtext",pfAppendText,pfAppendText,LONGVAR,FALSE "replacetext",pfReplaceText,pfReplaceText,LONGVAR,FALSE "textcolor",pgBad,psRAEditTXTCOLOR,LONGVAR,TRUE "selbackcolor",pgBad,psRAEditSELBCKCOLOR,LONGVAR,FALSE "seltextcolor",pgBad,psRAEditSELTXTCOLOR,LONGVAR,FALSE "commentcolor",pgBad,psRAEditCMNTCOLOR,LONGVAR,FALSE "stringcolor",pgBad,psRAEditSTRCOLOR,LONGVAR,FALSE "operatorcolor",pgBad,psRAEditOPRCOLOR,LONGVAR,FALSE "hilite1color",pgBad,psRAEditHILITE1,LONGVAR,FALSE "hilite2color",pgBad,psRAEditHILITE2,LONGVAR,FALSE "hilite3color",pgBad,psRAEditHILITE3,LONGVAR,FALSE "hiliteline",pgHiLiteLine,psBad,LONGVAR,FALSE "sethiliteline",pfSetHiLiteLine,pfSetHiLiteLine,LONGVAR,FALSE "selbarpencolor",pgBad,psRAEditSELBARPEN,LONGVAR,FALSE "linenumcolor",pgBad,psRAEditLNRCOLOR,LONGVAR,FALSE "sethilitewords",pfSetHiliteWords,pfSetHiliteWords,LONGVAR,FALSE "setdividerline",pfSetDividerLine,pfSetDividerLine,LONGVAR,FALSE "setfont",pfSetRAFont,pfSetRAFont,LONGVAR,FALSE "find",pfFind,pfFind,LONGVAR,FALSE "textlength",pgTextLength,psBad,LONGVAR,FALSE "canundo",pgCanUndo,psBad,BOOLVAR,FALSE "undo",pfUnDo,pfUnDo,LONGVAR,FALSE "canredo",pgCanReDo,psBad,BOOLVAR,FALSE "redo",pfReDo,pfReDo,LONGVAR,FALSE "canpaste",pgCanPaste,psBad,BOOLVAR,FALSE "paste",pfPaste,pfPaste,LONGVAR,FALSE "emptyundobuffer",pfEmptyUndoBuffer,pfEmptyUndoBuffer,LONGVAR,FALSE "cut",pfCut,pfCut,LONGVAR,FALSE "copy",pfCopy,pfCopy,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RAEditStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000044,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,TRUE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE RAEditEventTable AS EventData "change",evNotify1Used,0,$702 "contextmenu",evContextMenuUsed,evContextMenuOffs,0 "%",0,0,0END TABLETABLE RAGridPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psGridBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psGridForeColor,LONGVAR,TRUE "text",pgGridText,psGridText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "gridcolor",pgBad,psGridGridColor,LONGVAR,FALSE "setrowcolor",pfSetGridRowColor,pfSetGridRowColor,LONGVAR,FALSE "headertext",pgHeaderText,psHeaderText,STRINGVAR,FALSE "value",pgGridValue,psGridValue,LONGVAR,FALSE "selitem",pgBad,psGridComboIndex,LONGVAR,FALSE "addrow",pfGridAddRow,pfGridAddRow,LONGVAR,FALSE "addcol",pfGridAddCol,pfGridAddCol,LONGVAR,FALSE "deleterow",pfGridDeleteRow,pfGridDeleteRow,LONGVAR,FALSE "insertrow",pfGridInsertRow,pfGridInsertRow,LONGVAR,FALSE "moverow",pfGridMoveRow,pfGridMoveRow,LONGVAR,FALSE "additem",pfGridComboAddItem,pfGridComboAddItem,LONGVAR,FALSE "headerheight",pgBad,psHeaderHeight,LONGVAR,FALSE "rowheight",pgBad,psRowHeight,LONGVAR,FALSE "gridclear",pfGridClear,pfGridClear,LONGVAR,FALSE "comboclear",pfGridComboClear,pfGridComboClear,LONGVAR,FALSE "sort",pfGridSort,pfGridSort,LONGVAR,FALSE "row",pgGridRow,psGridRow,LONGVAR,FALSE "col",pgGridCol,psGridCol,LONGVAR,FALSE "scrollcell",pfScrollCell,pfScrollCell,LONGVAR,FALSE "sel",pgGridSel,psGridSel,LONGVAR,FALSE "rows",pgGridRows,psBad,LONGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "enteredit",pfGridEnterEdit,pfGridEnterEdit,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RAGridStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$5000000f,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "nosel",$00000001,STYLE,TRUE "nofocus",$00000002,STYLE,TRUE "hgridlines",$00000004,STYLE,TRUE "vgridlines",$00000008,STYLE,TRUE "gridframe",$00000010,STYLE,FALSE "nocolsize",$00000020,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,TRUE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE RAGridEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "headerclick",evNotify1Used,0,1 "buttonclick",evNotify2Used,0,2 "checkclick",evNotify3Used,0,3 "imageclick",evNotify4Used,0,4 "beforeselchange",evNotify5Used,0,5 "afterselchange",evNotify6Used,0,6 "beforeedit",evNotify7Used,0,7 "afteredit",evNotify8Used,0,8 "beforeupdate",evNotify9Used,0,9 "afterupdate",evNotify10Used,0,10 "userconvert",evNotify11Used,0,11 "%",0,0,0END TABLETABLE ListViewPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor"pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgBad,psBad,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "additem",pfListBoxAddItem,pfListBoxAddItem,LONGVAR,FALSE "clear",pfListBoxClear,pfListBoxClear,LONGVAR,FALSE "selitem",pgListBoxSelItem,psListBoxSelItem,LONGVAR,FALSE "topitem",pgListBoxTopItem,psListBoxTopItem,LONGVAR,FALSE "seltext",pgListBoxSelText,psBad,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ListViewStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,TRUE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ListViewEventTable AS EventData "select",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE StaticTextPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,FALSE "bitmap",pgBad,psStaticBitmap,LONGVAR,TRUE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE StaticTextStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000101,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify"$00000100,STYLE,TRUE "center",$00000001,STYLE,TRUE "right",$00000002,STYLE,FALSE "sunken",$00001000,STYLE,FALSE "etchedframe",$00000012,STYLE,FALSE "bitmap",$0000000e,STYLE,FALSE "centerimage",$00000200,STYLE,FALSE "blackframe",$00000007,STYLE,FALSE "whiteframe",$00000008,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE StaticTextEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE ImagePropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "IMAGE",pgBad,psBad,LONGVAR,TRUE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "bitmap",pgBad,psStaticBitmap,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ImageStyleTable AS StyleData  "base",$5000000e,STYLE,FALSE "default",$5000130e,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify"$00000100,STYLE,TRUE "sunken",$00001000,STYLE,TRUE "bitmap",$0000000e,STYLE,TRUE "centerimage",$00000200,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE ImageEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE RectanglePropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RectangleStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify"$00000100,STYLE,FALSE "center",$00000001,STYLE,FALSE "sunken",$00001000,STYLE,FALSE "etchedframe",$00000012,STYLE,FALSE "bitmap",$0000000e,STYLE,FALSE "centerimage",$00000200,STYLE,FALSE "blackframe",$00000007,STYLE,FALSE "whiteframe",$00000008,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE RectangleEventTable AS EventData "%",0,0,0END TABLETABLE OBCommPropTable AS PropData "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE OBCommStyleTable AS StyleData "%",0,0,FALSEEND TABLETABLE OBCommEventTable AS EventData "%",0,0,0END TABLETABLE IconButtonPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "BACKCOLOR",pgBad,psBad,LONGVAR,FALSE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,TRUE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "icon",pgBad,psButtonIcon,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE IconButtonStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000040,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "icon"$00000040,STYLE,TRUE "flat",$00008000,STYLE,FALSE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE IconButtonEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0END TABLETABLE SprShtPropTable AS PropData "NAME",pgBad,psBad,LONGVAR,TRUE "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "IMAGE",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psToolTip,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "hdc",pgHDC,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE "init",pgBad,psBad,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEEND TABLETABLE SprShtStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "topmost",$00000008,EXSTYLE,FALSE "windowedge",$00000100,EXSTYLE,FALSE "clientedge",$00000200,EXSTYLE,FALSE "staticedge",$00020000,EXSTYLE,FALSE "%",0,0,FALSEEND TABLETABLE SprShtEventTable AS EventData "scroll",evScrollUsed,evScrollOffs,0 "%",0,0,0END TABLETYPE PropMap PropMapPropTable AS LABEL PropMapStyleTable AS LABEL PropMapEventTable AS LABEL PropMapCount AS LONG PropMapName AS STRING*16END TYPETABLE ToolPropMap AS PropMap FormPropTable,FormStyleTable,FormEventTable,1,"FORM" ToolWindowPropTable,ToolWindowStyleTable,ToolWindowEventTable,0,"TOOLWINDOW" ButtonPropTable,ButtonStyleTable,ButtonEventTable,0,"BUTTON" StaticTextPropTable,StaticTextStyleTable,StaticTextEventTable,0,"STATICTEXT" FramePropTable,FrameStyleTable,FrameEventTable,0,"FRAME" SliderPropTable,SliderStyleTable,SliderEventTable,0,"SLIDER" TextBoxPropTable,TextBoxStyleTable,TextBoxEventTable,0,"TEXTBOX" ComboBoxPropTable,ComboBoxStyleTable,ComboBoxEventTable,0,"COMBOBOX" ListBoxPropTable,ListBoxStyleTable,ListBoxEventTable,0,"LISTBOX" RadioButtonPropTable,RadioButtonStyleTable,RadioButtonEventTable,0,"RADIOBUTTON" CheckBoxPropTable,CheckBoxStyleTable,CheckBoxEventTable,0,"CHECKBOX" ProgressBarPropTable,ProgressBarStyleTable,ProgressBarEventTable,0,"PROGRESSBAR" CalendarPropTable,CalendarStyleTable,CalendarEventTable,0,"CALENDAR" TabFolderPropTable,TabFolderStyleTable,TabFolderEventTable,0,"TABFOLDER" SpinnerPropTable,SpinnerStyleTable,SpinnerEventTable,0,"SPINNER" StatusBarPropTable,StatusBarStyleTable,StatusBarEventTable,0,"STATUSBAR" HeaderPropTable,HeaderStyleTable,HeaderEventTable,0,"HEADER" AnimatePropTable,AnimateStyleTable,AnimateEventTable,0,"ANIMATE" RichEditPropTable,RichEditStyleTable,RichEditEventTable,0,"RICHEDIT" RAEditPropTable,RAEditStyleTable,RAEditEventTable,0,"RAEDIT" RAGridPropTable,RAGridStyleTable,RAGridEventTable,0,"RAGRID" ListViewPropTable,ListViewStyleTable,ListViewEventTable,0,"LISTVIEW" ToolBarPropTable,ToolBarStyleTable,ToolBarEventTable,0,"TOOLBAR" TreeViewPropTable,TreeViewStyleTable,TreeViewEventTable,0,"TREEVIEW" DateTimePickPropTable,DateTimePickStyleTable,DateTimePickEventTable,0,"DATETIMEPICK" ImagePropTable,ImageStyleTable,ImageEventTable,0,"IMAGE" DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS"END TABLETEXTBLOCK RunVarsalign 4; Timer Event Dispatch Vectors!Timer rd !Timers_FltArgSafe0 rf 1_FltArgSafe1 rf 1_FloatRet rf 1_LoopCtr rd 10!hinstance rd 1!dc rd 1_InHandle rd 1_OutHandle rd 1_IOPthNum rd 1_XferAddr rd 1_PUArgs rd 15_ArgList rd 1_ArgNum rd 1_Poker rd 1_DummyArg rd 1_FcnArg1 rd 1_FcnArg2 rd 1_FcnArg3 rd 1_FcnArg4 rd 1_FcnArg5 rd 1_FcnArg6 rd 1_FcnArg7 rd 1_LongRet rd 1_StringRet rd 3_ArgSafe0 rd 1_ArgSafe1 rd 1_ArgSafe2 rd 1_ArgSafe3 rd 1_AccLo rd 1_AccHi rd 1!FileHandle rd 1!FilBufAdr rd 1!FilBufSiz rd 1_SwitchInt rd 1__ByteCounter rd 1_PrtPthNum rd 1_DataPtr rd 1_Decimals rw 1_Digits rw 1_BoolRet rb 1!PassEvent rb 1AltKey rb 1; COMM DCB Structure!DCBlengthOffs equ 0; rd 1!BaudRateOffs equ 4; rd 1!fBitsOffs equ 8; rd 1	!fBinaryBit equ 0	!fParityBit equ 1	!fOutxCtsFlowBit equ 2	!fOutxDsrFlowBit equ 3	!fDtrControlLoBit equ 4	!fDtrControlHiBit equ 5	!fDsrSensitivityBit equ 6	!fTXContinueOnXoffBit equ 7	!fOutXBit equ 8	!fInXBit equ 9	!fErrorCharBit equ 10	!fNullBit equ 11	!fRtsControlLoBit equ 12	!fRtsControlHiBit equ 13	!fAbortOnErrorBit equ 14!wReservedOffs equ 12; rw 1!XonLimOffs equ 14; rw 1!XoffLimOffs equ 16; rw 1!ByteSizeOffs equ 18; rb 1!ParityOffs equ 19;  rb 1!StopBitsOffs equ 20; rb 1!XonCharOffs equ 21; rb 1!XoffCharOffs equ 22; rb 1!ErrorCharOffs equ 23; rb 1!EofCharOffs equ 24; rb 1!EvtCharOffs equ 25; rb 1!wReserved1Offs equ 26; rw 1!HandleOffs equ 28; rd 1!StatusOffs equ 32; rd 1!ArrayOffs equ 36; rd 1!CommReserved1Offs equ 40; rb 1!CommReserved2Offs equ 41; rb 1!CommReserved3Offs equ 42; rb 1!CommReserved4Offs equ 43; rb 1!UserBaudRateOffs equ 44; rd 1!UserParityOffs equ 48; rb 1!UserByteSizeOffs equ 49; rb 1!UserStopBitsOffs equ 50; rb 1!UserRTSOffs equ 51; rb 1!UserDSRCheckOffs equ 52; rb 1!UserParityCheckOffs equ 53; rb 1!UserDTROffs equ 54; rb 1!UserCTSCheckOffs equ 55; rb 1!PortNameOffs equ 56; rb 32!CommStatusOffs equ 88; rd 1!cbInQueOffs equ 92; rd 1!cbOutQueOffs equ 96; rd 1align 4;_SYSTEMTIME StructurewYear rw 1 wMonth rw 1 wDayOfWeek rw 1 wDay rw 1 wHour rw 1 wMinute rw 1 wSecond rw 1 wMilliseconds rw 1;_FILETIME Structures!dwLowDateTime1 rd 1!dwHighDateTime1 rd 1!dwLowDateTime2 rd 1!dwHighDateTime2 rd 1ENDTEXTTEXTBLOCK GUIInitVars!OBMainWindowClass WNDCLASSmsg MSG!TrapColorChange dd 0!OBMainClass db 'OBMain',0!ToolTipClass db 'Tooltips_class32',0!icc dd $00000008,$00003FFF!!RichEd db 'RichEd20.dll',0!!RAEdit db 'RAEdit.dll',0!!RAGrid db 'RAGrid.dll',0!!Csmdll db 'Csmdll.dll',0!!DrawProgress db 'DrawProgress.dll',0!!ImageLib db 'ImageLib.dll',0!!SprShtLib db 'SprSht.dll',0!!ButtonExLib db 'ButtonEx.dll',0!title db 'OBMain',0align 4MenuEVPtr dd 0MenuID dd 0FindEVPtr dd 0FindMsgID dd 0FINDMSGSTRING db 'commdlg_FindReplace',0FLAGS dd 0nmhdr_hwndFrom dd 0nmhdr_idFrom dd 0nmhdr_code dd 0cr_cpMin dd 0cr_cpMax dd 0ofn_lStructSize dd 76ofn_hwndOwner dd 0ofn_hInstance dd 0ofn_lpstrFilter dd 0ofn_lpstrCustomFilter dd 0ofn_nMaxCustFilter dd 0ofn_nFilterIndex dd 1ofn_lpstrFile dd 0ofn_nMaxFile dd 0ofn_lpstrFileTitle dd 0ofn_nMaxFileTitle dd 0ofn_lpstrInitialDir dd 0ofn_lpstrTitle dd 0ofn_Flags dd 0ofn_nFileOffset dw 0ofn_nFileExtension dw 0ofn_lpstrDefExt dd 0ofn_lCustData dd 0ofn_lpfnHook dd 0ofn_lpTemplateName dd 0cc_lStructSize dd 36cc_hwndOwner dd 0cc_hInstance dd 0cc_rgbResult dd 0cc_lpCustColors dd _CustColorscc_Flags dd 0cc_lCustData dd 0cc_lpfnHook dd 0cc_lpTemplateName dd 0_CustColors rd 16fr_lStructSize dd 40fr_hwndOwner dd 0fr_hInstance dd 0fr_Flags dd 0fr_lpstrFindWhat dd 0fr_lpstrReplaceWith dd _PrintBuf+12fr_wFindWhatLen dw 0fr_wReplaceWithLen dw 0fr_lCustData dd 0fr_lpfnHook dd 0fr_lpTemplateName dd 0ft_SearchMin rd 1ft_SearchMax rd 1ft_SearchTextPtr rd 1ft_FoundMin rd 1ft_FoundMax rd 1cf_lStructSize dd 58cf_hwndOwner dd 0cf_hDC dd 0cf_lpLogFont dd 0cf_iPointSize dd 0cf_Flags dd 0cf_rgbColors dd 0cf_lCustData dd 0cf_lpfnHook dd 0cf_lpTemplateName dd 0cf_hInstance dd 0cf_lpszStyle dd 0cf_nFontType dw 0cf_nSizeMin dd 0cf_nSizeMax dd 0pr_lStructSize dd 66pr_hwndOwner dd 0pr_hDevMode dd 0pr_hDevNames dd 0pr_hDC dd 0pr_Flags dd 0pr_nFromPage dw 0pr_nToPage dw 0pr_nMinPage dw 0pr_nMaxPage dw 0pr_nCopies dw 0pr_hInstance dd 0pr_lCustData dd 0pr_lpfnPrintHook dd 0pr_lpfnSetupHook dd 0pr_lpPrintTemplateName dd 0pr_lpSetupTemplateName dd 0pr_hPrintTemplate dd 0pr_hSetupTemplate dd 0!RA_BCKCOLOR dd $C0F0F0!RA_TXTCOLOR dd $000000!RA_SELBCKCOLOR dd $800000!RA_SELTXTCOLOR dd $ffffff!RA_CMNTCOLOR dd $008000!RA_STRCOLOR dd $ff0000!RA_OPRCOLOR dd $0000a0!RA_HILITE1 dd $F0C0C0!RA_HILITE2 dd $C0F0C0!RA_HILITE3 dd $C0C0F0!RA_SELBARCOLOR dd $c0c0c0!RA_SELBARPEN dd $808080!RA_LNRCOLOR dd $800000!cbSize dd 52!rcItem dd 0,0,0,0!rcButton dd 0,0,0,0!stateButton dd 0!hwndCombo dd 0!hwndItem dd 0!hwndList dd 0ENDTEXTTEXTBLOCK GUIRunVars	; RAGrid Column Structurealign 4gc_colwt rd 1gc_lpszhdrtext rd 1gc_halign rd 1gc_calign rd 1gc_ctype rd 1gc_ctextmax rd 1gc_lpszformat rd 1gc_himl rd 1gc_hdrflag rd 1gc_colxp rd 1gc_edthwnd rd 1; RAGrid rowcol Structurerc_backcolor rd 1rc_textcolor rd 1CursorPosX rd 1CursorPosY rd 1Rect: ;StructureRectLeft rd 1RectTop rd 1RectRight rd 1RectBottom rd 1!ToolTip rd 1	; Paint StructurePaintStruct rd 16	!TargetGUIDesc rd 1!SourceGUIDesc rd 1	; RAGrid GridRow rd 1GridCol rd 1;TC_ITEM structure!TC_ITEMmask rd 1!TC_ITEMState rd 1!TC_ITEMStateMask rd 1!TC_ITEMText rd 1!TC_ITEMTextMax rd 1!TC_ITEMImage rd 1!TC_ITEMlParam rd 1; RAEdit VarsEditcpMin rd 1EditcpMax rd 1EditSelType rw 1EditLine rd 1EditcpLine rd 1EditlpLine rd 1EditnLines rd 1EditnHidden rd 1EditfChanged rd 1EditnPage rd 1EditnWordGroup rd 1OldFrameProc rd 1!from equ 0; rd 1!to equ 4; rd 1; _TBBUTTON Structure!iBitmap equ 0; rd 1!idCommand equ 4; rd 1!fsState equ 8; rb 1!fsStyle equ 9; rb 1!dwData equ 10; rd 1!iString equ 14; rd 1!CursorFlag rb 1align 4!Brush rd 1!Desc rd 1NMHDR rd 1!dsStatus rd 1ArrayIndex rd 1!dsBackColor rd 1!dsForeColor rd 1!dsControlType rd 1ENDTEXTTEXTBLOCK PreCodeSeg1section '.code' code readable executable; Main Code Sectionalign 4!Start:call _Initinvoke GetModuleHandle, NULLmov dword [!hinstance], eaxinvoke GetCommandLinemov dword [_ArgList],eaxmov dword edi,ProgramNamecall __MovArginvoke GetStdHandle, STD_INPUT_HANDLEmov dword [_InHandle], eaxinvoke GetStdHandle, STD_OUTPUT_HANDLEmov dword [_OutHandle], eaxmov byte [_CRLF+12],13mov byte [_CRLF+13],10mov byte [_CRLF+14],0mov byte [_Prompt+12],63mov byte [_Prompt+13],0mov byte [_NullStr+12],0mov dword [_ErrVec],_ErrExitENDTEXTTEXTBLOCK GUIEquates HandleOffs equ 0 IDOffs equ 4 OwnerOffs equ 8 ArrayOffs equ 12 LeftOffs equ 16 TopOffs equ 20 RightOffs equ 24 BottomOffs equ 28 BackColorOffs equ 32 ForeColorOffs equ 36 TypeOffs equ 40 StatusOffs equ 44 evActivateOffs equ 48 evCommandOffs equ 52 evMouseActivateOffs equ 56 evPaintOffs equ 60 HDCOffs equ 64 evMouseMoveOffs equ 68 evMouseWheelOffs equ 72 evScrollOffs equ 76 evCreateOffs equ 80 evDestroy equ 84 evKeyDownOffs equ 88 evKeyUpOffs equ 92 evDblClickOffs equ 96 cdDblClickOffs equ 100 evClickOffs equ 104 cdClickOffs equ 108 evChangeOffs equ 112 cdChangeOffs equ 116 evSelectOffs equ 120 cdSelectOffs equ 124 evNotify1Offs equ 128 cdNotify1Offs equ 132 evNotify2Offs equ 136 cdNotify2Offs equ 140 evNotify3Offs equ 144 cdNotify3Offs equ 148 evNotify4Offs equ 152 cdNotify4Offs equ 156 evNotify5Offs equ 160 cdNotify5Offs equ 164 evNotify6Offs equ 168 cdNotify6Offs equ 172 evNotify7Offs equ 176 cdNotify7Offs equ 180 evNotify8Offs equ 184 cdNotify8Offs equ 188 evNotify9Offs equ 192 cdNotify9Offs equ 196 evNotify10Offs equ 200 cdNotify10Offs equ 204 evNotify11Offs equ 208 cdNotify11Offs equ 212 evNotify12Offs equ 216 cdNotify12Offs equ 220 evNotify13Offs equ 224 cdNotify13Offs equ 228 evNotify14Offs equ 232 cdNotify14Offs equ 236 evNotify15Offs equ 240 cdNotify15Offs equ 244 evNotify16Offs equ 248 cdNotify16Offs equ 252 evNotify17Offs equ 256 cdNotify17Offs equ 260 evNotify18Offs equ 264 cdNotify18Offs equ 268 evNotify19Offs equ 272 cdNotify19Offs equ 276 evNotify20Offs equ 280 cdNotify20Offs equ 284 evNotify21Offs equ 288 cdNotify21Offs equ 292 evNotify22Offs equ 296 cdNotify22Offs equ 300 evNotify23Offs equ 304 cdNotify23Offs equ 308 evNotify24Offs equ 312 cdNotify24Offs equ 316 evNotify25Offs equ 320 cdNotify25Offs equ 324 evNotify26Offs equ 328 cdNotify26Offs equ 332 evNotify27Offs equ 336 cdNotify27Offs equ 340 evNotify28Offs equ 344 cdNotify28Offs equ 348 evNotify29Offs equ 352 cdNotify29Offs equ 356 evNotify30Offs equ 360 cdNotify30Offs equ 364 evNotify31Offs equ 368 cdNotify31Offs equ 372 evNotify32Offs equ 376 cdNotify32Offs equ 380 evSysCommandOffs equ 384 evResizeOffs equ 388 evMoveOffs equ 392 evLButtonDownOffs equ 396 evLButtonUpOffs equ 400 evRButtonDownOffs equ 404 evRButtonUpOffs equ 408 CursorOffs equ 412 evContextMenuOffs equ 416 evKeyStruckOffs equ 420 evReserved3Offs equ 424 evReserved4Offs equ 428 evReserved5Offs equ 432 evReserved6Offs equ 436 evReserved7Offs equ 440 Reserved1Offs equ 444 Reserved2Offs equ 448 Reserved3Offs equ 452 Reserved4Offs equ 456 Reserved5Offs equ 460 Reserved6Offs equ 464 Reserved7Offs equ 468 Reserved8Offs equ 472 OldProcOffs equ 476 WidthOffs equ 480 HeightOffs equ 484 ControlBrushOffs equ 488 InterceptSafeOffs equ 492 InterceptProcOffs equ 496 Style1Offs equ 500 Extra2Offs equ 504 DoNotUseOffs equ 508 TTcbSizeOffs equ 512 TTuFlagsOffs equ 516 TThwndOffs equ 520 TTuIDOffs equ 524 TTRectLeftOffs equ 528 TTRectTopOffs equ 532 TTRectRightOffs equ 536 TTRectBottomOffs equ 540 TThinstOffs equ 544 TTlpszTextOffs equ 548 TTlparamOffs equ 552 TTTextOffs equ 556 NextOffs equ 656 ENDTEXTTEXTBLOCK PreCodeSeg2invoke CreateWindowEx,0,!ToolTipClass,0,TTS_ALWAYSTIP,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,0,0,[!hinstance],0mov dword [!ToolTip],eaxinvoke InitCommonControlsEx,!iccinvoke LoadIcon,0,IDI_APPLICATIONmov [!OBMainWindowClass.hIcon],eaxinvoke LoadCursor,0,IDC_ARROWmov dword [!OBMain+CursorOffs],eaxmov [!OBMainWindowClass.hCursor],eaxmov [!OBMainWindowClass.style],0mov [!OBMainWindowClass.lpfnWndProc],!WindowProcmov [!OBMainWindowClass.cbClsExtra],0mov [!OBMainWindowClass.cbWndExtra],0mov eax,[!hinstance]mov [!OBMainWindowClass.hInstance],eaxmov [!OBMainWindowClass.hbrBackground],COLOR_BTNFACE+1mov [!OBMainWindowClass.lpszMenuName],0mov [!OBMainWindowClass.lpszClassName],!OBMainClassinvoke RegisterClass,!OBMainWindowClassmov dword [!OBMain+StatusOffs],0mov dword [!OBMain+IDOffs],1mov dword [!OBMain+ArrayOffs],0mov dword [!OBMain+LeftOffs],0mov dword [!OBMain+TopOffs],0mov dword [!OBMain+WidthOffs],400mov dword [!OBMain+HeightOffs],300mov dword [!OBMain+ForeColorOffs],$ffffffmov dword [!OBMain+BackColorOffs],$ffffffffmov dword [!OBMain+TypeOffs],!CT_FORMmov dword [!OBMain+ControlBrushOffs],0invoke CreateWindowEx,0,!OBMainClass,!title,WS_VISIBLE+WS_OVERLAPPEDWINDOW,0,0,400,300,NULL,NULL,[!hinstance],!OBMaininvoke SetWindowLong,[!OBMain],GWL_USERDATA,!OBMain!MsgLoop:invoke GetMessage,msg,NULL,0,0or eax,eaxjz !EndMsgLoopinvoke TranslateMessage,msginvoke DispatchMessage,msgjmp !MsgLoop!EndMsgLoop:invoke ExitProcess,[msg.wParam]proc !WindowProc,!hwnd,wmsg,wparam,lparamenterpush ebx esi edimov ebx,[wmsg]cmp [wmsg],WM_GETMINMAXINFOjne NotwmGetMaxInfomov dword edi,[!hwnd]mov dword [!OBMain+HandleOffs],edimov dword [!OBMain+OwnerOffs],0mov dword [!OBMain+InterceptSafeOffs],!WindowProcjmp !DefWndProcNotwmGetMaxInfo:mov esi,!OBMaincmp ebx,WM_DESTROYje !wmDestroy!WinProcCommon:cmp ebx,WM_SYSCOMMANDje !wmSysCommandcmp ebx,WM_SIZEje !wmSizecmp ebx,WM_MOVEje !wmMovecmp ebx,WM_TIMERje !wmTimercmp ebx,WM_SETCURSORje !wmSetCursorcmp ebx,WM_CREATEje !wmCreatecmp ebx,WM_PAINTje !wmPaintcmp ebx,WM_CONTEXTMENUje !wmContextMenumov eax,[wparam]mov [EventID],axshr eax,16mov [EventNotify],axinvoke GetWindowLong,[lparam],GWL_USERDATAmov [!Desc],eaxcmp ebx,WM_CTLCOLORSTATICje !CtlColorChangecmp ebx,WM_CTLCOLOREDITje !CtlColorChangecmp ebx,WM_CTLCOLORBTNje !CtlColorChangecmp ebx,WM_CTLCOLORSCROLLBARje !CtlColorChangecmp ebx,WM_CTLCOLORLISTBOXje !CtlColorChangecmp ebx,WM_CTLCOLORDLGje !CtlColorChangecmp ebx,WM_CTLCOLORMSGBOXje !CtlColorChangecmp ebx,WM_COMMANDje !wmCommandcmp ebx,WM_NOTIFYje !wmNotifycmp ebx,WM_HSCROLLje !wmScrollcmp ebx,WM_VSCROLLje !wmScrollcmp ebx,WM_CHARje !wmCharcmp ebx,WM_SYSCHARje !wmSysCharcmp ebx,WM_MOUSEMOVEje !wmMouseMovecmp ebx,WM_LBUTTONDOWNje !wmLButtonDowncmp ebx,WM_LBUTTONUPje !wmLButtonUpcmp ebx,WM_RBUTTONDOWNje !wmRButtonDowncmp ebx,WM_RBUTTONUPje !wmRButtonUpmov eax,[wmsg]cmp [FindMsgID],eaxje !FindMsg!DefWndProc:invoke DefWindowProc,[!hwnd],[wmsg],[wparam],[lparam]jmp !Finish!wmSetCursor:cmp [!CursorFlag],0je !DefWndProcmov eax,1jmp !Finish!wmSysCommand:mov [!PassEvent],0mov eax,[esi+evSysCommandOffs]or eax,eaxje !DefWndProcmov edx,[wparam]cmp edx,$f020je !DoSysCmdcmp edx,$f030je !DoSysCmdcmp edx,$f060je !DoSysCmdcmp edx,$f120je !DoSysCmdjmp !DefWndProc!DoSysCmd:mov [STATUS],edxcall dword eaxcmp [!PassEvent],0jne !DefWndProcxor eax,eaxjmp !Finish!wmSize:; need to update RightOffs and BottomOffsmov ecx,[lparam]mov edx,ecxand ecx,$ffffshr edx,16mov [esi+WidthOffs],ecxmov [esi+HeightOffs],edxmov eax,[esi+evResizeOffs]or eax,eaxje !DefWndProcmov edx,[wparam]mov [STATUS],edxcall dword eaxxor eax,eaxjmp !Finish!wmMove:; need to update RightOffs and BottomOffsmov ecx,[lparam]mov edx,ecxand ecx,$ffffshr edx,16mov [esi+LeftOffs],ecxmov [esi+TopOffs],edxmov eax,[esi+evMoveOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!FindMsg:mov edx,[FindEVPtr]or edx,edxje !DefWndProcmov eax,[fr_Flags]mov [FLAGS],eaxcall dword edxje !DefWndProc!wmTimer:mov edx,[wparam]mov ebx,edxshr ebx,16mov [ArrayIndex],ebxand edx,$0000ffffcmp edx,$ffffje !SysTimershl edx,2add edx,!Timermov eax,[edx]cmp eax,0je !Finishcall dword eaxxor eax,eaxjmp !Finish!SysTimer:mov eax,[!Timer]cmp eax,0je !Finishcall dword eaxxor eax,eaxjmp !Finish!wmNotify:mov edi,[lparam]; Address of NMHDRmov [NMHDR],edi; Save NMHDR for event processingmov esi,[edi]; Handleinvoke GetWindowLong,esi,GWL_USERDATAcmp eax,0je !DefWndProcmov esi,eax; Address of Descmov ebx,[edi+8]; Codemov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+TypeOffs]mov [!dsControlType],eaxmov ecx,cdNotify32Offs+4; Points past last Notify Offsadd ecx,esi; Add Offs to baseadd esi,evNotify1Offs; Points to first Notify Offs!NotifyLoop:cmp ebx,[esi+4]jne !NotNotifyCodemov eax,[esi]cmp eax,0jne !ProcNotifyjmp !DefWndProc!NotNotifyCode:add esi,8; Point to next Notifycmp esi,ecx; Past last Notify?jne !NotifyLoop; No, Try nextjmp !DefWndProc; Give up, no Notify match!ProcNotify:mov edi,[NMHDR]add edi,12cmp [!dsControlType],!CT_RAGridjne !RAEditCheckmov ebx,[edi]add ebx,[!ArrayBase]mov [GridCol],ebxmov ebx,[edi+4]add ebx,[!ArrayBase]mov [GridRow],ebxjmp !NotifyDispatch!RAEditCheck:cmp [!dsControlType],!CT_RAEditjne !TabFolderCheckmov ebx,[edi]add ebx,[!ArrayBase]mov [EditcpMin],ebxsub ebx,[edi+14]mov [EditcpLine],ebxmov ebx,[edi+4]add ebx,[!ArrayBase]mov [EditcpMax],ebxmov bx,[edi+8]mov [EditSelType],bxmov ebx,[edi+10]add ebx,[!ArrayBase]mov [EditLine],ebxmov ebx,[edi+18]add ebx,[!ArrayBase]mov [EditlpLine],ebxmov ebx,[edi+22]add ebx,[!ArrayBase]mov [EditnLines],ebxmov ebx,[edi+26]mov [EditnHidden],ebxmov ebx,[edi+30]mov [EditfChanged],ebxmov ebx,[edi+34]add ebx,[!ArrayBase]mov [EditnPage],ebxmov ebx,[edi+38]add ebx,[!ArrayBase]mov [EditnWordGroup],ebxjmp !NotifyDispatch!TabFolderCheck:cmp [!dsControlType],!CT_TABFOLDERjne !DefWndProc!NotifyDispatch:jmp !CommandDispatch!wmMouseMove:call !GetMousePosmov eax,[esi+evMouseMoveOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmLButtonDown:call !GetMousePosinvoke SetFocus, dword [esi]mov eax,[esi+evLButtonDownOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmLButtonUp:call !GetMousePosmov eax,[esi+evLButtonUpOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmRButtonDown:call !GetMousePos mov eax,[esi+evRButtonDownOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmRButtonUp:call !GetMousePos mov eax,[esi+evRButtonUpOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!GetMousePos:mov ebx,[lparam]and ebx,$ffffmov [CursorPosX],ebxmov ebx,[lparam]shr ebx,16mov [CursorPosY],ebxret!wmCreate:mov eax,[esi+evCreateOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmPaint:mov eax,[esi+evPaintOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!CtlColorChange:mov [!PassEvent],0cmp [!TrapColorChange],0je !NotColorChangeTrapmov eax,[!TrapColorChange]call dword eaxcmp [!PassEvent],0jne !NotColorChangeTrapxor eax,eaxjmp !Finish!NotColorChangeTrap:invoke GetWindowLong,[lparam],GWL_USERDATAcmp [!Desc],0je !DefWndProcmov esi,[!Desc]call !GetDescbt [!dsStatus],WinChangeBackColorjc !CtlBackcolorChangebt [!dsStatus],WinChangeForeColorjc !CtlForeColorChangejmp !DefWndProc!CtlBackcolorChange:bt [!dsStatus],WinChangeForeColorjc !CtlBothColorChangecmp [!dsBackColor],$ffffffffjne !NotTransparentinvoke SetBkMode,[wparam],TRANSPARENTinvoke GetStockObject,NULL_BRUSHjmp !Finish!NotTransparent:call !BackColorChangejmp !Finish!BackColorChange:invoke DeleteObject,[!Brush]invoke CreateSolidBrush,[!dsBackColor]mov [!Brush],eaxinvoke SetBkColor,[wparam],[!dsBackColor]mov eax,[!Brush]ret!CtlBothColorChange:call !BothColorChangejmp !Finish!BothColorChange:invoke DeleteObject,[!Brush]invoke CreateSolidBrush,[!dsBackColor]mov [!Brush],eaxinvoke SetBkColor,[wparam],[!dsBackColor]invoke SetTextColor,[wparam],[!dsForeColor]mov eax,[!Brush]ret!CtlForeColorChange:call !ForeColorChangejmp !Finish!ForeColorChange:invoke DeleteObject,[!Brush]invoke GetBkColor,[wparam]cmp [!dsControlType],!CT_TEXTBOXje !ListOrTextOrCombocmp [!dsControlType],!CT_LISTBOXje !ListOrTextOrCombocmp [!dsControlType],!CT_COMBOBOXje !ListOrTextOrComboinvoke GetPixel,[wparam],0,0!ListOrTextOrCombo:mov esi,[!Desc]bts dword [esi+StatusOffs],WinChangeBackColormov [esi+BackColorOffs],eaxinvoke CreateSolidBrush,eaxmov [!Brush],eaxinvoke SetTextColor,[wparam],[!dsForeColor]invoke SetBkMode,[wparam],TRANSPARENTmov eax,[!Brush]ret!wmCommand:mov ax,[EventID]cmp ax,999jg !wmMenucmp [!Desc],0je !DefWndProcmov esi,[!Desc]mov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+evCommandOffs]cmp eax,0jne !CommandDispatchxor ebx,ebxmov bx,[EventNotify]; Clickcmp ebx,[esi+cdClickOffs]jne !evChangemov eax,[esi+evClickOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evChange:cmp ebx,[esi+cdChangeOffs]jne !evSelectmov eax,[esi+evChangeOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evSelect:cmp ebx,[esi+cdSelectOffs]jne !evDblClickmov eax,[esi+evSelectOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evDblClick:cmp ebx,[esi+cdDblClickOffs]jne !DefWndProcmov eax,[esi+evDblClickOffs]cmp eax,0je !DefWndProc!CommandDispatch:call dword eaxxor eax,eaxjmp !Finish!wmMenu:mov edx,[MenuEVPtr]or edx,edxje !DefWndProcand eax,$ffffmov [MenuID],eaxcall dword edxjmp !Finish!wmScroll:cmp [!Desc],0je !DefWndProcmov esi,[!Desc]mov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+evScrollOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmChar:mov [AltKey],0jmp !CharCommon!wmSysChar:mov [AltKey],1!CharCommon:mov [!PassEvent],0mov esi,!OBMainmov eax,[esi+evKeyStruckOffs]cmp eax,0je !DefWndProccall dword eaxcmp [!PassEvent],0jne !DefWndProcxor eax,eaxjmp !Finish!wmContextMenu:invoke GetWindowLong,[wparam],GWL_USERDATAor eax,eaxje !DefWndProcmov esi,eaxmov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxcall !GetMousePosmov eax,[esi+evContextMenuOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!GetDesc:mov eax,[esi+StatusOffs]mov [!dsStatus],eaxmov eax,[esi+BackColorOffs]mov [!dsBackColor],eaxmov eax,[esi+ForeColorOffs]mov [!dsForeColor],eaxmov eax,[esi+TypeOffs]mov [!dsControlType],eaxret!wmDestroy:invoke DeleteObject,[!Brush]invoke PostQuitMessage,0xor eax,eax!Finish:pop edi esi ebxreturn ENDTEXTTEXTBLOCK Includesinclude 'include\kernel.inc'include 'include\user.inc'include 'include\gdi.inc'include 'include\comctl.inc'include 'include\comdlg.inc'include 'include\shell.inc'include 'include\cproc.inc'include 'include\riched.inc'include 'include\raedit.inc'include 'include\ragrid.inc'include 'include\OBComm.inc'include 'include\DrawProgress.inc'include 'include\macro\import.inc'include 'include\macro\stdcall.inc'include 'include\macro\resource.inc'include 'include\buttonex.inc'ENDTEXTTEXTBLOCK SubClassProcproc !SubClassProc,!hwnd,wmsg,wparam,lparamenterpush ebx esi edimov eax,[wparam]mov [EventID],axshr eax,16mov [EventNotify],axinvoke GetWindowLong,[lparam],GWL_USERDATAmov [!Desc],eaxmov ebx,[wmsg]cmp ebx,WM_CTLCOLORSTATICje !CtlColorChangecmp ebx,WM_CTLCOLOREDITje !CtlColorChangecmp ebx,WM_CTLCOLORBTNje !CtlColorChangecmp ebx,WM_CTLCOLORSCROLLBARje !CtlColorChangecmp ebx,WM_CTLCOLORLISTBOXje !CtlColorChangecmp ebx,WM_COMMANDje !wmCommandinvoke GetWindowLong,[!hwnd],GWL_USERDATAor eax,eaxje !DefWndProcadd eax,OldProcOffsmov eax,[eax]invoke CallWindowProc,eax,[!hwnd],[wmsg],[wparam],[lparam]jmp !FinishENDTEXTTEXTBLOCK ReadFileLib__ReadFile:mov [_ArgSafe0],esiinvoke ReadFile,[_IOPthNum],[_IOBuffer],1,XferCount,0mov [STATUS],eaxcmp eax,0je __ReadFile2cmp [XferCount],0je __ReadFile1cmp byte [_IOBuffer+12],13je __ReadFile1cmp byte [_IOBuffer+12],10je __ReadFilecmp [__ByteCounter],0je __ReadFilemov al, byte [_IOBuffer+12]mov esi,[_ArgSafe0]mov [esi],alinc esimov [_ArgSafe0],esidec [__ByteCounter]jmp __ReadFile__ReadFile1:cmp [__ByteCounter],0je __ReadOKmov esi,[_ArgSafe0]mov byte [esi],0jmp __ReadOK__ReadFile2:cmp eax,0jne __ReadOKinvoke GetLastErrormov [ERR],eaxjmp [_ErrVec]__ReadOK:retENDTEXTTEXTBLOCK WriteFileLib__WriteFile:mov [XferCount],0__WriteStrLen:cmp byte [esi],0je __WriteStrLenDoneinc esiinc [XferCount]dec [__ByteCounter]jne __WriteStrLen__WriteStrLenDone:invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0mov [STATUS],eaxcmp eax,0jne __WriteOKinvoke GetLastErrormov [ERR],eaxjmp [_ErrVec]__WriteOK:mov edx,[XferCount]mov [_ArgSafe0],edxmov eax,[_CRLF]mov [_XferAddr],eaxmov [XferCount],2invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0mov edx,[_ArgSafe0]add edx,[XferCount]mov [XferCount],edxretENDTEXTTEXTBLOCK WriteOBCommLib__WriteOBComm:xor eax,eax__WriteOBCommStrLen:cmp byte [esi],0je __WriteOBCommStrLenDoneinc esiinc eaxdec edxjne __WriteOBCommStrLen__WriteOBCommStrLenDone:invoke WriteFile, dword [edi],ebx,eax,XferCount,0mov [STATUS],eaxcmp eax,0jne __WriteOBCommOKinvoke GetLastErrormov [ERR],eaxjmp [_ErrVec]__WriteOBCommOK:retENDTEXTTEXTBLOCK TailStrLib__TailStr:push ebxmov edi,[esi]mov ecx,[esi+4]xor edx,edxdec eaxadd eax,edi__TailStrLen:mov bl,[edi]or bl,blje __TailStr2dec ecxje __TailStr1inc ediinc edxjmp __TailStrLen__TailStr1:inc edi__TailStr2:mov [esi],eaxmov [esi+4],edxpop ebxretENDTEXTTEXTBLOCK LCaseLib__LCase:mov ecx,[esi+4]mov esi,[esi]__LCaseLoop:mov al,[esi]or al,alje __LCaseDonecmp al,$41jb __NotUppercmp al, $5aja __NotUpperor al,$20__NotUpper:mov [esi],alinc esidec ecxjne __LCaseLoop__LCaseDone:retENDTEXTTEXTBLOCK UCaseLib__UCase:mov ecx,[esi+4]mov esi,[esi]__UCaseLoop:mov al,[esi]or al,alje __UCaseDone cmp al,$61jb __NotLowercmp al, $7aja __NotLowerand al,$df__NotLower:mov [esi],alinc esidec ecxjne __UCaseLoop__UCaseDone:retENDTEXTTEXTBLOCK SetStrConstLib__SetStrConst:mov ecx,[esi+4]mov al,[esi]mov [edi],alor al,alje __SetStrConstDonedec ecxje __SetStrConstDoneinc esiinc edijmp __SetStrConst__SetStrConstDone:retENDTEXTTEXTBLOCK DataLib__ReadBool:mov edi,[_DataPtr]mov al,[edi]cmp al,$30jne __ReadBoolTruexor al,aljmp __ReadBoolDone__ReadBoolTrue:mov al,1__ReadBoolDone:mov [esi],aladd edi,2mov [_DataPtr],ediret__ReadByte:push esicinvoke atol,[_DataPtr]pop esimov [esi],alcall __UpDateDataPtrret__ReadShort:push esicinvoke atol,[_DataPtr]pop esimov [esi],axcall __UpDateDataPtrret__ReadLong:push esicinvoke atol,[_DataPtr]pop esimov [esi],eaxcall __UpDateDataPtrret__ReadFlt:ret__ReadStr:mov edi,[_DataPtr]__ReadStrLoop:mov al,[edi]mov [esi],alinc ediinc esicmp al,0jne __ReadStrLoopmov [_DataPtr],ediret__UpDateDataPtr:mov esi,[_DataPtr]__UpDateDataPtrLoop:mov al,[esi]cmp al,0je __UpDateDataPtrDoneinc esijmp __UpDateDataPtrLoop__UpDateDataPtrDone:inc esimov [_DataPtr],esiretENDTEXTTEXTBLOCK InpDataLib__InpData:invoke ReadConsole,[_InHandle],[_IOBuffer],_BufSize,XferCount,0push eaxcmp [_ArgSafe1],6je __InpDataStringcmp [_ArgSafe1],1je __InpDataBoolcmp [_ArgSafe1],2je __InpDataBytecmp [_ArgSafe1],3je __InpDataShortcmp [_ArgSafe1],5je __InpDataFloatcall __GetNumValmov [esi],eaxjmp __InpDataDone__InpDataString:mov edi,[_ArgSafe0]mov edx,ediadd edx,4mov edx,[edx]mov edi,[edi]mov ecx,[XferCount]mov esi,[_IOBuffer]__InpDataStringLp:mov al,[esi]cmp al,$0djne __NotCRmov byte [edi],0jmp __InpDataDone__NotCR:mov [edi],aldec edxje __InpDataDoneinc esiinc edijne __InpDataStringLpjmp __InpDataDone__InpDataBool:jmp __InpDataDone__InpDataByte:call __GetNumValmov [esi],aljmp __InpDataDone__InpDataShort:call __GetNumValmov [esi],axjmp __InpDataDone__InpDataFloat:__InpDataDone:pop eaxret__GetNumVal:mov esi,[_IOBuffer]cinvoke atol,[_IOBuffer]mov esi,[_ArgSafe0]mov esi,[esi]retENDTEXTTEXTBLOCK BtoALib__BtoA:mov edi,[_ConvBuf1]or al,alje __BoolFalsemov esi,_TrueStrjmp __BldBool__BoolFalse:mov esi,_FalseStr__BldBool:mov al,[esi]mov [edi],alcmp al,0je __BtoADoneinc esiinc edijmp __BldBool__BtoADone:mov [edi],alretENDTEXTTEXTBLOCK MidStrLib__MidStr:dec eaxmov edi,[esi]add edi,eaxmov [esi],edimov [esi+4],edxretENDTEXTTEXTBLOCK MovArgLib__MovArg:mov esi,[_ArgList]mov edx,[edi+4]mov edi,[edi]__MovArg1:mov al,[esi]cmp al,32je __MovArgSpacemov [edi],alor al,alje __MovArgDoneinc esiinc edidec edxje __MovArgDonejmp __MovArg1__MovArgSpace:xor al,almov [edi],alinc esi__MovArgDone:mov [_ArgList],esiretENDTEXTTEXTBLOCK CmpStrLib__CmpStr:mov edx,[edi+4]mov edi,[edi]mov ecx,[esi+4]mov esi,[esi]__CmpStrLoop:mov al,[edi]mov ah,[esi]cmp al,0je __CmpStrDonecmp ah,0je __CmpStrDonecmp al,ahjne __CmpStrDiffinc ediinc esidec edxje __CmpStrDonedec ecxjne __CmpStrLoop__CmpStrDone:cmp al,ah__CmpStrDiff:retENDTEXTTEXTBLOCK MovStrLib__MovStr:push ebxmov edx,[edi+4]mov edi,[edi]__MovStr1:mov ecx,[esi+4]or ecx,ecxje __MovStrDone1mov ebx,[esi]__MovStr2:mov al,[ebx]mov [edi],alinc ediinc ebxdec edxje __MovStrDone2or al,alje __MovStr3dec ecxjne __MovStr2jmp __MovStr4__MovStr3:dec edi__MovStr4:mov ecx,[esi+8]or ecx,ecxje __MovStrDone1mov esi,ecxjmp __MovStr1__MovStrDone1:mov byte [edi],0__MovStrDone2:pop ebxretENDTEXTTEXTBLOCK AtoLLib__AtoL:mov dl,[esi]cmp dl,'$'jne __NotHexcall __NumScan__HexLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'$'je __AtoLDonecmp dl,$39jg __HexLetterand dl,$0fjmp __HexAcc__HexLetter:and dl,$0fadd dl,9__HexAcc:imul edx,ecxadd eax,edximul ecx,16 jmp __HexLoop__NotHex:cmp dl,'%'jne __NotOctalcall __NumScan__OctalLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'%'je __AtoLDoneand dl,$07imul edx,ecxadd eax,edximul ecx,8jmp __OctalLoop__NotOctal:cmp dl,'&'jne __NotBinarycall __NumScan__BinaryLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'&'je __AtoLDoneand dl,$01imul edx,ecxadd eax,edximul ecx,2jmp __OctalLoop__NotBinary:cinvoke atol,esi__AtoLDone:ret__NumScan:inc esimov dl,[esi]cmp dl,0jne __NumScanxor eax,eaxmov ecx,1retENDTEXTTEXTBLOCK StrLenLib__StrLen:xor eax,eax__StrLenGetVec:mov edi,[esi]mov edx,[esi+4]__StrLenLp:mov cl,[edi]cmp cl,0je __StrLenChkLnkinc eaxdec edxje __StrLenChkLnkinc edijmp __StrLenLp__StrLenChkLnk:mov esi,[esi+8]or esi,esijne __StrLenGetVecretENDTEXTTEXTBLOCK RightStrLib__RightStr:mov edi,[esi]mov ecx,[esi+4]__RightStrLen:mov dl,[edi]or dl,dlje __RightStr2dec ecxje __RightStr1inc edijmp __RightStrLen__RightStr1:inc edi__RightStr2:sub edi,eaxmov [esi],edimov [esi+4],eaxretENDTEXTTEXTBLOCK SetRightBottomLib__SetRightBottom:mov edi,[!TargetGUIDesc]mov dword eax,[edi+LeftOffs]add dword eax,[edi+WidthOffs]mov dword [edi+RightOffs],eaxmov dword eax,[edi+TopOffs]add dword eax,[edi+HeightOffs]mov dword [edi+BottomOffs],eaxretENDTEXTTABLE KeyTable AS KeyData 0,"data",DataX 0,"restore",RestoreX 0,"seteof",SetEOFX 0,"close",CloseX 0,"VACANT",MainLoop 0,"type",TypeX 0,"dim",DimX 0,"let",LetX 0,"VACANT",MainLoop 0,"begin",BeginX 0,"for",ForX 0,"return",ReturnX  0,"if",IfX 0,"seek",SeekX 0,"create",CreateX 0,"gosub",GosubX 0,"on",OnX 0,"print",PrintX 0,"input",InputX 0,"read",ReadX 0,"write",WriteX 0,"get",GetX 0,"put",PutX 0,"return",ReturnX 0,"end",EndX 0,"open",OpenX 0,"while",WhileX 0,"next",NextX 0,"rem",RemX 0,"else",ElseX 0,"delete",DeleteX 0,"buffer",BufferX 0,"repeat",RepeatX 0,"until",UntilX 0,"shell",ShellX 0,"fprint",FPrintX 0,"finput",FInputX 0,"base",BaseX 0,"incr",IncrX 0,"decr",DecrX 0,"bufread",BufReadX 0,"bufwrite",BufWriteX 0,"decimals",DecimalsX 0,"exchange",ExchangeX 0,"beep",BeepX 0,"redim",ReDimX 0,"play"PlayX: 0,"setvec",SetVecX 0,"digits",DigitsX 0,"macro",MacroX 0,"endmacro",EndMacroX 0,"table",TableX 0,"include",IncludeX 0,"freeze",FreezeX 0,"chdir",ChDirX 0,"mkdir",MkDirX 0,"rmdir",RmDirX 0,"menu",MenuX 0,"declare",DeclareX 0,"continue",ContinueX 0,"select",SelectX 0,"case",CaseX 0,"const",ConstX 0,"swap",SwapX 0,"program",ProgramX 0,"gencode",GenCodeX 0,"endgencode",EndGenCodeX 0,"makelower",MakeLowerX 0,"makeupper",MakeUpperX 0,"find",FindX 0,"endtext",EndTextX 0,"setposition",SetPositionX 0,"goto",GotoX 0,"getcursorposition",GetCursorPositionX 0,"screentoclient",ScreenToClientX 0,"getwindowrect",GetWindowRectX 0,"getclientrect",GetClientRectX 0,"getpixel",GetPixelX 0,"setpixel",SetPixelX 0,"setcursor",SetCursorX 0,"setstockcursor",SetStockCursorX 0,"setdefaultcursor",SetDefaultCursorX 0,"setcursorflag",SetCursorFlagX 0,"getdc",GetDCX 0,"releasedc",ReleaseDCX 0,"beginpaint",BeginPaintX 0,"endpaint",EndPaintX 0,"invalidaterect",InvalidateRectX 0,"setcapture",SetCaptureX 0,"releasecapture",ReleaseCaptureX 0,"msgbox",MsgBoxX 0,"warningbox",WarningBoxX 0,"infobox",InfoBoxX 0,"questionbox",QuestionBoxX 0,"errorbox",ErrorBoxX 0,"setstyle",SetStyleX 0,"textblock",TextBlockX 0,"destroy",DestroyX 0,"show",ShowX 0,"finddialog",FindDialogX 0,"replacedialog",ReplaceDialogX 0,"colordialog",ColorDialogX 0,"fontdialog",FontDialogX 0,"opendialog",OpenDialogX 0,"savedialog",SaveDialogX 0,"printdialog",PrintDialogX 0,"pagedialog",PageDialogX 0,"showpopup",ShowPopupX 0,"deletemenuitem",DeleteMenuItemX 0,"appendmenuitem",AppendmenuItemX 0,"popupmenu",PopupMenuX 0,"setmenuitembitmaps",SetMenuItemBitmapsX 0,"checkmenuitem",CheckMenuitemX 0,"enablemenuitem",EnableMenuitemX 0,"hilitemenuitem",HiliteMenuItemX 0,"enum",EnumX 0,"loadicon",LoadIconX 0,"loadcursor",LoadCursorX 0,"loadimage",LoadImageX 0,"passevent",PassEventX 0,"trapcolorchangeevent",TrapColorChangeEventX 0,"readcard",ReadCardX 0,"writecard",WriteCardX 0,"useimport",UseImportX 0,"importfunction",ImportFunctionX 0,"exportfunction",ExportFunctionX 0,"createtask",CreateTaskX 0,"sleep",SleepX 0,"settaskpriority",SetTaskPriorityX 0,"begintask",BeginTaskX 0,"exit",ExitX 0,"launch",LaunchX 0,"getdatetime",GetDateTimeX 0,"getgmtdatetime",GetGMTDateTimeX 0,"getdateformat",GetDateFormatX 0,"gettimeformat",GetTimeFormatX 0,"timeadd",TimeAddX 0,"call",CallX 0,"run",RunX 0,"set",SETDx 0,"db",AssemblyX 0,"dw",AssemblyX 0,"dd",AssemblyX 0,"rb",AssemblyX 0,"rw",AssemblyX 0,"rd",AssemblyX 0,"add",AssemblyX 0,"aad",AssemblyX 0,"aam",AssemblyX 0,"aas",AssemblyX 0,"adc",AssemblyX 0,"and",AssemblyX 0,"arpl",AssemblyX 0,"bound",AssemblyX 0,"bsf",AssemblyX 0,"bsr",AssemblyX 0,"bswap",AssemblyX 0,"bt",AssemblyX 0,"btc",AssemblyX 0,"btr",AssemblyX 0,"bts",AssemblyX 0,"cbw",AssemblyX 0,"cdq",AssemblyX 0,"clc",AssemblyX 0,"cld",AssemblyX 0,"cli",AssemblyX 0,"clts",AssemblyX 0,"cmc",AssemblyX 0,"cmp",AssemblyX 0,"cpms",AssemblyX 0,"cmpxchg",AssemblyX 0,"cwd",AssemblyX 0,"cwde",AssemblyX 0,"daa",AssemblyX 0,"das",AssemblyX 0,"dec",AssemblyX 0,"div",AssemblyX 0,"enter",AssemblyX 0,"esc",AssemblyX 0,"hlt",AssemblyX 0,"idiv",AssemblyX 0,"imul",AssemblyX 0,"in",AssemblyX 0,"inc",AssemblyX 0,"ins",AssemblyX 0,"int",AssemblyX 0,"into",AssemblyX 0,"invd",AssemblyX 0,"iret",AssemblyX 0,"iretd",AssemblyX 0,"invlpg",AssemblyX 0,"invoke",AssemblyX 0,"ja",AssemblyX 0,"jae",AssemblyX 0,"jb",AssemblyX 0,"jbe",AssemblyX 0,"jc",AssemblyX 0,"jcxz",AssemblyX 0,"je",AssemblyX 0,"jecxz",AssemblyX 0,"jg",AssemblyX 0,"jge",AssemblyX 0,"jl",AssemblyX 0,"jle",AssemblyX 0,"jmp",AssemblyX 0,"jna",AssemblyX 0,"jnae,",AssemblyX 0,"jnb",AssemblyX 0,"jnbe",AssemblyX 0,"jnc",AssemblyX 0,"jne",AssemblyX 0,"jng",AssemblyX 0,"jnge",AssemblyX 0,"jnl",AssemblyX 0,"jnle",AssemblyX 0,"jno",AssemblyX 0,"jnp",AssemblyX 0,"jns",AssemblyX 0,"jnz",AssemblyX 0,"jo",AssemblyX 0,"jp",AssemblyX 0,"jpe",AssemblyX 0,"jpo",AssemblyX 0,"js",AssemblyX 0,"jz",AssemblyX 0,"lahf",AssemblyX 0,"lar",AssemblyX 0,"lds",AssemblyX 0,"lea",AssemblyX 0,"leave",AssemblyX 0,"les",AssemblyX 0,"lfs",AssemblyX 0,"lgdt",AssemblyX 0,"lidt",AssemblyX 0,"lgs",AssemblyX 0,"lldt",AssemblyX 0,"lmsw",AssemblyX 0,"lock",AssemblyX 0,"lods",AssemblyX 0,"loop",AssemblyX 0,"loope",AssemblyX 0,"loopne",AssemblyX 0,"loopnz",AssemblyX 0,"loopz",AssemblyX 0,"mov",AssemblyX 0,"movs",AssemblyX 0,"movsx",AssemblyX 0,"movzx",AssemblyX 0,"mul",AssemblyX 0,"neg",AssemblyX 0,"nop",AssemblyX 0,"not",AssemblyX 0,"or",AssemblyX 0,"out",AssemblyX 0,"outs",AssemblyX 0,"pop",AssemblyX 0,"popa",AssemblyX 0,"popad",AssemblyX 0,"popf",AssemblyX 0,"popfd",AssemblyX 0,"push",AssemblyX 0,"pusha",AssemblyX 0,"pushad",AssemblyX 0,"pushf",AssemblyX 0,"pushfd",AssemblyX 0,"rcl",AssemblyX 0,"rcr",AssemblyX 0,"rep",AssemblyX 0,"repe",AssemblyX 0,"repne",AssemblyX 0,"repnz",AssemblyX 0,"repz",AssemblyX 0,"ret",AssemblyX 0,"retf",AssemblyX 0,"rol",AssemblyX 0,"ror",AssemblyX 0,"sahf",AssemblyX 0,"sal",AssemblyX 0,"shl",AssemblyX 0,"sar",AssemblyX 0,"sbb",AssemblyX 0,"scas",AssemblyX 0,"setae",AssemblyX 0,"setnb",AssemblyX 0,"setnae",AssemblyX 0,"setbe",AssemblyX 0,"setna",AssemblyX 0,"sete",AssemblyX 0,"setz",AssemblyX 0,"setne",AssemblyX 0,"setnz",AssemblyX 0,"setl",AssemblyX 0,"setnge",AssemblyX 0,"setge",AssemblyX 0,"setnl",AssemblyX 0,"setle",AssemblyX 0,"setng",AssemblyX 0,"setg",AssemblyX 0,"setnle",AssemblyX 0,"sets",AssemblyX 0,"setns",AssemblyX 0,"setc",AssemblyX 0,"setnc",AssemblyX 0,"seto",AssemblyX 0,"setno",AssemblyX 0,"setp",AssemblyX 0,"setpe",AssemblyX 0,"setnp",AssemblyX 0,"setpo",AssemblyX 0,"sgdt",AssemblyX 0,"sidt",AssemblyX 0,"shl",AssemblyX 0,"shr",AssemblyX 0,"shld",AssemblyX 0,"shrd",AssemblyX 0,"shld",AssemblyX 0,"smsw",AssemblyX 0,"stc",AssemblyX 0,"std",AssemblyX 0,"sti",AssemblyX 0,"stos",AssemblyX 0,"str",AssemblyX 0,"sub",AssemblyX 0,"test",AssemblyX 0,"verr",AssemblyX 0,"verw",AssemblyX 0,"wait",AssemblyX 0,"fwait",AssemblyX 0,"wbinvd",AssemblyX 0,"xchg",AssemblyX 0,"xlat",AssemblyX 0,"xlatb",AssemblyX 0,"xor",AssemblyXEND TABLETABLE ObjTable AS ObjData 0,STDCTL,"form","Havis","0",FormPropTable,FormStyleTable,FormEventTable 0,STDCTL,"button","BUTTON","0",ButtonPropTable,ButtonStyleTable,ButtonEventTable 0,STDCTL,"staticicon","STATIC","0",StaticIconPropTable,StaticIconStyleTable,StaticIconEventTable 0,STDCTL,"combobox","COMBOBOX","0",ComboBoxPropTable,ComboBoxStyleTable,ComboBoxEventTable 0,STDCTL,"textbox","EDIT","WS_EX_CLIENTEDGE",TextBoxPropTable,TextBoxStyleTable,TextBoxEventTable 0,STDCTL,"frame","BUTTON","0",FramePropTable,FrameStyleTable,FrameEventTable 0,STDCTL,"listbox","LISTBOX","0",ListBoxPropTable,ListBoxStyleTable,ListBoxEventTable 0,COMCTL,"slider","msctls_trackbar32","0",SliderPropTable,SliderStyleTable,SliderEventTable 0,COMCTL,"spinner","msctls_updown32","0",SpinnerPropTable,SpinnerStyleTable,SpinnerEventTable 0,COMCTL,"progressbar","msctls_progress32","0",ProgressBarPropTable,ProgressBarStyleTable,ProgressBarEventTable 0,COMCTL,"calendar","SysMonthCal32","0",CalendarPropTable,CalendarStyleTable,CalendarEventTable 0,COMCTL,"header","SysHeader32","0",HeaderPropTable,HeaderStyleTable,HeaderEventTable 0,COMCTL,"treeview","SysTreeView32","0",TreeViewPropTable,TreeViewStyleTable,TreeViewEventTable 0,COMCTL,"tabfolder","SysTabControl32","0",TabFolderPropTable,TabFolderStyleTable,TabFolderEventTable 0,COMCTL,"animate","SysAnimate32","0",AnimatePropTable,AnimateStyleTable,AnimateEventTable 0,COMCTL,"toolbar","ToolbarWindow32","0",ToolBarPropTable,ToolBarStyleTable,ToolBarEventTable 0,COMCTL,"statusbar","msctls_statusbar32","0",StatusBarPropTable,StatusBarStyleTable,StatusBarEventTable 0,STDCTL,"checkbox","BUTTON","0",CheckBoxPropTable,CheckBoxStyleTable,CheckBoxEventTable 0,STDCTL,"radiobutton","BUTTON","0",RadioButtonPropTable,RadioButtonStyleTable,CheckBoxEventTable 0,TIMCTL,"timer","TIMER","0",TimerPropTable,TimerStyleTable,TimerEventTable 0,COMCTL,"richedit","RICHEDIT20A","WS_EX_CLIENTEDGE",RichEditPropTable,RichEditStyleTable,RichEditEventTable 0,COMCTL,"raedit","RAEdit","WS_EX_CLIENTEDGE",RAEditPropTable,RAEditStyleTable,RAEditEventTable 0,COMCTL,"ragrid","RAGrid","WS_EX_CLIENTEDGE",RAGridPropTable,RAGridStyleTable,RAGridEventTable 0,STDCTL,"toolwindow","Havis","0",ToolWindowPropTable,ToolWindowStyleTable,ToolWindowEventTable 0,COMCTL,"listview","SysListView32","0",ListViewPropTable,ListViewStyleTable,ListViewEventTable 0,STDCTL,"statictext","STATIC","0",StaticTextPropTable,StaticTextStyleTable,StaticTextEventTable 0,STDCTL,"iconbutton","BUTTON","0",IconButtonPropTable,IconButtonStyleTable,IconButtonEventTable 0,STDCTL,"rectangle","STATIC","0",RectanglePropTable,RectangleStyleTable,RectangleEventTable 0,STDCTL,"obcomm","OBCOMM","0",OBCommPropTable,OBCommStyleTable,OBCommEventTable 0,COMCTL,"drawprogress","DRAWPROGRESS","0",DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable 0,COMCTL,"scrollbar","SCROLLBAR","0",ScrollBarPropTable,ScrollBarStyleTable,ScrollBarEventTable 0,COMCTL,"datetimepick","SysDateTimePick32","0",DateTimePickPropTable,DateTimePickStyleTable,DateTimePickEventTable 0,STDCTL,"image","STATIC","0",ImagePropTable,ImageStyleTable,ImageEventTable 0,STDCTL,"sprsht","SPREAD_SHEET","0",SprShtPropTable,SprShtStyleTable,SprShtEventTable 0,STDCTL,"buttonex","ButtonEx","0",ButtonExPropTable,ButtonExStyleTable,ButtonExEventTableEND TABLEErrorTbl: DATA "Undefined symbol"; ErrUDSymDATA "Invalid symbol name"; ErrIVSNamDATA "Type mismatch or wrong type"; ErrTypMisDATA "Invalid Expression"; ErrIVExpDATA "Syntax Error"; ErrSyntaxDATA "Symbol already defined"; ErrDupSymDATA "Symbol table full"; ErrSymFulDATA "Undefined Function"; ErrUDFcnDATA "Invalid data type"; ErrIVTypeDATA "Invalid data type modifier"; ErrIVModDATA "Macro argument error"; ErrMacArgDATA "Invalid directive"; ErrIVDirDATA "Macro already defined"; ErrDupMacDATA "Undefined Error"; ErrEndStrDATA "Nested macro"; ErrMacNstDATA "Macro buffer full"; ErrMacBufDATA "Invalid macro"; ErrIVMacDATA "END MACRO without MACRO";  ErrEndmDATA "Unbalanced control structure"; ErrUBConDATA "Nested too deep"; ErrNDeepDATA "Illegal Declaration inside Fcn or Sub"; ErrDecFcnDATA "Invalid parameter"; ErrIVParmDATA "Parameter Statement out of Place"; ErrErrParmDATA "Expression too complex"; ErrCpxExpDATA "Invalid function";  ErrIVFuncDATA "No more temps available"; ErrTmpUseDATA "Unbalanced parens"; ErrParenDATA "Function error"; ErrFcnDATA "Invalid target"; ErrIVTargDATA "Fcn/Sub/Proc/Event/Task nested"; ErrFSNestDATA "Undefined Error"; ErrTblArrDATA "END FCN statement not in fcn"; ErrEndFcnDATA "Array subscript error"; ErrArrSubDATA "END PROC statement not in proc"; ErrEndProcDATA "END TABLE not in TABLE"; ErrEndTblDATA "Undefined Error"; ErrTblArgsDATA "Wrong number of args in proc or fcn"; ErrFcnArgsDATA "TYPE statement inside proc or fcn"; ErrTypeFcnDATA "Duplicate event"; ErrDupEventDATA "Invalid property, event, or style"; ErrIVPropDATA "END EVENT statement not in event"; ErrEndEventDATA "Operand value is out of range for data type specified"; ErrOpRangeDATA "Text arrays not allowed"; ErrTextArrayDATA "Text already defined"; ErrTextDefinedDATA "Text not defined"; ErrTextNotDefinedDATA "END TASK statement not in task"; ErrEndTaskDATA "END SUB statement not in sub"; ErrEndSubDATA "EXIT EVENT statement not in event"; ErrExitEventDATA "EXIT PROC statement not in proc"; ErrExitProcDATA "EXIT TASK statement not in task"; ErrExitTaskDATA "EXIT SUB statement not in sub"; ErrExitSubDATA "EXIT SEG statement not in seg"; ErrExitSegDATA "END SEG statement not in seg"; ErrEndSegDATA "SEG inside seg"; ErrSegInSegDATA "Illegal operation for device"; ErrDeviceRunStringTbl: DATA "_IOBuffer",_BufSizeDATA "_PrintBuf",_BufSizeDATA "_NullStr",1DATA "_CRLF",2DATA "_Prompt",1DATA "_ConvBuf",32DATA "_ConvBuf1",32DATA "ProgramName",28DATA "_SwitchStr",_BufSizeDATA "%",0PreDefTbl: DATA "{",OPER,0,0,0,0DATA "}",OPER,0,0,0,0DATA "[",OPER,0,0,0,0DATA "]",OPER,0,0,0,0DATA "(",OPER,0,0,0,0DATA ")",OPER,0,0,0,0DATA "=",OPER,0,0,0,0DATA "<",OPER,0,0,0,0DATA ">",OPER,0,0,0,0DATA "<=",OPER,0,0,0,0DATA ">=",OPER,0,0,0,0DATA "<>",OPER,0,0,0,0DATA ".",OPER,0,0,0,0DATA ",",OPER,0,0,0,0DATA "+",OPER,0,0,0,0DATA "-",OPER,0,0,0,0DATA "*",OPER,0,0,0,0DATA "/",OPER,0,0,0,0DATA "~",OPER,4,0,0,0DATA "_NullStr",STRINGVAR,VectorBit,0,0,0DATA "0x0",LONGVAR,ConstBit,0,0,4DATA "<",OPER,0,0,0,0DATA ">",OPER,0,0,0,0DATA "(",OPER,0,0,0,0DATA ")",OPER,0,0,0,0DATA "*",OPER,0,0,0,0DATA "",OPER,0,0,0,0DATA "true",BOOLVAR,4,1,0,1DATA "false",BOOLVAR,4,0,0,1DATA "eof",FCN,0,1,0,0DATA "len",FCN,0,2,0,0DATA "str$",FCN,0,3,0,0DATA "val",FCN,0,4,0,0DATA "land",FCN,0,5,0,0DATA "mid$",FCN,0,6,0,0DATA "lor",FCN,0,7,0,0DATA "left$",FCN,0,8,0,0DATA "mod",FCN,0,9,0,0DATA "chr$",FCN,0,10,0,0DATA "right$",FCN,0,11,0,0DATA "asc",FCN,0,12,0,0DATA "not",FCN,0,13,0,0DATA "bufadr",FCN,0,14,0,0DATA "bufsiz",FCN,0,15,0,0DATA "tab",FCN,0,16,0,0DATA "timediff",FCN,0,17,0,0DATA "addr",FCN,0,18,0,0DATA "lxor",FCN,0,19,0,0DATA "lnot",FCN,0,20,0,0DATA "index",FCN,0,21,0,0DATA "size",FCN,0,22,0,0DATA "ival",FCN,0,23,0,0DATA "fval",FCN,0,24,0,0DATA "trim$",FCN,0,25,0,0DATA "lof",FCN,0,26,0,0DATA "pof",FCN,0,27,0,0DATA "sqr",FCN,0,28,0,0DATA "int",FCN,0,29,0,0DATA "abs",FCN,0,30,0,0DATA "sin",FCN,0,31,0,0DATA "cos",FCN,0,32,0,0DATA "tan",FCN,0,33,0,0DATA "asn",FCN,0,34,0,0DATA "acs",FCN,0,35,0,0DATA "atn",FCN,0,36,0,0DATA "log",FCN,0,37,0,0DATA "log10",FCN,0,38,0,0DATA "!Vacant",FCN,0,39,0,0DATA "!Vacant",FCN,0,40,0,0DATA "!Vacant",FCN,0,41,0,0DATA "!Vacant",FCN,0,42,0,0DATA "!Vacant",FCN,0,43,0,0DATA "!Vacant",FCN,0,44,0,0DATA "!Vacant",FCN,0,45,0,0DATA "!Vacant",FCN,0,46,0,0DATA "!Vacant",FCN,0,47,0,0DATA "chkword",FCN,0,48,0,0DATA "hex$",FCN,0,49,0,0DATA "bittst",FCN,0,50,0,0DATA "shl",FCN,0,51,0,0DATA "shr",FCN,0,52,0,0DATA "rol",FCN,0,53,0,0DATA "ror",FCN,0,54,0,0DATA "bitchg",FCN,0,55,0,0DATA "bitclr",FCN,0,56,0,0DATA "bitset",FCN,0,57,0,0DATA "substr",FCN,0,56,0,0DATA "zstr$",FCN,0,59,0,0DATA "zhex$",FCN,0,60,0,0DATA "using",FCN,0,61,0,0DATA "ERR",LONGVAR,0,0,0,4DATA "_BufSize",0,0,0,0,0DATA "POS",LONGVAR,0,0,0,4DATA "_DummyArg",LONGVAR,0,0,0,4DATA "OBMain",100,0,0,0,0DATA "_IOBuffer",STRINGVAR,VectorBit,_BufSize,_BufSize,_BufSizeDATA "_PrintBuf",STRINGVAR,VectorBit,_BufSize,_BufSize,_BufSizeDATA "NMHDR",LONGVAR,0,0,0,4DATA "_Digits",WORDVAR,0,0,0,2DATA "_Decimals",WORDVAR,0,0,0,2DATA "STATUS",LONGVAR,0,0,0,4DATA "_ArgSafe0",LONGVAR,0,0,0,4DATA "_ArgSafe1",LONGVAR,0,0,0,4DATA "_IOPthNum",LONGVAR,0,0,0,4DATA "EventNotify",WORDVAR,0,0,0,2DATA "EventID",WORDVAR,0,0,0,2DATA "_IOBufPtr",LONGVAR,0,0,0,4DATA "MenuID",LONGVAR,0,0,0,4DATA "Menu",LONGVAR,0,0,0,4DATA "_DataPtr",LONGVAR,0,0,0,4DATA "ProgramName",STRINGVAR,VectorBit,28,28,28DATA "!Vacant",LONGVAR,0,0,0,4DATA "_ConvBuf",STRINGVAR,VectorBit,32,32,32DATA "FLAGS",LONGVAR,0,0,0,4DATA "_ConvBuf1",STRINGVAR,VectorBit,32,32,32DATA "PaintStruct",LONGVAR,0,0,0,4DATA "_Tmp1",LONGVAR,TempBit,0,0,4DATA "_Tmp2",LONGVAR,TempBit,0,0,4DATA "_Tmp3",LONGVAR,TempBit,0,0,4DATA "_Tmp4",LONGVAR,TempBit,0,0,4DATA "_Tmp5",LONGVAR,TempBit,0,0,4DATA "_Tmp6",LONGVAR,TempBit,0,0,4DATA "_Tmp7",LONGVAR,TempBit,0,0,4DATA "_Tmp8",LONGVAR,TempBit,0,0,4DATA "_Tmp9",LONGVAR,TempBit,0,0,4DATA "_Tmp10",LONGVAR,TempBit,0,0,4DATA "_Tmp11",LONGVAR,TempBit,0,0,4DATA "_Tmp12",LONGVAR,TempBit,0,0,4DATA "_Tmp13",LONGVAR,TempBit,0,0,4DATA "_Tmp14",LONGVAR,TempBit,0,0,4DATA "_Tmp15",LONGVAR,TempBit,0,0,4DATA "_TmpVec1",VOIDX,TmpVec,0,0,12DATA "_TmpVec2",VOIDX,TmpVec,0,0,12DATA "_TmpVec3",VOIDX,TmpVec,0,0,12DATA "_TmpVec4",VOIDX,TmpVec,0,0,12DATA "_TmpVec5",VOIDX,TmpVec,0,0,12DATA "_TmpVec6",VOIDX,TmpVec,0,0,12DATA "_TmpVec7",VOIDX,TmpVec,0,0,12DATA "_TmpVec8",VOIDX,TmpVec,0,0,12DATA "_TmpVec9",VOIDX,TmpVec,0,0,12DATA "_TmpVec10",VOIDX,TmpVec,0,0,12DATA "_TmpVec11",VOIDX,TmpVec,0,0,12DATA "_TmpVec12",VOIDX,TmpVec,0,0,12DATA "_TmpVec13",VOIDX,TmpVec,0,0,12DATA "_TmpVec14",VOIDX,TmpVec,0,0,12DATA "_TmpVec15",VOIDX,TmpVec,0,0,12DATA "&",9,0,0,0,0DATA "|",9,0,0,0,0DATA "0BUGBUG",FLOATVAR,ConstBit,0,0,8DATA "NextArg",6,TmpVec,0,0,0DATA "XferCount",4,0,0,0,0DATA "_FTmp1",FLOATVAR,0,0,0,8DATA "_FTmp2",FLOATVAR,0,0,0,8DATA "_FTmp3",FLOATVAR,0,0,0,8DATA "_FTmp4",FLOATVAR,0,0,0,8DATA "_FTmp5",FLOATVAR,0,0,0,8DATA "_FTmp6",FLOATVAR,0,0,0,8DATA "_FTmp7",FLOATVAR,0,0,0,8DATA "_FTmp8",FLOATVAR,0,0,0,8DATA "_FTmp9",FLOATVAR,0,0,0,8DATA "_FTmp10",FLOATVAR,0,0,0,8DATA "_FTmp11",FLOATVAR,0,0,0,8DATA "_FTmp12",FLOATVAR,0,0,0,8DATA "_FTmp13",FLOATVAR,0,0,0,8DATA "_FTmp14",FLOATVAR,0,0,0,8DATA "_FTmp15",FLOATVAR,0,0,0,8DATA "TRUE",BOOLVAR,ConstBit,1,0,1DATA "True",BOOLVAR,ConstBit,1,0,1DATA "FALSE",BOOLVAR,ConstBit,0,0,1DATA "False",BOOLVAR,ConstBit,0,0,1DATA "sal",FCN,0,62,0,0DATA "sar",FCN,0,63,0,0DATA "rcl",FCN,0,64,0,0DATA "rcr",FCN,0,65,0,0DATA "tablesize",FCN,0,66,0,0DATA "filtyp",FCN,0,67,0,0DATA "curdir",FCN,0,68,0,0DATA "bin$",FCN,0,69,0,0DATA "oct$",FCN,0,70,0,0DATA "!Vacant",FCN,0,71,0,0DATA "rnd",FCN,0,72,0,0DATA "gettickcount",FCN,0,73,0,0DATA "!Vacant",FCN,0,74,0,0DATA "!Vacant",FCN,0,75,0,0DATA "!Vacant",FCN,0,76,0,0DATA "!Vacant",FCN,0,77,0,0DATA "lcase$",FCN,0,78,0,0DATA "ucase$",FCN,0,79,0,0DATA "tail$",FCN,0,80,0,0DATA "findaddr",FCN,0,81,0,0DATA "findoffs",FCN,0,82,0,0DATA "ArrayIndex",LONGVAR,0,0,0,4DATA "_BoolRet",BOOLVAR,0,0,0,1DATA "_LongRet",LONGVAR,0,0,0,4DATA "_StringRet",STRINGVAR,VectorBit,0,0,0DATA "_FloatRet",FLOATVAR,0,0,0,8DATA "str",FCN,0,3,0,0DATA "mid",FCN,0,6,0,0DATA "left",FCN,0,8,0,0DATA "chr",FCN,0,10,0,0DATA "right",FCN,0,11,0,0DATA "trim",FCN,0,25,0,0DATA "hex",FCN,0,49,0,0DATA "zstr",FCN,0,59,0,0DATA "zhex",FCN,0,60,0,0DATA "bin",FCN,0,69,0,0DATA "oct",FCN,0,70,0,0DATA "lcase",FCN,0,78,0,0DATA "ucase",FCN,0,79,0,0DATA "tail",FCN,0,80,0,0DATA "LOGFONT",TYPE,0,14,0,60DATA "lfHeight",LONGVAR,0,0,0,4DATA "lfWidth",LONGVAR,0,0,4,4DATA "lfEscapement",LONGVAR,0,0,8,4DATA "lfOrientation",LONGVAR,0,0,12,4DATA "lfWeight",LONGVAR,0,0,16,4DATA "lfItalic",BYTEVAR,0,0,20,1DATA "lfUnderline",BYTEVAR,0,21,0,1DATA "lfStrikeOut",BYTEVAR,0,22,0,1DATA "lfCharSet",BYTEVAR,0,0,23,1DATA "lfOutPrecision",BYTEVAR,0,0,24,1DATA "lfClipPrecision",BYTEVAR,0,0,25,1DATA "lfQuality",BYTEVAR,0,0,26,1DATA "lfPitchAndFamily",BYTEVAR,0,0,27,1DATA "lfFaceName",STRINGVAR,0,32,28,32DATA "GridRow",LONGVAR,0,0,0,4DATA "GridCol",LONGVAR,0,0,0,4DATA "EditcpMin",LONGVAR,0,0,0,4DATA "EditcpMax",LONGVAR,0,0,0,4DATA "EditSelType",WORDVAR,0,0,0,4DATA "EditLine",LONGVAR,0,0,0,4DATA "EditcpLine",LONGVAR,0,0,0,4DATA "EditlpLine",LONGVAR,0,0,0,4DATA "EditnLines",LONGVAR,0,0,0,4DATA "EditnHidden",LONGVAR,0,0,0,4DATA "EditfChanged",LONGVAR,0,0,0,4DATA "EditnPage",LONGVAR,0,0,0,4DATA "EditnWordGroup",LONGVAR,0,0,0,4DATA "ft_SearchMin",LONGVAR,0,0,0,4DATA "ft_SearchMax",LONGVAR,0,0,0,4DATA "ft_SearchTextPtr",LONGVAR,0,0,0,4DATA "fr_lpstrFindWhat",LONGVAR,0,0,0,4DATA "ft_FoundMin",LONGVAR,0,0,0,4DATA "ft_FoundMax",LONGVAR,0,0,0,4DATA "cr_cpMin",LONGVAR,0,0,0,4DATA "cr_cpMax",LONGVAR,0,0,0,4DATA "SC_CLOSE",LONGVAR,ConstBit,61536,0,4DATA "SC_MINIMIZE",LONGVAR,ConstBit,61472,0,4DATA "SC_MAXIMIZE",LONGVAR,ConstBit,61488,0,4DATA "SC_RESTORE",LONGVAR,ConstBit,61728,0,4DATA "wmsg",LONGVAR,0,0,0,4DATA "wparam",LONGVAR,0,0,0,4DATA "lparam",LONGVAR,0,0,0,4DATA "ncode",LONGVAR,0,0,0,4DATA "WM_MOUSEMOVE",LONGVAR,ConstBit,512,0,4DATA "WM_LBUTTONDOWN",LONGVAR,ConstBit,513,0,4DATA "WM_LBUTTONUP",LONGVAR,ConstBit,514,0,4DATA "WM_RBUTTONDOWN",LONGVAR,ConstBit,516,0,4DATA "WM_RBUTTONUP",LONGVAR,ConstBit,517,0,4DATA "MK_LBUTTON",LONGVAR,ConstBit,1,0,4DATA "MK_RBUTTON",LONGVAR,ConstBit,2,0,4DATA "MK_SHIFT",LONGVAR,ConstBit,4,0,4DATA "MK_CONTROL",LONGVAR,ConstBit,8,0,4DATA "MK_MBUTTON",LONGVAR,ConstBit,16,0,4DATA "CursorPosX",LONGVAR,0,0,0,4DATA "CursorPosY",LONGVAR,0,0,0,4DATA "RectLeft",LONGVAR,0,0,0,4DATA "RectTop",LONGVAR,0,0,0,4DATA "RectRight",LONGVAR,0,0,0,4DATA "RectBottom",LONGVAR,0,0,0,4DATA "IDOK",LONGVAR,ConstBit,1,0,4DATA "IDCANCEL",LONGVAR,ConstBit,2,0,4DATA "IDABORT",LONGVAR,ConstBit,3,0,4DATA "IDRETRY",LONGVAR,ConstBit,4,0,4DATA "IDIGNORE",LONGVAR,ConstBit,5,0,4DATA "IDYES",LONGVAR,ConstBit,6,0,4DATA "IDNO",LONGVAR,ConstBit,7,0,4DATA "IDCLOSE",LONGVAR,ConstBit,8,0,4DATA "IDHELP",LONGVAR,ConstBit,9,0,4DATA "ZTOP",LONGVAR,ConstBit,0,0,4DATA "ZBOTTOM",LONGVAR,ConstBit,1,0,4DATA "ZTOPMOST",LONGVAR,ConstBit,4294967295,0,4DATA "ZNOTOPMOST",LONGVAR,ConstBit,4294967294,0,4DATA "NOPARITY",LONGVAR,ConstBit,0,0,4DATA "ODDPARITY",LONGVAR,ConstBit,1,0,4DATA "EVENPARITY",LONGVAR,ConstBit,2,0,4DATA "MARKPARITY",LONGVAR,ConstBit,3,0,4DATA "SPACEPARITY",LONGVAR,ConstBit,4,0,4DATA "ONESTOPBIT",LONGVAR,ConstBit,0,0,4DATA "ONE5STOPBITS",LONGVAR,ConstBit,1,0,4DATA "TWOSTOPBITS",LONGVAR,ConstBit,2,0,4DATA "CommError",LONGVAR,0,0,0,4DATA "AltKey",BOOLVAR,0,0,0,1DATA "DATETIME",TYPE,0,8,0,16DATA "wYear",WORDVAR,0,0,0,2DATA "wMonth",WORDVAR,0,0,2,2DATA "wDayOfWeek",WORDVAR,0,0,4,2DATA "wDay",WORDVAR,0,0,6,2DATA "wHour",WORDVAR,0,0,8,2DATA "wMinute",WORDVAR,0,0,10,2DATA "wSecond",WORDVAR,0,0,12,2DATA "wMilliseconds",WORDVAR,0,0,14,2DATA "%"; *************************************** Compiler Code Starts Here ******************************; StartCompile:IF Changed=TRUE THEN	WARNINGBOX "File Not Saved","Save?",MB_YESNO	IF STATUS=IDYES THEN		IF FileName="Untitled" THEN			GOSUB SaveAs		ELSE			Edit.SAVEFILE SaveFileName			;// ENABLEMENUITEMMainMenu,mnuSave,FALSE			Button(3).ENABLED=FALSE		END IF	ELSE		SETDEFAULTCURSOR		RETURN	END IFEND IFSETSTOCKCURSOR WaitEdit.EMPTYUNDOBUFFERChanged=FALSE;// ENABLEMENUITEMMainMenu,mnuSave,FALSEButton(3).ENABLED=FALSEStatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5StartTime=GETTICKCOUNT()SELECT CASE Extension	CASE ".obc"; Console pgm		GUIFlag=FALSE		DLLFlag=FALSE	CASE ".obw"; Windows pgm		GUIFlag=TRUE		DLLFlag=FALSE	CASE ".obp"; Windows pgm project		GUIFlag=TRUE		DLLFlag=FALSE	CASE ".obd"; DLL (GUI)		GUIFlag=TRUE		DLLFlag=TRUE	CASE ".obl"; Library (DLL console)		GUIFlag=FALSE		DLLFlag=TRUE	CASE ".obo"; GUI Object DLL (custom control)		GUIFlag=TRUE		DLLFlag=TRUE	CASE ELSE		TempStr="No Recognized Extension"		SETDEFAULTCURSOR		WARNINGBOX "Error",TempStr,MB_OK		RETURNEND SELECTON ERROR GOTO NoInpFileInpFilPtr=1OPEN FileName FOR INPUT AS InpFile(InpFilPtr)ON ERROROPEN "_DeclareFile" FOR SCRATCH AS DeclareFileOPEN "_PreCodeFile" FOR SCRATCH AS PreCodeFileOPEN "_CodeFile" FOR SCRATCH AS CodeFileOPEN "_DataFile" FOR SCRATCH AS DataFileOPEN "_DimFile" FOR SCRATCH AS DimFileOPEN "_DescFile" FOR SCRATCH AS DescFileOPEN "_InitFile" FOR SCRATCH AS InitFileOPEN "_FunctionFile" FOR SCRATCH AS FunctionFileOPEN "_ExportFile" FOR SCRATCH AS ExportFileOPEN "_ResourceFile" FOR SCRATCH AS ResourceFileUseReadFile=FALSEUseWriteFile=FALSEUseWriteOBComm=FALSEUseSetStrConst=FALSEUseTrmStr=FALSEUsePrtUsing=FALSEUseData=FALSEUseMovStr=FALSEUseCmpStr=FALSEUseStrLen=FALSEUseSubStr=FALSEUseMidStr=FALSEUseRightStr=FALSEUseClrConv=FALSEUseAtoD=FALSEUseAtoL=FALSEUseNumScan=FALSEUseZLtoH=FALSEUseZLtoA=FALSEUseLtoA=FALSEUseDtoA=FALSEUseLtoH=FALSEUsePrintStr=FALSEUsePrintTab=FALSEUseInpData=FALSEUseBtoA=FALSEUseLCase=FALSEUseUCase=FALSEUseTailStr=FALSEUseSetRightBottom=FALSERichEdLibUsed=FALSERAEditLibUsed=FALSERAGridLibUsed=FALSECsmdllLibUsed=FALSEDrawProgressLibUsed=FALSEImageLibUsed=FALSESprShtLibUsed=FALSEButtonExLibUsed=FALSEGFNdx=1DataLabel=FALSEExclamationOK=FALSEGenFlag(GFNdx)=$ffSETVEC ByteArray=ADDR(TokenBuf)DeferFlag=FALSEEnumVal=0EnumStep=1FindReplaceFlag=0XBufSize=_BufSizeSelectFlag=FALSECaseFlag=FALSECaseElseFlag=FALSESegFlag=FALSESubFlag=FALSETaskFlag=FALSEProcFlag=FALSEFcnFlag=FALSEEventFlag=FALSEProcFcnFlag=FALSEDataFlag=FALSELastSym=UserSym-1StartFlag=FALSELopCtrNum=-1ArrayBase=1;  default to base 1SubClassFlag=FALSEPrintPathFlag=0ResourceFlag=FALSEExportFlag=FALSEDtaRegNum=0TmpMax=0TmpVecMax=0FTmpMax=0ChrTmpMax=0StrTmpMax=0ErrCnt=0LastStmt=""ConStkPtr=0LopVarNdx=0StringNum=0TimerNum=0SegNum=0LabelNum=0OELabelNum=0SCLabelNum=0GUILabelNum=0TableNum=0ObjectID=100MenuIDNum=999ProcNum=0InterceptProcNum=0LoopNum=0MacExFlag=0BasicLineCtr=0AsmLineCtr=0ErrNo=0PoolCtr=0VarBytRem=0GOSUB MainLoopInitFOR LopVarNdx=1 to 100	LoopVars(LopVarNdx)="%"NEXT LopVarNdxFOR MacDefNdx=1 TO MacBufSiz	MacBuf(MacDefNdx)=0NEXT MacDefNdxMacDefNdx=1RESTORE PreDefTblSymNdx=0InitSym:INCR SymNdxREAD TempStrIF TempStr="%" THEN LoadKeyWordsSymTemp.SymName=TempStrREAD SymTemp.DataTypeREAD SymTemp.DataModREAD SymTemp.DetailREAD SymTemp.DataAddrREAD SymTemp.DataSizeSymTable(SymNdx)=SymTempSymTableKey(SymNdx)=CHKWORD(TempStr)GOTO InitSymLoadKeyWords:LastKey=TABLESIZE(KeyTable)FOR KeyNdx=1 TO LastKey	KeyTable(KeyNdx).KeyCheckWord=CHKWORD(KeyTable(KeyNdx).KeyName)NEXT KeyNdxLastImportLib=TABLESIZE(ImportLibTable)FOR I=1 TO LastImportLib	ImportLibTable(I).ImportLibUse=FALSE	ImportLibTable(I).ImportLibLastUsed=FALSENEXT ILastImportFcn=TABLESIZE(ImportFcnTable)FOR I=1 TO LastImportFcn	ImportFcnTable(I).ImportFcnUse=FALSE	ImportFcnTable(I).ImportFcnLastUsed=FALSENEXT IPreamble:;*** Win95/NT ****NewLine=$0dOutBuf=";Compiler Declaration Section";;; Temp fix for init problem;GOSUB OutDeclareOutBuf=";Compiler Declaration Section"GOSUB OutDeclareOutBuf=""GOSUB OutDeclareOutBuf="format PE "IF GUIFlag=FALSE THEN	OutBuf=OutBuf+"console"ELSE	OutBuf=OutBuf+"GUI 4.0"END IFIF DLLFlag=TRUE THEN	OutBuf=OutBuf+" DLL"END IFGOSUB OutDeclareOutBuf="section '.data' data readable writeable"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataOutBuf="align 4"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataOutBuf="ERR dd 0"GOSUB OutInitDataOutBuf="!ArrayBase dd 1"GOSUB OutInitDataOutBuf="_ErrVec dd 0"GOSUB OutInitDataOutBuf="STATUS dd 0"GOSUB OutInitDataOutBuf="POS dd 0"GOSUB OutInitDataOutBuf="Ticks dd 0"GOSUB OutInitDataOutBuf="XferCount dd 0"GOSUB OutInitDataOutBuf="CommError dd 0"GOSUB OutInitDataOutBuf="EventNotify dw 0"GOSUB OutInitDataOutBuf="EventID dw 0"GOSUB OutInitDataOutBuf="_TrueStr db "+CHR(OBQUOTE)+"TRUE"+CHR(OBQUOTE)+",0"GOSUB OutInitDataOutBuf="_FalseStr db "+CHR(OBQUOTE)+"FALSE"+CHR(OBQUOTE)+",0"GOSUB OutInitDataIF GUIFlag=TRUE THEN	LastObj=TABLESIZE(ObjTable)	FOR ObjNdx=1 TO LastObj		ObjTable(ObjNdx).ObjCheckWord=CHKWORD(ObjTable(ObjNdx).ObjName)		OutBuf="!ControlType"+STR(ObjNdx)+" db '"+ObjTable(ObjNdx).ObjTypeName+"',0"		GOSUB OutInitData	NEXT ObjNdxEND IFOutBuf=""GOSUB OutDeclareOutBuf="entry !Start"GOSUB OutDeclareOutBuf=""GOSUB OutDeclareOutBuf="macro align value { rb (value-1) - (rva $ + value-1) mod value }"GOSUB OutDeclareOutBuf=""GOSUB OutDeclareOutBuf="_BufSize="+STR(_BufSize)GOSUB OutDeclareRESTORE RunVarsGOSUB OutUninitTextRESTORE PreCodeSeg1GOSUB OutPreCodeTextImportFcnTable(ptrGetStdHandle).ImportFcnUse=TRUEImportFcnTable(ptrGetCommandLine).ImportFcnUse=TRUEImportFcnTable(ptrGetModuleHandle).ImportFcnUse=TRUEIF GUIFlag=TRUE THEN	RESTORE GUIRunVars	GOSUB OutUninitText	RESTORE GUIInitVars	GOSUB OutInitText		OutBuf="!OBMain rd 192""	GOSUB OutDesc		ObjectCtr=1		GenConst CT,FORM,100	GenConst CT,BUTTON,101	GenConst CT,STATICICON,102	GenConst CT,COMBOBOX,103	GenConst CT,TEXTBOX,104	GenConst CT,FRAME,105	GenConst CT,LISTBOX,106	GenConst CT,SLIDER,107	GenConst CT,SPINNER,108	GenConst CT,PROGRESSBAR,109	GenConst CT,CALENDAR,110	GenConst CT,HEADER,111	GenConst CT,TREEVIEW,112	GenConst CT,TABFOLDER,113	GenConst CT,ANIMATE,114	GenConst CT,TOOLBAR,115	GenConst CT,STATUSBAR,116	GenConst CT,CHECKBOX,117	GenConst CT,RADIOBUTTON,118	GenConst CT,TIMER,119	GenConst CT,RICHEDIT,120	GenConst CT,RAEdit,121	GenConst CT,RAGrid,122	GenConst CT,TOOLWINDOW,123	GenConst CT,LISTVIEW,124	GenConst CT,STATICTEXT,125	GenConst CT,ICONBUTTON,126	GenConst CT,RECTANGLE,127	GenConst CT,OBCOMM,128	GenConst CT,DRAWPROGRESS,129	GenConst CT,SCROLLBAR,130	GenConst CT,DATETIMEPICK,131	GenConst CT,IMAGE,132	GenConst CT,SPRSHT,133	GenConst CT,ButtonEx,134		IF DLLFlag=FALSE THEN			RESTORE PreCodeSeg2		GOSUB OutPreCodeText		GOSUB MakeLine		GOSUB OutCode	END IF		ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	ImportFcnTable(ptrRegisterClass).ImportFcnUse=TRUE	ImportFcnTable(ptrLoadCursor).ImportFcnUse=TRUE	ImportFcnTable(ptrLoadIcon).ImportFcnUse=TRUE	ImportFcnTable(ptrLoadLibrary).ImportFcnUse=TRUE	ImportFcnTable(ptrInitCommonControlsEx).ImportFcnUse=TRUE	ImportFcnTable(ptrGetMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrTranslateMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrDispatchMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUE	ImportFcnTable(ptrSetBkColor).ImportFcnUse=TRUE	ImportFcnTable(ptrSetTextColor).ImportFcnUse=TRUE	ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE	ImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUE	ImportFcnTable(ptrDefWindowProc).ImportFcnUse=TRUE	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	ImportFcnTable(ptrGetBkColor).ImportFcnUse=TRUE	ImportFcnTable(ptrGetPixel).ImportFcnUse=TRUE	ImportFcnTable(ptrSetBkMode).ImportFcnUse=TRUE	ImportFcnTable(ptrGetStockObject).ImportFcnUse=TRUE	ImportFcnTable(ptrGetModuleHandle).ImportFcnUse=TRUE	ImportFcnTable(ptrPostQuitMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrSetTimer).ImportFcnUse=TRUE	ImportFcnTable(ptrShellExecute).ImportFcnUse=TRUE	ImportFcnTable(ptrMessageBox).ImportFcnUse=TRUE	ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE	ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUE	RESTORE GUIEquates	OutBuf=""	GOSUB OutDeclare	OutBuf="; GUI Equates"	GOSUB OutDeclare	OutBuf=""	GOSUB OutDeclare	BEGIN LOOP		READ OutBuf		EXIT IF OutBuf="ENDTEXT"		GOSUB OutDeclare		INCR AsmLineCtr	END LOOPEND IFGenEquate WinConstructed,0GenEquate WinEnabled,1GenEquate WinVisible,2GenEquate WinChangeBackColor,3GenEquate WinChangeForeColor,4GenEquate WinArray,5GenEquate WinSubClassed,6GenEquate WinLoaded,7GenEquate WinPlaced,8GenEquate WinTipExists,9OutBuf="_ErrExitMsg db 'Error exit',0"GOSUB OutInitDataRESTORE RunStringTblRunStringLoop:READ VarNameIF VarName="%" THEN RunStringDoneREAD ArraySizeTempInt=ArraySize/4IF Mod(ArraySize,4)<>0 THEN	TempInt=TempInt+1END IFOutBuf="align 4"GOSUB OutInitDataOutBuf=VarName+" dd "+VarName+"+12"GOSUB OutInitDataOutBuf=" dd "+STR(ArraySize)GOSUB OutInitDataOutBuf=" dd 0"GOSUB OutInitDataOutBuf=" rb "+STR(ArraySize)GOSUB OutInitDataGOTO RunStringLoopRunStringDone:OutBuf=""GOSUB OutInitCodeOutBuf="; Init Section"GOSUB OutInitCodeOutBuf="_Init:"GOSUB OutInitCodeIF GUIFlag=TRUE THEN	OutBuf="mov [!CursorFlag],0"	GOSUB OutInitCodeEND IFOutBuf=""GOSUB OutFunctionOutBuf="; Function Code Section"GOSUB OutFunctionOutBuf=""GOSUB OutFunctionBEGIN SEG MainLoopIF ErrNo<>0 THEN	SETDEFAULTCURSOR	IF ErrNo=ErrMacArg THEN		TempStr="Fatal Error... MACRO argument error in line "+STR(BasicLineCtr)		GOSUB ShowError		RETURN	END IF	IF ErrNo=$ff THEN		GOSUB ShowError		RETURN	END IF		RESTORE ErrorTbl	FOR Ctr1=1 to ErrNo		READ TempStr	NEXT Ctr1	TempStr=TempStr+" in line "+STR(BasicLineCtr)	GOSUB ShowError	RETURNEND IFIF DimFlag=0 THEN	BEGIN LOOP		IF SymTable(LastSym).DataType<>STRINGVAR OR LAND(SymTable(LastSym).DataMod,ConstBit)<>ConstBit THEN NotString		DECR LastSym	END LOOPEND IFNotString:GOSUB MainLoopInitIF MacExFlag=0 THEN	GOSUB ReadSource	IF TempInt=0 THEN FinishELSE	SrcLine=""	SrcNdx=0	MacExLp: AsciiByte=MacBuf(MacExNdx)	INCR MacExNdx	IF AsciiByte=0 THEN;  end of MACRO		MacExFlag=0		EXIT SEG	END IF	IF AsciiByte=NewLine THEN ProcLine	IF LAND($80,AsciiByte)=$80 THEN		AsciiByte=LAND($7f,AsciiByte)		IF AsciiByte=0 THEN			SrcLine=SrcLine+STR(SymTable(MacTblPtr).Detail)			GOTO MacExLp		END IF		IF AsciiByte>MaxArgNum THEN			ErrNo=ErrMacArg			EXIT SEG		END IF		MacArgPtr=AsciiByte		SrcLine=SrcLine+MacArgBuf(MacArgPtr)		GOTO MacExLp	END IF	SrcLine=SrcLine+CHR(AsciiByte)	GOTO MacExLpEND IFProcLine:SrcNdx=0IF GenFlag(GFNdx)=0 THEN	IF LEFT(SrcLine,1)<>"$" THEN MainLoop	INCR SrcNdx	GOSUB NexToken	IF TokenBuf<>"if" AND TokenBuf<>"else" AND TokenBuf<>"endif" THEN MainLoop	IF TokenBuf="if" THEN IFDx	IF TokenBuf="else" THEN ELSEDx	GOTO ENDIFDxEND IF	IF LEN(SrcLine)=0 THEN MainLoopTempByte=LEFT(SrcLine,1)IF TempByte="'" THEN	GOSUB Remark	GOSUB OutCodeData	EXIT SEGEND IFIF TempByte=";" THEN	GOSUB Remark	GOSUB OutCodeData	EXIT SEGEND IFIF TempByte="$" THEN	; Process Directive	GOSUB Remark	GOSUB OutCodeData	INCR SrcNdx	GOSUB NexToken	IF TokenBuf="if" THEN IFDx	IF TokenBuf="else" THEN ELSEDx	IF TokenBuf="endif" THEN ENDIFDx	IF TokenBuf="exok" THEN		ExclamationOK=TRUE		EXIT SEG	END IF	ErrNo=ErrSyntax	EXIT SEGEND IF GOSUB NexTokenSrcNdx=0IF NextByte<>":" THEN ProcStmt IF DataFlag=TRUE THEN	DataFlag=FALSEEND IFLNFlag=$ffGOSUB ProcLabelErrMainGOSUB NexToken; Eat the ':'GOSUB NexTokenIF TokenBuf="data" THEN	SymTable(SymNdx).DataMod=DataBit	GOTO DataX;  DATA statement processingEND IFGOSUB UnDoTokenSymbolSaf=SymbolSaf+":"ProcStmt:GOSUB NexTokenIF TokenSaf="STATUS" THEN	EqualMain	GOSUB NexToken	StatFlag=$ffEND IFIF LEN(TokenBuf)>0 THEN	LastStmt=TokenBufEND IFIF TokenLen=0 THEN	GOSUB OutLabel	EXIT SEGEND IFGOSUB KeyLookIF KeyNdx=0 THEN	REM maybe a macro	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=TRUE AND SymTable(SymNdx).DataType=MACROVAR THEN		GOSUB Remark		GOSUB OutCodeData		MacTblPtr=SymNdx		MacExNdx=SymTable(SymNdx).DataAddr		SymTable(SymNdx).Detail=SymTable(SymNdx).Detail+1; inc macro occurrance		NeedComma=0		MaxArgNum=0		MacExFlag=$ff		GOSUB OutLabel		IF MID(SrcLine,SrcNdx+1,1)=" " THEN			INCR SrcNdx		END IF		MacExLoop:		GOSUB MacToken		IF TokenLen=0 THEN			EXIT SEG		END IF		IF NeedComma=0 AND TokenSaf="," THEN			INCR MaxArgNum			MacArgBuf(MaxArgNum)=""			GOTO MacExLoop		END IF		IF NeedComma=$ff AND TokenSaf<>"," THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		IF NeedComma=$ff AND TokenSaf="," THEN			NeedComma=0			GOTO MacExLoop		END IF		INCR MaxArgNum		MacArgBuf(MaxArgNum)=TokenSaf		NeedComma=$ff		GOTO MacExLoop	END IF	IF SymFound=TRUE AND SymTable(SymNdx).DataType>99 THEN		KeyNdx=999; Pseudo code for GUI Target		ObjectType=SymTable(SymNdx).DataType		ObjectName=SymTable(SymNdx).SymName		ObjectDetail=SymTable(SymNdx).Detail		ObjectArray=SymTable(SymNdx).ArrayDim1	ELSE		KeyNdx=8; Assume LET	END IF	GOSUB UnDoTokenEND IFIF KeyNdx<>1 THEN	DataFlag=FALSEEND IFGOSUB RemarkSELECT CASE KeyNdx	CASE 1; DATA		GOSUB OutInitData		GOTO DataX	CASE 6; TYPE		GOSUB OutUninitData		GOTO TypeX	CASE 7; DIM		GOTO DimX	CASE 10; BEGIN		GOTO BeginX	CASE 999		ErrGUI		GOSUB NexToken		ObjectName=TokenSaf		StartFlag=TRUE		GOSUB OutCodeData; put out OmniBasic source as comment		GUITargetSymNdx=SymNdx		GUITargetFlag=$ff		GOSUB ProcessObject		ErrMain		GOTO GUITarget	CASE ELSE		StartFlag=TRUE		GOSUB OutCodeData; put out OmniBasic source as comment		OutBuf=""		GOSUB OutLabel		GOTO [KeyTable(KeyNdx).KeyLabel]END SELECTEND SEG MainLoopBEGIN SUB ProcLabelStartFlag=TRUEGOSUB TokenSymErrMainLabelFlag=$ffTDataType=SymTable(SymNdx).DataTypeTDetail=SymTable(SymNdx).DetailTDataSize=SymTable(SymNdx).DataSizeTempStr=SymbolSafSymbolSaf=TempStrIF SymFound=TRUE THEN; Label Found	IF TDataType<>LABELVAR THEN		ErrNo=ErrDupSym		RETURN	END IF	IF TDetail=LabelUnresolved THEN		SymTable(SymNdx).Detail=LabelResolved	ELSE		ErrNo=ErrDupSym		RETURN	END IFELSE	GOSUB ClrDatTyp	TDataType=LABELVAR	SymTemp.DataType=LABELVAR	GOSUB ClrSym	SymTemp.DataMod=0	SymTemp.Detail=LabelResolved	GOSUB SymInsert	ErrRetEND IFEND SUBBEGIN SUB ProcCmdIF Op1Class<>STRClass THEN	ErrNo=ErrTypMis	EXIT SUBEND IFOutBuf="mov dword edi,"+Op1NameGOSUB OutCodeDataOutBuf="call __MovArg"GOSUB OutCodeDataEND SUBSETDx:SetMask=0GOSUB SETDx1GOTO MainLoopSETDx1:; Changed into a subroutine because is called by; inline code OR CmdLine, so cannot "jump" to MainLoop as before.UMFlag=0GOSUB TokenSymErrRetIF SymFound=FALSE THEN	SymTemp.DataType=COMPVAR	GOSUB ClrSym	GOSUB SymInsert	ErrRetELSE	IF SymTable(SymNdx).DataType<>COMPVAR AND SymTable(SymNdx).DataType<> MACROVAR THEN		ErrNo=ErrTypMis		RETURN	END IF	IF LAND(SymTable(SymNdx).DataMod,SetMask)<>0 THEN		RETURN	END IFEND IFSymNdxSaf=SymNdxEqualRetGOSUB NexTokenIF TokenBuf="-" THEN	UMFlag=$ff	GOSUB NexTokenEND IFSELECT CASE TokenType	CASE TTypInt		GOSUB ChkInt		ErrRet		GOTO SetOp1	CASE TTypHex		GOSUB ChkHex		ErrRet		GOTO SetOp1	CASE TTypSym		GOSUB ChkSym		ErrRet		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO SetOp1	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTSetOp1:IF UMFlag=$ff THEN	TempStr="-"ELSE	TempStr=""END IFTempStr=TempStr+TokenSafIF MID(TempStr,1,2)="--" THEN	TempStr=MID(TempStr,2,LEN(TempStr)-2)END IFCVTemp=VAL(TempStr)GOSUB NexTokenIF TokenLen=0 THEN SetFinishIF TokenBuf="<" THEN	GOSUB NexToken	IF TokenBuf<>"<" THEN		ErrNo=ErrIVExp		RETURN	END IF	TokenType=TTypMathEND IFIF TokenBuf=">>" THEN	TokenType=TTypMathEND IFIF TokenType<>TTypMath THEN	ErrNo=ErrIVExp	RETURNEND IFCVOp=TokenBufGOSUB NexTokenSELECT CASE TokenType	CASE TTypInt		GOSUB ChkInt		ErrRet		GOTO SetOperator	CASE TTypHex		GOSUB ChkHex		ErrRet		GOTO SetOperator	CASE TTypSym		GOSUB ChkSym		ErrRet		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO SetOperator	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTSetOperator:SymNdx=SymNdxSafSymTable(SymNdx).Detail=CVTempIF CVOp="+" THEN	CVTemp=SymTable(SymNdx).Detail+VAL(TokenSaf)END IFSELECT CASE CVOp	CASE "-"		CVTemp=SymTable(SymNdx).Detail-VAL(TokenSaf)	CASE "*"		CVTemp=SymTable(SymNdx).Detail*VAL(TokenSaf)	CASE "/"		CVTemp=SymTable(SymNdx).Detail/VAL(TokenSaf)	CASE "&"		CVTemp=LAND(SymTable(SymNdx).Detail,VAL(TokenSaf))	CASE "|"		CVTemp=LOR(SymTable(SymNdx).Detail,VAL(TokenSaf))END SELECTIF CVOp="<" OR CVOp=">>" THEN	CVTemp=SymTable(SymNdx).Detail	TempInt=VAL(TokenSaf);;if (CVOp[0] == '>') CVTemp=CVTemp>>TempInt;;;else CVTemp=CVTemp<<TempInt;END IFSetFinish:SymNdx=SymNdxSafSymTable(SymNdx).Detail=CVTempSymTable(SymNdx).DataMod=SetMaskOutBuf=SymTable(SymNdx).SymName+" equ "+STR(CVTemp)GOSUB OutCodeDataRETURNMACRODx:GOSUB NexTokenIF TokenType<>TTypSym THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=TRUE THEN	ErrNo=ErrDupSym;  symbol already defined	GOTO MainLoopEND IFSymTemp.DataType=MACROVARGOSUB ClrSymSymTemp.DataAddr=MacDefNdx;  address of macro in macro bufferGOSUB SymInsertErrMainMacLp:GOSUB ReadSourceIF TempInt=0 THEN	TempStr="FATAL ERROR.. EOF in MACRO"	ErrNo=$ff	GOTO MainLoopEND IFMacLpExit:GOSUB NexTokenSELECT CASE TokenBuf	CASE "macro"		ErrNo=ErrMacNst;  nested macro		GOTO MainLoop	CASE "endmacro"		MacBuf(MacDefNdx)=0		GOSUB MacDefInc		GOTO MainLoop	CASE "end"		GOSUB NexToken		IF TokenBuf="macro" THEN			MacBuf(MacDefNdx)=0			GOSUB MacDefInc			GOTO MainLoop		END IFEND SELECT	SrcNdx=0lbl7027:INCR SrcNdxIF SrcNdx>LEN(SrcLine) THEN	MacBuf(MacDefNdx)=NewLine	GOSUB MacDefInc	ErrMain	GOTO MacLpEND IFIF MID(SrcLine,SrcNdx,1)="~" THEN	INCR SrcNdx	TempByte=MID(SrcLine,SrcNdx,1)	AsciiByte=ASC(TempByte)	IF TempByte>="0" AND TempByte<="9" THEN		AsciiByte=LAND($0f,AsciiByte)		AsciiByte=LOR($80,AsciiByte)		MacBuf(MacDefNdx)=AsciiByte		GOSUB MacDefInc		ErrMain		GOTO lbl7027	END IF	AsciiByte=LAND(AsciiByte,$4f); make upper case	TempByte=CHR(AsciiByte)	IF TempByte>="A" AND TempByte<="F" THEN		AsciiByte=LAND($0f,AsciiByte)		AsciiByte=LOR($80,AsciiByte)		AsciiByte=AsciiByte+9		MacBuf(MacDefNdx)=AsciiByte		GOSUB MacDefInc		ErrMain		GOTO lbl7027	END IF	ErrNo=ErrIVMac	GOTO MainLoopEND IFTempByte=MID(SrcLine,SrcNdx,1)AsciiByte=ASC(TempByte)MacBuf(MacDefNdx)=AsciiByteGOSUB MacDefIncErrMainGOTO lbl7027ENDMDx:ErrNo=ErrEndmGOTO MainLoopIFDx:CondValid=GenFlag(GFNdx)INCR GFNdxIF GFNdx>20 THEN	TempStr="FATAL Error Conditional stack overflow"	ErrNo=$ff	GOTO MainLoopEND IFUMFlag=0GOSUB TokenSymErrMainIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).DataType<>COMPVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFCondOp1=SymTable(SymNdx).DetailEqualMainGOSUB NexTokenIF TokenBuf="-" THEN	UMFlag=$ff	GOSUB NexTokenEND IFSELECT CASE TokenType	CASE TTypInt		GOSUB ChkInt		ErrMain		GOTO IFDx1	CASE TTypHex		GOSUB ChkHex		ErrMain		GOTO IFDx1	CASE TTypSym		GOSUB TokenSym1		ErrMain		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO IFDx1	CASE ELSE		ErrNo=ErrIVExp		GOTO MainLoopEND SELECTIFDx1:IF UMFlag=$ff THEN	TempStr="-"ELSE	TempStr=""END IFTempStr=TempStr+TokenSafIF MID(TempStr,1,2)="--" THEN	TempStr=MID(TempStr,2,LEN(TempStr)-2)END IFCondOp2=VAL(TempStr)IF CondOp1=CondOp2 AND CondValid=$ff THEN	GenFlag(GFNdx)=$ffELSE	GenFlag(GFNdx)=0END IFGOTO MainLoopELSEDx:IF GFNdx<2 THEN	TempStr="FATAL ERROR Conditional stack error (#ELSE)"	ErrNo=$ff	GOTO MainLoopEND IFIF GenFlag(GFNdx-1)=$ff THEN	GenFlag(GFNdx)=LNOT(GenFlag(GFNdx))END IFGOTO MainLoopENDIFDx:DECR GFNdxIF GFNdx=0 THEN	TempStr="FATAL ERROR Conditional stack error (#END IF)"	ErrNo=$ff	GOTO MainLoopEND IFCondValid=GenFlag(GFNdx)GOTO MainLoopFIXDx:SetMask=$80GOSUB SETDx1GOTO MainLoopDataX:UseData=TRUEIF DataFlag=FALSE THEN	DataFlag=TRUE	IF LabelFlag=0 OR SymTable(SymNdx).DataMod<>DataBit THEN		TempStr="FATAL ERROR... DATA block with no label in line "';BasicLineCtr		ErrNo=$ff		GOTO MainLoop	END IF	LastStmt="data"; needed for first 'DATA' in block	GOSUB Remark	GOSUB OutInitData	OutBuf=SymbolSaf+":"	GOSUB OutInitDataEND IFNeedComma=0DATALoop:GOSUB NexTokenIF TokenLen=0 THEN	GOTO MainLoopEND IFIF NeedComma=0 AND TokenBuf="," THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFIF NeedComma=$ff AND TokenBuf="," THEN	NeedComma=0	GOTO DATALoopEND IFIF TokenType=TTypQuote THEN	TempStr=MID(TokenSaf,2,LEN(TokenSaf)-2)	GOTO NextDataEND IFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrMain		TempStr=TokenSaf	CASE TTypInt		GOSUB ChkInt		ErrMain		TempStr=TokenSaf	CASE TTypFloat		GOSUB ChkFlt		ErrMain		TempStr=TokenSaf	CASE TTypSym		IF TokenBuf="true" OR TokenBuf="false" THEN			IF TokenBuf="true" THEN				TempStr="1"			ELSE				TempStr="0"			END IF			GOTO NextData		END IF		GOSUB TokenSym1		ErrMain		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			GOTO MainLoop		END IF		Konstant=SymTable(SymNdx).Detail		TempStr=STR(Konstant)	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECTNextData:IF TempStr="" THEN	TempStr=CHR($80)END IFOutBuf="db "+CHR(OBQUOTE)+TempStr+CHR(OBQUOTE)+",0"GOSUB OutInitDataNeedComma=$ffGOTO DATALoopBEGIN SEG RestoreXGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR OR SymTable(SymNdx).DataMod<>DataBit THEN	ErrNo=ErrTypMis	EXIT SEGEND IFOutBuf="mov dword [_DataPtr],"+SymbolSafGOSUB OutCodeDataEND SEG MainLoopBEGIN SEG ReturnXIF FcnFlag=TRUE THEN	GOSUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	GOSUB UnDoToken	GOSUB Expr	ErrMain	SELECT CASE TFcnDataType		CASE BOOLVAR			IF TDataType<>BOOLVAR THEN				ErrNo=ErrTypMis				EXIT SEG			END IF			OutBuf="mov byte al,["+TSymName+"]"		CASE LONGVAR			IF TDataType<>LONGVAR THEN				ErrNo=ErrTypMis				EXIT SEG			END IF			IF TSymName<>"~" THEN				OutBuf="mov eax,["+TSymName+"]"				GOSUB OutFunction			END IF			OutBuf="mov [_LongRet],eax"					CASE STRINGVAR			IF TDataType<>STRINGVAR THEN				ErrNo=ErrTypMis				EXIT SEG			END IF			OutBuf="mov edi,["+TSymName+"]"			GOSUB OutFunction			OutBuf="mov [_StringRet],edi"			GOSUB OutFunction			OutBuf="mov edi,["+TSymName+"+4]"			GOSUB OutFunction			OutBuf="mov [_StringRet+4],edi"			GOSUB OutFunction			OutBuf="mov edi,["+TSymName+"+8]"			GOSUB OutFunction			OutBuf="mov [_StringRet+8],edi"		CASE FLOATVAR			IF TDataType<>FLOATVAR THEN				ErrNo=ErrTypMis				EXIT SEG			END IF	END SELECT	GOSUB OutFunctionEND IFOutBuf="ret"GOSUB OutCodeDataEND SEG MainLoop BEGIN SEG ExitXGOSUB NexTokenIF TokenLen<>0 THEN	SELECT CASE TokenBuf		CASE "event"			GOTO ExitEvent		CASE "proc"			GOTO ExitProc		CASE "task"			GOTO ExitTask		CASE "sub"			GOTO ExitSub		CASE "seg"			GOTO ExitSeg		CASE "if"			GOTO ExitIf		CASE ELSE			ErrNo=ErrSyntax			EXIT SEG	END SELECTELSE	IF ConStkPtr<1 THEN		ErrNo=ErrUBCon		ErrMain	END IF	OutBuf="jmp _Lbl"+STR(ConStk(ConStkPtr).TermLabel)	GOSUB OutCodeDataEND IFEND SEG MainLoopBEGIN SEG ExitEventIF EventFlag=FALSE THEN	ErrNo=ErrExitEvent	EXIT SEGEND IFOutBuf="ret"GOSUB OutCodeDataEND SEG MainLoopBEGIN SEG ExitProcIF ProcFlag=FALSE THEN	ErrNo=ErrExitProc	EXIT SEGEND IFOutBuf="ret"GOSUB OutCodeDataEND SEG MainLoopBEGIN SEG ExitTaskIF TaskFlag=FALSE THEN	ErrNo=ErrExitTask	EXIT SEGEND IFOutBuf="pop esp"GOSUB OutCodeDataOutBuf="return"GOSUB OutCodeDataEND SEG MainLoopBEGIN SEG ExitSubIF SubFlag=FALSE THEN	ErrNo=ErrExitSub	EXIT SEGEND IFOutBuf="ret"GOSUB OutCodeDataEND SEG MainLoopBEGIN SEG EndSubIF SubFlag=FALSE THEN	ErrNo=ErrEndSub	EXIT SEGEND IFOutBuf="ret"GOSUB OutCodeDataGOSUB MakeLineGOSUB OutCodeDataSubFlag=FALSEProcFcnFlag=FALSEEND SEG MainLoopBEGIN SEG BeginSubGOSUB FcnFlagChkErrMainSubFlag=TRUEProcFcnFlag=TRUEGOSUB ProcLabelErrMainSymbolSaf=SymbolSaf+":"GOSUB OutLabelEND SEG MainLoopBEGIN SEG SeekXDiskIO=$ffGOSUB GetFileHandleErrMainIF TSubType=DEVICE THEN	ErrNo=ErrDevice	GOTO MainLoopEND IFGOSUB ExprErrMainIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	EXIT SEGEND IFGOSUB LoadNumericValueImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],eax,0,FILE_BEGIN"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrEND SEG MainLoopBEGIN SEG TypeXIF ProcFcnFlag=TRUE THEN	ErrNo=ErrTypeFcn	EXIT SEGEND IFGOSUB ClrDatTypGOSUB TokenSymErrMainIF SymFound=TRUE THEN	ErrNo=ErrDupSym	EXIT SEGEND IFTypeFlag=$ffTypePtr=SymNdxTypeVars=0TypeBytes=0SymTemp.DataType=TYPEGOSUB ClrSymGOSUB SymInsertErrMainTypeLp:GOSUB ReadSourceIF TempInt=0 THEN	ErrNo=$ff	EXIT SEGEND IFTypeLp2:GOSUB NexTokenIF TokenBuf="end" THEN	GOSUB NexToken	IF TokenBuf="type" THEN TypeEnd	ErrNo=ErrSyntax	EXIT SEGEND IFGOSUB UnDoToken		IF LEFT(SrcLine,1)="*" THEN TypeLpGOSUB DimVarIF DimOK=0 THEN MainLoopINCR TypeVarsSymTemp.DataAddr=TypeBytesGOSUB SymInsertErrMain TypeBytes=TypeBytes+SymTemp.DataSizeIF MultiFlag=$ff THEN	;GOSUB AddMultiEND IFGOTO TypeLpTypeEnd:SymTable(TypePtr).DataSize=TypeBytesSymTable(TypePtr).Detail=TypeVarsEND SEG MainLoopBEGIN SEG DimXGOSUB DimVarIF DimOK=0 THEN MainLoopGOSUB SymInsertErrMainIF TDataType<>TEXT AND TDataType<>TIMER THEN	GOSUB DecVarELSE	GOSUB OutCodeDataEND IFIF MultiFlag=$ff THEN	;GOSUB AddMultiEND IFEND SEG MainLoopBEGIN SEG LetXTarget=$ffGOSUB GetExpErrMainIF TextFlag<>0 THEN	IF LAND(SymTemp.DataMod,TextDefinedBit)<>0 THEN		ErrNo=ErrTextDefined		EXIT SEG	END IF	SymTable(SymNdx).DataMod=TextDefinedBit	EqualMain	TempInt=SrcNdx+1	BEGIN LOOP		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		IF TokenSaf="," THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		GOSUB NexToken		IF TokenLen=0 THEN			GOTO TextDone		ELSE			IF TokenSaf<>"," THEN				ErrNo=ErrSyntax				EXIT SEG			END IF		END IF	END LOOP	TextDone:	OutBuf=SymTemp.SymName+" db "+TAIL(SrcLine,TempInt)	GOSUB OutInitData	EXIT SEGEND IFGOSUB ProcExpErrMainGOSUB ClassOpErrMainIF DMConst<>0 THEN	GOSUB NexToken	SrcNdx=2	IF TokenBuf="equ" THEN		ErrNo=ErrDupSym			ELSE		ErrNo=ErrIVTarg	END IF	EXIT SEGEND IFOp1Name=TSymNameOp1Mod=TDataModOp1Detail=TDetailOp1DataSize=TDataSizeOp1Type=TDataTypeOp1Class=OpClassSELECT CASE Op1Type	CASE 1		OpSizeStr=" byte "	CASE 2		OpSizeStr=" byte "	CASE 3		OpSizeStr=" word "	CASE 4		OpSizeStr=" dword "	CASE ELSE		OpSizeStr=" "END SELECTIF Op1Name="NextArg" THEN	ErrNo=ErrIVTarg	EXIT SEGEND IFIF LAND(TempBit,Op1Mod)<>0 AND LAND(VectorBit,Op1Mod)=0 THEN	ErrNo=ErrIVTarg	EXIT SEGEND IF GOSUB NexTokenIF TokenBuf<>"=" THEN	ErrNo=ErrSyntax	EXIT SEGEND IFIF Op1Mod=VectorBit AND Op1Type=STRINGVAR AND NextByte=CHR($22) THEN	GOSUB NexToken	IF RIGHT(TokenSaf,1)<>CHR(OBQUOTE) THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	IF LEN(TokenBuf)=2 THEN		OutBuf="mov ["+Op1Name+"+12],0"		GOSUB OutCode		EXIT SEG	ELSE		IF NextByte<>"+" AND Op1Detail>LEN(TokenSaf) THEN			ediUsed=TRUE			OutBuf="mov edi,["+Op1Name+"]"			GOSUB OutCode			GOSUB MakeStrConst			OutBuf="mov esi,_StrConst"+STR(PoolCtr)			GOSUB OutCode			UseSetStrConst=TRUE			OutBuf="call __SetStrConst"			GOSUB OutCode			EXIT SEG		END IF	END IF	GOSUB UnDoTokenEND IFIF Op1Type=LABELPTR THEN	GOSUB NexToken	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		;print "make label here",SrcLine	ELSE 		IF  SymTable(SymNdx).DataType<>LABELVAR AND SymTable(SymNdx).DataType<>LABELPTR THEN			ErrNo=ErrTypMis			EXIT SEG		END IF		END IF	IF LAND(VectorBit,Op1Mod)=0 THEN		OutBuf="mov dword ["+Op1Name+"],"+SymTemp.SymName	ELSE		OutBuf="mov dword esi,["+Op1Name+"]"		GOSUB OutCode		OutBuf="mov dword [esi], dword "+SymTemp.SymName	END IF	GOSUB OutCode	GOTO MainLoopEND IFGOSUB GetExpErrMainTarget=0GOSUB ProcOp2GOSUB NexTokenIF TokenLen<>0 THEN; check for junk on end	ErrNo=ErrSyntax	EXIT SEGEND IFIF Op2Name="NextArg" THEN	GOSUB ProcCmd	EXIT SEGEND IFIF Op1Class<>Op2Class THEN;  int=float for example	EXIT IF Op1Class=INTClass AND Op2Class=FLTClass	EXIT IF Op1Class=FLTClass AND Op2Class=INTClass	ErrNo=ErrTypMis	EXIT SEGEND IFIF Op1Class=INTClass OR Op1Class=FLTClass OR Op1Class=BOOLClass THEN	IF TSymName<>"~" THEN		TDataType=Op1Type		GOSUB GetDtaTyp		IF Op1Mod=0 AND Op2Mod=ConstBit THEN			Op2Name=STR(Op2Detail)			IF Op1Type=BOOLVAR OR Op1Type=BYTEVAR THEN				IF Op2Detail>255 THEN					ErrNo=ErrOpRange					EXIT SEG				END IF			END IF			IF Op1Type=WORDVAR THEN				IF Op2Detail>65535 THEN					ErrNo=ErrOpRange					EXIT SEG				END IF			END IF			IF Op1Type=LONGVAR THEN				IF Op2Detail>$7fffffff THEN					ErrNo=ErrOpRange					EXIT SEG				END IF			END IF			OutBuf="mov"+OpSizeStr+"["+Op1Name+"],"+Op2Name			GOSUB OutCodeData			EXIT SEG		END IF		IF Op1Mod=0 AND Op2Mod=0 THEN			IF Op1Type>Op2Type AND Op2Type<>BOOLVAR THEN				OutBuf="xor eax,eax"				GOSUB OutCodeData			END IF 			IF Op2Type=BOOLVAR OR Op2Type=BYTEVAR THEN				OutBuf="mov al, byte ["+Op2Name+"]"							GOSUB OutCodeData				GOSUB StoreInt				EXIT SEG			END IF			IF Op2Type=WORDVAR THEN				OutBuf="mov ax, word ["+Op2Name+"]"							GOSUB OutCodeData				GOSUB StoreInt				EXIT SEG			END IF			IF Op2Type=LONGVAR THEN				OutBuf="mov eax, dword ["+Op2Name+"]"							GOSUB OutCodeData				GOSUB StoreInt				EXIT SEG			END IF		END IF		D0Loaded=0		GOSUB LoadReg		ErrMain	END IF	GOSUB StoreD0	EXIT SEGEND IFIF Op1Class=STRClass THEN	ediUsed=TRUE	OutBuf="mov edi,"+Op1Name	GOSUB OutCodeData	OutBuf="mov esi,"+Op2Name	GOSUB OutCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	GOSUB OutCodeData	EXIT SEGEND IFIF Op1Class=CPXClass OR Op1Class=ARRClass THEN	ediUsed=TRUE	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov edi,"+Op1Name	ELSE		OutBuf="mov edi,["+Op1Name+"]"	END IF	GOSUB OutCodeData	IF LAND(Op2Mod,VectorBit)=0 THEN		OutBuf="mov esi,"+Op2Name	ELSE		OutBuf="mov esi,["+Op2Name+"]; Get src addr"	END IF	GOSUB OutCodeData	IF Op1Class=ARRClass THEN		TempInt=Op1DataSize	ELSE		TempInt=SymTable(Op1Detail).DataSize	END IF	OutBuf="mov ecx,"+STR(TempInt)		GOSUB OutCodeData	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	GOSUB OutCodeData	OutBuf="mov al,byte [esi]"	GOSUB OutCodeData	OutBuf="mov byte [edi],al"	GOSUB OutCodeData	OutBuf="inc esi"	GOSUB OutCodeData	OutBuf="inc edi"	GOSUB OutCodeData	OutBuf="dec ecx"	GOSUB OutCodeData	OutBuf="jne "+"_Lbl"+STR(LabelNum)	GOSUB OutCodeData	EXIT SEGEND IFSELECT CASE Op1Class	CASE BOOLClass		D0Loaded=0		GOSUB LoadReg		ErrMain		GOSUB StoreD0		EXIT SEG	CASE OBJClass		ErrNo=ErrIVType		EXIT SEG	CASE FRMClass		ErrNo=ErrIVType		GOTO MainLoop	CASE ELSE 		TempStr="Internal Error"		GOSUB ShowError		EXIT SEGEND SELECTEND SEG MainLoopBEGIN SUB ProcOp2IF GUIObjFlag<>0 THEN;//	GOSUB UnDoToken;//	GUITargetFlag=0;//	GOSUB ValidateObject;//	ErrRet;//	GOSUB GUISource	Op2Name=GUITempName	Op2Type=GUIDataType	SELECT CASE Op2Type		CASE BOOLVAR			Op2Class=BOOLClass		CASE LONGVAR			Op2Class=INTClass		CASE STRINGVAR			Op2Class=STRClass	END SELECT	OpClass=Op2Class	TSymName=Op2Name	TDataType=Op2Type	Op2Mod=0	TDataMod=0	Op2Detail=0	TDetail=0	SymTemp.SymName="~"ELSE	GOSUB ProcExp	ErrRet	GOSUB ClassOp	Op2Name=TSymName	Op2Class=OpClass	Op2Type=TDataType	Op2Mod=TDataMod	Op2Detail=TDetailEND IFEND SUBBEGIN SUB StoreIntIF Op1Type=BOOLVAR OR Op1Type=BYTEVAR THEN	OutBuf="mov ["+Op1Name+"],al"END IFIF Op1Type=WORDVAR THEN	OutBuf="mov ["+Op1Name+"],ax"END IFIF Op1Type=LONGVAR THEN	OutBuf="mov ["+Op1Name+"],eax"END IFGOSUB OutCodeDataEND SUBProcDataLabel:SrcNdx=0GOSUB PrepVarErrRetIF SymFound=TRUE THEN	ErrNo=ErrDupSym	RETURNEND IFRETURNEquX:GOSUB ProcDataLabelErrMainSymTemp.DataType=COMPVARSymTemp.DataMod=SetMaskGOSUB SymInsertGOSUB NexTokenEquX1:OutBuf=SymTemp.SymName+" equ "DMArray=0ArraySize=0DimFlag=0GOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrMain		TempStr=TokenSaf		TempInt=VAL(TempStr)	CASE TTypInt		GOSUB ChkInt		ErrMain		TempStr=TokenSaf		TempInt=VAL(TempStr)	CASE TTypSym		GOSUB TokenSym1		ErrMain		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			RETURN		END IF		TempInt=SymTable(SymNdx).Detail		TempStr=STR(TempInt)	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECTSymTable(DataSymNdx).Detail=TempIntOutBuf=OutBuf+TempStrGOSUB OutUninitDataGOTO MainLoopDefineData:DMArray=0ArraySize=0DimFlag=0NeedComma=0DefineDataLoop:GOSUB NexTokenIF TokenLen=0 THEN	RETURNEND IFIF NeedComma=0 AND TokenBuf="," THEN	ErrNo=ErrSyntax	RETURNEND IFIF NeedComma=$ff AND TokenBuf="," THEN	NeedComma=0	TempStr=", "	DMArray=$ff	GOTO DefineNextDataEND IFIF TokenType=TTypQuote THEN	IF SymTemp.DataAddr<>1 THEN		ErrNo=ErrSyntax		RETURN	END IF	ArraySize=ArraySize+LEN(TokenSaf)-3	TempStr="'"+MID(TokenSaf,2,LEN(TokenSaf)-2)+"'"	GOTO DefineNextDataEND IFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrRet		TempStr=TokenSaf	CASE TTypInt		GOSUB ChkInt		ErrRet		TempStr=TokenSaf	CASE TTypFloat		GOSUB ChkFlt		ErrRet		TempStr=TokenSaf	CASE TTypSym		GOSUB TokenSym1		ErrRet		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			RETURN		END IF		Konstant=SymTable(SymNdx).Detail		TempStr=STR(Konstant)	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTDefineNextData:IF NeedComma=0 THEN	INCR ArraySizeEND IFNeedComma=$ffOutBuf=OutBuf+TempStrGOTO DefineDataLoopRETURNForX:GOSUB TokenSymErrMainIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFForDataType=SymTable(SymNdx).DataTypeGOSUB IncConStkErrMainConStk(ConStkPtr).LoopName=SymTemp.SymNameGOSUB GetSymTempGOSUB ClassOp1IF OpClass<>INTClass OR DMVector<>0 OR DMArray<>0 THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFGOSUB GetLopVecErrMainConStk(ConStkPtr).LoopVec=LopVarNdxConStk(ConStkPtr).ConType=5ConStk(ConStkPtr).ConLine=BasicLineCtrEqualMainGOSUB ExprErrMainIF TSymName="~" THEN	TSymName="eax"END IF; set initial value into loop varIF DMConst<>0 THEN	GOSUB ChkForIMM	ErrMain	OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],"+TSymNameELSE	IF DMVector<>0 THEN		ediUsed=TRUE		OutBuf="mov edi,["+TSymName+"]"		GOSUB OutCodeData		OutBuf="mov eax,[edi]"		GOSUB OutCodeData	ELSE		OutBuf="mov eax,["+TSymName+"]"		GOSUB OutCodeData	END IF	OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],eax"END IFGOSUB OutCodeDataGOSUB NexTokenIF TokenBuf<>"to" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB ExprErrMainIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFIF TSymName<>"~" AND DMConst<>0 THEN	GOSUB ChkForIMM	ErrMain	ConStk(ConStkPtr).ImmTo=$ff	ConStk(ConStkPtr).ImmToVal=TSymNameELSE	ConStk(ConStkPtr).ImmTo=0END IFIF ConStk(ConStkPtr).ImmTo=0 THEN	IF DMVector<>0 THEN		ediUsed=TRUE		OutBuf="mov edi,["+TSymName+"]"		GOSUB OutCodeData		OutBuf="mov eax,[edi]"		GOSUB OutCodeData	ELSE		IF TSymName<>"~" THEN			OutBuf="mov eax,["+TempStr+"]"			GOSUB OutCodeData		END IF	END IF	OutBuf="mov [_LopVec"+STR(LopVarNdx)+"],eax"	GOSUB OutCodeDataEND IFGOSUB NexTokenIF TokenLen=0 THEN	ConStk(ConStkPtr).NoStep=$ffELSE	IF TokenBuf<>"step" THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	ConStk(ConStkPtr).NoStep=0	GOSUB Expr	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		GOTO MainLoop	END IF	ErrMain	ConStk(ConStkPtr).NegImmStep=0	IF TSymName<>"~" AND DMConst<>0 THEN		GOSUB ChkForIMM		ErrMain		ConStk(ConStkPtr).ImmStep=$ff		ConStk(ConStkPtr).ImmStepVal=TSymName		IF LEN(TSymName)=10 THEN;???			IF Mid(TSymName,3,1)>"7" THEN;???				ConStk(ConStkPtr).NegImmStep=$ff			END IF		END IF	ELSE		ConStk(ConStkPtr).ImmStep=0		IF TSymName="~" THEN			TSymName="eax"		END IF		IF DMVector<>0 THEN			ediUsed=TRUE			OutBuf="mov edi,["+TSymName+"]"			GOSUB OutCodeData			OutBuf="mov eax,[edi]"			GOSUB OutCodeData		ELSE			OutBuf="mov eax,["+TSymName+"]"			GOSUB OutCodeData		END IF		OutBuf="mov [_LopVec"+Str(LopVarNdx)+"+4],eax"		GOSUB OutCodeData	END IFEND IFINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataConStk(ConStkPtr).LoopLabel=LabelNumINCR LabelNumConStk(ConStkPtr).ContLabel=LabelNumINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNum; compare loopvar to "to" valueIF ConStk(ConStkPtr).ImmStep=$ff AND ConStk(ConStkPtr).NegImmStep=0 OR ConStk(ConStkPtr).NoStep=$ff THEN	SymTemp.SymName=ConStk(ConStkPtr).LoopName	IF ForDataType<LONGVAR THEN		OutBuf="xor eax,eax"		GOSUB OutCodeData	END IF		IF ConStk(ConStkPtr).ImmTo=$ff THEN		OutBuf="cmp ["+ConStk(ConStkPtr).LoopName+"],"+ConStk(ConStkPtr).ImmToVal		GOSUB OutCodeData	ELSE		OutBuf="mov eax,["+ConStk(ConStkPtr).LoopName+"]"		GOSUB OutCodeData		OutBuf="cmp eax,[_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"]"		GOSUB OutCodeData	END IF	If ForDataType=LONGVAR THEN		OutBuf="jg "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	ELSE		OutBuf="ja "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	END IF	GOSUB OutCodeDataEND IFIF ConStk(ConStkPtr).ImmStep=$ff AND ConStk(ConStkPtr).NegImmStep=$ff THEN	IF ConStk(ConStkPtr).ImmTo=$ff THEN		OutBuf=";if ("+ConStk(ConStkPtr).LoopName+"<"+ConStk(ConStkPtr).ImmToVal+") goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	ELSE		OutBuf=";if ("+ConStk(ConStkPtr).LoopName+"<_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Limit) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	END IFEND IFIF ConStk(ConStkPtr).ImmStep=0 AND ConStk(ConStkPtr).NoStep=0 THEN	IF ConStk(ConStkPtr).ImmTo=0 THEN		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step>=0) && ("+ConStk(ConStkPtr).LoopName+">_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Limit)) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step<0) && ("+ConStk(ConStkPtr).LoopName+"<_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Limit)) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	ELSE		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step>=0) && ("+ConStk(ConStkPtr).LoopName+">"+ConStk(ConStkPtr).ImmToVal+")) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step<0) && ("+ConStk(ConStkPtr).LoopName+"<"+ConStk(ConStkPtr).ImmToVal+")) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	END IFEND IFGOTO MainLoopIfX:GOSUB CmpOps ErrMainINCR LabelNumIF TokenBuf<>"then" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB NexTokenIF TokenLen=0 THEN StructIFGOSUB UnDoTokenGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFIF SimpleCmp=0 THEN	OutBuf="jne "+SymTemp.SymNameELSE	OutBuf=SimpleOp+SymTemp.SymNameEND IFGOSUB OutCodeDataGOTO MainLoopStructIF:GOSUB IncConStkErrMainConStk(ConStkPtr).TermLabel=LabelNumConStk(ConStkPtr).ConType=0ConStk(ConStkPtr).ConLine=BasicLineCtrIF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(LabelNum)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)END IFGOSUB OutCodeData GOTO MainLoopGotoX:ToSub="jmp "GotoX1:LNFlag=$ffGOSUB NexTokenIF TokenBuf="[" THEN	GOSUB RightBracket	ErrMain	GOSUB Expr	IF TDataType<>LABELPTR THEN		ErrNo=ErrTypMis		GOTO MainLoop	END IF	IF DMVector<>0 THEN		OutBuf="mov esi,["+TSymName+"]"		GOSUB OutCode		OutBuf=ToSub+"dword [esi]"			ELSE		OutBuf=ToSub+"["+TSymName+"]"	END IF	GOSUB OutCode	IF EndSegFlag=TRUE THEN		GOSUB MakeLine		GOSUB OutCodeData	END IF	GOTO MainLoopEND IFGOSUB UnDoTokenGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFOutBuf=ToSub+SymbolSafGOSUB OutCodeDataIF EndSegFlag=TRUE THEN	GOSUB MakeLine	GOSUB OutCodeDataEND IFGOTO MainLoopGosubX:ToSub="call "GOTO GotoX1OnX:LNFlag=$ffNeedComma=$00JmpArgs=0GOSUB NexTokenIF TokenBuf="error" THEN ON_ERRORGOSUB UnDoTokenINCR LabelNumINCR TableNumOutBuf="align 4"GOSUB OutInitDataOutBuf="_Table"+STR(TableNum)+":"GOSUB OutInitDataGOSUB GetIntOp; get test integerErrMainGOSUB NexTokenIF TokenBuf="goto" OR TokenBuf="gosub" THEN	IF TokenBuf="goto" THEN		ToSubFlag=0	ELSE		ToSubFlag=$ff	END IFELSE	ErrNo=ErrSyntax	GOTO MainLoopEND IFChkArgs:GOSUB NexTokenIF TokenLen=0 THEN MakSwitchIF TokenBuf="," AND NeedComma=$ff THEN	NeedComma=0	GOTO ChkArgsEND IFIF TokenBuf="," AND NeedComma=0 THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFIF TokenBuf<>"," AND NeedComma=$ff THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB UnDoTokenGOSUB ChkLabelErrMainTempInt=SymTable(SymNdx).DetailTDataType=SymTable(SymNdx).DataTypeIF TDataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFOutBuf="dd "+SymTable(SymNdx).SymNameGOSUB OutInitDataINCR JmpArgsNeedComma=$ffGOTO ChkArgsMakSwitch:IF JmpArgs<1 THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFCtr1=0OutBuf="cmp eax,1"GOSUB OutCodeDataOutBuf="jl "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="cmp eax,"+STR(JmpArgs)GOSUB OutCodeDataOutBuf="jg "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="dec eax"GOSUB OutCodeDataOutBuf="shl eax,2"GOSUB OutCodeDataOutBuf="add eax,_Table"+STR(TableNum)GOSUB OutCodeDataOutBuf="mov eax,[eax]"GOSUB OutCodeDataIF ToSubFlag=0 THEN	OutBuf="jmp dword eax"ELSE	OutBuf="call dword eax"END IFGOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOTO MainLoopON_ERROR:GOSUB NexTokenIF TokenLen=0 THEN; Turn off ON ERROR	OutBuf="mov [_ErrVec],_ErrExit"	GOSUB OutCode	GOTO MainLoopEND IFIF TokenBuf<>"goto" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFOutBuf="mov [_ErrVec],"+SymTemp.SymNameGOSUB OutCodeGOTO MainLoopPrintX:UseStrLen=TRUEGOSUB DevChkPrintFlag=$ffIF DevFlag=$ff THEN	PrintPathFlag=$ff	GOSUB GetFileHandle	ErrMain	PrintPathFlag=0END IFGOSUB NexTokenIF TokenBuf="using" THEN PrtUsingGOSUB UnDoTokenPrintLp:GOSUB NexTokenIF TokenLen=0 THEN PrintExGOSUB UnDoTokenGOSUB ExprErrMainIF TDataType=VOIDX THEN PrtArgSepIF TabFlag=$ff THEN	TabFlag=0	GOTO PrtArgSepEND IFIF TDataType<>STRINGVAR OR DMAddr<>0 THEN	GOSUB MakString	ErrMainEND IFGOSUB ClassOpOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataediUsed=TRUEOutBuf="mov edi,_PrintBuf"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataOutBuf="mov esi,_PrintBuf"GOSUB OutCodeDataOutBuf="call __StrLen"GOSUB OutCodeDataOutBuf="mov edx,eax"GOSUB OutCodeDataOutBuf="add edx,[POS]"GOSUB OutCodeDataOutBuf="mov [POS],edx"GOSUB OutCodeDataImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUEOutBuf="invoke WriteConsole,[_OutHandle],[_PrintBuf],eax,XferCount,NULL"GOSUB OutCodeDataGOSUB CallErrZPrtArgSep:GOSUB NexTokenIF FileIO<>0 THEN	GOSUB OutCRLF	IF TokenBuf="," OR TokenBuf=";" THEN		IF NextByte<>"" THEN PrintLp	END IF	GOTO PrintExEND IFIF TokenBuf="," THEN	OutBuf="xor eax,eax"	GOSUB OutCodeData	OutBuf="";call __PrintTab	GOSUB OutCodeData	GOSUB CallErr	IF NextByte="" THEN PrintEx	GOTO PrintLpEND IFIF TokenBuf=";" THEN	IF NextByte="" THEN PrintEx	GOTO PrintLpEND IFPrintEx:IF TokenBuf<>"," AND TokenBuf<>";" THEN	ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE	OutBuf="invoke WriteConsole,[_OutHandle],[_CRLF],2,XferCount,NULL"	GOSUB OutCodeData	OutBuf="mov [POS],0"	GOSUB OutCodeDataEND IFGOTO MainLoopPrtUsing:GOSUB UnDoTokenGOSUB ExprGOTO MainLoopInputX:GOSUB DevChkIF DevFlag=$ff THEN	GOSUB GetFileHandle	ErrMainEND IFIF FileIO=0 THEN	GOSUB NexToken	GOSUB UnDoToken	IF TokenType=TTypQuote THEN		GOSUB Expr		ErrMain		ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE		OutBuf="invoke WriteConsole,[_OutHandle],["+TSymName+"],["+TSymName+"+4],XferCount,NULL"		GOSUB OutCodeData		CommaMain	ELSE		ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE		OutBuf="invoke WriteConsole,[_OutHandle],[_Prompt],1,XferCount,NULL"		GOSUB OutCodeData	END IF	GOSUB CallErrZEND IFTarget=$ffBEGIN LOOP	GOSUB Expr	ErrMain	IF DMVector=0 THEN		GOSUB Vectorize		ErrMain		GOSUB ClassOp	END IF	IF DMVector<>0 AND DMTemp=0 THEN		GOSUB SetTmpVec		ErrMain	END IF	OutBuf="mov esi,"+TSymName	GOSUB OutCodeData	OutBuf="mov [_ArgSafe0],esi"	GOSUB OutCodeData	OutBuf="mov [_ArgSafe1],"+STR(TDataType)	GOSUB OutCodeData	UseInpData=TRUE	OutBuf="call __InpData"	GOSUB OutCodeData	GOSUB CallErrZ	GOSUB NexToken	EXIT IF TokenBuf<>","END LOOPIF FileIO=0 AND NewLine=$0d THEN	GOSUB OutCRLFEND IFGOTO MainLoopReadX:NeedComma=0GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).SubType=FILE OR SymTable(SymNdx).SubType=DEVICE THEN FileReadGOSUB GetSymTempGOSUB UnDoTokenTarget=$ffReadFlag=$ffBEGIN LOOP	IF NeedComma=$ff THEN		GOSUB NexToken		IF TokenLen=0 THEN MainLoop		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			GOTO MainLoop		ELSE			NeedComma=0		END IF	END IF	GOSUB GetExp	ErrMain	IF TokenLen=0 THEN MainLoop	GOSUB ProcExp	ErrMain	GOSUB ClassOp	GOSUB GetBase	IF TDataType=COMPVAR OR TDataType>6 THEN		ErrNo=ErrTypMis		GOTO MainLoop	END IF	IF DMAddr<>0 THEN		TDataType=LONGVAR	END IF	SELECT CASE TDataType		CASE BOOLVAR			OutBuf="call __ReadBool"		CASE BYTEVAR			OutBuf="call __ReadByte";		CASE WORDVAR			OutBuf="call __ReadShort"		CASE LONGVAR			OutBuf="call __ReadLong"		CASE FLOATVAR			OutBuf="call __ReadFlt"		CASE STRINGVAR			OutBuf="mov eax,"+STR(TDetail)			GOSUB OutCodeData			OutBuf="call __ReadStr"	END SELECT	GOSUB OutCodeData	NeedComma=$ffEND LOOPFileRead:UseReadFile=TRUEGOSUB UnDoTokenGOSUB ReadWriteErrMainOutBuf="call __ReadFile"GOSUB OutCodeDataGOTO MainLoopBeginResource:IF ResourceFlag=TRUE THEN	TempStr="Already have resource section"	ErrNo=$ff	GOTO MainLoopEND IFResourceFlag=TRUEOutBuf=""GOSUB OutResourceOutBuf="section '.rsrc' resource data readable"GOSUB OutResourceOutBuf=""GOSUB OutResourceBEGIN LOOP	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in RESOURCE"		ErrNo=$ff		GOTO MainLoop	END IF	GOSUB NexToken	IF TokenBuf="end" THEN		GOSUB NexToken		IF TokenBuf="resource" THEN			OutBuf=""			GOSUB OutResource			OutBuf="; End of Resource Section"			GOSUB OutResource			GOSUB MakeLine			GOSUB OutResource			GOTO MainLoop		ELSE			GOSUB UnDoToken		END IF	END IF	OutBuf=SrcLine	GOSUB OutResourceEND LOOPEndResource:TempStr="END RESOURCE while not in resource"ErrNo=$ffGOTO MainLoopBeginExport:IF ExportFlag=TRUE THEN	TempStr="Already have export section"	ErrNo=$ff	GOTO MainLoopEND IFExportFlag=TRUEOutBuf=""GOSUB OutExportOutBuf="section '.edata' export data readable"GOSUB OutExportOutBuf=""GOSUB OutExportBEGIN LOOP	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in EXPORT"		ErrNo=$ff		GOTO MainLoop	END IF	GOSUB NexToken	IF TokenBuf="end" THEN		GOSUB NexToken		IF TokenBuf="export" THEN			OutBuf=""			GOSUB OutExport			OutBuf="; End of Export Section"			GOSUB OutExport			GOSUB MakeLine			GOSUB OutExport			GOTO MainLoop		ELSE			GOSUB UnDoToken		END IF	END IF	OutBuf=SrcLine	GOSUB OutExportEND LOOPEndExport:TempStr="END EXPORT while not in export"ErrNo=$ffGOTO MainLoopWriteX:UseWriteFile=TRUEGOSUB ReadWriteErrMainOutBuf="call __WriteFile"GOSUB OutCodeDataGOTO MainLoopGetX:GOSUB GetPutErrMainGOSUB OutReadGOTO MainLoopPutX:GOSUB GetPutErrMainGOSUB OutWriteGOTO MainLoopEndX:GOSUB NexTokenIF TokenLen<>0 THEN	LastStmt=LastStmt+TokenBuf; prevents bug involving false 'end'	SELECT CASE TokenBuf		CASE "if"			GOTO EndIf		CASE "loop"			GOTO EndLoop		CASE "while"			GOTO EndWhile		CASE "select"			GOTO EndSelect		CASE "fcn"			GOTO EndFcn		CASE "proc"			GOTO EndProc		CASE "task"			GOTO EndTask		CASE "sub"			GOTO EndSub		CASE "seg"			GOTO EndSeg		CASE "table"			GOTO EndTable		CASE "text"			GOTO EndTextX		CASE "type"			GOTO EndType		CASE "event"			GOTO EndEvent		CASE "menu"			GOTO EndMenu		CASE "enum"			GOTO EndEnum		CASE "enum"			GOTO EndResource		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECTEND IFIF GUIFlag=FALSE THEN	OutBuf="xor eax,eax"	GOSUB OutCodeData	ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE	OutBuf="invoke ExitProcess, eax"	GOSUB OutCodeDataELSE	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	OutBuf="invoke DeleteObject,[!Brush]"	GOSUB OutCodeData	ImportFcnTable(ptrPostMessage).ImportFcnUse=TRUE	OutBuf="invoke PostMessage,[!OBMain],WM_CLOSE,0,0"	GOSUB OutCodeDataEND IFGOTO MainLoopOpenX:Target=0GOSUB GetFileNameErrMainGOSUB NexTokenIF TokenBuf<>"for" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB NexTokenSELECT CASE TokenBuf	CASE "input"		FcnName="GENERIC_READ"		OpenMode=0	CASE "output"		FcnName="GENERIC_WRITE"		OpenMode=1	CASE "scratch"		FcnName="GENERIC_WRITE"		OpenMode=2	CASE "append"		FcnName="GENERIC_WRITE"		OpenMode=3	CASE "update"		FcnName="GENERIC_READ+GENERIC_WRITE"		OpenMode=4	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECT	GOSUB NexTokenIF TokenBuf<>"as" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB GetExpErrMainIF SymTable(SymNdx).DataType<>LONGVAR THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFGOSUB ProcExpErrMainGOSUB ClassOpIF TSubType=FILE THEN	ArgStr="OPEN_ALWAYS"ELSE	IF TSubType=DEVICE THEN		ArgStr="OPEN_EXISTING"		IF OpenMode=2 OR OpenMode=3 THEN			ErrNo=ErrDevice			GOTO MainLoop		END IF	ELSE		ErrNo=ErrIVType		GOTO MainLoop	END IFEND IFIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopEND IFIF DMVector=0 THEN	PathIsVector=0	PathVar=TSymNameELSE	PathIsVector=$ff	PathVar=TSymNameEND IFImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,[_IOBuffer],"+FcnName+",FILE_SHARE_READ+FILE_SHARE_WRITE,0,"+ArgStr+",FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataGOSUB SetStatusIF PathIsVector=0 THEN	OutBuf="mov ["+PathVar+"],eax"ELSE	OutBuf="mov edi,["+PathVar+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"END IFGOSUB OutCodeDataGOSUB CallErrIF OpenMode=2 THEN	ImportFcnTable(ptrSetEndOfFile).ImportFcnUse=TRUE	OutBuf="invoke SetEndOfFile,eax"	GOSUB OutCodeDataELSE	IF OpenMode=3 THEN		ImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUE		OutBuf="invoke SetFilePointer,eax,0,0,FILE_END"		GOSUB OutCodeData	END IFEND IFGOTO MainLoopCloseX:DiskIO=$ffCloseLp:GOSUB GetFileHandleErrMainImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUEOutBuf="invoke CloseHandle,[_IOPthNum]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOSUB NexTokenIF TokenLen=0 THEN MainLoopIF TokenBuf<>"," THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOTO CloseLpWhileX:INCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOSUB CmpOpsErrMainIF TokenBuf<>"do" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB IncConStkErrMainConStk(ConStkPtr).LoopLabel=LabelNumConStk(ConStkPtr).ContLabel=LabelNum; For consistancy with CONTINUE statementINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumConStk(ConStkPtr).ConType=1ConStk(ConStkPtr).ConLine=BasicLineCtrIF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(LabelNum)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)END IFGOSUB OutCodeDataGOTO MainLoopEndWhile:TempInt=1GOSUB ConStkChkErrMainOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopNextX:IF ConStkPtr=0 THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFGOSUB NexTokenIF TokenLen=0 THEN	TokenSaf=ConStk(ConStkPtr).LoopNameEND IFIF TokenSaf<>ConStk(ConStkPtr).LoopName THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFTempInt=5OutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"GOSUB OutCodeDataGOSUB ConStkChkErrMain; add "step" to loop varIF ConStk(ConStkPtr).NoStep=$ff THEN	OutBuf="inc ["+ConStk(ConStkPtr).LoopName+"]"	GOSUB OutCodeDataELSE	IF ConStk(ConStkPtr).ImmStep=0 THEN		OutBuf=";"+ConStk(ConStkPtr).LoopName+"="+ConStk(ConStkPtr).LoopName+"+_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Step;"		GOSUB OutCodeData	ELSE		OutBuf=";"+ConStk(ConStkPtr).LoopName+"="+ConStk(ConStkPtr).LoopName+"+"+ConStk(ConStkPtr).ImmStepVal+";"		GOSUB OutCodeData	END IFEND IF; branch back to loop beginningOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)GOSUB OutCodeData; generate done labelOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopRemX:GOTO MainLoopElseX:GOSUB NexToken;  make sure nothing followsIF TokenLen<>0 THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFTempInt=0GOSUB ConStkChkErrMainINCR LabelNumOutBuf="jmp "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataConStk(ConStkPtr).TermLabel=LabelNumGOTO MainLoopEndIf:TempInt=0GOSUB ConStkChkErrMainOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopDeleteX:GOSUB GetFileNameErrMainImportFcnTable(ptrDeleteFile).ImportFcnUse=TRUEOutBuf="invoke DeleteFile,[_IOBuffer]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopBufferX:GOSUB TokenSymErrMainBufName=SymTemp.SymNameIF SymFound=FALSE THEN	GOSUB MakeBuffer	GOSUB ClrSym	SymTemp.DataMod=0	SymTemp.DataType=BUFFER	SymTemp.DataSize=8	GOSUB SymInsert	ErrMainEND IFTDataType=SymTable(SymNdx).DataTypeIF TDataType<>BUFFER THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFEqualMainGOSUB ExprErrMainIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainEND IFIF DMConst<>0 AND TSymName="0" THEN	GOSUB ReleaseBufferELSE	GOSUB GetBufferEND IFGOTO MainLoopBeginX:GOSUB NexTokenSELECT CASE TokenBuf	CASE "fcn"		GOSUB OutFunction		GOTO BeginFcn	CASE "proc"		GOSUB OutFunction		GOTO BeginProc	CASE "loop"		GOSUB OutCodeData		GOTO BeginLoop	CASE "task"		GOSUB OutCodeData		GOTO BeginTaskX	CASE "sub"		GOSUB OutCodeData		GOTO BeginSub	CASE "seg"		GOSUB OutCodeData		GOTO BeginSeg	CASE "menu"		GOSUB OutCodeData		GOTO BeginMenu	CASE "resource"		GOSUB OutResource		GOTO BeginResource	CASE "export"		GOSUB OutExport		GOTO BeginExport	CASE ELSE		ErrNo=ErrSyntaxEND SELECTGOTO MainLoopBeginLoop:GOSUB IncConStkErrMainGOSUB NexTokenIF TokenLen=0 THEN	ConStk(ConStkPtr).ConType=3ELSE	INCR LopCtrNum	IF LopCtrNum>9 THEN		ErrNo=ErrTmpUse		GOTO MainLoop	END IF	IF TokenBuf<>"count" THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	EqualMain	GOSUB GetIntOp	ErrMain	OutBuf="mov [_LoopCtr+"+STR(LopCtrNum*4)+"],"+LdRegName	GOSUB OutCodeData	ConStk(ConStkPtr).ConType=4END IFConStk(ConStkPtr).ConLine=BasicLineCtrINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataConStk(ConStkPtr).LoopLabel=LabelNumConStk(ConStkPtr).ContLabel=LabelNum; For consistancy with CONTINUE statementINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumGOTO MainLoopEndLoop:TempInt=3GOSUB ConStkChkIF ErrNo<>0 THEN	ErrNo=0	TempInt=4	GOSUB ConStkChk	ErrMainEND IFIF TempInt=3 THEN	OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ELSE	OutBuf="dec [_LoopCtr"+"+"+STR(LopCtrNum*4)+"];"	GOSUB OutCodeData	OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	DECR LopCtrNumEND IFGOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopRepeatX:GOSUB IncConStkErrMainINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataConStk(ConStkPtr).LoopLabel=LabelNumConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=2INCR LabelNumConStk(ConStkPtr).ContLabel=LabelNumINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumGOTO MainLoopUntilX:TempInt=2GOSUB ConStkChkErrMainOutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"GOSUB OutCodeDataGOSUB CmpOpsErrMainIF TokenLen<>0 THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFIF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)END IFGOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopExitIf:IF ConStkPtr<1 THEN	ErrNo=ErrUBCon	ErrMainEND IFGOSUB CmpOpsErrMainIF ConStkPtr<1 THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFIF SimpleCmp=0 THEN	OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)ELSE	OutBuf=SimpleOp+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)END IFGOSUB OutCodeDataGOTO MainLoopShellX:GOSUB ExprIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymName+"; Get src"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataImportFcnTable(ptrsystem).ImportFcnUse=TRUEOutBuf="cinvoke system,[_IOBuffer]"GOSUB OutCodeDataGOTO MainLoopFPrintX:FileIO=$ffGOTO PrintXFInputX:FileIO=$ffGOTO InputXBaseX:GOSUB NexTokenIF TokenBuf<>"0" AND TokenBuf<>"1" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFIF TokenBuf="0" THEN	ArrayBase=0	OutBuf="mov [!ArrayBase],0"ELSE	ArrayBase=1	OutBuf="mov [!ArrayBase],1"END IFGOSUB OutCodeDataGOTO MainLoopIncrX:DecInc="inc"INCx1:Target=$ffGOSUB ExprErrMainFcnOp1Nam=TSymNameIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopEND IFIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFIF DMAddr=0 THEN	IF LAND(VectorBit,TDataMod)=VectorBit THEN		OutBuf="mov esi,["+SymTemp.SymName+"]"		GOSUB OutCodeData		OutBuf=DecInc+_DataType+"[esi]; INC/DEC operand"	ELSE		OutBuf=DecInc+" ["+SymTemp.SymName+"]"	END IFELSE	GOSUB GetVarSiz	IF LAND(VectorBit,TDataMod)=VectorBit THEN		OutBuf="mov esi,["+SymTemp.SymName+"]"		GOSUB OutCodeData		OutBuf="add [esi],"+STR(VarSize)	ELSE		OutBuf="add ["+SymTemp.SymName+"],"+STR(VarSize)	END IFEND IFGOSUB OutCodeDataGOTO MainLoopDecrX:DecInc="dec"GOTO INCx1BufReadX:GOSUB BufRWErrMainGOSUB OutReadGOTO MainLoopBufWriteX:GOSUB BufRWErrMainGOSUB OutWriteGOTO MainLoopDecimalsX:DigDec=0Decimals1:GOSUB GetIntOpErrMainIF DigDec=0 THEN	OutBuf="mov [_Decimals],eax"ELSE	OutBuf="mov [_Digits],eax"END IFGOSUB OutCodeDataGOTO MainLoopExchangeX:Target=$ffGOSUB ExprErrMainIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopEND IFOp1Name=TSymNameOp1Class=OpClassOp1Type=TDataTypeOp1Mod=TDataModOp1Detail=TDetailOp1DataSize=TDataSizeIF Op1Name="NextArg" THEN	ErrNo=ErrIVTarg	GOTO MainLoopEND IFCommaMainGOSUB ExprErrMainIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopEND IFOp2Name=TSymNameOp2Class=OpClassOp2Type=TDataTypeOp2Mod=TDataModOp2Detail=TDetailOp2DataSize=TDataSizeIF Op2Name="NextArg" THEN	ErrNo=ErrIVTarg	GOTO MainLoopEND IFIF Op1Type<>Op2Type THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFIF Op1Class<>CPXClass AND Op1DataSize<>Op2DataSize THEN	IF Op1Type<>STRINGVAR THEN		ErrNo=ErrTypMis		GOTO MainLoop	ELSE		IF Op1Detail<>Op2Detail THEN			ErrNo=ErrTypMis			GOTO MainLoop		END IF	END IFEND IFIF Op1Class=CPXClass AND SymTable(Op1Detail).DataSize<>SymTable(Op2Detail).DataSize THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFIF Op1Class=FLTClass OR Op1Class=INTClass OR Op1Class=BOOLClass THEN	Promote=$ff	SymTemp.SymName=Op1Name	GOSUB LoadReg	ErrMain	SymTemp.SymName=Op2Name	GOSUB LoadReg	ErrMain	TempStr=Op1Name	Op1Name=Op2Name	Op2Name=TempStr	GOSUB StoreD0	ErrMain	OutBuf="mov eax,edx"	GOSUB OutCodeData	Op1Name=Op2Name	GOSUB StoreD0	GOTO MainLoopEND IFIF Op1Class=CPXClass OR Op1Class=ARRClass OR Op1Type=STRINGVAR THEN	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov esi,"+Op1Name	ELSE		OutBuf="mov esi,["+Op1Name+"]"		GOSUB OutCodeData		OutBuf="mov esi,[esi]"	END IF	GOSUB OutCodeData	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov esi,"+Op2Name	ELSE		OutBuf="mov esi,["+Op2Name+"]"		GOSUB OutCodeData		OutBuf="mov esi,[esi]"	END IF	GOSUB OutCodeData	IF Op1Class=ARRClass THEN		TempInt=Op1DataSize	ELSE		IF Op1Type=STRINGVAR THEN			TempInt=Op1Detail		ELSE			TempInt=SymTable(Op1Detail).DataSize		END IF	END IF	INCR LabelNum			OutBuf="mov edx,"+STR(TempInt)		GOSUB OutCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	GOSUB OutCodeData	OutBuf="mov al,[esi]"	GOSUB OutCodeData	OutBuf="mov ah,[edi]"	GOSUB OutCodeData	OutBuf="mov [esi],ah"	GOSUB OutCodeData	OutBuf="mov [edi],al"	GOSUB OutCodeData	OutBuf="inc esi"	GOSUB OutCodeData	OutBuf="inc edi"	GOSUB OutCodeData		OutBuf="dec edx"	GOSUB OutCodeData	OutBuf="jne "+"_Lbl"+STR(LabelNum)	GOSUB OutCodeData	GOTO MainLoop	END IFErrNo=ErrIVTypeGOTO MainLoopBeepX:GOTO MainLoopReDimX:IgnoreRightParen=$ffGOSUB TokenSymErrMainBufName=SymTemp.SymNameBufDataSize=SymTable(SymNdx).DataAddrIF LAND(SymTable(SymNdx).DataMod,ReDimBit)<>ReDimBit THEN	ErrNo=ErrTypMisEND IFGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFTempInt=0Ctr1=0FOR I=SrcNdx TO EndNdx	IF MID(SrcLine,I,1)="," THEN		INCR Ctr1	END IFNEXT IIF Ctr1>2 THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB ExprErrMainIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainEND IFOutBuf="imul eax,"+STR(BufDataSize)GOSUB OutCodeDataIF DMConst<>0 AND TSymName="0" THEN	GOSUB ReleaseBufferELSE	GOSUB GetBufferEND IFGOTO MainLoopPlayX:GOSUB NexTokenSELECT CASE TokenBuf	CASE "wave"		GOTO PlayWave	CASE ELSE		ErrNo=ErrSyntax	END SELECTPlayWave:GOSUB ExprErrMainIF OpClass<>STRClass THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataOutBuf="mov eax,[esi]"GOSUB OutCodeDataOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataOutBuf="mov [_ArgSafe1],0"GOSUB OutCodeDataGOSUB NexTokenIF TokenLen=0 THEN PlayWave1GOSUB ExprIF OpClass<>INTClass THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainEND IFOutBuf="mov _ArgSafe1,eax"GOSUB OutCodeDataPlayWave1:ImportFcnTable(ptrsndPlaySound).ImportFcnUse=TRUEOutBuf="invoke sndPlaySound,[_ArgSafe0],[_ArgSafe1]"GOSUB OutCodeDataGOTO MainLoopSetVecX:GOSUB TokenSymErrMainIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFVectorName=SymTemp.SymNameVDataMod=SymTable(SymNdx).DataModVDataAddr=SymTable(SymNdx).DataAddrIF SymTable(SymNdx).DataType=STRINGVAR THEN	VDetail=SymTable(SymNdx).DetailELSE	VDetail=0END IFIF LAND(VDataMod,VectorBit)=0 THEN; Not a vector	ErrNo=ErrTypMis	GOTO MainLoopEND IFEqualMainGOSUB NexTokenIF TokenBuf="[" THEN	GOSUB RightBracket	ErrMain	GOSUB Expr	MID(SrcLine,SrcLineMod,1)="]"	ErrMain	IF TDataType<>LABELPTR THEN		ErrNo=ErrTypMis		GOTO MainLoop	END IF	OutBuf="mov eax,[esi]"	GOSUB OutCodeData	SymTemp.SymName=VectorName	GOSUB SymSrch	SymNdx=SymTable(SymNdx).Detail	TempInt=SymTable(SymNdx).DataSize	OutBuf="sub eax,"+STR(TempInt)	GOSUB OutCodeData	OutBuf="mov ["+VectorName+"],eax"	GOSUB OutCodeData	GOTO MainLoopELSE	GOSUB UnDoToken	GOSUB GetIntOp	ErrMain	IF LAND(VDataMod,ArrayBit)=ArrayBit THEN		TempInt=ArrayBase*VDataAddr		OutBuf="sub eax,"+STR(TempInt)		GOSUB OutCodeData	END IF	OutBuf="mov ["+VectorName+"],eax"	GOSUB OutCodeData	IF VDetail<>0 THEN;  must be STRING.. do rest of vector		GOSUB NexToken		IF TokenLen=0 THEN			OutBuf="mov ["+VectorName+"+4],"+STR(VDetail)		ELSE			IF TokenBuf<>"," THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB GetIntOp			ErrMain			OutBuf="mov ["+VectorName+"+4],eax"		END IF		GOSUB OutCodeData		OutBuf="mov ["+VectorName+"+8],0"		GOSUB OutCodeData	END IFEND IFGOTO MainLoopDigitsX:DigDec=$ffGOTO Decimals1MacroX:GOTO MACRODxEndMacroX:ErrNo=ErrEndmGOTO MainLoopTableX:ArraySize=0GOSUB ClrDatTypGOSUB TokenSymSymNdxSaf=SymNdxErrMainIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopEND IFGOSUB NexTokenIF TokenBuf<>"as" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFOutBuf=""GOSUB OutInitDataOutBuf="align 4"GOSUB OutInitDataOutBuf=SymTemp.SymName+":"GOSUB OutInitDataGOSUB ClrSymGOSUB NexTokenSELECT CASE TokenBuf	SymTemp.SubType=NONE	CASE "boolean"		SymTemp.DataType=BOOLVAR		SymTemp.DataAddr=1	CASE "byte"		SymTemp.DataType=BYTEVAR		SymTemp.DataAddr=1	CASE "integer"		SymTemp.DataType=WORDVAR		SymTemp.DataAddr=2	CASE "long"		SymTemp.DataType=LONGVAR		SymTemp.DataAddr=4	CASE "quad"		SymTemp.DataType=QUADVAR		SymTemp.DataAddr=8	CASE "float"		SymTemp.DataType=FLOATVAR		SymTemp.DataAddr=8	CASE "label"		SymTemp.DataType=LABELPTR		SymTemp.DataAddr=4	CASE "string"		SymTemp.DataType=STRINGVAR		IF NextByte<>"*" THEN			TempInt=255; Default string size		ELSE			GOSUB NexToken; Eat '*'			GOSUB NexToken			TempStr=TokenSaf			GOSUB StrSiz			ErrMain		END IF		SymTemp.Detail=TempInt		SymTemp.DataAddr=TempInt		StringLength=TempInt	CASE "file"		SymTemp.DataType=LONGVAR		SymTemp.DataAddr=4		SymTemp.SubType=FILE	CASE "device"		SymTemp.DataType=LONGVAR		SymTemp.DataAddr=4		SymTemp.SubType=DEVICE	CASE ELSE		TableName=SymTemp.SymName		SymTemp.SymName=TokenSaf		GOSUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO MainLoop		END IF		IF SymTable(SymNdx).DataType<>TYPE THEN			ErrNo=ErrTypMis			GOTO MainLoop		END IF		TypeNdx=SymNdx		TypeVars=SymTable(SymNdx).Detail		SymTemp.DataType=COMPLEX		SymTemp.Detail=TypeNdx		SymTemp.DataAddr=SymTable(SymNdx).DataSize		SymTemp.SymName=TableNameEND SELECTSymTemp.DataMod=ArrayBitSymNdx=SymNdxSafTDataAddr=SymTemp.DataAddrGOSUB SymInsertErrMainTblDataType=SymTemp.DataTypeTDataType=TblDataType; Useful only if NOT COMPLEX data typeRepeatFlag=0TblLoop:BEGIN LOOP	INCR ArraySize	IF RepeatFlag<>0 THEN		DECR RepeatCnt		IF RepeatCnt=0 THEN			RepeatFlag=0			GOTO TblLoop		END IF		SrcNdx=0		GOSUB NexToken	ELSE		GOSUB ReadSource		GOSUB NexToken		IF TokenBuf="repeat" THEN			RepeatFlag=$ff			GOSUB NexToken			IF TokenBuf="until" THEN				GOSUB NexToken				RepeatCnt=VAL(TokenSaf)				RepeatCnt=RepeatCnt-ArraySize+1			ELSE				RepeatCnt=VAL(TokenSaf)+1			END IF			SrcLine=SrcLineSaf			GOTO TblLoop		ELSE			SrcLineSaf=SrcLine		END IF	END IF	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in TABLE"		ErrNo=$ff		GOTO MainLoop	END IF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"			IF TokenBuf="end" THEN		GOSUB  NexToken		IF TokenBuf<>"table" THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		SymTable(SymNdxSaf).DataSize=(ArraySize-1)*TDataAddr		OutBuf="; End of table"		GOSUB OutInitData		GOSUB MakeLine		GOSUB OutInitData		OutBuf=""		GOSUB OutInitData		GOTO MainLoop	END IF	IF TblDataType=COMPLEX THEN		GOSUB UnDoToken		FOR I=1 TO TypeVars			GOSUB NexToken			IF TokenBuf="," THEN				GOSUB NexToken				IF TokenBuf="," THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF			END IF			TDataType=SymTable(TypeNdx+I).DataType			IF TDataType=STRINGVAR THEN				StringLength=SymTable(TypeNdx+I).Detail			END IF			GOSUB MakeTableEntry			ErrMain			NEXT I	ELSE		GOSUB MakeTableEntry		ErrMain	END IFEND LOOPMakeTableEntry:SELECT CASE TDataType	CASE BOOLVAR		IF TokenBuf="true" THEN			OutBuf="db 1"		ELSE			IF TokenBuf="false" THEN				OutBuf="db 0"			ELSE				ErrNo=ErrTypMis				RETURN			END IF		END IF		CASE BYTEVAR		GOSUB ChkConst		ErrRet		IF IVAL(TokenSaf)>255 THEN			ErrNo=ErrOpRange			RETURN		END IF		GOSUB TblInt		ErrRet		OutBuf="db "+TempStr	CASE WORDVAR		GOSUB ChkConst		ErrRet		IF IVAL(TokenSaf)>65535 THEN			ErrNo=ErrOpRange			RETURN		END IF		GOSUB TblInt		ErrRet		OutBuf="dw "+TempStr	CASE LABELPTR		GOSUB UnDoToken		GOSUB ChkLabel		ErrRet		OutBuf="dd "+TempStr	CASE LONGVAR		GOSUB ChkConst		ErrRet		IF IVAL(TokenSaf)>$7fffffff THEN			ErrNo=ErrOpRange			RETURN		END IF		GOSUB TblInt		ErrRet		OutBuf="dd "+TokenSaf;TempStr'''	CASE FLOATVAR		;	CASE STRINGVAR		IF TokenType<>TTypQuote THEN			ErrNo=ErrTypMis			RETURN			END IF		IF LEN(TokenSaf)-1>StringLength THEN			TempStr="Fatal Error: Oversize string in table"			ErrNo=$ff			RETURN		END IF		IF LEN(TokenSaf)>2 THEN			OutBuf="db "+TokenSaf+",0"		ELSE			OutBuf="db 0"		END IF		FOR Ctr1=1 TO StringLength-LEN(TokenSaf)+1			OutBuf=OutBuf+",0"		NEXT Ctr1END SELECTGOSUB OutInitDataRETURNChkConst:IF TokenType=TTypInt THEN	RETURNEND IFIF TokenType=TTypHex THEN	RETURNEND IFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	RETURNEND IFTokenSaf=STR(SymTable(SymNdx).Detail)TokenBuf=TokenSafTokenType=TTypIntRETURNTblInt:IF TokenType=TTypInt THEN	GOSUB ValidInt	IF IntOK=0 THEN		ErrNo=ErrIVExp		RETURN	END IFEND IFIF TokenType=TTypHex THEN	GOSUB ValidHex	IF HexOK=0 THEN		ErrNo=ErrIVExp		RETURN	END IFEND IFTempStr=TokenSafRETURNEndTable:TempStr="Fatal Error: END TABLE while not in table"ErrNo=$ffGOTO MainLoopIncludeX:UseFilNam=""UseLoop:GOSUB NexTokenIF TokenLen=0 THEN Include1UseFilNam=UseFilNam+TokenSafGOTO UseLoopInclude1:ON ERROR GOTO NoUseFileINCR InpFilPtrIF InpFilPtr>20 THEN	TempStr="FATAL ERROR Include Stack OverFlow"	ErrNo=$ff	GOTO MainLoopEND IFOPEN UseFilNam FOR INPUT AS InpFile(InpFilPtr)ON ERRORGOTO MainLoopNoUseFile:TempStr="Cannot Open Include File: "';UseFilNamGOSUB ShowErrorRETURNNoImportFile:TempStr="Cannot Open Import File"GOSUB ShowErrorRETURNFreezeX:GOTO FIXDxSetEOFX:DiskIO=$ffGOSUB GetFileHandleErrMainIF TSubType=DEVICE THEN	ErrNo=ErrDevice	GOTO MainLoopEND IFImportFcnTable(ptrSetEndOfFile).ImportFcnUse=TRUEOutBuf="invoke SetEndOfFile,[_IOPthNum]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopChDirX:GOSUB GetFileNameErrMainImportFcnTable(ptrSetCurrentDirectory).ImportFcnUse=TRUEOutBuf="invoke SetCurrentDirectory,[_IOBuffer]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZ GOTO MainLoopMkDirX:GOSUB GetFileNameErrMainImportFcnTable(ptrCreateDirectory).ImportFcnUse=TRUEOutBuf="invoke CreateDirectory,[_IOBuffer],0"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopRmDirX:GOSUB GetFileNameErrMainImportFcnTable(ptrRemoveDirectory).ImportFcnUse=TRUEOutBuf="invoke RemoveDirectory,[_IOBuffer]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopEndFcn:IF FcnFlag=FALSE THEN	ErrNo=ErrEndFcn	GOTO MainLoopEND IF; Put default return data hereSELECT CASE TFcnDataType	CASE BOOLVAR		OutBuf="mov [_BoolRet],0"	CASE LONGVAR		OutBuf="mov [_LongRet],0"	CASE STRINGVAR		ediUsed=TRUE		OutBuf="mov edi,_NullStr"		GOSUB OutFunction		OutBuf="mov [_StringRet],edi"		GOSUB OutFunction		OutBuf="mov [_StringRet+4],0"		GOSUB OutFunction		OutBuf="mov [_StringRet+8],0"	CASE FLOATVAR		;END SELECTGOSUB OutFunctionOutBuf="ret"GOSUB OutFunctionFcnFlag=FALSEProcFcnFlag=FALSEGOSUB MakeLineGOSUB OutFunctionGOTO MainLoopMakeLine:OutBuf=";________________________________________________________________________________________________________________________________"RETURNEndProc:IF ProcFlag=FALSE THEN	ErrNo=ErrEndProc	GOTO MainLoopEND IFOutBuf="ret"GOSUB OutFunctionProcFlag=FALSEProcFcnFlag=FALSEGOSUB MakeLineGOSUB OutFunctionGOTO MainLoopDeclareX:GOSUB NexTokenSymTemp.DataMod=UsrFcnBitIF TokenBuf="proc" THEN	ProcFcn=0	SymTemp.DataType=PROCELSE	IF TokenBuf="fcn" THEN		ProcFcn=$ff		SymTemp.DataType=FCN	ELSE		ErrNo=ErrSyntax		GOTO MainLoop	END IFEND IFGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopEND IFCtr3=0GOSUB NexTokenIF TokenSaf<>"(" THEN	IF ProcFcn=0 THEN		GOTO ProcFcnDone	ELSE		ErrNo=ErrSyntax		GOTO MainLoop	END IFEND IFNeedComma=0DeclareLoop:GOSUB NexTokenIF TokenBuf=")" THEN	IF ProcFcn=0 THEN		GOTO ProcFcnDone	ELSE		GOSUB NexToken		IF TokenBuf<>"as" THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		SELECT CASE TokenBuf			CASE "boolean"				SymTemp.FcnDataType=BOOLVAR			CASE "integer"				SymTemp.FcnDataType=LONGVAR			CASE "string"				SymTemp.FcnDataType=STRINGVAR			CASE "float"				SymTemp.FcnDataType=FLOATVAR			CASE ELSE				ErrNo=ErrSyntax				GOTO MainLoop		END SELECT		GOTO ProcFcnDone	END IFELSE	IF NeedComma<>0 THEN		IF TokenSaf<>"," THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		NeedComma=0		GOTO DeclareLoop	ELSE		IF TokenSaf="," THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF	END IF	INCR Ctr3	IF Ctr3>7 THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	SELECT CASE TokenBuf		CASE "boolean"			TempInt=BOOLVAR		CASE "integer"			TempInt=LONGVAR		CASE "string"			TempInt=STRINGVAR		CASE "float"			TempInt=FLOATVAR		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECT	SELECT CASE Ctr3		CASE 1			SymTemp.DataAddr=TempInt		CASE 2			SymTemp.DataSize=TempInt		CASE 3			SymTemp.ArrayDim1=TempInt		CASE 4			SymTemp.ArrayDim2=TempInt		CASE 5			SymTemp.ArrayDim3=TempInt		CASE 6			SymTemp.ArrayDims=TempInt		CASE 7			SymTemp.Misc=TempInt	END SELECT	NeedComma=$ff	GOTO DeclareLoopEND IFProcFcnDone:IF ProcFcn=$ff THEN	IF Ctr3=0 THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IFEND IFSymTemp.FcnArgs=Ctr3SymTemp.Detail=LabelUnresolvedGOSUB SymInsertGOTO MainLoopBeginFcn:GOSUB FcnFlagChkErrMainFcnFlag=TRUEProcFcnFlag=TRUEGOSUB ProcFcnPrepGOSUB PopArgsErrMainGOTO MainLoopBeginProc:GOSUB FcnFlagChkErrMainProcFlag=TRUEProcFcnFlag=TRUEGOSUB ProcFcnPrepIF SymTemp.FcnArgs<>0 THEN	GOSUB PopArgs	ErrMainEND IFGOTO MainLoopFcnFlagChk:IF ProcFcnFlag=TRUE THEN	ErrNo=ErrFSNest	RETURNEND IFRETURNContinueX:IF ConStkPtr<1 THEN	ErrNo=ErrUBCon	ErrMainEND IFGOSUB NexTokenIF TokenLen=0 THEN	OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).ContLabel)	GOSUB OutCodeData	GOTO MainLoopEND IFIF TokenBuf<>"if" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFIF ConStkPtr<1 THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFTempInt=ConStk(ConStkPtr).ConTypeIF TempInt<0 OR TempInt>5 THEN; Everything except Select Case	ErrNo=ErrUBCon	GOTO MainLoopEND IFGOSUB CmpOpsErrMainIF SimpleCmp=0 THEN	OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).ContLabel)ELSE	OutBuf=SimpleOp+"_Lbl"+STR(ConStk(ConStkPtr).ContLabel)END IFGOSUB OutCodeDataGOTO MainLoopSelectX:IF SelectFlag=TRUE THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFSelectFlag=TRUEGOSUB NexTokenIF TokenBuf<>"case" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB ExprErrMainIF OpClass<>STRClass AND OpClass<>INTClass THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFIF OpClass=INTClass AND TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainEND IFSwitchClass=OpClassIF OpClass=INTClass THEN	OutBuf="mov [_SwitchInt],eax"ELSE	ediUsed=TRUE	OutBuf="mov edi,["+TSymName+"]"	GOSUB OutCodeData	OutBuf="mov [_SwitchStr],edi"	GOSUB OutCodeData	OutBuf="mov edi,["+TSymName+"+4]"	GOSUB OutCodeData	OutBuf="mov [_SwitchStr+4],edi"	GOSUB OutCodeData	OutBuf="mov edi,["+TSymName+"+8]"	GOSUB OutCodeData	OutBuf="mov [_SwitchStr+8],edi"END IFGOSUB OutCodeDataGOSUB IncConStkErrMainConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=7INCR LabelNumConStk(ConStkPtr).TermLabel=LabelNum	GOTO MainLoopEndSelect:IF SelectFlag=FALSE THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFIF CaseFlag=TRUE THEN	GOSUB EndCasex	CaseFlag=FALSEEND IFSelectFlag=FALSECaseElseFlag=FALSETempInt=7GOSUB ConStkChkErrMainOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoop CaseX:IF SelectFlag=FALSE OR CaseElseFlag=TRUE THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFIF CaseFlag=TRUE THEN	GOSUB EndCasexEND IFCaseFlag=TRUEINCR LabelNumConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=7ConStk(ConStkPtr).ContLabel=LabelNumGOSUB NexTokenIF TokenBuf="else" THEN	CaseElseFlag=TRUEELSE	GOSUB UnDoToken	GOSUB Expr	ErrMain	IF OpClass<>STRClass AND OpClass<>INTClass THEN		ErrNo=ErrIVType		GOTO MainLoop	END IF	IF OpClass=INTClass AND TSymName<>"~" THEN		D0Loaded=0		GOSUB LoadReg		ErrMain	END IF	IF OpClass<>SwitchClass THEN		ErrNo=ErrTypMis		GOTO MainLoop	END IF	CaseToFlag=FALSE	GOSUB NexToken	IF TokenLen<>0 THEN		IF TokenBuf="to" THEN			CaseToFlag=TRUE		ELSE			ErrNo=ErrSyntax			GOTO MainLoop		END IF	END IF	IF CaseToFlag=FALSE THEN		SymType="jne "		GOSUB GenCase	ELSE		SymType="jg "		GOSUB GenCase		REM Get second arg here		D0Loaded=0		GOSUB Expr		ErrMain		IF OpClass<>STRClass AND OpClass<>INTClass THEN			ErrNo=ErrIVType			GOTO MainLoop		END IF		IF OpClass=INTClass AND TSymName<>"~" THEN			D0Loaded=0			GOSUB LoadReg			ErrMain		END IF		IF OpClass<>SwitchClass THEN			ErrNo=ErrTypMis			GOTO MainLoop		END IF		SymType="jl "		GOSUB GenCase 		END IFEND IF	GOTO MainLoopEndCase:IF SelectFlag=FALSE OR CaseFlag=FALSE THEN	ErrNo=ErrUBCon	GOTO MainLoopEND IFCaseFlag=FALSEGOSUB EndCasexGOTO MainLoopConstX:GOTO SETDxSwapX:GOTO ExchangeXProgramX:StartFlag=TRUEGOTO MainLoopGenCodeX:GOSUB ReadSourceIF TempInt=0 THEN	TempStr="FATAL ERROR.. EOF in Text"	ErrNo=$ff	GOTO MainLoopEND IFIF SrcLine="ENDGENCODE" THEN MainLoop;;;;;;;; fix thisGOTO MainLoopEndGenCodeX:TempStr="Fatal Error: EndGenCode while not in GenCode"ErrNo=$ffGOTO MainLoopMakeLowerX:GOSUB GetStringOpErrMainOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseLCase=TRUEOutBuf="call __LCase"GOSUB OutCodeDataGOTO MainLoopMakeUpperX:GOSUB GetStringOpErrMainOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseUCase=TRUEOutBuf="call __UCase"GOSUB OutCodeDataGOTO MainLoopTextBlockX:UseData=TRUEGOSUB TokenSymErrMainIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopEND IFGOSUB ClrDatTypTDataType=LABELVARSymTemp.DataType=LABELVARGOSUB ClrSymSymTemp.DataMod=DataBitSymTemp.Detail=LabelResolvedGOSUB SymInsertErrMainOutBuf=SymTemp.SymName+":"GOSUB OutInitDataTextLoop:GOSUB ReadSourceIF TempInt=0 THEN	TempStr="FATAL ERROR.. EOF in Text"	ErrNo=$ff	GOTO MainLoopEND IFOutBuf=" db "+CHR(OBQUOTE)+SrcLine+CHR(OBQUOTE)+",0"GOSUB OutInitDataGOSUB NexTokenIF TokenBuf="end" THEN	GOSUB NexToken	IF TokenBuf="text" THEN		GOTO MainLoop	ELSE		GOTO TextLoop	END IFEND IFIF TokenBuf<>"endtext" THEN TextLoopGOTO MainLoopEndTextX:TempStr="Fatal Error: EndText while not in Text"ErrNo=$ffGOTO MainLoopEndType:TempStr="Fatal Error: END TYPE while not in TYPE or Empty TYPE Declaration"ErrNo=$ffGOTO MainLoopSetPositionX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainGOSUB SetPosErrMainGOSUB SetPosFromTableGOTO MainLoopGetCursorPositionX:ErrGUIImportFcnTable(ptrGetCursorPos).ImportFcnUse=TRUEOutBuf="invoke GetCursorPos,CursorPosX"GOSUB OutCodeDataGOTO MainLoopScreenToClientX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrScreenToClient).ImportFcnUse=TRUEOutBuf="invoke ScreenToClient, dword ["+HandleName+"],CursorPosX"GOSUB OutCodeDataGOTO MainLoopGetWindowRectX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrGetWindowRect).ImportFcnUse=TRUEOutBuf="invoke GetWindowRect, dword ["+HandleName+"],RectLeft"GOSUB OutCodeDataGOTO MainLoopGetClientRectX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrGetClientRect).ImportFcnUse=TRUEOutBuf="invoke GetClientRect, dword ["+HandleName+"],RectLeft"GOSUB OutCodeDataGOTO MainLoopGetPixelX:ErrGUIGUITargetFlag=$ff;???GOSUB ValidateObjectErrMainCommaMainGOSUB GetIntOpErrMainOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOpErrMainImportFcnTable(ptrGetPixel).ImportFcnUse=TRUEOutBuf="invoke GetPixel, dword [edi+HDCOffs],[_ArgSafe0],eax"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopSetPixelX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainCommaMainGOSUB GetIntOpErrMainOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOpErrMainOutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOpErrMainImportFcnTable(ptrSetPixel).ImportFcnUse=TRUEOutBuf="invoke SetPixel, dword [edi+HDCOffs],[_ArgSafe0],[_ArgSafe1],eax"GOSUB OutCodeDataGOTO MainLoopSetCursorX:ErrGUIGOSUB GetIntOpErrMainIF TSubType<>CURSOR THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFSetCursorCommon:OutBuf="mov [!CursorFlag],1"GOSUB OutCodeDataImportFcnTable(ptrSetCursor).ImportFcnUse=TRUEOutBuf="invoke SetCursor,eax"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopSetDefaultCursorX:OutBuf="mov [!CursorFlag],0"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain+CursorOffs]"GOSUB OutCodeDataImportFcnTable(ptrSetCursor).ImportFcnUse=TRUEOutBuf="invoke SetCursor,eax"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopSetStockCursorX:GOSUB NexTokenSELECT CASE TokenBuf	CASE "appstarting"		TempStr="IDC_APPSTARTING"	CASE "arrow"		TempStr="IDC_ARROW"	CASE "cross"		TempStr="IDC_CROSS"	CASE "hand"		TempStr="IDC_HAND"	CASE "help"		TempStr="IDC_HELP"	CASE "ibeam"		TempStr="IDC_IBEAM"	CASE "no"		TempStr="IDC_NO"	CASE "size"		TempStr="IDC_SIZEALL"	CASE "sizeall"		TempStr="IDC_SIZEALL"	CASE "sizenesw"		TempStr="IDC_SIZENESW"	CASE "sizens"		TempStr="IDC_SIZENS"	CASE "sizenwse"		TempStr="IDC_SIZENWSE"	CASE "sizewe"		TempStr="IDC_SIZEWE"	CASE "uparrow"		TempStr="IDC_UPARROW"	CASE "wait"		TempStr="IDC_WAIT"	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoop	END SELECTOutBuf="invoke LoadCursor,0,"+TempStrGOSUB OutCodeDataGOTO SetCursorCommonSetCursorFlagX:ErrGUIGOSUB NexTokenIF TokenBuf="true" THEN	OutBuf="mov [!CursorFlag],1"ELSE	IF TokenBuf="false" THEN		OutBuf="mov [!CursorFlag],0"	ELSE		ErrNo=ErrSyntax	END IFEND IFGOSUB OutCodeDataGOTO MainLoopGetDCX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrGetDC).ImportFcnUse=TRUEOutBuf="invoke GetDC, dword ["+HandleName+"]"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov [edi+HDCOffs],eax"GOSUB OutCodeDataGOTO MainLoopReleaseDCX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrReleaseDC).ImportFcnUse=TRUEOutBuf="invoke ReleaseDC, dword ["+HandleName+"], dword [edi+HDCOffs]"GOSUB OutCodeDataGOTO MainLoopBeginPaintX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrBeginPaint).ImportFcnUse=TRUEOutBuf="invoke BeginPaint, dword ["+HandleName+"],PaintStruct"GOSUB OutCodeDataGOTO MainLoopEndPaintX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrEndPaint).ImportFcnUse=TRUEOutBuf="invoke EndPaint, dword ["+HandleName+"],PaintStruct"GOSUB OutCodeDataGOTO MainLoopInvalidateRectX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataGOTO MainLoopSetCaptureX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrSetCapture).ImportFcnUse=TRUEOutBuf="invoke SetCapture, dword ["+HandleName+"]"GOSUB OutCodeDataGOTO MainLoopReleaseCaptureX:ErrGUIImportFcnTable(ptrReleaseCapture).ImportFcnUse=TRUEOutBuf="invoke ReleaseCapture"GOSUB OutCodeDataGOTO MainLoopCreateX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFTSubType=SymTable(SymNdx).SubTypeGOSUB UnDoTokenSELECT CASE TSubType	CASE FONT		GOTO CreateFont	CASE BITMAP		GOTO CreateImage	CASE ICON		GOTO CreateIcon	CASE CURSOR		GOTO CreateCursorEND SELECTGUITargetFlag=$ffCreateObjectFlag=TRUEInFlag=FalseChildFlag=FALSEGOSUB ValidateObjectErrMainGOSUB SetPosErrMainObjectTypeSafe=ObjectType-99ObjectNameSafe=ObjectNameTempExStyleStr=ObjTable(ObjectTypeSafe).ObjExStyleSETVEC StyleArray=[ObjTable(ObjectTypeSafe).ObjStyleTable]TempStr="default"GOSUB FindStyleErrMainStyleCode=StyleArray(I).StyleValueIF NextByte="," THEN; Style Arg	StyleCode=0	GOSUB NexToken; Eat the comma	BEGIN LOOP		EXIT IF NextByte=" " OR NextByte=","		GOSUB NexToken		EXIT IF TokenLen=0		IF TokenBuf<>"+" THEN			TempStr=TokenBuf			GOSUB FindStyle			ErrMain			StyleCode=StyleCode+StyleArray(I).StyleValue		END IF	END LOOPEND IFTempStyleStr="$"+HEX(StyleCode)ObjectParent="!OBMain"INCR ObjectIDBEGIN LOOP	GOSUB NexToken	EXIT IF TokenLen=0	SELECT CASE TokenBuf		CASE "child"			IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			ChildFlag=TRUE		CASE "in"			IF ObjectTypeSafe=ptrFORM OR ObjectTypeSafe=ptrTOOLWINDOW THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB ValidateParentObject			InFlag=TRUE		CASE "topmost"			IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN							ErrNo=ErrSyntax				GOTO MainLoop			END IF			FormExStyle=FormExStyle+"+WS_EX_TOPMOST"		CASE "appwindow"			IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN							ErrNo=ErrSyntax				GOTO MainLoop			END IF			FormExStyle=FormExStyle+"+WS_EX_APPWINDOW"					CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECTEND LOOPINCR LabelNumOutBuf="bt dword [edi+StatusOffs],WinConstructed"GOSUB OutCodeDataOutBuf="jc _Lbl"+STR(LabelNum)GOSUB OutCodeDataTempStr="!ControlType"+STR(ObjectTypeSafe)IF ObjectTypeSafe=ptrFORM OR ObjectTypeSafe=ptrTOOLWINDOW THEN; FORM	OutBuf="!"+ObjectName+"WindowClass WNDCLASS"	GOSUB OutInitData	OutBuf="!"+ObjectName+"Class db '"+ObjectName+"',0"	GOSUB OutInitData	ImportFcnTable(ptrLoadIcon).ImportFcnUse=TRUE	OutBuf="invoke LoadIcon,0,IDI_APPLICATION"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.hIcon],eax"	GOSUB OutCodeData	ImportFcnTable(ptrLoadCursor).ImportFcnUse=TRUE	OutBuf="invoke LoadCursor,0,IDC_ARROW"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+CursorOffs],eax"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.hCursor],eax"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.style],0"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.lpfnWndProc],!"+ObjectName+"Proc"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.cbClsExtra],0"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.cbWndExtra],0"	GOSUB OutCodeData	OutBuf="mov eax,[!hinstance]"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.hbrBackground],COLOR_BTNFACE+1"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.lpszMenuName],0"		GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.lpszClassName],!"+ObjectName+"Class"	GOSUB OutCodeData	ImportFcnTable(ptrRegisterClass).ImportFcnUse=TRUE	OutBuf="invoke RegisterClass,!"+ObjectName+"WindowClass"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+HandleOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+IDOffs],1"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+ArrayOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+ForeColorOffs],$ffffff"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+BackColorOffs],$ffffffff"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+TypeOffs],!CT_FORM"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+ControlBrushOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+InterceptSafeOffs],!"+ObjectName+"Proc"	GOSUB OutCodeData	IF ChildFlag=TRUE THEN		ObjectParent="[!OBMain]"	ELSE		ObjectParent="NULL"	END IF	UseSetRightBottom=TRUE	OutBuf="call __SetRightBottom"	GOSUB OutCodeData	ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE	OutBuf="invoke CreateWindowEx,"+FormExStyle+",!"+ObjectName+"Class,!title,WS_VISIBLE+WS_OVERLAPPEDWINDOW,dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs], dword "+ObjectParent+",NULL,[!hinstance],!"+ObjectName	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,[!"+ObjectName+"+HandleOffs],GWL_USERDATA,!"+ObjectName	GOSUB OutCodeData	OutBuf="mov dword [edi+StatusOffs],$07"	GOSUB OutCodeData	OutBuf="proc !"+ObjectName+"Proc"+",!hwnd,wmsg,wparam,lparam"	GOSUB OutFunction	OutBuf="enter"	GOSUB OutFunction	OutBuf="push ebx esi edi"	GOSUB OutFunction	OutBuf="mov [!PassEvent],0"	GOSUB OutFunction	OutBuf="mov ebx,[wmsg]"	GOSUB OutFunction	OutBuf="cmp ebx,WM_GETMINMAXINFO"	GOSUB OutFunction	OutBuf="jne "+ObjectName+"NotwmGetMaxInfo"	GOSUB OutFunction	OutBuf="mov dword edi,[!hwnd]"	GOSUB OutFunction	OutBuf="mov dword [!"+ObjectName+"+HandleOffs],edi"	GOSUB OutFunction	OutBuf="mov dword [!"+ObjectName+"+OwnerOffs],0"	GOSUB OutFunction	OutBuf="jmp !DefWndProc"	GOSUB OutFunction	OutBuf=ObjectName+"NotwmGetMaxInfo:"	GOSUB OutFunction	OutBuf="mov esi,!"+ObjectName	GOSUB OutFunction	OutBuf="cmp ebx,WM_DESTROY"	GOSUB OutFunction	OutBuf="jne !WinProcCommon"	GOSUB OutFunction	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	OutBuf="invoke DeleteObject,dword [esi+ControlBrushOffs]"	GOSUB OutFunction	OutBuf="jmp !DefWndProc"	GOSUB OutFunction	GOTO CREATEDoneEND IFUseSetRightBottom=TRUEOutBuf="call __SetRightBottom"GOSUB OutCodeDataImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUEOutBuf="invoke CreateWindowEx,"+TempExStyleStr+","+TempStr+",NULL,"+TempStyleStr+", dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs], dword ["+ObjectParent+"],"+STR(ObjectID)+",[!hinstance],!"+ObjectNameGOSUB OutCodeDataOutBuf="mov dword edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+HandleOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword eax,GWL_USERDATA,edi"GOSUB OutCodeDataOutBuf="mov dword edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+TTcbSizeOffs],44"GOSUB OutCodeDataOutBuf="mov dword [edi+TTuFlagsOffs],TTF_IDISHWND+TTF_SUBCLASS"GOSUB OutCodeDataOutBuf="mov dword eax,[edi+HandleOffs]"GOSUB OutCodeDataOutBuf="mov dword [edi+TTuIDOffs],eax"GOSUB OutCodeDataOutBuf="mov eax,edi"GOSUB OutCodeDataOutBuf="add eax,TTTextOffs"GOSUB OutCodeDataOutBuf="mov dword [edi+TTlpszTextOffs],eax"GOSUB OutCodeDataIF ObjectTypeSafe=ptrRICHEDIT THEN	RichEdLibUsed=TRUEEND IFIF ObjectTypeSafe=ptrRAEdit THEN	RAEditLibUsed=TRUEEND IFIF ObjectTypeSafe=ptrRAGrid THEN	RAGridLibUsed=TRUEEND IFIF ObjectTypeSafe=ptrDRAWPROGRESS THEN	DrawProgressLibUsed=TRUEEND IFIF ObjectTypeSafe=ptrButtonEx THEN	ButtonExLibUsed=TRUEEND IFIF ObjectTypeSafe=ptrCOMBOBOX THEN	OutBuf="mov dword edi,[!TargetGUIDesc]"	GOSUB OutCodeData	ImportFcnTable(ptrGetComboBoxInfo).ImportFcnUse=TRUE		OutBuf="invoke GetComboBoxInfo, dword ["+HandleName+"],!cbSize"	GOSUB OutCodeData	OutBuf="mov dword edi,[!TargetGUIDesc]"	GOSUB OutCodeData	OutBuf="mov eax,[!hwndCombo]"	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"	GOSUB OutCodeData	OutBuf="mov eax,[!hwndItem]"	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"	GOSUB OutCodeData	OutBuf="mov eax,[!hwndList]"	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"	GOSUB OutCodeDataEND IF	ObjectName=ObjectNameSafeObjectNameSafe="!"+ObjectNameIF InFlag=TRUE THEN	IF LAND(SymTable(SymNdx).DataMod,SubClassedBit)=0 THEN		INCR ProcNum		TDataMod=SymTable(SymNdx).DataMod		TDataMod=LOR(TDataMod,SubClassedBit)		SymTable(SymNdx).DataMod=TDataMod		INCR SCLabelNum		OutBuf="bts dword ["+ObjectParentName+"+StatusOffs],WinSubClassed"		GOSUB OutCodeData		OutBuf="jc _SCLbl"+STR(SCLabelNum)		GOSUB OutCodeData		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		OutBuf="invoke SetWindowLong, dword ["+ObjectParent+"],GWL_WNDPROC,!SubClassProc"		GOSUB OutCodeData		OutBuf="mov ["+ObjectParentName+"+OldProcOffs],eax"		GOSUB OutCodeData		OutBuf="_SCLbl"+STR(SCLabelNum)+":"		GOSUB OutCodeData			IF SubClassFlag=FALSE THEN			RESTORE SubClassProc			GOSUB OutLibCodeText			SubClassFlag=TRUE		END IF		ImportFcnTable(ptrCallWindowProc).ImportFcnUse=TRUE			END IFEND IFOutBuf="mov dword edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+TypeOffs],"+STR(ObjectTypeSafe+99)GOSUB OutCodeDataOutBuf="mov dword [edi+IDOffs],"+STR(ObjectID)GOSUB OutCodeDataOutBuf="mov eax,["+ObjectParent+"]"GOSUB OutCodeDataOutBuf="mov dword [edi+OwnerOffs],eax"GOSUB OutCodeDataIF GUIArrayFlag=0 THEN	OutBuf="mov dword [edi+ArrayOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [edi+StatusOffs],$07"ELSE	OutBuf="mov eax,[ArrayIndex]"	GOSUB OutCodeData	OutBuf="mov dword [edi+ArrayOffs],eax"	GOSUB OutCodeData	OutBuf="mov dword [edi+StatusOffs],$27"END IFGOSUB OutCodeDataIF ObjectTypeSafe=ptrCOMBOBOX OR ObjectTypeSafe=ptrTEXTBOX OR ObjectTypeSafe=ptrLISTBOX OR ObjectTypeSafe=ptrRAGrid THEN	OutBuf="mov dword [edi+BackColorOffs],$ffffff"	GOSUB OutCodeDataELSE	IF ObjectTypeSafe=ptrRAEdit THEN		OutBuf="mov dword [edi+BackColorOffs],$c0f0f0"		GOSUB OutCodeData	ELSE		OutBuf="mov dword [edi+BackColorOffs],$ffffffff"		GOSUB OutCodeData	END IFEND IFOutBuf="mov dword [edi+ForeColorOffs],$ffffff"GOSUB OutCodeDataOutBuf="mov dword [edi+ControlBrushOffs],0"GOSUB OutCodeDataImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUEOutBuf="invoke GetWindowLong,dword [edi+HandleOffs],GWL_WNDPROC"GOSUB OutCodeDataOutBuf="mov dword edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+InterceptSafeOffs],eax"GOSUB OutCodeDataCREATEDone:OutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOTO MainLoopMsgBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSafGOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopWarningBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONWARNING"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopInfoBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONINFORMATION"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopQuestionBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONQUESTION"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopErrorBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONERROR"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopSetStyleX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainCommaMainGOSUB NexTokenTempStr=TokenSafCommaMainGOSUB NexTokenIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUEOutBuf="invoke GetWindowLong, dword ["+HandleName+"],GWL_STYLE"GOSUB OutCodeDataSELECT CASE TokenBuf	CASE "true"		OutBuf="or eax,"+TempStr	CASE "false"		OutBuf="not eax"		GOSUB OutCodeData		OutBuf="or eax,"+TempStr		GOSUB OutCodeData		OutBuf="not eax"	CASE ELSE		ErrNo=ErrIVType		GOTO MainLoopEND SELECTGOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_STYLE,eax"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataGOTO MainLoopFindX:ErrGUIGOSUB NexTokenIF TokenBuf="." THEN	GOSUB NexToken	IF TokenBuf<>"notify" THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	TempStr="Find_notify"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	OutBuf="mov [FindEVPtr],"+TempStr	GOSUB OutInitCode	GOTO MainLoopELSE	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOTO MainLoopDestroyX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainINCR LabelNumOutBuf="bt dword [edi+StatusOffs],WinConstructed"GOSUB OutCodeDataOutBuf="jnc _Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="btr dword [edi+StatusOffs],WinConstructed"GOSUB OutCodeDataImportFcnTable(ptrDestroyWindow).ImportFcnUse=TRUEOutBuf="invoke DestroyWindow, dword ["+HandleName+"]"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOTO MainLoopShowX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMain; finish thisGOTO MainLoopEndEvent:IF EventFlag=FALSE THEN	ErrNo=ErrEndEvent	GOTO MainLoopEND IFOutBuf="ret"GOSUB OutCodeDataEventFlag=FALSEProcFcnFlag=FALSEGOSUB MakeLineGOSUB OutCodeDataGOTO MainLoopFindDialogX:ErrGUIFindReplace=0FindReplaceDialog:ErrGUIGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [fr_lpstrFindWhat],eax"GOSUB OutCodeDataOutBuf="mov eax,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="mov [fr_wFindWhatLen],ax"GOSUB OutCodeDataOutBuf="mov eax,[!hinstance]"GOSUB OutCodeDataOutBuf="mov [fr_hInstance],eax"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain]"GOSUB OutCodeDataOutBuf="mov [fr_hwndOwner],eax"GOSUB OutCodeDataIF FindReplace=0 THEN	OutBuf="mov [fr_Flags],FR_DOWN"	GOSUB OutCodeData	ImportFcnTable(ptrFindText).ImportFcnUse=TRUE	OutBuf="invoke FindText,fr_lStructSize"	GOSUB OutCodeDataELSE	CommaMain	GOSUB GetStringOp	ErrMain	OutBuf="mov eax,["+TSymName+"]"	GOSUB OutCodeData	OutBuf="mov [fr_lpstrReplaceWith],eax"	GOSUB OutCodeData	OutBuf="mov eax,["+TSymName+"+4]"	GOSUB OutCodeData	OutBuf="mov [fr_wReplaceWithLen],ax"	GOSUB OutCodeData	OutBuf="mov [fr_Flags],FR_DOWN"	GOSUB OutCodeData	ImportFcnTable(ptrReplaceText).ImportFcnUse=TRUE	OutBuf="invoke ReplaceText,fr_lStructSize"	GOSUB OutCodeDataEND IFGOSUB SetStatusIF FindReplaceFlag=0 THEN; How about the REPLACE case?	FindReplaceFlag=$ff	ImportFcnTable(ptrRegisterWindowMessage).ImportFcnUse=TRUE	OutBuf="invoke RegisterWindowMessage,FINDMSGSTRING"	GOSUB OutCodeData	OutBuf="mov [FindMsgID],eax"	GOSUB OutCodeData	END IFGOTO MainLoopReplaceDialogX:ErrGUIFindReplace=$ffGOTO FindReplaceDialogGOTO MainLoopColorDialogX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).DataType<>LONGVAR THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFImportFcnTable(ptrChooseColor).ImportFcnUse=TRUE	OutBuf="invoke ChooseColor,cc_lStructSize"GOSUB OutCodeDataINCR LabelNumOutBuf="or eax,eax"GOSUB OutCodeDataOutBuf="jne _Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="mov [cc_rgbResult],$ffffffff"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="mov eax,[cc_rgbResult]"GOSUB OutCodeDataOutBuf="mov ["+TokenSaf+"],eax"GOSUB OutCodeDataGOTO MainLoopFontDialogX:ErrGUIGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [cf_lpszStyle],eax"GOSUB OutCodeDataOutBuf="mov [cf_Flags],CF_SCREENFONTS"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain]"GOSUB OutCodeDataOutBuf="mov [cf_hwndOwner],eax"GOSUB OutCodeDataImportFcnTable(ptrChooseFont).ImportFcnUse=TRUEOutBuf="invoke ChooseFont,cf_lStructSize"GOSUB OutCodeDataGOTO MainLoopOpenDialogX:ErrGUIOpenSave=0OpenSaveDialog:ErrGUIGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [ofn_lpstrFile],eax"GOSUB OutCodeDataOutBuf="mov eax,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="mov [ofn_nMaxFile],eax"GOSUB OutCodeDataCommaMainGOSUB GetTextOpErrMainOutBuf="mov eax,"+TSymNameGOSUB OutCodeDataOutBuf="mov [ofn_lpstrFilter],eax"GOSUB OutCodeDataCommaMainGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [ofn_lpstrInitialDir],eax"GOSUB OutCodeDataOutBuf="mov eax,[!hinstance]"GOSUB OutCodeDataOutBuf="mov [ofn_hInstance],eax"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain]"GOSUB OutCodeDataOutBuf="mov [ofn_hwndOwner],eax"GOSUB OutCodeDataIF OpenSave=0 THEN	OutBuf="mov [ofn_Flags],OFN_FILEMUSTEXIST+OFN_PATHMUSTEXIST+OFN_HIDEREADONLY"	GOSUB OutCodeData	ImportFcnTable(ptrGetOpenFileName).ImportFcnUse=TRUE	OutBuf="invoke GetOpenFileName,ofn_lStructSize"	GOSUB OutCodeDataELSE	OutBuf="mov [ofn_Flags],OFN_OVERWRITEPROMPT"	GOSUB OutCodeData	ImportFcnTable(ptrGetSaveFileName).ImportFcnUse=TRUE	OutBuf="invoke GetSaveFileName,ofn_lStructSize"	GOSUB OutCodeDataEND IFGOSUB SetStatusGOTO MainLoopSaveDialogX:ErrGUIOpenSave=$ffGOTO OpenSaveDialogGOTO MainLoopPrintDialogX:ErrGUIGOTO MainLoopPageDialogX:ErrGUIGOTO MainLoopShowPopupX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFMenuTitleName=TokenSafCommaMainGOSUB GetIntOpErrMainOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOpErrMainImportFcnTable(ptrTrackPopupMenuEx).ImportFcnUse=TRUEOutBuf="invoke TrackPopupMenuEx,["+MenuTitleName+"],TPM_LEFTALIGN+TPM_TOPALIGN,[_ArgSafe0],eax,[!OBMain],0"GOSUB OutCodeDataGOTO MainLoopDeleteMenuItemX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFMenuTitleName=TokenSafCommaMainGOSUB GetIntOpErrMainImportFcnTable(ptrDeleteMenu).ImportFcnUse=TRUEOutBuf="invoke  DeleteMenu, dword ["+MenuTitleName+"],eax,MF_BYCOMMAND"GOSUB OutCodeDataGOTO MainLoopAppendmenuItemX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFMenuTitleName=TokenSafCommaMainGOSUB GetIntOpErrMainCommaMainGOSUB GetStringOpErrMainMenuItemName=TSymNameImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUEOutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,eax,["+MenuItemName+"]"GOSUB OutCodeDataGOTO MainLoopPopupMenuX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFMenuTitleName=TokenSafImportFcnTable(ptrCreatePopupMenu).ImportFcnUse=TRUEOutBuf="invoke CreatePopupMenu"GOSUB OutCodeDataOutBuf="mov ["+TokenSaf+"],eax"GOSUB OutCodeDataBEGIN LOOP	GOSUB MainLoopInit	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in MENU"		ErrNo=$ff		GOTO MainLoop	END IF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,1))=";"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"	GOSUB Remark	GOSUB OutCodeData	GOSUB NexToken	SELECT CASE TokenBuf		CASE "menuitem"			GOSUB NexToken			GOSUB SymChk			IF SymbolOK=0 THEN				ErrNo=ErrIVSNam				GOTO MainLoop			END IF							SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				INCR MenuIDNum				GOSUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.DataSize=4				SymTemp.DataMod=ConstBit				SymTemp.Detail=MenuIDNum				GOSUB SymInsert				ErrMain				OutBuf=TokenSaf+" equ "+STR(MenuIDNum)				GOSUB OutDeclare			ELSE				ErrNo=ErrDupSym				GOTO MainLoop			END IF			CommaMain			GOSUB GetStringOp			ErrMain			MenuItemName=TSymName			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,"+STR(MenuIDNum)+",["+MenuItemName+"]"			GOSUB OutCodeData		CASE "reserveitems"			GOSUB NexToken			GOSUB SymChk			IF SymbolOK=0 THEN				ErrNo=ErrIVSNam				GOTO MainLoop			END IF							SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				INCR MenuIDNum				GOSUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.DataSize=4				SymTemp.DataMod=ConstBit				SymTemp.Detail=MenuIDNum				GOSUB SymInsert				ErrMain				OutBuf=TokenSaf+" equ "+STR(MenuIDNum)				GOSUB OutDeclare			ELSE				ErrNo=ErrDupSym				GOTO MainLoop			END IF			CommaMain			GOSUB NexToken			ErrMain			MenuIDNum=MenuIDNum+VAL(TokenBuf)-1		CASE "submenu"			IF LEN(MenuTitleName)=0 THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB NexToken			HandleName="edi+HandleOffs"			OutBuf="mov edi,"+TokenSaf			GOSUB OutCodeData						SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO MainLoop			END IF			IF SymTable(SymNdx).SubType<>MENU THEN				ErrNo=ErrIVType				GOTO MainLoop			END IF			CommaMain			GOSUB GetStringOp			ErrMain			MenuItemName=TSymName			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_POPUP, dword ["+HandleName+"],["+MenuItemName+"]"			GOSUB OutCodeData		CASE "menuseparator"			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke AppendMenu,["+MenuTitleName+"],MF_SEPARATOR,0,0"			GOSUB OutCodeData		CASE "end"			GOSUB NexToken			IF TokenBuf<>"menu" THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOTO PopupMenuDone		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop							END SELECTEND LOOPPopupMenuDone:GOTO MainLoopMenuX:ErrGUIGOSUB NexTokenIF TokenBuf="." THEN	GOSUB NexToken	IF TokenBuf<>"command" THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	TempStr="Menu_command"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	OutBuf="mov [MenuEVPtr],"+TempStr	GOSUB OutInitCodeELSE	ErrNo=ErrSyntaxEND IFGOTO MainLoopBeginMenu:ErrGUIMenuBarName=""MenuTitleName=""GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFGOSUB GetSymTempIF SymTemp.DataType<>FORM AND SymTemp.DataType<>TOOLWINDOW THEN	ErrNo=ErrIVType	GOTO MainLoopEND IF	MenuWindowName="!"+SymTemp.SymNameBEGIN LOOP	GOSUB MainLoopInit	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="EOF in MENU"		ErrNo=$ff		GOTO MainLoop	END IF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,1))=";"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"	GOSUB Remark	GOSUB OutCodeData	GOSUB NexToken	SELECT CASE TokenBuf		CASE "menubar"			GOSUB NexToken			MenuBarName=TokenSaf			SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=TRUE THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB ClrDatTyp			GOSUB ClrSym			SymTemp.DataType=LONGVAR			SymTemp.SubType=MENU			SymTemp.DataMod=0			SymTemp.Detail=0			GOSUB SymInsert			ErrMain			OutBuf=MenuBarName+" rd 1"			GOSUB OutUninitData			ImportFcnTable(ptrCreateMenu).ImportFcnUse=TRUE			OutBuf="invoke CreateMenu"			GOSUB OutCodeData			OutBuf="mov ["+MenuBarName+"],eax"			GOSUB OutCodeData		CASE "menutitle"			IF LEN(MenuBarName)=0 THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB NexToken			MenuTitleName=TokenSaf			SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=TRUE THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB ClrDatTyp			GOSUB ClrSym			SymTemp.DataType=LONGVAR			SymTemp.SubType=MENU			SymTemp.DataMod=0			SymTemp.Detail=0			GOSUB SymInsert			ErrMain			OutBuf=MenuTitleName+" rd 1"			GOSUB OutUninitData			ImportFcnTable(ptrCreatePopupMenu).ImportFcnUse=TRUE			OutBuf="invoke CreatePopupMenu"			GOSUB OutCodeData			OutBuf="mov ["+MenuTitleName+"],eax"			GOSUB OutCodeData			CommaMain			GOSUB GetStringOp			ErrMain			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke AppendMenu,["+MenuBarName+"],MF_POPUP,["+MenuTitleName+"],["+TSymName+"]"			GOSUB OutCodeData		CASE "menuitem"			IF LEN(MenuTitleName)=0 THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB NexToken			GOSUB SymChk			IF SymbolOK=0 THEN				ErrNo=ErrIVSNam				GOTO MainLoop			END IF							SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				INCR MenuIDNum				GOSUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.DataSize=4				SymTemp.DataMod=ConstBit				SymTemp.Detail=MenuIDNum				GOSUB SymInsert				ErrMain				OutBuf=TokenSaf+" equ "+STR(MenuIDNum)				GOSUB OutDeclare			ELSE				ErrNo=ErrDupSym				GOTO MainLoop			END IF			CommaMain			GOSUB GetStringOp			ErrMain			MenuItemName=TSymName			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,"+STR(MenuIDNum)+",["+MenuItemName+"]"			GOSUB OutCodeData							CASE "submenu"			IF LEN(MenuTitleName)=0 THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOSUB NexToken			HandleName="edi+HandleOffs"			OutBuf="mov edi,"+TokenSaf			GOSUB OutCodeData						SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO MainLoop			END IF			IF SymTable(SymNdx).SubType<>MENU THEN				ErrNo=ErrIVType				GOTO MainLoop			END IF			CommaMain			GOSUB GetStringOp			ErrMain			MenuItemName=TSymName			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_POPUP, dword ["+HandleName+"],["+MenuItemName+"]"			GOSUB OutCodeData		CASE "menuseparator"			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke AppendMenu,["+MenuTitleName+"],MF_SEPARATOR,0,0"			GOSUB OutCodeData		CASE "end"			GOSUB NexToken			IF TokenBuf<>"menu" THEN				ErrNo=ErrSyntax				GOTO MainLoop			END IF			GOTO MenuDone		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop							END SELECTEND LOOPMenuDone:ImportFcnTable(ptrSetMenu).ImportFcnUse=TRUEOutBuf="invoke SetMenu,["+MenuWindowName+"],["+MenuBarName+"]"GOSUB OutCodeDataGOTO MainLoopEndMenu:TempStr="Fatal Error: EndMenu while not in menu"ErrNo=$ffGOTO MainLoopSetMenuItemBitmapsX:GOSUB NexTokenObjectName=TokenSafSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFGOSUB GetSymTempIF SymTemp.SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFCommaMainGOSUB GetIntOpErrMainOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOpErrMainOutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataIF TSubType<>BITMAP THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFCommaMainGOSUB GetIntOpErrMainIF TSubType<>BITMAP THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFImportFcnTable(ptrSetMenuItemBitmaps).ImportFcnUse=TRUEOutBuf="invoke SetMenuItemBitmaps,["+ObjectName+"],[_ArgSafe0],MF_BYCOMMAND,[_ArgSafe1],eax"GOSUB OutCodeDataGOTO MainLoopCheckMenuitemX:MenuOp=1MenuCommon:GOSUB NexTokenObjectName=TokenSafSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFGOSUB GetSymTempIF SymTemp.SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFCommaMainGOSUB GetIntOpErrMainCommaMainGOSUB NexTokenSELECT CASE MenuOp	CASE 1		IF TokenBuf="true" THEN			TempStr="MF_CHECKED+MF_BYCOMMAND"		ELSE			TempStr="MF_UNCHECKED+MF_BYCOMMAND"		END IF		ImportFcnTable(ptrCheckMenuItem).ImportFcnUse=TRUE		OutBuf="invoke CheckMenuItem,["+ObjectName+"],eax,"+TempStr	CASE 2		IF TokenBuf="true" THEN			TempStr="MF_ENABLED+MF_BYCOMMAND"		ELSE			TempStr="MF_GRAYED+MF_BYCOMMAND"		END IF		ImportFcnTable(ptrEnableMenuItem).ImportFcnUse=TRUE		OutBuf="invoke EnableMenuItem,["+ObjectName+"],eax,"+TempStr	CASE 3		IF TokenBuf="true" THEN			TempStr="MF_HILITE+MF_BYCOMMAND"		ELSE			TempStr="MF_UNHILITE+MF_BYCOMMAND"		END IF		ImportFcnTable(ptrHiliteMenuItem).ImportFcnUse=TRUE		OutBuf="invoke HiliteMenuItem,[!OBMain],["+ObjectName+"],eax,"+TempStrEND SELECTGOSUB OutCodeDataGOTO MainLoopEnableMenuitemX:ErrGUIMenuOp=2GOTO MenuCommonHiliteMenuItemX:ErrGUIMenuOp=3GOTO MenuCommonEnumX:GOSUB NexTokenEnumStep=1IF TokenLen<>0 THEN	EnumVal=VAL(TokenSaf)	GOSUB NexToken	IF TokenLen<>0 THEN		IF TokenBuf<>"step" THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		EnumStep=VAL(TokenSaf)	END IF	END IFBEGIN LOOP	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in Enum"		ErrNo=$ff		GOTO MainLoop	END IF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"	GOSUB NexToken	IF TokenBuf="end" THEN		GOSUB NexToken		IF TokenBuf<>"enum" THEN			ErrNo=ErrSyntax		END IF		GOTO MainLoop	END IF	GOSUB SymChk	IF SymbolOK=0 THEN		ErrNo=ErrIVSNam		GOTO MainLoop	END IF					SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		GOSUB ClrSym		SymTemp.DataType=COMPVAR		SymTemp.DataSize=4		SymTemp.Detail=EnumVal		SymTemp.DataMod=0		GOSUB SymInsert		ErrMain		OutBuf=TokenSaf+" equ "+STR(EnumVal)		GOSUB OutDeclare	ELSE		ErrNo=ErrDupSym		GOTO MainLoop	END IF	EnumVal=EnumVal+EnumStepEND LOOPGOTO MainLoopEndEnum:TempStr="Fatal Error: EndEnum while not in enum"ErrNo=$ffGOTO MainLoopCreateFont:GOSUB ExprOp1Name=TSymNameOp1Mod=TDataModCommaMainGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF LAND(SymTable(SymNdx).DataMod,LogFontBit)=0 THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFImportFcnTable(ptrCreateFontIndirect).ImportFcnUse=TRUEOutBuf="invoke CreateFontIndirect,"+TokenSafGOSUB OutCodeDataIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"END IFGOSUB OutCodeDataGOTO MainLoopCreateCursor:IconCursorFlag=FALSEGOTO CreateIconCursorCreateIcon:IconCursorFlag=TRUECreateIconCursor:ErrGUIGOSUB ExprOp1Name=TSymNameOp1Mod=TDataModIF IconCursorFlag=TRUE THEN	IF TSubType<>ICON THEN		ErrNo=ErrIVType		GOTO MainLoop	END IFELSE	IF TSubType<>CURSOR THEN		ErrNo=ErrIVType		GOTO MainLoop	END IFEND IFCommaMainGOSUB NexTokenIF IconCursorFlag=TRUE THEN	TempStr=TokenSaf+".ico"	Opt="1"ELSE	TempStr=TokenSaf+".cur"	Opt="0"END IFON ERROR GOTO BadIconFileOPEN TempStr FOR INPUT AS BitMapFileON ERROROutBuf="!"+Op1Name+":"GOSUB OutInitDataOutBuf=""GET BitMapFile,IconDirTempInt=IconDir.dwBytesInResI=0SEEK BitMapFile,IconDir.dwImageOffsetBEGIN LOOP	FOR J=1 TO 32		INCR I		IF I>TempInt THEN			IF OutBuf<>"" THEN				GOSUB OutInitData			END IF			GOTO CreateIcon1		END IF		GET BitMapFile,AsciiByte		TempName=HEX(AsciiByte)		IF LEN(TempName)=1 THEN			TempStr="$0"+TempName		ELSE			TempStr="$"+TempName		END IF		IF J=1 THEN			OutBuf=OutBuf+" db "+TempStr		ELSE			OutBuf=OutBuf+","+TempStr		END IF						NEXT J	GOSUB OutInitData	OutBuf=""END LOOPCreateIcon1:CLOSE BitMapFileImportFcnTable(ptrCreateIconFromResource).ImportFcnUse=TRUEOutBuf="invoke CreateIconFromResource,!"+Op1Name+","+STR(TempInt)+","+Opt+",$30000"GOSUB OutCodeDataIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"END IFGOSUB OutCodeDataGOTO MainLoopBadIconFile:TempStr="Fatal Error: Icon File does not exist"ErrNo=$ffGOTO MainLoopLoadIconX:IconCursorFlag=TRUELoadIconCursor:ErrGUIGOSUB ExprOp1Name=TSymNameOp1Mod=TDataModIF IconCursorFlag=TRUE THEN	IF TSubType<>ICON THEN		ErrNo=ErrIVType		GOTO MainLoop	END IF	FcnName="IMAGE_ICON"ELSE	IF TSubType<>CURSOR THEN		ErrNo=ErrIVType		GOTO MainLoop	END IF	FcnName="IMAGE_CURSOR"END IFCommaMainGOSUB GetStringOpErrMainImportFcnTable(ptrLoadImage).ImportFcnUse=TRUEOutBuf="invoke LoadImage,0,["+TSymName+"],"+FcnName+",0,0,$10"GOSUB OutCodeDataGOSUB SetStatusIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"END IFGOSUB OutCodeDataGOTO MainLoopLoadCursorX:IconCursorFlag=FALSEGOTO LoadIconCursorLoadImageX:ErrGUIGOSUB ExprOp1Name=TSymNameOp1Mod=TDataModIF TSubType<>BITMAP THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFCommaMainGOSUB GetStringOpErrMainImageLibUsed=TRUEImportFcnTable(ptrBitmapFromFile).ImportFcnUse=TRUEOutBuf="invoke BitmapFromFile,["+TSymName+"]"GOSUB OutCodeDataGOSUB SetStatusIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"END IFGOSUB OutCodeDataGOTO MainLoopCreateImage:ErrGUIGOSUB ExprOp1Name=TSymNameOp1Mod=TDataModIF TSubType<>BITMAP THEN	ErrNo=ErrIVType	GOTO MainLoopEND IFCommaMainGOSUB NexTokenTempStr=TokenBufGOSUB NexTokenTempStr=TempStr+TokenBufGOSUB NexTokenTempStr=TempStr+TokenBufIF RIGHT(TempStr,4)<>".bmp" AND RIGHT(TempStr,4)<>".jpg" AND RIGHT(TempStr,4)<>".gif" THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFON ERROR GOTO BadImageFileOPEN TempStr FOR INPUT AS ImageFileON ERROROutBuf="!"+Op1Name+":"GOSUB OutInitDataOutBuf=""TempInt=LOF(ImageFile)I=0BEGIN LOOP	FOR J=1 TO 32		INCR I		IF I>TempInt THEN			IF OutBuf<>"" THEN				GOSUB OutInitData			END IF			GOTO CreateImage1		END IF		GET ImageFile,AsciiByte		TempName=HEX(AsciiByte)		IF LEN(TempName)=1 THEN			TempStr="$0"+TempName		ELSE			TempStr="$"+TempName		END IF		IF J=1 THEN			OutBuf=OutBuf+" db "+TempStr		ELSE			OutBuf=OutBuf+","+TempStr		END IF						NEXT J	GOSUB OutInitData	OutBuf=""END LOOPCreateImage1:CLOSE ImageFileImageLibUsed=TRUEImportFcnTable(ptrBitmapFromMemory).ImportFcnUse=TRUEOutBuf="invoke BitmapFromMemory,!"+TSymName+","+STR(TempInt)GOSUB OutCodeDataIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"END IFGOSUB OutCodeDataGOTO MainLoopBadImageFile:TempStr="Fatal Error: ImageFile File does not exist"ErrNo=$ffGOTO MainLoopPassEventX:ErrGUIOutBuf="mov [!PassEvent],1"GOSUB OutCodeDataGOTO MainLoopPassKbdEventX:ErrGUIOutBuf="mov [!PassKbdEvent],1"GOSUB OutCodeDataGOTO MainLoopTrapColorChangeEventX:GOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFOutBuf="mov [!TrapColorChange],"+SymbolSafGOSUB OutCodeDataGOTO MainLoopReadCardX:CsmdllLibUsed=TRUE' READCARD Buffer,NumBytesImportFcnTable(ptrCSMGetDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMGetDriveHandle, [DriverName], DriverHandle, 1"GOSUB OutCodeData' Get and test status, set STATUS to -1 if badImportFcnTable(ptrCSMReadBlock).ImportFcnUse=TRUEOutBuf="invoke CSMReadBlock,[DriverHandle],0,2,0,CardBuf,262144"GOSUB OutCodeDataGOSUB SetStatusImportFcnTable(ptrCSMReleaseDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMReleaseDriveHandle,[DriverHandle]"GOSUB OutCodeDataGOTO MainLoopWriteCardX:CsmdllLibUsed=TRUE' WRITECARD Buffer,NumBytesImportFcnTable(ptrCSMGetDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMGetDriveHandle, [DriverName], DriverHandle, 1"GOSUB OutCodeData' Get and test status, set STATUS to -1 if badImportFcnTable(ptrCSMWriteBlock).ImportFcnUse=TRUEOutBuf="invoke CSMWriteBlock,[DriverHandle],0,2,96,0,CardBuf,0,262144"GOSUB OutCodeDataGOSUB SetStatusImportFcnTable(ptrCSMReleaseDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMReleaseDriveHandle,[DriverHandle]"GOSUB OutCodeDataGOTO MainLoopUseImportX:GOSUB NexTokenFOR I=1 TO LastImportFcn	IF ImportFcnTable(I).ImportFcnAlias=TokenSaf THEN		ImportFcnTable(I).ImportFcnUse=TRUE		GOTO MainLoop	END IFNEXT IErrNo=ErrUDSymGOTO MainLoopImportFunctionX:GOTO MainLoopExportFunctionX:GOTO MainLoopCreateTaskX:ErrGUIGOSUB NexTokenOutBuf="!"+TokenSaf+" rd 1"GOSUB OutUninitDataImportFcnTable(ptrCreateThread).ImportFcnUse=TRUEOutBuf="invoke CreateThread,0,0,"+TokenSaf+",0,0,STATUS"GOSUB OutCodeDataOutBuf="mov [!"+TokenSaf+"],eax"GOSUB OutCodeDataGOTO MainLoopSleepX:ErrGUIGOSUB GetIntOpErrMainImportFcnTable(ptrSleep).ImportFcnUse=TRUEOutBuf="invoke Sleep,eax"GOSUB OutCodeDataGOTO MainLoopSetTaskPriorityX:ErrGUIGOSUB NexTokenFcnName="!"+TokenSafCommaMainGOSUB GetIntOpErrMainImportFcnTable(ptrSetThreadPriority).ImportFcnUse=TRUEOutBuf="invoke SetThreadPriority,["+FcnName+"],eax"GOSUB OutCodeDataGOTO MainLoopBeginTaskX:ErrGUIGOSUB FcnFlagChkErrMainTaskFlag=TRUEProcFcnFlag=TRUEGOSUB NexTokenOutBuf=TokenSaf+":"GOSUB OutCodeDataOutBuf="pop eax"GOSUB OutCodeDataGOSUB SetStatusOutBuf="push esp"GOSUB OutCodeDataGOTO MainLoopEndTask:ErrGUIIF TaskFlag=FALSE THEN	ErrNo=ErrEndTask	GOTO MainLoopEND IFOutBuf="pop esp"GOSUB OutCodeDataOutBuf="ret"GOSUB OutCodeDataTaskFlag=FALSEProcFcnFlag=FALSEGOSUB MakeLineGOSUB OutCodeDataGOTO MainLoopLaunchX:GOSUB ExprIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymName+"; Get src"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataGOSUB NexTokenIF TokenLen=0 THEN	OutBuf="mov [_PrintBuf+12],0"	GOSUB OutCodeDataELSE	IF TokenBuf<>"," THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	GOSUB Expr	IF TDataType<>STRINGVAR THEN		ErrNo=ErrTypMis		GOTO MainLoop	END IFEND IFOutBuf="mov edi,_PrintBuf"GOSUB OutCodeDataOutBuf="mov esi,"+TSymName+"; Get src"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataImportFcnTable(ptrShellExecute).ImportFcnUse=TRUEOutBuf="invoke ShellExecute,[!OBMain],NULL,[_IOBuffer],[_PrintBuf],0,SW_SHOWNORMAL"GOSUB OutCodeDataGOTO MainLoopGetDateTimeX:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFImportFcnTable(ptrGetLocalTime).ImportFcnUse=TRUEOutBuf="invoke GetLocalTime,"+TokenSafGOSUB OutCodeDataGOTO MainLoopGetGMTDateTimeX:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFImportFcnTable(ptrGetSystemTime).ImportFcnUse=TRUEOutBuf="invoke GetSystemTime,"+TokenSafGOSUB OutCodeDataGOTO MainLoopGetDateFormatX:FcnName="GetDateFormat"GetDateTimeFormat:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFObjectName=TokenSafCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).DataType<>STRINGVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFOutBuf="mov [_ArgSafe0],"+STR(SymTable(SymNdx).Detail)GOSUB OutCodeDataImportFcnTable(ptrGetDateFormat).ImportFcnUse=TRUEImportFcnTable(ptrGetTimeFormat).ImportFcnUse=TRUEOutBuf="invoke "+FcnName+",0,0,"+ObjectName+",["+TSymName+"],["+SymTable(SymNdx).SymName+"],[_ArgSafe0]"GOSUB OutCodeDataGOTO MainLoopGetTimeFormatX:FcnName="GetTimeFormat"GOTO GetDateTimeFormatTimeAddX:; TIMEADD DateTime1,SecondsGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IF;IF TDataType<>DATETIME THEN;	ErrNo=ErrTypMis;	GOTO MainLoop;END IFFcnOp1Nam=TokenSafCommaMainGOSUB GetIntOpErrMainOutBuf="mov edx,10000000"GOSUB OutCodeDataOutBuf="imul edx"GOSUB OutCodeDataOutBuf="mov [!dwLowDateTime2],eax"GOSUB OutCodeDataOutBuf="mov [!dwHighDateTime2],edx"GOSUB OutCodeDataImportFcnTable(ptrSystemTimeToFileTime).ImportFcnUse=TRUEOutBuf="invoke SystemTimeToFileTime, dword "+FcnOp1Nam+",!dwLowDateTime1"GOSUB OutCodeDataOutBuf="mov eax,[!dwLowDateTime1]"GOSUB OutCodeDataOutBuf="mov edx,[!dwHighDateTime1]"GOSUB OutCodeDataOutBuf="add eax,[!dwLowDateTime2]"GOSUB OutCodeDataOutBuf="adc edx,[!dwHighDateTime2]"GOSUB OutCodeDataOutBuf="mov [!dwLowDateTime1],eax"GOSUB OutCodeDataOutBuf="mov [!dwHighDateTime1],edx"GOSUB OutCodeDataImportFcnTable(ptrFileTimeToSystemTime).ImportFcnUse=TRUEOutBuf="invoke FileTimeToSystemTime,!dwLowDateTime1, dword "+FcnOp1Nam+""GOSUB OutCodeDataGOTO MainLoopCallX:GOSUB NexTokenIF TokenBuf="sub" THEN	GOTO GosubXELSE	IF TokenBuf="proc" THEN		GOTO CallProc	ELSE		GOTO AssemblyX	END IFEND IFGOTO MainLoopCallProc:GOSUB NexTokenSymTemp.SymName=TokenSafFcnName=TokenSafGOSUB SymSrchGOSUB GetSymTempIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTemp.DataType<>PROC THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFFcnDataMod=SymTable(SymNdx).DataModFcnSymNdx=SymNdxIF SymTemp.FcnArgs<>0 THEN	GOSUB PushArgs	ErrMainEND IFTempInt=FcnDataModTempInt=LOR(TempInt,CalledBit)SymTable(FcnSymNdx).DataMod=TempIntOutBuf="call "+FcnNameGOSUB OutCodeDataGOTO MainLoopBeginSeg:IF SegFlag=TRUE THEN	ErrNo=ErrSegInSeg	GOTO MainLoopEND IFSegFlag=TRUEINCR SegNumGOSUB ProcLabelErrMainSymbolSaf=SymbolSaf+":"GOSUB OutLabelGOTO MainLoopEndSeg:IF SegFlag=FALSE THEN	ErrNo=ErrEndSeg	GOTO MainLoopEND IFSegFlag=FALSEOutBuf="_Seg"+STR(SegNum)+":"GOSUB OutCodeDataEndSegFlag=TRUEGOTO GotoXExitSeg:IF SegFlag=FALSE THEN	ErrNo=ErrExitSeg	GOTO MainLoopEND IFOutBuf="jmp "+"_Seg"+STR(SegNum)GOSUB OutCodeDataGOTO MainLoopRunSeg:GOTO GotoXGOTO MainLoopRunX:GOSUB NexTokenIF TokenBuf="seg" THEN RunSegGOTO MainLoopAssemblyX:StartFlag=TRUEOutBuf=SrcLineGOSUB OutCodeDataGOTO MainLoopFinish:IF InpFilPtr>1 THEN	CLOSE InpFile(InpFilPtr)	DECR InpFilPtr	GOTO MainLoopEND IFGOSUB ChkUseCLOSE InpFile(InpFilPtr)IF LastStmt="data" THEN	DataFlag=FALSEEND IFINCR TimerNumOutBuf="!Timers equ "+STR(TimerNum)GOSUB OutDeclareIF LastStmt<>"end" AND GUIFlag=FALSE THEN	OutBuf=""	GOSUB OutCodeData	OutBuf="; Automatic END statement"	GOSUB OutCodeData	OutBuf="xor eax,eax"	GOSUB OutCodeData	ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE	OutBuf="invoke ExitProcess, eax"	GOSUB OutCodeDataEND IFOutBuf="_ErrExit:"GOSUB OutCodeIF GUIFlag=FALSE THEN	ImportFcnTable(ptrputs).ImportFcnUse=TRUE	OutBuf="cinvoke puts,_ErrExitMsg"	GOSUB OutCodeELSE	OutBuf="invoke MessageBox,[!OBMain],_ErrExitMsg,0,MB_OK"	GOSUB OutCodeDataEND IF	OutBuf="mov eax,[ERR]"GOSUB OutCodeDataImportFcnTable(ptrExitProcess).ImportFcnUse=TRUEOutBuf="invoke ExitProcess, eax"GOSUB OutCodeDataOutBuf="; End of Declaration Section"GOSUB OutDeclareGOSUB MakeLineGOSUB OutDeclareCLOSE DeclareFileOutBuf="!ObjectCount dd "+STR(ObjectCtr)GOSUB OutInitDataOutBuf="; End of Initialized Data Section"GOSUB OutInitDataGOSUB MakeLineGOSUB OutInitDataOutBuf=""GOSUB OutInitDataOutBuf="; Start of Uninitialized Data Section"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataCLOSE DataFileOutBuf="; End of Uninitialized Data Section"GOSUB OutUninitDataGOSUB MakeLineGOSUB OutUninitDataOutBuf=""GOSUB OutUninitDataOutBuf="; Start of Control Descriptor Section"GOSUB OutUninitDataCLOSE DimFileCLOSE DescFileCLOSE PreCodeFileOutBuf="; End of Code Section"GOSUB OutCodeGOSUB MakeLineGOSUB OutCodeCLOSE CodeFileIF ExclamationOK=TRUE THEN	RichEdLibUsed=TRUE	RAEditLibUsed=TRUE	RAGridLibUsed=TRUE	CsmdllLibUsed=TRUE	DrawProgressLibUsed=TRUE	ImageLibUsed=TRUE	SprShtLibUsed=TRUE	ButtonExLibUsed=TRUEEND IFIF RichEdLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!RichEd"	GOSUB OutInitCodeEND IFIF RAEditLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!RAEdit"	GOSUB OutInitCodeEND IFIF RAGridLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!RAGrid"	GOSUB OutInitCodeEND IFIF CsmdllLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!Csmdll"	GOSUB OutInitCodeEND IFIF DrawProgressLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!DrawProgress"	GOSUB OutInitCodeEND IFIF ImageLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!ImageLib"	GOSUB OutInitCodeEND IFIF SprShtLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!SprShtLib"	GOSUB OutInitCodeEND IFIF ButtonExLibUsed=TRUE THEN	OutBuf="invoke LoadLibrary,!!ButtonExLib"	GOSUB OutInitCodeEND IFOutBuf="ret"GOSUB OutInitCodeOutBuf="; End of Init Section"GOSUB OutInitCodeGOSUB MakeLineGOSUB OutInitCodeCLOSE InitFileOutBuf="; End of Function Section"GOSUB OutFunctionGOSUB MakeLineGOSUB OutFunctionCLOSE FunctionFileCLOSE ExportFileCLOSE ResourceFileON ERROR GOTO NoCFileDELETE BareFileName+".asm"NoCFile:ON ERROR;******;TempStr=STR(BasicLineCtr)+" OmniBasic lines compiled to "+STR(AsmLineCtr)+" Assembler lines";GOSUB OutPrint;TempStr="";GOSUB OutPrint AsmFileName=BareFileName+".asm"OPEN AsmFileName FOR SCRATCH AS OutFileOPEN "_DeclareFile" FOR INPUT AS DeclareFileFilBufSiz=LOF(DeclareFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DeclareFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DeclareFileDELETE "_DeclareFile"RESTORE IncludesOutBuf=""WRITE OutFile,OutBufOutBuf="; Import Section"WRITE OutFile,OutBufOutBuf=""WRITE OutFile,OutBufBEGIN LOOP	READ OutBuf	EXIT IF OutBuf="ENDTEXT"	WRITE OutFile,OutBuf	INCR AsmLineCtrEND LOOPOutBuf=""WRITE OutFile,OutBufOutBuf="section '.idata' import data readable writeable"WRITE OutFile,OutBufOutBuf=""WRITE OutFile,OutBufFOR I=1 TO LastImportLib; Find last fcn for each Lib	TempInt=0	FOR J=1 TO LastImportFcn		IF ImportFcnTable(J).ImportFcnUse=TRUE AND ImportFcnTable(J).ImportLibUseNdx=I THEN			TempInt=J		END IF			NEXT J	IF TempInt<>0 THEN		ImportFcnTable(TempInt).ImportFcnLastUsed=TRUE	END IFNEXT IFOR I=1 TO LastImportFcn; Mark each Lib used as used	IF ImportFcnTable(I).ImportFcnUse=TRUE THEN		TempInt=ImportFcnTable(I).ImportLibUseNdx		ImportLibTable(TempInt).ImportLibUse=TRUE	END IFNEXT ITempInt=0; Find last Lib usedFOR I=1 TO LastImportLib	IF ImportLibTable(I).ImportLibUse=TRUE THEN		TempInt=I	END IF		NEXT IImportLibTable(TempInt).ImportLibLastUsed=TRUEOutBuf="library "; Output the Lib SectionFOR I=1 TO LastImportLib	IF ImportLibTable(I).ImportLibUse=TRUE THEN		OutBuf=OutBuf+ImportLibTable(I).ImportLibAlias+","+CHR(OBQUOTE)+ImportLibTable(I).ImportLibName+CHR(OBQUOTE)		IF ImportLibTable(I).ImportLibLastUsed=FALSE THEN			OutBuf=OutBuf+CHR$($2c)+CHR$($5c)		END IF		WRITE OutFile,OutBuf		OutBuf="        "	END IFNEXT IOutBuf=""WRITE OutFile,OutBufFOR I=1 TO LastImportLib; Output the Fcn lists	TempStr="import"	IF ImportLibTable(I).ImportLibUse=TRUE THEN		OutBuf=ImportLibTable(I).ImportLibAlias+":"		WRITE OutFile,OutBuf		FOR J=1 TO LastImportFcn			OutBuf=CHR$($09)+TempStr+CHR$($09)			IF ImportFcnTable(J).ImportLibUseNdx=I AND ImportFcnTable(J).ImportFcnUse=TRUE THEN				OutBuf=OutBuf+ImportFcnTable(J).ImportFcnAlias+CHR$($2c)+CHR(OBQUOTE)+ImportFcnTable(J).ImportFcnName+CHR(OBQUOTE)				IF ImportFcnTable(J).ImportFcnLastUsed=FALSE THEN					OutBuf=OutBuf+CHR$($2c)+CHR$($5c)				END IF				WRITE OutFile,OutBuf				TempStr=""			END IF		NEXT J	END IFNEXT IOutBuf=""WRITE OutFile,OutBufOutBuf="; End of Import Section"WRITE OutFile,OutBufGOSUB MakeLineWRITE OutFile,OutBufOutBuf=""WRITE OutFile,OutBufOPEN "_DataFile" FOR INPUT AS DataFileFilBufSiz=LOF(DataFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DataFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DataFileDELETE "_DataFile"OPEN "_DimFile" FOR INPUT AS DimFileFilBufSiz=LOF(DimFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DimFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DimFileDELETE "_DimFile"OPEN "_DescFile" FOR INPUT AS DescFileFilBufSiz=LOF(DescFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DescFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DescFileDELETE "_DescFile"OPEN "_PreCodeFile" FOR INPUT AS PreCodeFileFilBufSiz=LOF(PreCodeFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD PreCodeFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizCLOSE PreCodeFileDELETE "_PreCodeFile"OPEN "_CodeFile" FOR INPUT AS CodeFileFilBufSiz=LOF(CodeFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD CodeFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE CodeFileDELETE "_CodeFile"OPEN "_InitFile" FOR INPUT AS InitFileFilBufSiz=LOF(InitFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD InitFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE InitFileDELETE "_InitFile"OPEN "_FunctionFile" FOR INPUT AS FunctionFileFilBufSiz=LOF(FunctionFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD FunctionFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE FunctionFileDELETE "_FunctionFile"OPEN "_ExportFile" FOR INPUT AS ExportFileFilBufSiz=LOF(ExportFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD ExportFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE ExportFileDELETE "_ExportFile"OPEN "_ResourceFile" FOR INPUT AS ResourceFileFilBufSiz=LOF(ResourceFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD ResourceFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE ResourceFileDELETE "_ResourceFile"CLOSE OutFile;'end;******FOR Ctr1=1 TO LastSym	TDataType=SymTable(Ctr1).DataType	IF TDataType=LABELVAR OR TDataType=FCN OR TDataType=PROC THEN		TDetail=SymTable(Ctr1).Detail		TDataMod=SymTable(Ctr1).DataMod		IF TDetail=LabelUnresolved THEN			IF TDataType=LABELVAR THEN				INCR ErrCnt				TempStr="Label unresolved: "+SymTable(Ctr1).SymName				SETDEFAULTCURSOR				WARNINGBOX "Error",TempStr,MB_OK				RETURN			ELSE				IF TDataType=FCN OR TDataType=PROC THEN					IF LAND(TDataMod,UsrFcnBit)=UsrFcnBit THEN						IF LAND(TDataMod,CalledBit)=CalledBit THEN							INCR ErrCnt							TempStr="Fcn or proc unresolved: "+SymTable(Ctr1).SymName							SETDEFAULTCURSOR							WARNINGBOX "Error",TempStr,MB_OK							RETURN						END IF					END IF				END IF			END IF								END IF	END IFNEXT Ctr1lbl9999:IF ConStkPtr<>0 THEN	TempStr="Unbalanced control structure in line "+STR(ConStk(ConStkPtr).ConLine)	SETDEFAULTCURSOR	WARNINGBOX "Error",TempStr,MB_OK	RETURN	DECR ConStkPtr; ???	INCR ErrCnt	GOTO lbl9999END IFIF GFNdx<>1 THEN	TempStr="Unbalanced conditional stack"	SETDEFAULTCURSOR	WARNINGBOX "Error",TempStr,MB_OK	RETURN	INCR ErrCntEND IFIF ProcFcnFlag=TRUE THEN	TempStr="Proc, fcn, event, task, or sub not complete"	SETDEFAULTCURSOR	WARNINGBOX "Error",TempStr,MB_OK	RETURN	INCR ErrCntEND IFIF ErrCnt<>0 THEN	TempStr=STR(ErrCnt)+" error(s)"	SETDEFAULTCURSOR	WARNINGBOX "Error",TempStr,MB_OK	RETURNELSE	REM Do assembly here;	PRINT (GETTICKCOUNT()-StartTime)	IF AsmOutFlag=FALSE AND NoGen=FALSE THEN;		TempStr="Assemble:";		GOSUB OutPrint		GOSUB Assemble;		PRINT (GETTICKCOUNT()-StartTime)	END IFEND IFIF AsmOutFlag=FALSE OR NoGen=TRUE THEN	DELETE BareFileName+".asm"END IFIF AsmOutFlag=TRUE OR NoGen=TRUE THEN	GOSUB FormatCompileTime	MSGBOX "Success",TempName,MB_OK	GOSUB ShowMode	IF AsmOutFlag=TRUE THEN		FileName=BareFileName+".asm"		Edit.LOADFILE FileName		SaveFileName=FileName		BareFileName=LEFT(FileName,LEN(FileName)-4)		Extension=RIGHT(FileName,4)		TempStr=ProgramName+"     ["+FileName+"]"		OBMain.TEXT=TempStr		Timer1.TIME=50		StatusBar.SETTEXT 5,"Not Changed"		StatusBarSafe5="Edit Objects"		StatusBar.SETTEXT 5,StatusBarSafe5		Changed=FALSE		Edit.SETFOCUS	END IF	END IFRETURNNoInpFile:TempStr="Cannot open file: "+FileNameSETDEFAULTCURSORWARNINGBOX "Error",TempStr,MB_OKRETURN;***** Subroutine Section ******DimVar:GOSUB PrepVarErrRetIF SymFound=TRUE THEN	ErrNo=ErrDupSym	RETURNEND IFIF SubCtr<>0 THEN	DMArray=$ff	ArraySize=SubValue(1)*SubValue(2)*SubValue(3)	SymTemp.ArrayDim1=SubValue(1)	SymTemp.ArrayDim2=SubValue(2)	SymTemp.ArrayDim3=SubValue(3)	SymTemp.ArrayDims=SubCtr	IF SubCtr>1 THEN		MultiFlag=$ff		TDataMod=LOR(TDataMod,MultiBit)	END IF	IF ArraySize=0 THEN		DMReDim=$ff		TDataMod=LOR(TDataMod,ReDimBit)	END IFEND IFGOSUB NexTokenIF TokenBuf<>"as" THEN	ErrNo=ErrSyntax	RETURNEND IFGOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	RETURNEND IFSymTemp.SubType=NONESELECT CASE TokenBuf	CASE "boolean"		TDataType=BOOLVAR		SymType=" rb "		TDataSize=1		TDataAddr=1		GOTO DimVar1	CASE "byte"		TDataType=BYTEVAR		SymType=" rb "		TDataSize=1		TDataAddr=1		GOTO DimVar1	CASE "integer"		TDataType=WORDVAR		SymType=" rw "		TDataSize=2		TDataAddr=2		GOTO DimVar1	CASE "long"		TDataType=LONGVAR		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "quad"		TDataType=LONGVAR		SymType=" rq "		TDataSize=8		TDataAddr=8		GOTO DimVar1	CASE "label"		TDataType=LABELPTR		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "float"		TDataType=FLOATVAR		SymType=" rf "		TDataSize=8		TDataAddr=8		GOTO DimVar1	CASE "string"		TDataType=STRINGVAR		SymType=" rb "		IF NextByte<>"*" THEN			TempInt=255; Default string size		ELSE			GOSUB NexToken; Eat '*'			GOSUB NexToken			TempStr=TokenSaf			GOSUB StrSiz			ErrRet		END IF		SymTemp.Detail=TempInt		IF TypeFlag=0 AND DMArray=0 THEN			VectorFlag=$ff			TDataMod=LOR(TDataMod,VectorBit)		END IF		TDataSize=TempInt		TDataAddr=TempInt		GOTO DimVar1	CASE "text"		IF DMArray<>0 THEN			ErrNo=ErrTextArray			RETURN		END IF		TDataType=TEXT		TDataSize=0		TDataAddr=0		GOTO DimVar1	CASE "file"		TDataType=LONGVAR		SymTemp.SubType=FILE		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "device"		TDataType=LONGVAR		SymTemp.SubType=DEVICE		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "font"		TDataType=LONGVAR		SymTemp.SubType=FONT		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "icon"		TDataType=LONGVAR		SymTemp.SubType=ICON		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "cursor"		TDataType=LONGVAR		SymTemp.SubType=CURSOR		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "bitmap"		TDataType=LONGVAR		SymTemp.SubType=BITMAP		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "handle"		TDataType=LONGVAR		SymTemp.SubType=HANDLE		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "menu"		TDataType=LONGVAR		SymTemp.SubType=MENU		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "timer"		TDataType=TIMER			INCR TimerNum		SymTemp.Detail=TimerNum		IF 	DMArray<>0 THEN			TimerNum=TimerNum+ArraySize-1		END IF		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "obcomm"		TDataType=OBCOMM		SymType=" rb "		TDataSize=100		TDataAddr=100		GOTO DimVar1	CASE ELSE		GOSUB ObjLook		IF ObjNdx<>0 THEN			ObjectCtr=ObjectCtr+SubValue(1)			TDataType=ObjNdx+99			SymType=" rd "			TDataSize=192			TDataAddr=192			IF SubCtr>1 THEN; 1 Dim arrays only for controls				ErrNo=ErrSyntax				RETURN			END IF			IF TDataType=FORM OR TDataType=FRAME  OR TDataType=TABFOLDER OR TDataType=TOOLBAR OR TDataType=STATUSBAR OR TDataType=TOOLWINDOW THEN				IF SubCtr>0 THEN; 'Holder' Array not allowed					ErrNo=ErrSyntax					RETURN				END IF			END IF		ELSE			IF TokenBuf="logfont" THEN				TDataMod=LogFontBit			END IF			IF TokenBuf="datetime" THEN				TDataMod=DateTimeBit			END IF			TSymName=SymTemp.SymName			TypePtr=SymNdx			SubCtrSaf=SubCtr			SubValSaf=SubValue			GOSUB TokenSym1			ErrRet			IF SymFound=FALSE OR SymTable(SymNdx).DataType<>TYPE THEN				ErrNo=ErrIVType				RETURN			END IF			TDataSize=SymTable(SymNdx).DataSize			TDataAddr=SymTable(SymNdx).DataSize			SymType=" rb "			SymTemp.Detail=SymNdx			SymNdx=TypePtr			SymTemp.SymName=TSymName			SubCtr=SubCtrSaf			SubValue=SubValSaf			TDataType=COMPLEX		END IFEND SELECTDimVar1:GOSUB NexTokenIF TokenLen=0 OR TokenBuf=";" THEN DimVar2IF TDataType=TEXT THEN	RETURNEND IFIF TokenBuf="=" THEN	IF TDataType<1 OR TDataType>6 OR SymTemp.SubType<>NONE THEN		ErrNo=ErrSyntax		RETURN	END IF	TDataMod=LOR(TDataMod,InitDataBit)	GOTO DimVar2; Temporary Bypass;;;END IFIF TokenBuf="pointer" THEN	IF TypeFlag<>0 OR DMArray<>0 THEN		ErrNo=ErrIVParm		RETURN	END IF	DMAddr=$ff	VectorFlag=0	SymType=" rd "	TDataSize=4	TDataAddr=4	TDataMod=LOR(TDataMod,PointerBit)	GOTO DimVar2END IFIF TokenBuf="alias" THEN	IF TypeFlag<>0 THEN		ErrNo=ErrIVParm		RETURN	END IF	IF TDataType=STRINGVAR THEN		ErrNo=ErrSyntax		RETURN	END IF	AliasFlag=$ff	GOSUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		RETURN	END IF	SymNdxSaf=SymNdx	HandleName=SymTemp.SymName	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		RETURN	END IF	AliasDataType=SymTable(SymNdx).DataType	TempInt=SymTable(SymNdx).DataMod	IF LAND(TempInt,ArrayBit)=ArrayBit THEN		AliasDataType=BYTEVAR' (Anything but string)	END IF	SymNdx=SymNdxSaf	SymTemp.SymName=HandleName	GUITempName=TokenSaf	GOTO DimVar2END IFIF TokenBuf="vector" THEN	IF TypeFlag<>0 OR DMAddr<>0 THEN		ErrNo=ErrIVParm		RETURN	END IF	VectorFlag=$ff	TDataMod=LOR(TDataMod,VectorBit)	GOTO DimVar2END IFErrNo=ErrIVModRETURNDimVar2:SymTemp.DataType=TDataTypeIF DMArray<>0 THEN	TDataMod=LOR(ArrayBit,TDataMod)END IFDimOK=$ffSymTemp.DataMod=TDataModSymTemp.DataSize=ArraySize*TDataSizeSymTemp.DataAddr=TDataAddrIF TDataType=STRINGVAR OR TDataType=COMPLEX OR TDataType>99 THEN	ArraySize=SymTemp.DataSizeEND IFRETURNDecVar:TSymName=SymTemp.SymNameIF AliasFlag<>0 THEN	GOSUB OutUninitData; Basic line as comment	IF AliasDataType=STRINGVAR THEN		OutBuf=TSymName+" equ "+GUITempName+"+12"	ELSE		OutBuf=TSymName+" equ "+GUITempName	END IF	GOSUB OutUninitData	RETURNEND IFComment=OutBufIF DMAddr<>0 THEN	GOSUB OutUninitData; Basic line as comment	OutBuf=TSymName+" rd 1"	GOSUB OutUninitData	RETURNEND IFIF DMReDim<>0 THEN	GOSUB OutInitData; Basic line as comment	BufName=TSymName	GOSUB MakeBuffer	RETURNEND IFIF VectorFlag=$ff THEN	IF TDataType=STRINGVAR AND DMArray=0 THEN		GOSUB OutInitData; Basic line as comment		OutBuf="align 4"		GOSUB OutInitData		OutBuf=TSymName+" dd "+TempStr+"+12"		GOSUB OutInitData		OutBuf=" dd "+STR(TDataSize)		GOSUB OutInitData		OutBuf=" dd 0"		GOSUB OutInitData		OutBuf=" rb "+STR(ArraySize)		GOSUB OutInitData	ELSE		GOSUB OutUninitData; Basic line as comment		OutBuf="align 4"		GOSUB OutUninitData		OutBuf=TSymName+" rd 3"		GOSUB OutUninitData	END IF	RETURNEND IFIF TDataType=STRINGVAR THEN; String array case	GOSUB OutUninitData; Basic line as comment	OutBuf=TSymName+" rb "+STR(ArraySize)	GOSUB OutUninitData	RETURNEND IFIF DMArray<>0 OR TDataType=COMPLEX THEN	IF TDataType<100 THEN		GOSUB OutUninitData		OutBuf="align 4"		GOSUB OutUninitData			OutBuf=TSymName+SymType+STR(ArraySize)		GOSUB OutUninitData	ELSE		IF TDataType=OBCOMM THEN			GOSUB OutUninitData			OutBuf=TSymName+SymType+STR(ArraySize)			GOSUB OutUninitData		ELSE			GOSUB OutDesc			OutBuf="!"+TSymName+SymType+STR(ArraySize)			GOSUB OutDesc		END IF			END IF	RETURNELSE	IF TDataSize=2 THEN		OutBuf="align 2"		GOSUB OutUninitData	ELSE		IF TDataSize>=4 AND TDataType<100 THEN			OutBuf="align 4"			GOSUB OutUninitData		END IF	END IF	IF TDataType<100 THEN		OutBuf=Comment		GOSUB OutUninitData		OutBuf=TSymName+SymType+"1"		GOSUB OutUninitData	ELSE		OutBuf=Comment		IF TDataType=OBCOMM THEN			GOSUB OutUninitData			OutBuf=TSymName+SymType+"100"			GOSUB OutUninitData		ELSE			GOSUB OutDesc			OutBuf="!"+TSymName+SymType+"192"			GOSUB OutDesc		END IF			END IFEND IFRETURNPrepVar:TDataMod=LAND(MemberBit,TypeFlag)SymTemp.Detail=0GOSUB ClrDatTypVectorFlag=0MultiFlag=0DimOK=0DimFlag=$ffTDataType=COMPVARTDataSize=1ArraySize=1GOSUB ClrSymGOSUB TokenSymDataSymNdx=SymNdxRETURNVarBlank:OutBuf=""GOSUB OutUninitDataRETURNOutLabel:IF LabelFlag=$ff THEN	OutBuf=SymbolSaf	GOSUB OutCodeDataEND IFRETURNGetExp:FloatFlag=0TypePtr=0ExpEnd=0ExpNdx=1ExpLen=0ParenCnt=0FcnCtr=0AECtr=0ExpTable(ExpNdx)=1LastEntry=SymTable(ExpTable(ExpNdx))GetExp1:IF ExpEnd=$ff THEN ExpExitIF NextByte="," AND FcnCtr=0 AND AECtr=0 THEN ExpExitIF IgnoreRightParen<>0 AND SrcNdx+1=EndNdx THEN ExpExitIF IgnoreRightParen<>0 AND NextByte=")" AND ParenCnt<1 THEN ExpExitGetExp2:GOSUB NexTokenIF TokenLen=0 THEN ExpExitIF TokenBuf="," THEN	GOSUB AddRtGrp2	IncExpNdx	ExpTable(ExpNdx)=2	IncExpNdx	ExpTable(ExpNdx)=1	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1END IF;***********************; Start of Pointer Stuff HereIF TokenBuf="[" THEN	IncExpNdx	GOSUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrIVExp		GOTO ExpExit	END IF	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		GOTO ExpExit	END IF	GOSUB GetSymTemp	IF LAND(SymTemp.DataMod,PointerBit)<>PointerBit THEN		ErrNo=ErrTypMis		GOTO ExpExit	END IF	IF SymTemp.DataType=FLOATVAR THEN		INCR FloatFlag	END IF	IF SymTemp.DataType=COMPLEX THEN		ExpTable(ExpNdx)=24;  cpx begin		IncExpNdx	END IF	ExpTable(ExpNdx)=26;  "["	IncExpNdx	ExpTable(ExpNdx)=SymNdx	LastEntry=SymTemp	GOSUB NexToken	IF TokenBuf<>"]" OR TokenLen=0 THEN		ErrNo=ErrSyntax		GOTO ExpExit	END IF	IncExpNdx	ExpTable(ExpNdx)=27;  put "]" in table	IF SymTemp.DataType<>COMPLEX THEN GetExp1	IncExpNdx	IF NextByte="." THEN		GOSUB NexToken;  eat "."		ExpTable(ExpNdx)=13;  "."		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO ExpExit		END IF		SymTemp.SymName=TokenSaf		GOSUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO ExpExit		END IF		GOSUB GetSymTemp		IF LAND(MemberBit,SymTemp.DataMod)<>MemberBit THEN			ErrNo=ErrTypMis			GOTO ExpExit		END IF		IF SymTemp.DataType=FLOATVAR THEN			INCR FloatFlag		END IF		IncExpNdx		ExpTable(ExpNdx)=SymNdx		IncExpNdx	END IF	ExpTable(ExpNdx)=25;  cpx end	GOTO GetExp1END IF; End of Pointer Stuff Here;***********************IF TokenType=TTypMath THEN	IncExpNdx	SELECT CASE TokenBuf		CASE "+"			GOSUB Unary			ExpTable(ExpNdx)=15		CASE"-"			GOSUB Unary			ExpTable(ExpNdx)=16		CASE "*"			ExpTable(ExpNdx)=17		CASE "/"			ExpTable(ExpNdx)=18		CASE "&"			ExpTable(ExpNdx)=147		CASE "|"			ExpTable(ExpNdx)=148		CASE "^"			ExpTable(ExpNdx)=149	END SELECT	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1END IFIF TokenBuf="(" THEN	IncExpNdx	IF LAND(ArrayBit,LastEntry.DataMod)<>0 AND SymTemp.DataType<$10 THEN		ExpTable(ExpNdx)=3		INCR ParenCnt		ParenStk(ParenCnt)=3		INCR AECtr		IncExpNdx		ExpTable(ExpNdx)=1		GOTO GetExp3	END IF	IF LAND(ArrayBit,LastEntry.DataMod)<>0 AND SymTemp.DataType=LABELPTR THEN		ExpTable(ExpNdx)=3		INCR ParenCnt		ParenStk(ParenCnt)=3		INCR AECtr		IncExpNdx		ExpTable(ExpNdx)=1		GOTO GetExp3	END IF	IF LastEntry.DataType=FCN THEN		ExpTable(ExpNdx)=5		INCR ParenCnt		ParenStk(ParenCnt)=5		INCR FcnCtr		IncExpNdx		ExpTable(ExpNdx)=1		GOTO GetExp3	END IF	IF LastEntry.DataType<>9 AND ExpNdx<>1 THEN		ErrNo=ErrIVExp		GOTO ExpExit	END IF	LevelCnt=1	GOSUB PreScan1	GOSUB AddLftGrp	ExpTable(ExpNdx)=1	INCR ParenCnt	ParenStk(ParenCnt)=1GetExp3:	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1END IFIF TokenBuf=")" THEN	GOSUB AddRtGrp2	IncExpNdx	IF ParenCnt=0 THEN		ErrNo=ErrParen		GOTO ExpExit	END IF	IF ParenStk(ParenCnt)=3 OR ParenStk(ParenCnt)=5 THEN		ExpTable(ExpNdx)=2		IncExpNdx	END IF	ExpTable(ExpNdx)=ParenStk(ParenCnt)+1	IF ExpTable(ExpNdx)=4 THEN		DECR AECtr	END IF	IF ExpTable(ExpNdx)=6 THEN		DECR FcnCtr	END IF	DECR ParenCnt	LastEntry=SymTable(ExpTable(ExpNdx))	GOSUB AddRtGrp1	GOTO GetExp1END IFIF TokenBuf="." THEN	IncExpNdx	ExpTable(ExpNdx)=13	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1END IFSELECT CASE TokenType	CASE TTypSym		IncExpNdx		SymTemp.SymName=TokenBuf		GOSUB SymSearch		IF SymFound=TRUE THEN			GOSUB GetSymTemp			IF SymTemp.DataType=FCN THEN; Function found				IF MID(SrcLine,SrcNdx+1,2)="()" THEN					ExpTable(ExpNdx)=SymNdx					IncExpNdx					INCR SrcNdx					ExpTable(ExpNdx)=5					IncExpNdx					INCR SrcNdx					ExpTable(ExpNdx)=6					NextByte=MID(SrcLine,SrcNdx+1,1)					GOTO GetExp1				END IF				GOSUB PreScan				GOSUB AddLftGrp				LastEntry=SymTemp				ExpTable(ExpNdx)=SymNdx				GOTO GetExp1			END IF		END IF		SymTemp.SymName=TokenSaf		GOSUB SymSrch		IF ErrNo<>0 THEN ExpExit		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO ExpExit		END IF		GOSUB GetSymTemp		IF SymTemp.DataType>=100 THEN;//			GUIObjFlag=$ff;//			RETURN;//		END IF;//		IF SymTemp.DataType=TEXT THEN;//			TextFlag=$ff;//			RETURN;//		END IF;//		IF LAND(SymTemp.DataMod,PointerBit)=0 AND SymTemp.DataType<$10 THEN;  special test for pointer			DataTemp=SymTemp.DataType			IF SymTemp.DataType=FLOATVAR THEN				INCR FloatFlag			END IF		ELSE			DataTemp=LONGVAR		END IF		IF DataTemp>=BOOLVAR AND DataTemp<=STRINGVAR OR DataTemp=COMPLEX OR DataTemp=BUFFER THEN			ExpTable(ExpNdx)=SymNdx			IF LAND(MemberBit,SymTemp.DataMod)<>0 AND LastEntry.SymName<>"." AND SymTemp.DataType<$10 THEN				ErrNo=ErrIVExp				GOTO ExpExit			END IF			IF TypePtr<>0 AND LastEntry.SymName="." THEN				IF SymNdx-TypePtr>SymTable(TypePtr).Detail OR TypePtr>SymNdx THEN					ErrNo=ErrUDSym					GOTO ExpExit				ELSE					TypePtr=0				END IF			END IF			IF DataTemp=COMPLEX THEN				TempStr=NextByte				GOSUB PreScan				GOSUB AddLftGrp				NextByte=TempStr				INCR ParenCnt				ParenStk(ParenCnt)=24				ExpTable(ExpNdx)=24				IncExpNdx				TypePtr=SymTemp.Detail			END IF			IF DataTemp<>COMPLEX AND LAND(ArrayBit,SymTemp.DataMod)=ArrayBit AND SymTemp.DataType<$10 THEN				TempStr=NextByte				GOSUB PreScan				GOSUB AddLftGrp				NextByte=TempStr			END IF			IF DataTemp<>COMPLEX THEN				GOSUB AddLftGrp			END IF			ExpTable(ExpNdx)=SymNdx			LastEntry=SymTemp			GOSUB AddRtGrp1			GOTO GetExp1		END IF		IF DataTemp=COMPVAR OR DataTemp=MACROVAR THEN			Konstant=SymTable(SymNdx).Detail			SymTemp.SymName=STR(Konstant)			GOSUB ProcKonst			IF ErrNo<>0 THEN ExpExit			GOSUB AddRtGrp1			GOTO GetExp1		END IF		GOTO ExpExit	CASE TTypFloat		INCR FloatFlag		IncExpNdx		GOSUB AddLftGrp		GOSUB ValidFlt		IF FloatOK=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		END IF		SymTemp.SymName=TokenBuf		GOSUB SymSrch		IF SymFound=FALSE THEN			GOSUB ClrSym			SymTemp.DataType=FLOATVAR			SymTemp.DataSize=8			SymTemp.DataMod=ConstBit			GOSUB SymInsert			ErrRet		END IF		GOSUB GetSymTemp		LastEntry=SymTemp		ExpTable(ExpNdx)=SymNdx		GOSUB AddRtGrp1	CASE TTypInt		IncExpNdx		GOSUB AddLftGrp		GOSUB ValidInt		IF IntOK=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		END IF		Konstant=VAL(TokenBuf)		SymTemp.SymName=Str(Konstant)		GOSUB ProcKonst		IF ErrNo<>0 THEN ExpExit		GOSUB AddRtGrp1	CASE TTypHex		IncExpNdx		GOSUB AddLftGrp		GOSUB ValidHex		IF HexOK=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		END IF		SymTemp.SymName=TokenBuf		GOSUB ProcKonst		IF ErrNo<>0 THEN ExpExit		GOSUB AddRtGrp1	CASE TTypQuote		IncExpNdx		IF LEN(TokenSaf)=2 THEN;  null string			LastEntry=SymTable(20)			ExpTable(ExpNdx)=20;  20 is table entry for null string			GOTO GetExp1		END IF		GOSUB MakeStrConst		TempStr="_StrConst"+STR(PoolCtr)		SymTemp.SymName=TempStr		;Skip SymSrch, just point to next vacancy in symbol table		SymNdx=LastSym+1		IF SymNdx>SymTabSiz THEN			SymFull=$ff		END IF		SymTemp.DataType=STRINGVAR		SymTemp.DataMod=ConstBit		GOSUB ClrSym		SymTemp.Detail=LEN(TokenSaf)-1		SymTemp.DataSize=SymTemp.Detail		GOSUB SymInsert		IF ErrNo<>0 THEN			GOTO ExpExit		END IF		LastEntry=SymTemp		ExpTable(ExpNdx)=SymNdx	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTGOTO GetExp1ExpExit:IF ExpLen=ExpTabSiz THEN	ErrNo=ErrCpxExpEND IFIF ExpLen=1 THEN	ErrNo=ErrIVExpEND IFIF ErrNo=0 THEN; Check this block of code	IF ParenCnt<>0 THEN		IF ParenStk(ParenCnt)=24 THEN			IncExpNdx			ExpTable(ExpNdx)=25			DECR ParenCnt		END IF	END IF	IF ParenCnt<>0 THEN		IF ParenStk(ParenCnt)=22 THEN			IncExpNdx			ExpTable(ExpNdx)=23			ParenCnt=0		END IF	END IF	IF ParenCnt<>0 THEN		ErrNo=ErrParen	ELSE		IncExpNdx		ExpTable(ExpNdx)=2	END IFEND IFRETURNPreScan:LevelCnt=0GOSUB PreScan1RETURNPreScan1:SrcNdxSaf=SrcNdxExpEndSaf=ExpEndPreScan2:GOSUB NexTokenIF TokenLen=0 THEN	NextByte="%"	SrcNdx=SrcNdxSaf	ExpEnd=ExpEndSaf	RETURNEND IFIF TokenType=TTypMath AND LevelCnt=0 THEN	NextByte=TokenBuf	SrcNdx=SrcNdxSaf	ExpEnd=ExpEndSaf	RETURNEND IFIF TokenBuf="(" THEN	INCR LevelCntEND IFIF TokenBuf=")" THEN	DECR LevelCntEND IFGOTO PreScan2Unary:LastExpression=ExpTable(ExpNdx-1)IF LastExpression=1 OR LastExpression=3 OR LastExpression=5 OR LastExpression=22 OR LastExpression=24 THEN	ExpTable(ExpNdx)=21; *********	IncExpNdxEND IFRETURNAddLftGrp:IF NextByte="*" OR NextByte="/" OR NextByte="&" THEN	IF LAND(MemberBit,SymTemp.DataMod)<>MemberBit THEN		IF ParenCnt<>0 THEN			IF ParenStk(ParenCnt)=22 THEN				RETURN			END IF		END IF		INCR ParenCnt		ParenStk(ParenCnt)=22		ExpTable(ExpNdx)=22		IncExpNdx	END IFEND IFRETURNAddRtGrp1:IF ParenCnt=0 THEN	RETURNEND IFIF NextByte="+" OR NextByte="-" OR NextByte="*" OR NextByte="/"  OR NextByte="&" OR NextByte="|" OR NextByte="^" THEN	IF ParenStk(ParenCnt)=24 THEN		IncExpNdx		DECR ParenCnt		ExpTable(ExpNdx)=25	END IF	IF ParenCnt=0 THEN		RETURN	END IF	IF NextByte="+" OR NextByte="-"  OR NextByte="|" THEN; ???? should "&", "^" be here also?		IF ParenStk(ParenCnt)=22 THEN			IncExpNdx			DECR ParenCnt			ExpTable(ExpNdx)=23			LastEntry=SymTable(ExpTable(ExpNdx))			RETURN		ELSE			RETURN		END IF	END IFEND IFRETURNAddRtGrp2:IF ParenStk(ParenCnt)=24 THEN	IncExpNdx	DECR ParenCnt	ExpTable(ExpNdx)=25END IFIF ParenStk(ParenCnt)=22 THEN	IncExpNdx	DECR ParenCnt	ExpTable(ExpNdx)=23END IFRETURNProcKonst:GOSUB SymSrchIF SymFound=FALSE THEN	GOSUB ClrSym	SymTemp.DataType=LONGVAR	SymTemp.DataSize=4	SymTemp.DataMod=ConstBit	SymTemp.Detail=IVAL(SymTemp.SymName)	GOSUB SymInsert	ErrRetEND IFGOSUB GetSymTempLastEntry=SymTempExpTable(ExpNdx)=SymNdxRETURNProcExp:IF ExpFlag=TRUE THEN	FOR Ctr1=1 to ExpLen		;PRINT SymTable(ExpTable(Ctr1)).SymName;	NEXT Ctr1	TempStr=""	;GOSUB OutPrintEND IFBEGIN LOOP	LastGroup=$00	TempInt=ExpNdx	GOSUB ParenScan	ExpNdx=TempInt	IF ParenCnt=0 THEN		RETURN	END IF	GOSUB SolveTerm	ErrRet	GOSUB SquishExpEND LOOPParenScan:ParenCnt=0ExpNdx=0PType=0ExpLeft=0ExpRight=0IF ExpNdx>ExpLen THEN;???	RETURNEND IFParenScn1:INCR ExpNdxPType=ExpTable(ExpNdx)IF PType=1 OR PType=PTArrOpn OR PType=PTFcnOpn OR PType=22 OR PType=PTCpxOpn OR PType=26 THEN	ExpLeft=ExpNdx	INCR ParenCntEND IFIF PType=2 OR PType=PTArrCls OR PType=PTFcnCls OR PType=23 OR PType=PTFCpxCls OR PType=27 THEN	ExpRight=ExpNdx	RETURNEND IFGOTO ParenScn1SquishExp:BEGIN LOOP	IF ExpRight+1>ExpLen THEN		ExpLen=ExpLeft-1		RETURN	END IF	ExpTable(ExpLeft)=ExpTable(ExpRight+1)	INCR ExpLeft	INCR ExpRightEND LOOPSolveTerm:D0Loaded=0IF ExpLeft=1 AND ExpRight=ExpLen THEN	LastGroup=$ffEND IFIF ExpLeft=2 AND ExpRight=ExpLen-1 AND ExpTable(1)=1 THEN	LastGroup=$ffEND IF;*******************************; Pointer Stuff Begins HereIF PType=27 THEN	ExpNdx=ExpLeft+1	GOSUB ClassOp	GOSUB GetTmpVec	ErrRet	SymTable(SymNdx).DataMod=LAND(SymTable(SymNdx).DataMod,$fd);  kill addr bit	ExpTable(ExpNdx)=SymNdx	OutBuf="mov esi,["+TSymName+"]"	GOSUB OutCodeData	IF SymTemp.DataType=COMPLEX THEN		OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+3)).DataAddr)		GOSUB OutCodeData	END IF	OutBuf="mov ["+SymTemp.SymName+"],esi"	GOSUB OutCodeData	IF TDataType=STRINGVAR THEN		OutBuf="mov ["+SymTemp.SymName+"+4],"+STR(TDetail)		GOSUB OutCodeData		OutBuf="mov ["+SymTemp.SymName+"+8],0"		GOSUB OutCodeData	END IF	GOTO GrpCpxEndEND IF; Pointer Stuff Ends Here;*******************************IF PType=PTArrCls THEN	ExpNdx=ExpLeft-1	GOSUB ClassOp	ArrayDataType=TDataType	ArrayDetail=TDetail	GOSUB GetTmpVec	ErrRet	GOSUB GetBase	ExpTable(ExpNdx)=SymNdx	TempStr=SymTemp.SymName	GOSUB GetOpSize	GOSUB BldOffset	ErrRet	OutBuf="mov ["+TempStr+"],esi"	GOSUB OutCodeData	IF ArrayDataType=STRINGVAR THEN		OutBuf="mov ["+TempStr+"+4],"+STR(ArrayDetail)		GOSUB OutCodeData		OutBuf="mov ["+TempStr+"+8],0"		GOSUB OutCodeData	END IF	GOTO ArrFcnEndEND IFIF PType=PTFcnCls THEN; Function	HasFcn=$ff	ExpNdx=ExpLeft-1	GOSUB GetSymTempExpNdx	FcnName=SymTemp.SymName	ExpNdx=ExpNdx+2	IF SymTemp.DataMod=UsrFcnBit THEN		TFcnDataType=SymTemp.FcnDataType		GOSUB GetFcnTypes		FOR Ctr3=1 TO TFcnArgs			GOSUB ClassOp			GOSUB ArgPush			ErrRet			INCR ExpNdx		NEXT Ctr3		OutBuf="call "+FcnName		GOSUB OutCodeData		SELECT CASE TFcnDataType			CASE BOOLVAR				ExpTable(ExpNdx)=193			CASE LONGVAR				ExpTable(ExpNdx)=194			CASE STRINGVAR				ExpTable(ExpNdx)=195			CASE FLOATVAR				ExpTable(ExpNdx)=196		END SELECT						ELSE		FcnCode=SymTemp.Detail		IF FcnCode<51 THEN			ON FcnCode GOSUB F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13,F14,F15,F16,F17,F18,F19,F20,F21,F22,F23,F24,F25,F26,F27,F28,F29,F30,F31,F32,F33,F34,F35,F36,F37,F38,F39,F40,F41,F42,F43,F44,F45,F46,F47,F48,F49,F50		ELSE			ON FcnCode-50 GOSUB F51,F52,F53,F54,F55,F56,F57,F58,F59,F60,F61,F62,F63,F64,F65,F66,F67,F68,F69,F70,F71,F72,F73,F74,F75,F76,F77,F78,F79,F80,F81,F82		END IF	END IF	ErrRet	GOTO ArrFcnEndEND IFIF PType=PTFCpxCls THEN	IF ExpRight-ExpLeft=2 THEN		ExpNdx=ExpLeft+1		GOSUB ClassOp		IF DMVector=0 THEN			GOSUB Vectorize			ErrRet		END IF		IF DMVector<>0 AND DMTemp=0 THEN			GOSUB SetTmpVec			ErrRet		END IF		GOTO GrpCpxEnd	END IF	ExpNdx=ExpLeft+3	GOSUB ClassOp	IF TDataType=STRINGVAR AND DMVector=0 THEN		;GOSUB VecString	END IF	IF DMVector<>0 AND DMTemp=0 THEN		GOSUB SetTmpVec		ErrRet	END IF	ExpNdx=ExpNdx-2	GOSUB ClassOp	IF DMVector=0 THEN		GOSUB Vectorize		ErrRet	END IF	IF DMVector<>0 AND DMTemp=0 THEN		GOSUB SetTmpVec		ErrRet	END IF	ExpNdx=ExpNdx+2	GOSUB ClassOp	ExpNdx=ExpNdx-2	SymNdx=ExpTable(ExpNdx)	SymTable(SymNdx).DataType=TDataType	SymTable(SymNdx).DataSize=TDataSize	SymTable(SymNdx).Detail=TDetail	IF DMVector<>0 THEN		OutBuf="mov eax,["+SymTable(SymNdx).SymName+"]"		GOSUB OutCodeData		OutBuf="add eax,["+TSymName+"]"		GOSUB OutCodeData		OutBuf="mov ["+SymTable(SymNdx).SymName+"],eax"		GOSUB OutCodeData	END IF	IF OpClass=STRClass AND ReadFlag=0 THEN		OutBuf="mov ["+SymTable(SymNdx).SymName+"+4],"+STR(SymTemp.Detail)		GOSUB OutCodeData		OutBuf="mov ["+SymTable(SymNdx).SymName+"+8],0"		GOSUB OutCodeData		END IF	GOTO GrpCpxEndEND IF; Get here if PType=2ExpNdx=ExpLeft+1GOSUB ClassOpMakeLongIF ExpRight-ExpLeft=2 AND DMArray<>0 THEN	IF CompFlag<>0 THEN		ErrNo=ErrIVExp	END IF	GOTO GrpCpxEndEND IFIF LastGroup=$ff AND ExpRight-ExpLeft<>2 AND Target=$ff THEN	ErrNo=ErrIVTarg	RETURNEND IFIF ExpRight-ExpLeft=2 THEN	IF TDataType=STRINGVAR AND DMVector=0 AND DMAddr=0 THEN		GOSUB VecString	END IF	IF TDataType=STRINGVAR AND DMVector<>0 AND DMTemp=0 AND DiskIO=$ff  AND BufRWFlg=0 THEN		GOSUB GetBase	END IF	GOTO GrpCpxEndEND IFScanStr:GOSUB ClassOpMakeLongIF TDataType=STRINGVAR AND DMVector=0 AND DMAddr=0 THEN	GOSUB VecStringEND IFIF DMVector<>0 AND DMTemp=0 THEN	REM need to make a temp vector	GOSUB SetTmpVec	ErrRetEND IFINCR ExpNdxIF ExpNdx<ExpRight THEN ScanStrExpNdx=ExpLeft+1GOSUB ClassOpMakeLongIF TDataType=STRINGVAR THEN	DataOp=0	Ctr1=0	Label6184:	IF DataOp=0 THEN		GOSUB ClassOp		IF TDataType<>STRINGVAR THEN			ErrNo=ErrIVExp			RETURN		END IF		INCR Ctr1		IF Ctr1>1 THEN			OutBuf="mov esi,"+TSymName			GOSUB OutCodeData			TSymName=SymTable(ExpTable(ExpNdx-2)).SymName			OutBuf="mov ["+TSymName+"+8],esi"			GOSUB OutCodeData		END IF		DataOp=$ff	ELSE		MathOp=ExpTable(ExpNdx)		IF MathOp<15 THEN			ErrNo=ErrIVExp			RETURN		END IF		DataOp=0	END IF	INCR ExpNdx	IF ExpNdx<ExpRight THEN Label6184	IF DataOp=0 THEN		ErrNo=ErrIVExp		RETURN	END IF	ExpNdx=ExpLeft+1	GOTO GrpCpxEndEND IFIF TDataType<2 OR TDataType>5 THEN	ErrNo=ErrIVExp	RETURNELSE	DataOp=0	Ctr1=0	Label6186:	IF DataOp=0 THEN		DataOp=$ff		GOSUB LoadReg		ErrRet		INCR Ctr1		IF Ctr1>1 THEN			SELECT CASE MathOp				CASE 15					GOSUB DoAdd				CASE 16					GOSUB DoSub				CASE 17					GOSUB DoMul				CASE 18					GOSUB DoDiv				CASE 147					GOSUB DoAnd				CASE 148					GOSUB DoOr				CASE 149					GOSUB DoXor			END SELECT		END IF	ELSE		MathOp=ExpTable(ExpNdx)		DataOp=0	END IF	INCR ExpNdx	IF ExpNdx<ExpRight THEN Label6186	IF DataOp=0 THEN		ErrNo=ErrIVExp	END IF	ExpNdx=ExpLeft+1	IF LastGroup=$ff AND CompFlag=0 THEN		ExpTable(ExpNdx)=19		IF TDataType=FLOATVAR THEN			SymTable(19).DataType=FLOATVAR		ELSE			SymTable(19).DataType=LONGVAR		END IF		GOTO GrpCpxEnd	END IF	IF FloatFlag=0 THEN		GOSUB GetTmp		ErrRet	ELSE		GOSUB GetFltTmp		ErrRet	END IF       	OutBuf="mov ["+SymTemp.SymName+"],"+Reg0Name	GOSUB OutCodeData	D1Cleared=0	ExpTable(ExpNdx)=SymNdx	GOTO GrpCpxEndEND IFArrFcnEnd:DECR ExpLeftGrpCpxEnd:ExpTable(ExpLeft)=ExpTable(ExpNdx)ExpNdx=ExpLeftINCR ExpLeftRETURNGetBase:GetBaseFlag=TRUETArrayDim2Safe=TArrayDim2IF DMMember<>0 THEN	IF DMArray=0 THEN		OutBuf="mov esi,"+STR(TDataAddr)	ELSE		GOSUB GetOpSize		OutBuf="mov esi,0-("+STR(ArrayBase)+"*"+STR(TempInt)+"*"+STR(TArrayDim2)+")"	END IF	GOSUB OutCodeData	RETURNEND IFIF DMVector<>0 THEN	OutBuf="mov esi,["+TSymName+"]"	GOSUB OutCodeData	IF TDataType=COMPLEX THEN		CpxArrayOffset=ArrayBase*TDataAddr		OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)		GOSUB OutCodeData	END IF	RETURNEND IFIF DMArray<>0 THEN	OutBuf="mov esi,"+TSymName+"-("+STR(ArrayBase)+"*"+STR(TDataAddr)+"*"+STR(TArrayDim2)+")"	IF TDataType=COMPLEX THEN		CpxArrayOffset=ArrayBase*TDataAddr		IF GetPutFlag=TRUE THEN			OutBuf="mov esi,"+TSymName		ELSE			OutBuf=OutBuf+"+"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)		END IF	END IF	GOSUB OutCodeData	RETURNEND IFIF TDataType=COMPLEX THEN	OutBuf="mov esi,"+TSymName+"+"+STR(SymTable(ExpTable(ExpNdx+2)).DataAddr)	GOSUB OutCodeData	RETURNEND IFOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataRETURNBldOffset:SymTable(SymNdx).DataSize=TempIntSymTable(SymNdx).DataMod=LAND(ArrayMsk,SymTable(SymNdx).DataMod)GOSUB ClassOpExpNdx=ExpNdx+2NumArgs=ExpRight-ExpLeft-1IF NumArgs<>SubCtr THEN	ErrNo=ErrArrSub	RETURNEND IFGOSUB SubLoadIF TempInt<>1 THEN	OutBuf="imul eax,"+STR(TempInt); first sub*datasize	GOSUB OutCodeDataEND IFIF NumArgs=1 THEN;  1 DIM array	OutBuf="add esi,eax"	GOSUB OutCodeData	ExpNdx=ExpNdx-2	RETURNEND IFIF NumArgs=2 THEN;  2 DIM array	OutBuf="mov edx,eax"; save first sub*datasize	GOSUB OutCodeData	OutBuf="imul edx,"+STR(TArrayDim2Safe)	GOSUB OutCodeData	INCR ExpNdx	GOSUB SubLoad	ErrRet	DecArrayNdx	OutBuf="imul eax,"+STR(TempInt)	GOSUB OutCodeData	OutBuf="add eax,edx"	GOSUB OutCodeData	OutBuf="add esi,eax"	GOSUB OutCodeData	ExpNdx=ExpNdx-3ELSE	ErrNo=ErrArrSubEND IFRETURNVecString:IF BufRWFlg=$ff THEN;  for the case of BUFRW fn,ADDR(a$),size	RETURNEND IFGOSUB GetTmpVecErrRetGOSUB GetBaseExpTable(ExpNdx)=SymNdxTempStr=SymTemp.SymNameTempInt=TDetailIF PType=PTArrCls THEN	GOSUB BldOffsetEND IFOutBuf="mov ["+TempStr+"],esi"GOSUB OutCodeDataIF ReadFlag=0 THEN	OutBuf="mov ["+TempStr+"+4],"+STR(TempInt)	GOSUB OutCodeData	OutBuf="mov ["+TempStr+"+8],0"	GOSUB OutCodeDataEND IFRETURNClassOp:GOSUB GetSymTempExpNdxGOSUB ClassOp1RETURNClassOp1:GOSUB ClrDatTypTSymName=SymTemp.SymNameTDataType=SymTemp.DataTypeTSubType=SymTemp.SubTypeTDataMod=SymTemp.DataModTDetail=SymTemp.DetailTDataAddr=SymTemp.DataAddrTDataSize=SymTemp.DataSizeTArrayDim2=SymTemp.ArrayDim2GOSUB GetDtaTyp DMTemp=LAND(TempBit,TDataMod)DMVector=LAND(VectorBit,TDataMod)DMMember=LAND(MemberBit,TDataMod)DMMulti=LAND(MultiBit,TDataMod)DMConst=LAND(ConstBit,TDataMod)DMAddr=LAND(PointerBit,TDataMod)IF LAND(ArrayBit,TDataMod)=ArrayBit THEN	DMArray=$ff	OpClass=ARRClass	IF DMMulti<>0 THEN		;MultiNdx=TMultiPtr		SubCtr=SymTemp.ArrayDims'''		;SubValue(1)=SymTable(MultiNdx).Detail		;SubValue(2)=SymTable(MultiNdx).DataAddr		;SubValue(3)=SymTable(MultiNdx).DataSize	ELSE		SubCtr=1	END IF	RETURNEND IFIF TDataType>=2 AND TDataType<=4 OR LAND(TDataMod,PointerBit)=PointerBit THEN	OpClass=INTClass	RETURNEND IFIF TDataType=FCN AND LAND(TDataSize,$00000004)=4 THEN	OpClass=INTClassEND IFSELECT CASE TDataType	CASE BOOLVAR		OpClass=BOOLClass	CASE STRINGVAR		OpClass=STRClass	CASE FLOATVAR		OpClass=FLTClass	CASE COMPLEX		OpClass=CPXClass	CASE LABELPTR		OpClass=LBLClass	CASE ELSE		OpClass=0END SELECTRETURNExpr:GOSUB GetExpErrRetGOSUB ProcExpErrRetGOSUB ClassOpRETURNTokenSym:GOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	RETURNEND IFGOSUB TokenSym1RETURNTokenSym1:GOSUB GtRootSymGOSUB ValidSymIF SymbolOK=0 THEN	ErrNo=ErrIVSNam	RETURNEND IFSymTemp.SymName=SymbolSafGOSUB SymSrchRETURNClrSym:SymTemp.SubType=0SymTemp.Detail=0SymTemp.DataAddr=0SymTemp.DataSize=0SymTemp.ArrayDim1=0SymTemp.ArrayDim2=1SymTemp.ArrayDim3=1SymTemp.GUIEvents=0SymTemp.GUINotifyEvents=0SymTemp.ArrayDims=0SymTemp.Misc=0SymTemp.FcnDataType=0SymTemp.FcnArgs=0RETURNCallErr:IF StatFlag=$ff THEN	RETURNEND IFINCR OELabelNumOutBuf="cmp eax,-1"GOSUB OutCodeOutBuf="jg _OELbl"+STR(OELabelNum)GOSUB OutCodeImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeOutBuf="mov [ERR],eax"GOSUB OutCodeOutBuf="jmp [_ErrVec]"GOSUB OutCodeOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeRETURNCallErrZ:IF StatFlag=$ff THEN	RETURNEND IFINCR OELabelNumOutBuf="cmp eax,0"GOSUB OutCodeOutBuf="jne _OELbl"+STR(OELabelNum)GOSUB OutCodeImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeOutBuf="mov [ERR],eax"GOSUB OutCodeOutBuf="jmp [_ErrVec]"GOSUB OutCodeOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeRETURNGetOpSize:SELECT CASE TDataType	CASE BOOLVAR		TempInt=1	CASE BYTEVAR		TempInt=1	CASE WORDVAR		TempInt=2	CASE LONGVAR		TempInt=4	CASE LABELPTR		TempInt=4	CASE FLOATVAR		TempInt=8	CASE COMPLEX		TempInt=SymTable(SymTable(SymNdx).Detail).DataSize	CASE STRINGVAR		TempInt=(SymTable(SymNdx).Detail)END SELECTIF LAND(TDataMod,PointerBit)=PointerBit THEN	TempInt=4END IFRETURNDevChk:GOSUB NexTokenIF TokenBuf="#" THEN	DevFlag=$ffELSE	GOSUB UnDoTokenEND IFRETURNGetFileHandle:GOSUB GetExpErrRetIF SymTable(SymNdx).DataType>99 THEN	ErrNo=ErrSyntax	RETURNEND IFGOSUB ProcExpErrRetGOSUB GetFileHandle2IF KeyNdx<>3 AND KeyNdx<>4 THEN; Not SETEOF, CLOSE	GOSUB NexToken	IF TokenBuf<>"," THEN		ErrNo=ErrSyntax	END IFEND IFRETURNGetFileHandle2:GOSUB ClassOpIF TSubType<>FILE AND TSubType<>DEVICE THEN	ErrNo=ErrIVType	RETURNEND IFIF Target=0 THEN	IF TSymName<>"~" THEN		D0Loaded=0		GOSUB LoadReg		ErrRet	END IF	OutBuf="mov [_IOPthNum],eax"	GOSUB OutCodeDataELSE	IF DMConst<>0 THEN		ErrNo=ErrIVExp		RETURN	END IF	IF DMVector=0 THEN		PathIsVector=0		PathVar=TSymName	ELSE		PathIsVector=$ff		PathVar=TSymName	END IFEND IFRETURNGetFileName:GOSUB ExprErrRetIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	RETURNEND IFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataRETURNBufRW:BufRWFlg=$ffDiskIO=$ffGOSUB GetFileHandleErrRetGOSUB GetIntOp; Get AddressErrRetOutBuf="mov [_XferAddr],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOp; Get # of bytesErrRetOutBuf="mov [XferCount],eax"GOSUB OutCodeDataRETURNGetPut:GetPutFlag=TRUEDiskIO=$ffGOSUB GetFileHandleErrRetGOSUB ExprErrRetIF GetBaseFlag=FALSE THEN	OutBuf="mov esi,"+TSymName	GOSUB OutCodeDataEND IFIF DMConst<>0 THEN	ErrNo=ErrTypMis	RETURNEND IFOutBuf="mov [_XferAddr],esi"GOSUB OutCodeDataOutBuf="mov [XferCount],"+STR(SymTemp.DataSize)GOSUB OutCodeDataGOSUB NexTokenIF TokenLen=0 THEN	RETURNEND IFIF TokenBuf<>"," THEN	ErrNo=ErrSyntax	RETURNEND IFGOSUB GetIntOpErrMainDecArrayNdxOutBuf="mov edx,[XferCount]"GOSUB OutCodeDataOutBuf="imul eax,edx"GOSUB OutCodeDataImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],eax,0,FILE_BEGIN"GOSUB OutCodeDataGOSUB CallErrRETURNReadWrite:DiskIO=$ffImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEGOSUB GetFileHandleErrRetGOSUB ExprErrRetIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMisEND IFOutBuf="mov [_XferAddr],esi"GOSUB OutCodeDataOutBuf="mov [__ByteCounter],"+STR(SymTemp.Detail)GOSUB OutCodeDataRETURNGetRegPrm:GOSUB GetSymTempExpNdxGOSUB GetRP1RETURNGetRP1:TDataType=SymTemp.DataTypeTDataMod=SymTemp.DataModIF LAND(SymTemp.DataMod,PointerBit)<>PointerBit THEN	IF TDataType<1 OR TDataType>5 THEN		ErrNo=ErrIVExp		RETURN	END IFEND IFGOSUB GetDtaTypIF FloatFlag=0 THEN	Reg0Name="eax"	Reg1Name="edx"ELSE	Reg0Name="eaxf"	Reg1Name="edxf"END IFIF D0Loaded=0 THEN	LdRegName=Reg0NameELSE	LdRegName=Reg1NameEND IFRETURNLoadReg:IF Promote=$ff OR Demote=$ff THEN	GOSUB SymSrch	GOSUB GetSymTemp	GOSUB GetRP1ELSE	GOSUB GetRegPrmEND IFErrRetTDataType=SymTemp.DataTypeIF LAND(ConstBit,SymTemp.DataMod)=ConstBit THEN	TConst=$ff	TConstVal=SymTemp.DetailELSE	TConst=0END IFIF D0Loaded=0 THEN	D0Const=TConst	D0ConstVal=TConstVal	SELECT CASE TDataType		CASE BOOLVAR			LdRegName="al"		CASE BYTEVAR			LdRegName="al"		CASE WORDVAR			LdRegName="ax"		CASE LONGVAR			LdRegName="eax"	END SELECT	ELSE	D1Const=TConst	D0ConstVal=TConstVal	SELECT CASE TDataType		CASE BOOLVAR			LdRegName="dl"		CASE BYTEVAR			LdRegName="dl"		CASE WORDVAR			LdRegName="dx"		CASE LONGVAR			LdRegName="edx"	END SELECTEND IFIF TConst<>0 THEN	OutBuf="mov "+LdRegName+","+STR(TConstVal)ELSE	IF LAND(VectorBit,SymTemp.DataMod)=0 THEN		GOSUB ClrDataRegs		OutBuf="mov "+LdRegName+","+_DataType+"["+SymTemp.SymName+"]"	ELSE		ediUsed=TRUE		OutBuf="mov edi,["+SymTemp.SymName+"]"		GOSUB OutCodeData		GOSUB ClrDataRegs		OutBuf="mov "+LdRegName+","+_DataType+"[edi]"	END IFEND IFD0Loaded=$ffGOSUB OutCodeDataRETURNStoreD0:SymTemp.SymName=Op1NameGOSUB SymSrchTSymName=SymTable(SymNdx).SymNameTDataType=SymTable(SymNdx).DataTypeTDataMod=SymTable(SymNdx).DataModDMConst=0SELECT CASE TDataType	CASE BOOLVAR		Reg0Name="al"		OpSizeStr=" byte "	CASE BYTEVAR		Reg0Name="al"		OpSizeStr=" byte "	CASE WORDVAR		Reg0Name="ax"		OpSizeStr=" word "	CASE LONGVAR		Reg0Name="eax"		OpSizeStr=" dword "	CASE FLOATVAR		Reg0Name="floatreg"		OpSizeStr=" qword "END SELECTIF LAND(TDataMod,PointerBit)<>0 THEN		Reg0Name="eax"		OpSizeStr=" dword "END IFIF LAND(TDataMod,VectorBit)=0 THEN	OutBuf="mov"+OpSizeStr+"["+TSymName+"],"+Reg0NameELSE	IF LAND(TDataMod,PointerBit)<>0 THEN		Reg0Name="eax"		OutBuf="mov esi,"+SymTemp.SymName		GOSUB OutCodeData	ELSE		OutBuf="mov esi,["+SymTemp.SymName+"]"		GOSUB OutCodeData	END IF	OutBuf="mov"+OpSizeStr+"[esi],"+Reg0NameEND IFGOSUB OutCodeDataRETURNGetIntTmp:OpClass=INTClassGOSUB GetTmpRETURNGetTmp:IF TmpUse=NumTemps THEN	ErrNo=ErrTmpUse	RETURNEND IFINCR TmpUseIF TmpUse>TmpMax THEN	TmpMax=TmpUse	GOSUB VarBlank	Comment="Temporary Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf="_Tmp"+STR(TmpUse)+" rd 1"	GOSUB OutUninitDataEND IFSymTemp.SymName="_Tmp"+STR(TmpUse)GOSUB SymSrchIF OpClass=INTClass THEN	SymTable(SymNdx).DataType=LONGVARELSE	SymTable(SymNdx).DataType=TDataTypeEND IFSymTable(SymNdx).DataSize=TDataSizeRETURNGetFltTmp:IF FTmpUse=NumTemps THEN	ErrNo=ErrTmpUse	RETURNEND IFINCR FTmpUseIF FTmpUse>FTmpMax THEN	FTmpMax=FTmpUse	GOSUB VarBlank	Comment="Temporary Floating Point Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf=";static double _FTmp"+STR(FTmpUse)+";"	GOSUB OutUninitData	GOSUB VarBlankEND IFSymTemp.SymName="_FTmp"+STR(FTmpUse)GOSUB SymSrchRETURNGetStrVec:INCR StrTmpUseIF StrTmpUse>StrTmpMax THEN	StrTmpMax=StrTmpUse	GOSUB VarBlank	Comment="Temporary String Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf="_StrTmp"+STR(StrTmpUse)+" rb 32"	GOSUB OutUninitDataEND IFGOSUB ReqTmpVecErrRetSymTable(SymNdx).DataMod=TmpVecSymTable(SymNdx).DataType=STRINGVARSymTable(SymNdx).Detail=32TempInt=32SymTable(SymNdx).DataAddr=0SymTable(SymNdx).DataSize=32OutBuf="mov esi,_StrTmp"+STR(StrTmpUse)GOSUB OutCodeDataGOSUB SetStrVecRETURNGetChrVec:INCR ChrTmpUseIF ChrTmpUse>ChrTmpMax THEN	ChrTmpMax=ChrTmpUse	GOSUB VarBlank	Comment="Temporary Character Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf="_ChrTmp"+STR(ChrTmpUse)+" rb 1"	GOSUB OutUninitData	GOSUB VarBlankEND IFGOSUB ReqTmpVecErrRetSymTable(SymNdx).DataMod=TmpVecSymTable(SymNdx).DataType=STRINGVARSymTable(SymNdx).Detail=1TempInt=1SymTable(SymNdx).DataAddr=0SymTable(SymNdx).DataSize=1OutBuf="mov esi,_ChrTmp"+STR(ChrTmpUse)GOSUB OutCodeDataGOSUB SetStrVecRETURNSetStrVec:OutBuf="mov ["+SymTemp.SymName+"],esi"GOSUB OutCodeDataOutBuf="mov ["+SymTemp.SymName+"+4],"+STR(TempInt)GOSUB OutCodeDataOutBuf="mov ["+SymTemp.SymName+"+8],0"GOSUB OutCodeDataRETURNReqTmpVec:IF TmpVecUse=NumTemps THEN	ErrNo=ErrTmpUse	RETURNEND IFINCR TmpVecUseIF TmpVecUse>TmpVecMax THEN	TmpVecMax=TmpVecUse	GOSUB MakTmpVecEND IFSymTemp.SymName="_TmpVec"+STR(TmpVecUse)GOSUB SymSrchSymNdxSaf=SymNdxRETURNGetTmpVec:GOSUB ReqTmpVecErrRetSymTable(SymNdx).DataMod=TmpVecSymTable(SymNdx).DataMod=LOR(TDataMod,SymTable(SymNdx).DataMod)SymTable(SymNdx).DataType=TDataTypeSymTable(SymNdx).SubType=TSubTypeSymTable(SymNdx).Detail=TDetailSymTable(SymNdx).DataAddr=TDataAddrSymTable(SymNdx).DataSize=TDataSizeRETURNMakTmpVec:GOSUB VarBlankComment="Temporary Vector"GOSUB BldCommentGOSUB OutUninitDataOutBuf="_TmpVec"+STR(TmpVecUse)+" rd 3"GOSUB OutUninitDataRETURNSetTmpVec:GOSUB GetTmpVecErrRetExpTable(ExpNdx)=SymNdxediUsed=TRUEOutBuf="mov edi,["+TSymName+"]"GOSUB OutCodeDataIF SymTemp.DataType=COMPLEX THEN	OutBuf="add edi,"+STR(SymTable(ExpTable(ExpNdx+2)).DataAddr)	GOSUB OutCodeDataEND IFOutBuf="mov ["+SymTable(SymNdx).SymName+"],edi"GOSUB OutCodeDataIF TDataType<>STRINGVAR THEN	RETURNEND IFOutBuf="mov edi,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="mov ["+SymTable(SymNdx).SymName+"+4],edi"GOSUB OutCodeDataOutBuf="mov edi,["+TSymName+"+8]"GOSUB OutCodeDataOutBuf="mov ["+SymTable(SymNdx).SymName+"+8],edi"GOSUB OutCodeDataGOSUB ClassOpRETURNVectorize:GOSUB GetTmpVecErrRetGOSUB GetBaseExpTable(ExpNdx)=SymNdxOutBuf="mov ["+SymTemp.SymName+"],esi"GOSUB OutCodeDataRETURNGetLopVec:LopVarNdx=0GetLV1:INCR LopVarNdxIF LopVarNdx=101 THEN	ErrNo=ErrTmpUse	RETURNEND IFIF LoopVars(LopVarNdx)=ConStk(ConStkPtr).LoopName THEN GetLV2IF LoopVars(LopVarNdx)<>"%" THEN GetLV1LoopVars(LopVarNdx)=ConStk(ConStkPtr).LoopNameGOSUB VarBlankComment="For Loop Vector"GOSUB BldCommentGOSUB OutUninitDataOutBuf="_LopVec"+STR(LopVarNdx)+" rd 2"GOSUB OutUninitDataGetLV2:RETURNDoAnd:IF TDataType=FLOATVAR THEN	ErrNo=ErrTypMisEND IFOutBuf="and eax,edx"GOSUB OutCodeDataRETURNDoOr:IF TDataType=FLOATVAR THEN	ErrNo=ErrTypMisEND IFOutBuf="or eax,edx"GOSUB OutCodeDataRETURNDoAdd:OutBuf="add "+Reg0Name+","+Reg1NameGOSUB OutCodeDataRETURNDoXor:OutBuf="xor "+Reg0Name+","+Reg1NameGOSUB OutCodeDataRETURNDoSub:OutBuf="sub "+Reg0Name+","+Reg1NameGOSUB OutCodeDataRETURNDoMul:OutBuf="imul "+Reg1NameGOSUB OutCodeDataRETURNDoDiv:; The following is ONLY for integer divide; Check for edx=0 here and trap divide-by-zeroOutBuf="cmp edx,0"GOSUB OutCodeDataINCR LabelNumOutBuf="jne _Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="mov [ERR],$db00db00"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="mov ecx,edx"GOSUB OutCodeDataOutBuf="xor edx,edx"GOSUB OutCodeDataOutBuf="idiv ecx"GOSUB OutCodeDataRETURNCmpNum:D0Loaded=0Promote=$ffSymTemp.SymName=Op1NameGOSUB LoadRegSymTemp.SymName=Op2NameGOSUB LoadRegIF TDataType=BOOLVAR THEN	OutBuf="cmp al,dl"ELSE	OutBuf="cmp "+Reg0Name+","+Reg1NameEND IFGOSUB OutCodeDataIF SimpleCmp=0 THEN	OutBuf=SymType+"bl"	GOSUB OutCodeDataEND IFRETURNCmpString:ediUsed=TRUEOutBuf="mov edi,"+Op1NameGOSUB OutCodeDataOutBuf="mov esi,"+Op2NameGOSUB OutCodeDataUseCmpStr=TRUEOutBuf="call __CmpStr"GOSUB OutCodeDataIF SimpleCmp=0 THEN	OutBuf=SymType+"bl"	GOSUB OutCodeDataEND IFRETURNNexToken:ExpEnd=0TokenLen=0TokenType=0QuoteFlag=0EscSeq=0NextByte=""TokenBuf=""TokenSaf=""NexToken1:INCR SrcNdxIF SrcNdx>LEN(SrcLine) THEN NexToken5TempByte=MID(SrcLine,SrcNdx,1)NextByte=MID(SrcLine,SrcNdx+1,1)AsciiByte=ASC(TempByte)IF AsciiByte=OBQUOTE AND EscSeq=0 THEN	IF QuoteFlag=0 AND TokenLen<>0 THEN NexToken5	GOSUB NexToken3	IF QuoteFlag=1 THEN		TokenType=TTypQuote		GOTO NexToken6	ELSE		QuoteFlag=1		EscSeq=0		GOTO NexToken1	END IFEND IFIF QuoteFlag=1 THEN	IF EscSeq=$ff THEN		EscSeq=0	ELSE		IF AsciiByte=$5c THEN			EscSeq=$ff		END IF	END IF	GOSUB NexToken3	GOTO NexToken1END IFIF TempByte="." THEN	IF TokenType=TTypInt THEN		TokenType=TTypFloat		GOSUB NexToken3		GOTO NexToken1	END IF	IF TokenLen=0 THEN		IF NextByte>="0" AND NextByte<="9" THEN			TokenType=TTypFloat			GOSUB NexToken3			GOTO NexToken1		END IF	END IFEND IFIF TempByte="'" OR TempByte=";" THEN NexToken5; RemarkIF TempByte="<" OR TempByte=">" OR TempByte="=" THEN	IF TokenLen<>0 THEN NexToken5	TokenType=TTypRelOp	GOSUB NexToken3	IF TempByte="=" THEN		GOTO NexToken6	END IF	IF NextByte=">" OR NextByte="=" THEN		INCR SrcNdx		TempByte=MID(SrcLine,SrcNdx,1)		GOSUB NexToken3	END IF	GOTO NexToken6END IFIF AsciiByte=$20 OR AsciiByte=$09 THEN	IF TokenLen<>0 THEN		DECR SrcNdx		NextByte=" "		ExpEnd=$ff		GOTO NexTokDone	END IF	GOTO NexToken1END IFIF DimFlag=0 THEN	IF TempByte="(" OR TempByte=")" THEN		IF TokenLen<>0 THEN NexToken5		GOSUB NexToken3		TokenType=TTypParen		GOTO NexToken6	END IFEND IFIF DimFlag=0 OR TempByte<>"," THEN;  special cond for multi-dim array	IF TempByte="," OR TempByte=";" OR TempByte=":" OR TempByte="." THEN		IF TokenLen<>0 THEN NexToken5		GOSUB NexToken3		TokenType=TTypPunct		GOTO NexToken6	END IFEND IFIF TempByte="+" OR TempByte="-" OR TempByte="*" OR TempByte="/"  OR TempByte="&" OR TempByte="|" THEN	IF TokenLen<>0 THEN NexToken5	GOSUB NexToken3	TokenType=TTypMath	GOTO NexToken6END IFIF DimFlag=$ff THEN NexToken2IF TempByte="$" OR TempByte="_" OR TempByte="@" THEN NexToken2IF TempByte="!" AND ExclamationOK=TRUE THEN NexToken2IF TempByte>="0" AND TempByte<="9" THEN NexToken2IF TempByte>="A" AND TempByte<="Z" THEN NexToken2IF TempByte>="a" AND TempByte<="z" THEN NexToken2IF TokenLen<>0 THEN NexToken5GOSUB NexToken3TokenType=TTypMiscGOTO NexToken6NexToken2:GOSUB NexToken3GOTO NexToken1NexToken5:DECR SrcNdxNextByte=MID(SrcLine,SrcNdx+1,1)NexToken6:IF NextByte=" " OR ASC(NextByte)=9 OR NextByte=":" OR NextByte=";" THEN	ExpEnd=$ffEND IFIF NextByte="<" OR NextByte=">" OR NextByte="=" OR NextByte="" OR NextByte=";" THEN	ExpEnd=$ffEND IFNexTokDone:IF TokenType=TTypInt AND RIGHT(TokenBuf,1)="h" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="$"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="$"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	END IF	TokenBuf=TokenSaf	TokenType=TTypHexEND IFIF TokenType=TTypInt AND RIGHT(TokenBuf,1)="o" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="%"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="%"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	END IF	TokenBuf=TokenSaf	TokenType=TTypOctEND IFIF TokenType=TTypInt AND RIGHT(TokenBuf,1)="b" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="&"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="&"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	END IF	TokenBuf=TokenSaf	TokenType=TTypBinEND IFIF TokenType=TTypInt AND MID(TokenBuf,2,1)="x" THEN; C hex->Motorala	TokenSaf="$"+MID(TokenBuf,3,LEN(TokenBuf)-2)	TokenBuf=TokenSaf	TokenType=TTypHexEND IFRETURNNexToken3:INCR TokenLenTokenSaf=TokenSaf+TempByteIF TempByte>="A" AND TempByte<="Z" THEN	AsciiByte=LOR(AsciiByte,$20)	TempByte=CHR(AsciiByte)END IFTokenBuf=TokenBuf+TempByteIF TokenLen=1 THEN	IF TokenBuf="$" THEN		TokenType=TTypHex	END IF	IF TokenBuf>="0" AND TokenBuf<="9" THEN		TokenType=TTypInt	END IF	IF TokenBuf>="a" AND TokenBuf<="z" OR TokenBuf="_" THEN		TokenType=TTypSym	END IF	IF TokenBuf="!" AND ExclamationOK=TRUE THEN		TokenType=TTypSym	END IFEND IFRETURNUnDoToken:SrcNdx=SrcNdx-TokenLenNextByte=""RETURNMacToken:TokenLen=0TokenSaf=""MacToken1:INCR SrcNdxTempByte=MID(SrcLine,SrcNdx,1)AsciiByte=ASC(TempByte)IF AsciiByte=NewLine OR AsciiByte=0 THEN	DECR SrcNdx	RETURNEND IFIF AsciiByte=$2c THEN;  comma	IF TokenLen=0 THEN		TokenSaf=TempByte		TokenLen=1	ELSE		DECR SrcNdx	END IF	RETURNEND IFTokenSaf=TokenSaf+TempByteINCR TokenLenGOTO MacToken1SymChk:SymbolOK=0IF ByteArray(1)<$61 OR ByteArray(1)>$7a THEN	IF ByteArray(1)<>$5f THEN		RETURN	END IFEND IFFOR I=2 TO TokenLen	IF ByteArray(I)<$61 OR ByteArray(I)>$7a THEN		IF ByteArray(I)<$30 OR ByteArray(I)>$39 THEN			IF ByteArray(I)<>$24 OR ByteArray(I)<>$5f THEN				RETURN			END IF		END IF	END IFNEXT ISymbolOK=$ffRETURN	ValidSym:SymbolOK=0IF LEN(RootSym)>28 THEN	RETURNEND IFIF LNFlag=0 THEN NotLineNumIF LEN(RootSym)>5 THEN NotLineNumTempByte=MID(RootSym,1,1)IF TempByte<"0" OR TempByte>"9" THEN NotLineNumLabNdx=1BldLineNumLbl:INCR LabNdxIF LabNdx>LEN(RootSym) THEN	SymbolSaf="_LN"	SymbolSaf=SymbolSaf+RootSym	SymbolOK=$ff	RETURNEND IFTempByte=MID(RootSym,LabNdx,1)IF TempByte<"0" OR TempByte>"9" THEN	RETURNEND IFGOTO BldLineNumLblNotLineNum:LabNdx=1TempByte=MID(RootSym,1,1)IF TempByte>="A" AND TempByte<="Z" THEN ValidSymLoopIF TempByte>="a" AND TempByte<="z" THEN ValidSymLoopIF TempByte="_" THEN ValidSymLoopIF TempByte="!" AND ExclamationOK=TRUE THEN ValidSymLoopRETURNValidSymLoop:INCR LabNdxIF LabNdx>LEN(RootSym) THEN	SymbolOK=$ff	SymbolSaf=RootSym	RETURNEND IFTempByte=MID(RootSym,LabNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidSymLoopIF TempByte>="A" AND TempByte<="Z" THEN ValidSymLoopIF TempByte>="a" AND TempByte<="z" THEN ValidSymLoopIF TempByte="_" THEN ValidSymLoopIF TempByte="$" AND LabNdx=LEN(RootSym) THEN ValidSymLoopRETURNValidInt:IntOK=0IF LEN(TokenBuf)>10 THEN	RETURNEND IFValidNdx=0ValidIntLoop:INCR ValidNdxIF ValidNdx>LEN(TokenBuf) THEN	IntOK=$ff	RETURNEND IFTempByte=MID(TokenBuf,ValidNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidIntLoopIF TempByte="-" THEN ValidIntLoopRETURNValidHex:HexOK=0IF LEN(TokenBuf)>9 THEN	RETURNEND IFValidNdx=1ValidHexLoop:INCR ValidNdxIF ValidNdx>LEN(TokenBuf) THEN	HexOK=$ff	RETURNEND IFTempByte=MID(TokenBuf,ValidNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidHexLoopIF TempByte>="a" AND TempByte<="f" THEN ValidHexLoopRETURNValidFlt:OneDot=0FloatOK=0IF LEN(TokenBuf)>21 THEN	RETURNEND IFValidNdx=0ValidFltLoop:INCR ValidNdxIF ValidNdx>LEN(TokenBuf) THEN	FloatOK=$ff	RETURNEND IFTempByte=MID(TokenBuf,ValidNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidFltLoopIF TempByte="." THEN	IF OneDot=0 THEN		OneDot=$ff		GOTO ValidFltLoop	END IFEND IFRETURNSymSrch:SymFull=0SymFound=FALSESymNdx=0TempName=SymTemp.SymNameTempStr=TempNameTempInt=CHKWORD(TempStr)SymSrch1:INCR SymNdxIF SymNdx>LastSym THEN	IF SymNdx>SymTabSiz THEN		SymFull=$ff	END IF	RETURNEND IFIF SymTableKey(SymNdx)<>TempInt THEN SymSrch1IF SymTable(SymNdx).SymName<>TempName THEN SymSrch1INCR SymTable(SymNdx).UseCountSymFound=TRUERETURNSymSearch:GOSUB SymSrchIF SymFound=TRUE THEN	RETURNEND IFSymTemp.SymName=TokenSafGOSUB SymSrchRETURNSymInsert:IF SymFull=$ff THEN	ErrNo=ErrSymFul	RETURNEND IFSymTable(SymNdx)=SymTempLastSym=SymNdxTempStr=SymTemp.SymNameSymTableKey(SymNdx)=CHKWORD(TempStr)RETURNKeyLook:KeyNdx=0TempInt=CHKWORD(TokenBuf)BEGIN LOOP	INCR KeyNdx	IF KeyNdx>LastKey THEN		KeyNdx=0		RETURN	END IF	CONTINUE IF KeyTable(KeyNdx).KeyCheckWord<>TempInt	IF KeyTable(KeyNdx).KeyName=TokenBuf THEN		RETURN	END IFEND LOOPObjLook:ObjNdx=0TempInt=CHKWORD(TokenBuf)BEGIN LOOP	INCR ObjNdx	IF ObjNdx>LastObj THEN		ObjNdx=0		RETURN	END IF	CONTINUE IF ObjTable(ObjNdx).ObjCheckWord<>TempInt	IF ObjTable(ObjNdx).ObjName=TokenBuf THEN		RETURN	END IFEND LOOPCmpOps:Op1Class=0AndOrFlag=$ffCompFlag=$ffGUIObjFlag=0;//TextFlag=0;//CmpOps1:CmpOpFlag=FALSEPromote=0Demote=0TmpUse=0TmpVecUse=0FTmpUse=0ChrTmpUse=0StrTmpUse=0TypeFlag=0TDataMod=0GOSUB ClrDatTypGOSUB GetExpErrRetIF GUIObjFlag<>0 THEN;//	GOSUB UnDoToken;//	GUITargetFlag=0;//	GOSUB ValidateObject;//	ErrMain;//	GOSUB GUISource	Op1Name=GUITempName	Op1Type=GUIDataType	SELECT CASE Op1Type		CASE BOOLVAR			Op1Class=BOOLClass		CASE LONGVAR			Op1Class=INTClass		CASE STRINGVAR			Op1Class=STRClass	END SELECT	Op1Mod=0	Op1Detail=0ELSE	GOSUB ProcExp	ErrRet	GOSUB ClassOp	Op1Name=TSymName	Op1Class=OpClass	Op1Type=TDataType	Op1Mod=TDataMod	Op1Detail=TDetailEND IFIF TDataType=BOOLVAR THEN	IF NextByte="=" OR NextByte="<" THEN		GOSUB NexToken		IF TokenBuf="=" THEN			SymType="sete "			SimpleOp="je "			SimpleStructOp="jne "		ELSE			SymType="setne "			SimpleOp="jne "			SimpleStructOp="je "		END IF		IF TokenBuf<>"=" AND TokenBuf<>"<>" THEN			ErrNo=ErrIVExp			RETURN		END IF		GOTO CmpOps2	ELSE		Op2Name="true"		Op2Class=BOOLClass		Op2Type=1		Op2Mod=$04		Op2Detail=1		SymType="sete "		GOTO CmpOps3	END IFEND IFGOSUB NexTokenIF TokenType<>1 THEN	ErrNo=ErrIVExp	RETURNEND IFSymType=""SELECT CASE TokenBuf	CASE "="		SymType="sete "		SimpleOp="je "		SimpleStructOp="jne "	CASE "<"		SymType="setl "		SimpleOp="jl "		SimpleStructOp="jge "	CASE ">"		SymType="setg "		SimpleOp="jg "		SimpleStructOp="jle "	CASE "<="		SymType="setle "		SimpleOp="jle "		SimpleStructOp="jg "	CASE ">="		SymType="setge "		SimpleOp="jge "		SimpleStructOp="jl "	CASE "<>"		SymType="setne "		SimpleOp="jne "		SimpleStructOp="je "	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTCmpOps2:GUIObjFlag=0CmpOpFlag=TRUEGOSUB GetExpErrRetIF GUIObjFlag<>0 THEN;//	GOSUB UnDoToken;//	GUITargetFlag=0;//	GOSUB ValidateObject;//	ErrMain;//	GOSUB GUISource	Op2Name=GUITempName	Op2Type=GUIDataType	SELECT CASE Op2Type		CASE BOOLVAR			Op2Class=BOOLClass		CASE LONGVAR			Op2Class=INTClass		CASE STRINGVAR			Op2Class=STRClass	END SELECT	Op2Mod=0	Op2Detail=0ELSE	GOSUB ProcExp	ErrRet	GOSUB ClassOp	Op2Name=TSymName	Op2Class=OpClass	Op2Type=TDataType	Op2Mod=TDataMod	Op2Detail=TDetailEND IFTempInt=LOR(Op1Mod,TempBit)TempInt2=LOR(Op2Mod,TempBit)IF ComplexCmp=0 THEN	IF HasFcn=0 AND Op1Class=INTClass AND TempInt=TempBit AND Op2Class=INTClass AND Op2Mod=ConstBit THEN		GOSUB NexToken		IF TokenBuf<>"or" AND TokenBuf<>"and" THEN			SimpleCmp=$ff			IF Op1Type=BYTEVAR AND Op2Detail>255 THEN				ErrNo=ErrOpRange				RETURN			END IF			IF Op1Type=WORDVAR AND Op2Detail>65535 THEN				ErrNo=ErrOpRange				RETURN			END IF			IF Op1Type=LONGVAR AND Op2Detail>$7fffffff THEN				ErrNo=ErrOpRange				RETURN			END IF			OutBuf="cmp ["+Op1Name+"],"+STR(Op2Detail)			GOSUB OutCodeData			RETURN		END IF		GOSUB UnDoToken	END IF	IF HasFcn=0 AND Op1Class=BOOLClass AND TempInt=TempBit AND Op2Class=BOOLClass AND Op2Mod=ConstBit THEN		GOSUB NexToken		IF TokenBuf<>"or" AND TokenBuf<>"and" THEN			SimpleCmp=$ff			OutBuf="cmp ["+Op1Name+"],"+STR(Op2Detail)			GOSUB OutCodeData			RETURN		END IF		GOSUB UnDoToken	END IF	IF HasFcn=0 AND Op1Class=INTClass AND Op1Mod<>ConstBit AND TempInt=TempBit AND Op2Class=INTClass AND TempInt2=TempBit THEN		GOSUB NexToken		IF TokenBuf<>"or" AND TokenBuf<>"and" THEN			SimpleCmp=$ff			SELECT CASE Op1Type				CASE BYTEVAR					IF Op2Type=BYTEVAR THEN						OutBuf="mov al,["+Op2Name+"]"						GOSUB OutCodeData						OutBuf="cmp ["+Op1Name+"],al"						GOSUB OutCodeData						RETURN					ELSE						IF Op2Type=WORDVAR THEN							OutBuf="xor ax,ax"							GOSUB OutCodeData							OutBuf="mov al,["+Op1Name+"]"							GOSUB OutCodeData							OutBuf="mov dx,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp ax,dx"							GOSUB OutCodeData							RETURN						ELSE							OutBuf="xor eax,eax"							GOSUB OutCodeData							OutBuf="mov al,["+Op1Name+"]"							GOSUB OutCodeData							OutBuf="mov edx,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp eax,edx"							GOSUB OutCodeData							RETURN						END IF					END IF											CASE WORDVAR					IF Op2Type=WORDVAR THEN						OutBuf="mov ax,["+Op2Name+"]"						GOSUB OutCodeData						OutBuf="cmp ["+Op1Name+"],ax"						GOSUB OutCodeData						RETURN					ELSE						IF Op2Type=BYTEVAR THEN							OutBuf="xor ax,ax"							GOSUB OutCodeData							OutBuf="mov al,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp ["+Op1Name+"],ax"							GOSUB OutCodeData							RETURN						ELSE							OutBuf="xor eax,eax"							GOSUB OutCodeData							OutBuf="mov ax,["+Op1Name+"]"							GOSUB OutCodeData							OutBuf="mov edx,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp eax,edx"							GOSUB OutCodeData							RETURN						END IF																			END IF				CASE LONGVAR					IF Op2Type=LONGVAR THEN						OutBuf="mov eax,["+Op2Name+"]"						GOSUB OutCodeData					ELSE						OutBuf="xor eax,eax"						GOSUB OutCodeData						IF Op2Type=WORDVAR THEN							OutBuf="mov ax,["+Op2Name+"]"							GOSUB OutCodeData						ELSE							OutBuf="mov al,["+Op2Name+"]"							GOSUB OutCodeData						END IF					END IF					OutBuf="cmp ["+Op1Name+"],eax"					GOSUB OutCodeData					RETURN			END SELECT			OutBuf="cmp ["+Op1Name+"],eax"			GOSUB OutCodeData			RETURN		END IF		GOSUB UnDoToken	END IFEND IFComplexCmp=$ffCmpOps3:GOSUB NexTokenIF TokenBuf<>"or" AND TokenBuf<>"and" AND InitTrue=0 THEN	SimpleCmp=$ffEND IFGOSUB UnDoTokenIF Op1Class=INTClass OR Op1Class=FLTClass OR Op1Class=BOOLClass THEN	GOSUB CmpNum	ErrRetEND IFIF Op1Class<>Op2Class THEN	EXIT IF Op1Class=INTClass AND Op2Class=FLTClass	EXIT IF Op1Class=FLTClass AND Op2Class=INTClass	ErrNo=ErrTypMis	RETURNEND IFIF Op1Class=STRClass THEN	GOSUB CmpStringEND IFIF Op1Class=0 OR Op1Class=ARRClass OR Op1Class=CPXClass THEN	ErrNo=ErrIVExp	RETURNEND IFIF InitTrue=0 AND SimpleCmp=0 THEN	OutBuf="xor bh,bh"	GOSUB OutCodeData	InitTrue=$ffEND IFIF SimpleCmp=0 THEN	IF AndOrFlag=0 THEN		OutBuf="and bh,bl"	ELSE		OutBuf="or bh,bl"	END IF	GOSUB OutCodeDataEND IFGOSUB NexTokenIF TokenBuf="and" THEN	AndOrFlag=0	GOTO CmpOps1END IFIF TokenBuf="or" THEN	AndOrFlag=$ff	GOTO CmpOps1END IFRETURNClrDatTyp:DMTemp=0DMVector=0DMMember=0DMMulti=0DMConst=0DMAddr=0DMArray=0RETURNGtRootSym:SubscrErr=0RootSym=""SubCtr=0Subscript(1)=""Subscript(2)=""Subscript(3)=""SubValue(1)=1SubValue(2)=1SubValue(3)=1LabNdx=0GtRtSym1:INCR LabNdxIF LabNdx>LEN(TokenSaf) THEN	RETURNEND IFTempByte=MID(TokenSaf,LabNdx,1)IF TempByte<>"(" THEN	RootSym=RootSym+TempByte	GOTO GtRtSym1END IFIF RIGHT(TokenSaf,1)<>")" THEN	SubscrErr=$ff	RETURNEND IFGtRtSym2:INCR SubCtrIF SubCtr>2 THEN	ErrNo=ErrSyntax	RETURNEND IFGtRtSym3:INCR LabNdxTempByte=MID(TokenSaf,LabNdx,1)IF TempByte=")" OR TempByte="," THEN	SymNdxSaf=SymNdx	TempStr=SymTemp.SymName	IF LEFT(Subscript(SubCtr),1)>="0" AND LEFT(Subscript(SubCtr),1)<="9" THEN		SubValue(SubCtr)=VAL(Subscript(SubCtr))	ELSE		SymTemp.SymName=Subscript(SubCtr)		GOSUB SymSrch		IF SymFound=TRUE AND SymTable(SymNdx).DataType=COMPVAR OR SymTable(SymNdx).DataType=MACROVAR THEN			SubValue(SubCtr)=SymTable(SymNdx).Detail		ELSE			ErrNo=ErrUDSym			RETURN		END IF	END IF	SymNdx=SymNdxSaf	SymTemp.SymName=TempStr	IF TempByte="," THEN GtRtSym2	RETURNEND IFSubscript(SubCtr)=Subscript(SubCtr)+TempByteGOTO GtRtSym3F1:; EOF(FileNum)GOSUB ClassOpGOSUB GetFileHandle2ErrRetIF TSubType=DEVICE THEN	ErrNo=ErrDevice	GOTO MainLoopEND IFImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUEOutBuf="invoke GetFileSize,[_IOPthNum],0"GOSUB OutCodeDataOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataGOSUB CallErrImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],0,0,FILE_CURRENT"GOSUB OutCodeDataGOSUB CallErrOpClass=BOOLClassTDataType=BOOLVARGOSUB GetTmpErrRetOutBuf="cmp eax,[_ArgSafe0]"GOSUB OutCodeDataOutBuf="sete cl; Set result"GOSUB OutCodeDataOutBuf="mov byte ["+SymTemp.SymName+"],cl"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF2:; LEN(String)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis	RETURNEND IFOutBuf="mov esi,"+SymTemp.SymNameGOSUB OutCodeDataGOSUB GetIntTmpErrRetUseStrLen=TRUEOutBuf="call __StrLen"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF3:; STR(Number)GOSUB ClassOpGOSUB LoadRegErrRetIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF OpClass=INTClass THEN	IF FloatFlag<>0 THEN		OutBuf=";eax=eaxf;"		GOSUB OutCodeData		END IF	SELECT CASE FcnCode		CASE 69			TempInt=2		CASE 70			TempInt=8		CASE 3			TempInt=10		CASE 49			TempInt=16		CASE ELSE			ErrNo=ErrTypMis			RETURN	END SELECT	ImportFcnTable(ptrltoa).ImportFcnUse=TRUE				OutBuf="cinvoke ltoa,eax,[_ConvBuf1],"+STR(TempInt)ELSE	OutBuf=""END IFGOSUB OutCodeDataGOSUB NumToARETURNNumToA:GOSUB GetStrVecErrRetediUsed=TRUEOutBuf="mov edi,"+SymTemp.SymNameGOSUB OutCodeDataOutBuf="mov esi,_ConvBuf1"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF4:; VAL(String)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis;  wrong type	RETURNEND IFIF Op1Class=FLTClass AND FcnCode=4 THEN	FcnCode=24END IFIF FcnCode=24 THEN	OutBuf=";eaxf=_AtoD();"ELSE	OutBuf="mov esi,["+TSymName+"]"	GOSUB OutCodeData	UseAtoL=TRUE	OutBuf="call __AtoL"END IFGOSUB OutCodeDataIF FcnCode=24 THEN	INCR FloatFlag	OpClass=FLTClass	TDataType=FLOATVAR	GOSUB GetFltTmp	ErrRetELSE	OpClass=INTClass	GOSUB GetIntTmp	ErrRetEND IFIF FcnCode=24 THEN	OutBuf=";"+SymTemp.SymName+"=eaxf;"ELSE	OutBuf="mov ["+SymTemp.SymName+"],eax"END IFGOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF5:; LAND(Exp1,Exp2)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF TSymName<>"~" THEN	GOSUB LoadReg	ErrRetEND IFINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF TSymName<>"~" THEN	GOSUB LoadReg	ErrRetEND IFGOSUB GetIntTmpErrRetSELECT CASE FcnCode	CASE 5; LAND()		OutBuf="and eax,edx"	CASE 7; LOR()		OutBuf="or eax,edx"	CASE 9; MOD()		OutBuf="mov ecx,edx"		GOSUB OutCodeData		OutBuf="xor edx,edx"		GOSUB OutCodeData		OutBuf="idiv ecx"		GOSUB OutCodeData		OutBuf="mov eax,edx"	CASE 19; LXOR()		OutBuf="xor eax,edx"END SELECTGOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF6:; MID(String,Position,Quantity)IF FcnCode=6 THEN	IF ExpRight-ExpLeft<>4 THEN		ErrNo=ErrFcn		RETURN	END IFEND IFGOSUB MidLftRtRETURNMidLftRt:GOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	RETURNEND IFIF DMVector<>0 AND DMTemp=0 THEN	REM need to make a temp vector	GOSUB SetTmpVec	ErrRetEND IFOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB LoadReg; first argErrRetSELECT CASE FcnCode	CASE 6; Mid$		INCR ExpNdx		GOSUB ClassOp		IF OpClass<>INTClass THEN			ErrNo=ErrTypMis			RETURN		END IF		GOSUB LoadReg; second arg		ErrRet		UseMidStr=TRUE		OutBuf="call __MidStr"	CASE 8; Left$		OutBuf="mov edx,eax"		GOSUB OutCodeData		OutBuf="mov eax,1"		GOSUB OutCodeData		UseMidStr=TRUE		OutBuf="call __MidStr"	CASE 11; Right$		UseRightStr=TRUE		OutBuf="call __RightStr"	CASE 80; Tail$		UseTailStr=TRUE		OutBuf="call __TailStr"END SELECTGOSUB OutCodeDataExpNdx=ExpLeft+1RETURNF7:; LOR(Exp1,Exp2)GOSUB F5RETURNF8:; LEFT(String,Quantity)IF ExpRight-ExpLeft<>3 THEN	ErrNo=ErrFcn	RETURNEND IFGOSUB MidLftRtRETURNF9:; MOD(Exp1,Exp2)GOSUB F5RETURNF10:; CHR(Expr)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB LoadRegErrRetGOSUB GetChrVecErrRetOutBuf="mov [_ChrTmp"+STR(ChrTmpUse)+"],al"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF11:; RIGHT(String,Quantity)IF Target<>0 THEN	ErrNo=ErrIVTarg	RETURNEND IFGOSUB MidLftRtRETURNF12:; ASC(String)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrFcn	RETURNEND IFGOSUB GetIntTmpErrRetOutBuf="mov esi,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov al, byte [esi]"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF13:; NOT(Boolean)GOSUB ClassOpIF TDataType<>1 THEN	ErrNo=ErrTypMis	RETURNEND IFOpClass=BOOLClassTDataType=BOOLVARErrRetIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainEND IFGOSUB GetTmpOutBuf="btc eax,0"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNBEGIN SUB F14; BUFADR(Buffer)GOSUB ClassOpIF TDataType<>BUFFER THEN	ErrNo=ErrTypMis	EXIT SUBEND IFGOSUB GetIntTmpErrRetIF FcnCode=14 THEN	OutBuf="mov eax,["+TSymName+"]"ELSE	OutBuf="mov eax,["+TSymName+"+4]"END IFGOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F15; BUFSIZ(Buffer)GOSUB F14END SUBF16:; TAB()IF PrintFlag=0 THEN	ErrNo=ErrFcn	RETURNEND IFTabFlag=$ffGOSUB ClassOpIF OpClass=INTClass THEN	GOSUB LoadReg	ErrRet	OutBuf="call __PrintTab"	GOSUB OutCodeData	GOSUB CallErrELSE	ErrNo=ErrTypMisEND IFRETURNF17:; TIMEDIFF(DateTime1,DateTime2)GOSUB ClassOpIF TDataType<>DATETIME THEN	ErrNo=ErrTypMis	RETURNEND IFFcnOp1Nam=TSymNameINCR ExpNdxGOSUB ClassOpIF TDataType<>DATETIME THEN	ErrNo=ErrTypMis	RETURNEND IFFcnOp2Nam=TSymNameImportFcnTable(ptrSystemTimeToFileTime).ImportFcnUse=TRUEOutBuf="invoke SystemTimeToFileTime,["+FcnOp1Nam+"],!dwLowDateTime1"GOSUB OutCodeDataOutBuf="invoke SystemTimeToFileTime,["+FcnOp2Nam+"],!dwLowDateTime2"GOSUB OutCodeDataOutBuf="mov eax,[!dwLowDateTime1]"GOSUB OutCodeDataOutBuf="mov edx,[!dwHighDateTime1]"GOSUB OutCodeDataOutBuf="sub eax,[!dwLowDateTime2]"GOSUB OutCodeDataOutBuf="sbb edx,[!dwHighDateTime2]"GOSUB OutCodeDataOutBuf="mov ebx,10000000"GOSUB OutCodeDataOutBuf="idiv ebx"GOSUB OutCodeDataGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNBEGIN SUB F18:; ADDR(Var)GOSUB ClassOpIF FloatFlag>0 THEN	DECR FloatFlagEND IFIF TDataType>STRINGVAR AND TDataType<COMPLEX OR DMConst<>0 THEN	ErrNo=ErrTypMis	EXIT SUBEND IFIF DMArray=0 THEN	GOSUB GetBaseELSE	IF DMVector=0 THEN		OutBuf="mov esi,"+TSymName		GOSUB OutCodeData	ELSE		OutBuf="mov esi,["+TSymName+"]"		GOSUB OutCodeData	END IFEND IFOutBuf="mov eax,esi"GOSUB OutCodeDataGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxEND SUBF19:; LXOR(IntExpr)GOSUB F5RETURNBEGIN SUB F20; LNOT(IntExpr)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	EXIT SUBEND IFIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrRetEND IFGOSUB GetIntTmpErrRetOutBuf="not "+Reg0NameGOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F21; INDEX(Pointer,IntExpr)GOSUB ClassOpIF DMAddr=0 THEN	ErrNo=ErrTypMis	EXIT SUBEND IFFcnOp1Nam=TSymNameIF DMVector<>0 THEN	FcnOp1Nam=FcnOp1Nam+"._Ptr"END IFGOSUB GetVarSizINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	EXIT SUBEND IFGOSUB GetIntTmpErrRetOutBuf="mov eax,"+TSymNameGOSUB OutCodeDataOutBuf="imul eax,"+STR(VarSize)GOSUB OutCodeDataOutBuf="add eax,["+FcnOp1Nam+"]"GOSUB OutCodeDataOutBuf="mov ["+SymTemp.SymName+"],eax"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB GetVarSizSELECT CASE TDataType	CASE COMPLEX		VarSize=SymTable(TDetail).DataSize	CASE STRINGVAR		VarSize=TDetail	CASE BOOLVAR		VarSize=1	CASE BYTEVAR		VarSize=1	CASE WORDVAR		VarSize=2	CASE LONGVAR		VarSize=4	CASE FLOATVAR		VarSize=8END SELECTEND SUBBEGIN SUB F22; SIZE(Var)GOSUB ClassOpIF FloatFlag>0 THEN	DECR FloatFlagEND IFIF TDataType<1 OR TDataType>6 THEN SIZE1VarSize=TDataSizeGOTO SIZE2SIZE1:IF TDataType=BUFFER THEN	VarSize=8	GOTO SIZE2END IFIF TDataType=COMPLEX THEN	VarSize=TDataSize	GOTO SIZE2END IFErrNo=ErrTypMisRETURNSIZE2:GOSUB GetIntTmpErrRetOutBuf="mov ["+SymTemp.SymName+"],"+STR(VarSize)GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxEND SUBF23:; IVAL(String)GOSUB F4RETURNF24:; FVAL(String)GOSUB F4RETURNF25:; TRIM$GOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	RETURNEND IFIF DMVector<>0 AND DMTemp=0 THEN	GOSUB SetTmpVec	ErrRetEND IFOutBuf=""'call __TrmStrGOSUB OutCodeDataExpNdx=ExpLeft+1RETURNF26:; LOF(FileNum)GOSUB ClassOpGOSUB GetFileHandle2ErrRetImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUEOutBuf="invoke GetFileSize,[_IOPthNum],0"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF27:; POF(FileNum)GOSUB ClassOpGOSUB GetFileHandle2ErrRetImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],0,0,FILE_CURRENT"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF28:; SQR(Expr)GOSUB ClassOpINCR FloatFlagIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNEND IFSELECT CASE FcnCode	CASE 28		TempStr="sqrt"	CASE 31		TempStr="sin"	CASE 32		TempStr="cos"	CASE 33		TempStr="tan"	CASE 34		TempStr="asin"	CASE 35		TempStr="acos"	CASE 36		TempStr="atan"	CASE 37		TempStr="log"	CASE 38		TempStr="log10"END SELECTGOSUB GetFltTmpErrRetIF DMVector=0 THEN	OutBuf=";"+SymTemp.SymName+"="+TempStr+"((double)"+TSymName+");"ELSE	OutBuf=";"+SymTemp.SymName+"="+TempStr+"(*((double*)"+TSymName+"._Ptr));"END IFGOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF29:; INT(FloatExpr)GOSUB ClassOpIF FloatFlag>0 THEN	DECR FloatFlagEND IFIF OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB GetIntTmpErrRetIF DMVector=0 THEN	OutBuf=";"+SymTemp.SymName+"=(long)"+TSymName+";"ELSE	OutBuf=";"+SymTemp.SymName+"=(long)*((double*)"+TSymName+"._Ptr);"END IFGOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF30:; ABS(Expr)GOSUB ClassOpIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF SymTemp.SymName<>"~" THEN	D0Loaded=0	GOSUB LoadRegEND IFIF OpClass=INTClass THEN	GOSUB GetIntTmp	ErrRet	ImportFcnTable(ptrabs).ImportFcnUse=TRUE	OutBuf="cinvoke abs,eax"	GOSUB OutCodeData	GOSUB StoreD0TmpELSE	GOSUB GetFltTmp	ErrRet	OutBuf=";"+SymTemp.SymName+"=fabs("+TSymName+");"	GOSUB OutCodeDataEND IFExpTable(ExpNdx)=SymNdxRETURNF31:; SIN(Expr)GOSUB F28RETURNF32:; COS(Expr)GOSUB F28RETURNF33:; TAN(Expr)GOSUB F28RETURNF34:; ASN(Expr)GOSUB F28RETURNF35:; ACS(Expr)GOSUB F28RETURNF36:; ATN(Expr)GOSUB F28RETURNF37:; LOG(Expr)GOSUB F28RETURNF38:; LOG10(Expr)RETURNF39:; VacantRETURNF40:; VacantRETURNF41:; VacantRETURNF42:; VacantRETURNF43:; VacantRETURNF44:; VacantRETURNF45:; VacantRETURNF46:; VacantRETURNF47:; VacantRETURNF48:; CHKWORD(STRING);code template is for ASC(STRING)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrFcn	RETURNEND IFGOSUB GetIntTmpErrRetOutBuf="xor eax,eax"GOSUB OutCodeDataOutBuf="mov esi,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov edx,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="xor ecx,ecx"GOSUB OutCodeDataINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="xor ebx,ebx"GOSUB OutCodeDataOutBuf="mov bl, byte [esi]"GOSUB OutCodeDataOutBuf="or bl,bl"GOSUB OutCodeDataOutBuf="je "+"_Lbl"+STR(LabelNum+1)GOSUB OutCodeDataOutBuf="sal ebx,cl"GOSUB OutCodeDataOutBuf="inc esi"GOSUB OutCodeDataOutBuf="add cl,4"GOSUB OutCodeDataOutBuf="add eax,ebx"GOSUB OutCodeDataOutBuf="dec edx"GOSUB OutCodeDataOutBuf="jne "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF49:; HEX(INT)GOSUB F3RETURNF50:; BITTST(ByteVar,Bit#)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB LoadRegErrRetINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB LoadRegErrRetOutBuf="bt eax,edx"GOSUB OutCodeDataOpClass=BOOLClassTDataType=BOOLVARGOSUB GetTmpErrRetOutBuf="setc cl; Set result"GOSUB OutCodeDataOutBuf="mov byte ["+SymTemp.SymName+"],cl"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF51:; SHLGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB LoadRegErrRetINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB LoadRegErrRetOutBuf="mov ecx,edx"GOSUB OutCodeDataOpSizeStr="cl"SELECT CASE FcnCode	CASE 51		TempStr="shl "	CASE 52		TempStr="shr "	CASE 53		TempStr="rol "	CASE 54		TempStr="ror "	CASE 55		TempStr="btc "		OpSizeStr="ecx"	CASE 56		TempStr="btr "		OpSizeStr="ecx"	CASE 57		TempStr="bts "		OpSizeStr="ecx"	CASE 62		TempStr="sal "	CASE 63		TempStr="sar "	CASE 64		TempStr="rcl "	CASE 65		TempStr="rcr "END SELECTOutBuf=TempStr+Reg0Name+","+OpSizeStrGOSUB OutCodeDataGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF52:; SHRGOSUB F51RETURNF53:; ROLGOSUB F51RETURNF54:; RORGOSUB F51RETURNF55:; BITCHGGOSUB F51RETURNF56:; BITCLRGOSUB F51RETURNF57:; BITSETGOSUB F51RETURNF58:; SUBSTR(Str1,Str2,[StartPos])GOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrIVType	RETURNEND IFIF DMVector<>0 AND DMTemp=0 THEN	GOSUB SetTmpVec	ErrRetEND IFFcnOp1Nam=TSymNameINCR ExpNdxGOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrIVType	RETURNEND IFIF DMVector<>0 AND DMTemp=0 THEN	GOSUB SetTmpVec	ErrRetEND IFTempStr=TSymNameIF ExpRight-ExpLeft=4 THEN	INCR ExpNdx	GOSUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrIVType		RETURN	END IFELSE	TSymName="1"END IFGOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=_SubStr(&"+FcnOp1Nam+",&"+TempStr+","+TSymName+");"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF59:; ZSTR(INT)GOSUB ClassOpGOSUB LoadRegErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFOutBuf=";_ZLtoA(eax);"GOSUB OutCodeDataGOSUB NumToARETURNF60:; ZHEX(INT)GOSUB ClassOpGOSUB LoadRegErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFOutBuf=";_ZLtoH(eax);"GOSUB OutCodeDataGOSUB NumToARETURNF61:; USING()RETURNF62:; SAL()GOSUB F51RETURNF63:; SAR()GOSUB F51RETURNF64:; RCL()GOSUB F51RETURNF65:; RCR()GOSUB F51RETURNF66:' TABLESIZE()GOSUB ClassOpIF LAND(TDataMod,ArrayBit)<>ArrayBit THEN	ErrNo=ErrTypMis	RETURNEND IFGOSUB GetIntTmpErrRetTempInt=TDataSize/TDataAddrOutBuf="mov ["+SymTemp.SymName+"],"+STR(TempInt)GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF67:' FilTyp()'GetFileTypeRETURNF68:' CurDir()'GetCurrentDirectoryRETURNF69:' BIN()GOSUB F3RETURNF70:' OCT()GOSUB F3RETURNF71:' Vacant()RETURNF72:' RND()GOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=rand();"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF73:' GETTICKCOUNT()GOSUB GetIntTmpErrRetImportFcnTable(ptrGetTickCount).ImportFcnUse=TRUEOutBuf="invoke GetTickCount"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF74:' Vacant()RETURNF75:' Vacant()RETURNF76:' Vacant()RETURNF77:' Vacant()RETURNF78:' LCASE()GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis	RETURNEND IFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataOutBuf="mov esi,_IOBuffer"GOSUB OutCodeDataIF FcnCode=78 THEN	UseLCase=TRUE	OutBuf="call __LCase"ELSE	UseUCase=TRUE	OutBuf="call __UCase"END IFGOSUB OutCodeDataExpTable(ExpNdx)=96RETURNF79:' UCASE()GOTO F78F80:' Tail(String,Start)IF Target<>0 THEN	ErrNo=ErrIVTarg	RETURNEND IFGOSUB MidLftRtRETURNF81:' FINDADDR()GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFD0Loaded=0GOSUB LoadRegOutBuf="mov [_Poker],eax"GOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFD0Loaded=0GOSUB LoadRegOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFD0Loaded=0GOSUB LoadReg GOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=0;"GOSUB OutCodeDataOutBuf=";while (_ArgSafe0){"GOSUB OutCodeDataOutBuf=";if(*_Poker == eax){"GOSUB OutCodeDataOutBuf=";"+SymTemp.SymName+"=(long)_Poker;"GOSUB OutCodeDataOutBuf=";break;}"GOSUB OutCodeDataOutBuf=";_Poker++;"GOSUB OutCodeDataOutBuf=";_ArgSafe0--;}"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF82:' FINDOFFS()GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFD0Loaded=0GOSUB LoadReg' %%%%%%%%%%%############ bug followsOutBuf="mov [_Poker],eax"OutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataGOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFD0Loaded=0GOSUB LoadRegOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFD0Loaded=0GOSUB LoadReg GOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=-1;"GOSUB OutCodeDataOutBuf=";while (_ArgSafe0){"GOSUB OutCodeDataOutBuf=";if(*_Poker == eax){"GOSUB OutCodeDataOutBuf=";"+SymTemp.SymName+"=(long)_Poker-_ArgSafe1;"GOSUB OutCodeDataOutBuf=";break;}"GOSUB OutCodeDataOutBuf=";_Poker++;"GOSUB OutCodeDataOutBuf=";_BlkCnt++;"GOSUB OutCodeDataOutBuf=";_ArgSafe0--;}"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNOutCodeData:INCR AsmLineCtrIF StartFlag=TRUE THEN	IF ProcFcnFlag=FALSE OR GUIFlag=TRUE THEN		GOSUB OutCode	ELSE		GOSUB OutFunction	END IFELSE	WRITE DataFile,OutBufEND IFRETURNOutUninitData:WRITE DimFile,OutBufINCR AsmLineCtrRETURNOutDesc:WRITE DescFile,OutBufINCR AsmLineCtrRETURNOutDeclare:WRITE DeclareFile,OutBufINCR AsmLineCtrRETURNOutInitData:WRITE DataFile,OutBufINCR AsmLineCtrRETURNOutCode:IF DeferFlag=TRUE THEN	DeferFlag=FALSE	IF OutBuf="mov eax, dword [_Tmp1]" THEN		AsmLineCtr=AsmLineCtr-2		RETURN	ELSE		TempStr=OutBuf		OutBuf="mov [_Tmp1],eax"		WRITE CodeFile,OutBuf		OutBuf=TempStr		WRITE CodeFile,OutBuf		RETURN	END IF			END IFIF OutBuf="mov [_Tmp1],eax" THEN	DeferFlag=TRUE	RETURNEND IFWRITE CodeFile,OutBufINCR AsmLineCtrRETURNOutFunction:IF DeferFlag=TRUE THEN	DeferFlag=FALSE	IF OutBuf="mov eax, dword [_Tmp1]" THEN		AsmLineCtr=AsmLineCtr-2		RETURN	ELSE		TempStr=OutBuf		OutBuf="mov [_Tmp1],eax"		WRITE FunctionFile,OutBuf		OutBuf=TempStr		WRITE FunctionFile,OutBuf		RETURN	END IF			END IFIF OutBuf="mov [_Tmp1],eax" THEN	DeferFlag=TRUE	RETURNEND IFWRITE FunctionFile,OutBufINCR AsmLineCtrRETURNOutPreCode:WRITE PreCodeFile,OutBufINCR AsmLineCtrRETURNOutResource:WRITE ResourceFile,OutBufINCR AsmLineCtrRETURNOutExport:WRITE ExportFile,OutBufINCR AsmLineCtrRETURNOutInitCode:WRITE InitFile,OutBufINCR AsmLineCtrRETURNStoreD0Tmp:OutBuf="mov ["+SymTemp.SymName+"],eax"GOSUB OutCodeDataD1Cleared=0RETURNOutWrite:IF PrintFlag=0 THEN	ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE	OutBuf="invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0"ELSE	OutBuf=";STATUS=write(_PrtPthNum,_XferAddr,XferCount);"END IFGOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZRETURNOutRead:ImportFcnTable(ptrReadFile).ImportFcnUse=TRUEOutBuf="invoke ReadFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZRETURNSetStatus:OutBuf="mov [STATUS],eax"GOSUB OutCodeDataRETURNOutCRLF:OutBuf="mov [_XferAddr],_CRLF"GOSUB OutCodeDataOutBuf="mov [XferCount],2"GOSUB OutCodeDataOutBuf=";STATUS=write(_PrtPthNum,_XferAddr,XferCount);"GOSUB OutCodeDataGOSUB CallErr RETURNMacDefInc:INCR MacDefNdxIF MacDefNdx>MacBufSiz THEN	DECR MacDefNdx	ErrNo=ErrMacBufEND IFRETURNIncConStk:INCR ConStkPtrIF ConStkPtr>40 THEN	ErrNo=ErrNDeepEND IFRETURNMakString:IF OpClass=BOOLClass THEN	IF TSymName<>"~" THEN		D0Loaded=0		GOSUB LoadReg		ErrRet	END IF	UseBtoA=TRUE	OutBuf="call __BtoA"	GOSUB OutCodeData	GOSUB NumToA	RETURNEND IFIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrRetEND IFIF FloatFlag=0 THEN	ImportFcnTable(ptrltoa).ImportFcnUse=TRUE	OutBuf="cinvoke ltoa,eax,[_ConvBuf1],10"ELSE	OutBuf=";_DtoA(eaxf);"END IFGOSUB OutCodeDataGOSUB NumToARETURNConStkChk:IF ConStkPtr<1 THEN	ErrNo=ErrUBCon	RETURNEND IFIF ConStk(ConStkPtr).ConType<>TempInt THEN	ErrNo=ErrUBConEND IFRETURNStrSiz:SymNdxSaf=SymNdxTokenBuf=SymTemp.SymNameTempByte=LEFT(TempStr,1)IF TempByte>="0" AND TempByte<="9" THEN	TempInt=VAL(TempStr)ELSE	SymTemp.SymName=TempStr	GOSUB SymSrch	IF SymFound=TRUE AND SymTable(SymNdx).DataType=COMPVAR OR SymTable(SymNdx).DataType=MACROVAR THEN		TempInt=SymTable(SymNdx).Detail	ELSE		ErrNo=ErrUDSym		RETURN	END IFEND IFSymNdx=SymNdxSafSymTemp.SymName=TokenBufRETURNRemark:OutBuf="; LN:"+STR(BasicLineCtr)+" "+SrcLineRETURNBldComment:OutBuf=";"+CommentRETURNGetDtaTyp:SELECT CASE TDataType	CASE BOOLVAR		_DataType=" byte "	CASE BYTEVAR		_DataType=" byte "	CASE WORDVAR		_DataType=" word "	CASE LONGVAR		_DataType=" dword "	CASE FLOATVAR		_DataType=" double "END SELECTIF LAND(TDataMod,PointerBit)=PointerBit THEN	_DataType=" dword "END IFRETURNVecSymNam:'GOSUB GetDtaTypVSymName=TSymNameTSymName="["+VSymName+"]"RETURNGetIntOp:GOSUB GetExpErrRetGOSUB ProcOp2ErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF SymTemp.SymName<>"~" THEN	D0Loaded=0	GOSUB LoadRegEND IFRETURNGetGUINdx:GOSUB ExprErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF SymTemp.SymName<>"~" THEN	D0Loaded=0	GOSUB LoadRegEND IFRETURNGetFltOp:GOSUB ExprErrRetIF OpClass<>FLTClass AND OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNEND IFIF TSymName="~" AND OpClass=INTClass THEN	TSymName="eax"END IFIF TSymName<>"~" OR OpClass=INTClass THEN	OutBuf=";eaxf="+TSymName+";"	GOSUB OutCodeDataEND IFRETURNGetComma:GOSUB NexTokenIF TokenBuf<>"," THEN	ErrNo=ErrSyntaxEND IFRETURNGetColon:GOSUB NexTokenIF TokenBuf<>":" THEN	ErrNo=ErrSyntaxEND IFRETURNGetEqual:GOSUB NexTokenIF TokenBuf<>"=" THEN	ErrNo=ErrSyntaxEND IFRETURNSubLoad:D0Loaded=0GOSUB LoadRegErrRetIF FloatFlag<>0 THEN	OutBuf=";eax=eaxf;"	GOSUB OutCodeDataEND IFRETURNReadSource:IF InpFilPtr=1 THEN	INCR BasicLineCtrEND IFSrcLine=""SrcNdx=0EndNdx=0EndFound=0QuoteFlag=0WhiteSpaceCtr=0FirstValidChar=FALSEBEGIN LOOP	GET InpFile(InpFilPtr),RawData	TempInt=XferCount	IF TempInt=0 THEN		IF ASC(LastRawData)<>$0d THEN			RawData=CHR$($0d)			TempInt=1		ELSE				IF EndFound=0 THEN				EndNdx=EndNdx-WhiteSpaceCtr			END IF			RETURN		END IF	END IF	LastRawData=RawData	AsciiByte=ASC(RawData) 	IF AsciiByte=NewLine THEN		IF EndFound=0 THEN			EndNdx=EndNdx-WhiteSpaceCtr		END IF		RETURN	END IF	IF QuoteFlag=0 THEN		IF AsciiByte=OBQUOTE THEN			QuoteFlag=$ff		END IF	ELSE		IF AsciiByte=OBQUOTE THEN			QuoteFlag=0		END IF	END IF	IF AsciiByte=$27  OR AsciiByte=$3b THEN; Comment?		IF QuoteFlag=0 THEN			EndFound=$ff			EndNdx=EndNdx-WhiteSpaceCtr		END IF	END IF	IF AsciiByte=$09 OR AsciiByte=$20 THEN		INCR WhiteSpaceCtr	ELSE		IF AsciiByte<>$0d THEN			WhiteSpaceCtr=0		END IF	END IF	IF FirstValidChar=FALSE THEN		IF AsciiByte<>$0a AND AsciiByte<>$0d AND AsciiByte<>$09 AND AsciiByte<>$20 THEN			FirstValidChar=TRUE			SrcLine=SrcLine+RawData			IF EndFound=0 THEN				INCR EndNdx			END IF		END IF	ELSE		IF AsciiByte<>$0d THEN' Temporary code?			SrcLine=SrcLine+RawData			IF EndFound=0 THEN				INCR EndNdx			END IF		END IF	END IFEND LOOPRETURNGenCase:IF OpClass=INTClass THEN	OutBuf="mov edx,[_SwitchInt]"	GOSUB OutCodeData	OutBuf="cmp eax,edx"	GOSUB OutCodeData	OutBuf=SymType+"_Lbl"+STR(LabelNum)ELSE	ediUsed=TRUE	OutBuf="mov edi,_SwitchStr"	GOSUB OutCodeData	OutBuf="mov esi,"+TSymName	GOSUB OutCodeData	UseCmpStr=TRUE	OutBuf="call __CmpStr"	GOSUB OutCodeData		OutBuf=SymType+"_Lbl"+STR(LabelNum)END IFGOSUB OutCodeDataRETURNEndCasex:TempInt=7GOSUB ConStkChkErrRetOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"' get here if case not trueGOSUB OutCodeDataRETURNMainLoopInit:ediUsed=FALSEDataLabel=FALSEGetBaseFlag=FALSEGetPutFlag=FALSEGOSUB ClrDatTypDMReDim=0CmpOpFlag=FALSEInitTrue=0IgnoreRightParen=0SimpleCmp=0ComplexCmp=0HasFcn=0Target=0GUIObjFlag=0'//TextFlag=0'//PrintFlag=0StatFlag=0TabFlag=0DevFlag=0CreateObjectFlag=FALSEFileIO=0DiskIO=0BufRWFlg=0D1Cleared=0LabelFlag=0Op1Class=0ReadFlag=0CompFlag=0Promote=0Demote=0LNFlag=0TmpUse=0TmpVecUse=0FTmpUse=0ChrTmpUse=0StrTmpUse=0DimFlag=0TypeFlag=0AliasFlag=0TDataMod=0EndSegFlag=FALSERETURNClrDataRegs:IF TDataType<>LONGVAR AND TDataType<>BOOLVAR THEN' Check for pointer here also?	IF D1Cleared=0 THEN		IF D0Loaded=0 THEN			OutBuf="xor eax,eax"		ELSE			D1Cleared=$ff			OutBuf="xor edx,edx"		END IF		GOSUB OutCodeData	END IFEND IFRETURNGetSymTemp:SymTemp=SymTable(SymNdx)RETURNGetSymTempExpNdx:SymTemp=SymTable(ExpTable(ExpNdx))RETURNBEGIN SUB ChkLabelLNFlag=$ffGOSUB TokenSymErrRetIF SymFound=FALSE THEN	SymTemp.DataType=LABELVAR	GOSUB ClrSym	SymTemp.Detail=LabelUnresolved	IF KeyNdx=2 THEN' Restore		SymTemp.DataMod=DataBit	END IF	GOSUB SymInsert	ErrRetEND IFEND SUBBEGIN SUB MakeStrConstINCR PoolCtrOutBuf="_StrConst"+STR(PoolCtr)+" db "+TokenSaf+",0"GOSUB OutInitDataEND SUBBEGIN SUB MakeBufferComment="Memory Buffer"GOSUB BldCommentGOSUB OutInitDataOutBuf=BufName+" dd 0"GOSUB OutInitDataOutBuf=" dd 0"GOSUB OutInitDataEND SUBBEGIN SUB ReleaseBufferOutBuf="cmp ["+BufName+"+4],0"GOSUB OutCodeDataINCR LabelNumOutBuf="je "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,["+BufName+"],0,MEM_RELEASE"GOSUB OutCodeDataOutBuf="mov ["+BufName+"],0"GOSUB OutCodeDataOutBuf="mov ["+BufName+"+4],0"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataEND SUBBEGIN SUB GetBufferOutBuf="push eax"GOSUB OutCodeDataOutBuf="cmp ["+BufName+"+4],0"GOSUB OutCodeDataINCR LabelNumOutBuf="je "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,["+BufName+"],0,MEM_RELEASE"GOSUB OutCodeDataOutBuf="mov ["+BufName+"],0"GOSUB OutCodeDataOutBuf="mov ["+BufName+"+4],0"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="pop eax"GOSUB OutCodeDataOutBuf="mov ["+BufName+"+4],eax"GOSUB OutCodeDataImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUEOutBuf="invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE"GOSUB OutCodeDataOutBuf="mov ["+BufName+"],eax"GOSUB OutCodeDataEND SUBBEGIN SUB PushArgsIgnoreRightParen=$ffSymTemp=SymTable(SymNdx)GOSUB GetFcnTypesGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFNeedComma=0Ctr3=0PushArgsLp:IF Ctr3>TFcnArgs THEN	ErrNo=ErrFcnArgs	RETURNEND IFGOSUB NexTokenIF TokenBuf=")" THEN	IF Ctr3<>TFcnArgs THEN		ErrNo=ErrFcnArgs	END IF	EXIT SUB	END IFIF NeedComma<>0 THEN	IF TokenSaf<>"," THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	NeedComma=0	GOTO PushArgsLpELSE	IF TokenSaf="," THEN		ErrNo=ErrSyntax		EXIT SUB	END IFEND IFGOSUB UnDoTokenGOSUB ExprErrRetINCR Ctr3GOSUB ArgPushErrRetNeedComma=$ffGOTO PushArgsLpEND SUBPopArgs:SymTemp=SymTable(SymNdx)GOSUB GetFcnTypesGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFNeedComma=0Ctr3=0PopArgsLp:IF Ctr3>TFcnArgs THEN	ErrNo=ErrFcnArgs	RETURNEND IFGOSUB NexTokenIF TokenBuf=")" THEN	IF Ctr3<>TFcnArgs THEN		ErrNo=ErrFcnArgs	END IF	RETURN	END IFIF NeedComma<>0 THEN	IF TokenSaf<>"," THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	NeedComma=0	GOTO PopArgsLpELSE	IF TokenSaf="," THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IFEND IFINCR Ctr3SymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=TRUE THEN	ErrNo=ErrDupSym	ErrRetEND IFSymTemp.Detail=0OutBuf="; Auto diminsion of argument"GOSUB OutUninitDataOutBuf="align 4"GOSUB OutUninitDataSELECT CASE FcnTypes(Ctr3)	CASE BOOLVAR		; Pop bool here	CASE LONGVAR		OutBuf=TokenSaf+" rd 1"		GOSUB OutUninitData		OutBuf="mov eax,[_FcnArg"+STR(Ctr3)+"]"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"],eax"		GOSUB OutCodeData		SymTemp.DataType=LONGVAR		SymTemp.DataMod=0		SymTemp.DataAddr=4	CASE FLOATVAR		; Pop float here	CASE STRINGVAR		OutBuf=TokenSaf+" rd 3"		GOSUB OutUninitData		OutBuf="mov esi,[_FcnArg"+STR(Ctr3)+"]"		GOSUB OutCodeData		OutBuf="mov eax,[esi]"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"],eax"		GOSUB OutCodeData		OutBuf="add esi,4"		GOSUB OutCodeData		OutBuf="mov eax,[esi]"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"+4],eax"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"+8],0"		GOSUB OutCodeData		SymTemp.DataType=STRINGVAR		SymTemp.DataMod=VectorBitEND SELECTGOSUB SymInsertNeedComma=$ffGOTO PopArgsLpRETURNGetFcnTypes:TFcnArgs=SymTemp.FcnArgsTFcnDataType=SymTemp.FcnDataTypeFcnTypes(1)=SymTemp.DataAddrFcnTypes(2)=SymTemp.DataSizeFcnTypes(3)=SymTemp.ArrayDim1FcnTypes(4)=SymTemp.ArrayDim2FcnTypes(5)=SymTemp.ArrayDim3FcnTypes(6)=SymTemp.ArrayDimsFcnTypes(7)=SymTemp.MiscRETURNChkInt:GOSUB ValidIntIF IntOK=0 THEN	ErrNo=ErrIVExpEND IFRETURNChkSym:GOSUB TokenSym1ErrRetIF SymFound=FALSE THEN	ErrNo=ErrUDSym	RETURNEND IFRETURNChkHex:GOSUB ValidHexIF HexOK=0 THEN	ErrNo=ErrIVExp	RETURNEND IFRETURNChkFlt:GOSUB ValidFltIF FloatOK=0 THEN	ErrNo=ErrIVExp	GOTO MainLoopEND IFRETURNLoadNumericValue:IF TSymName<>"~" THEN	IF OpClass=INTClass THEN		D0Loaded=0		GOSUB LoadReg	ELSE		;TSymName="eaxf"	END IFELSE	IF OpClass=INTClass THEN		TSymName="eax"	ELSE		;TSymName="eaxf"	END IFEND IFRETURNPushNumeric:GOSUB LoadNumericValueOutBuf="mov [_FcnArg"+STR(Ctr3)+"],eax"GOSUB OutCodeDataRETURNProcFcnPrep:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFSymTable(SymNdx).Detail=LabelResolvedGOSUB GetSymTempOutBuf=SymTemp.SymName+":"GOSUB OutFunctionGOSUB GetFcnTypesRETURNArgPush:SELECT CASE OpClass	CASE BOOLClass		IF FcnTypes(Ctr3)<>BOOLVAR THEN			ErrNo=ErrTypMis			RETURN		END IF		; Push bool here	CASE INTClass		IF FcnTypes(Ctr3)<>LONGVAR THEN			ErrNo=ErrTypMis			RETURN		END IF		GOSUB PushNumeric	CASE FLTClass		IF FcnTypes(Ctr3)<>FLOATVAR THEN			ErrNo=ErrTypMis			RETURN		END IF		GOSUB PushNumeric	CASE STRClass		IF FcnTypes(Ctr3)<>STRINGVAR THEN			ErrNo=ErrTypMis			RETURN		END IF		OutBuf="mov [_FcnArg"+STR(Ctr3)+"],"+TSymName		GOSUB OutCodeDataEND SELECTRETURNChkUse:RESTORE MovArgLibGOSUB OutLibCodeTextIF UseReadFile=TRUE THEN	ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE	RESTORE ReadFileLib	GOSUB OutLibCodeTextEND IFIF UseWriteFile=TRUE THEN	ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE	RESTORE WriteFileLib	GOSUB OutLibCodeTextEND IFIF UseWriteOBComm=TRUE THEN	ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE	RESTORE WriteOBCommLib	GOSUB OutLibCodeTextEND IFIF UseInpData=TRUE THEN	ImportFcnTable(ptrReadConsole).ImportFcnUse=TRUE	ImportFcnTable(ptratol).ImportFcnUse=TRUE	RESTORE InpDataLib	GOSUB OutLibCodeTextEND IFIF UseData=TRUE THEN	ImportFcnTable(ptratol).ImportFcnUse=TRUE	RESTORE DataLib	GOSUB OutLibCodeTextEND IFIF UseCmpStr=TRUE THEN	RESTORE CmpStrLib	GOSUB OutLibCodeTextEND IFIF UseMovStr=TRUE THEN	RESTORE MovStrLib	GOSUB OutLibCodeTextEND IFIF UseStrLen=TRUE THEN	RESTORE StrLenLib	GOSUB OutLibCodeTextEND IFIF UseAtoL=TRUE THEN	ImportFcnTable(ptratol).ImportFcnUse=TRUE	RESTORE AtoLLib	GOSUB OutLibCodeTextEND IFIF UseBtoA=TRUE THEN	RESTORE BtoALib	GOSUB OutLibCodeTextEND IFIF UseSetStrConst=TRUE THEN	RESTORE SetStrConstLib	GOSUB OutLibCodeTextEND IFIF UseMidStr=TRUE THEN	RESTORE MidStrLib	GOSUB OutLibCodeTextEND IFIF UseSetRightBottom=TRUE THEN	RESTORE SetRightBottomLib	GOSUB OutLibCodeTextEND IFIF UseRightStr=TRUE THEN	RESTORE RightStrLib	GOSUB OutLibCodeTextEND IFIF UseTailStr=TRUE THEN	RESTORE TailStrLib	GOSUB OutLibCodeTextEND IFIF UseLCase=TRUE THEN	RESTORE LCaseLib	GOSUB OutLibCodeTextEND IFIF UseUCase=TRUE THEN	RESTORE UCaseLib	GOSUB OutLibCodeTextEND IFRETURNOutLibCodeText:BEGIN LOOP	READ OutBuf	EXIT IF OutBuf="ENDTEXT"	GOSUB OutFunction	INCR AsmLineCtrEND LOOPRETURNOutPreCodeText:BEGIN LOOP	READ OutBuf	EXIT IF OutBuf="ENDTEXT"	WRITE PreCodeFile,OutBuf	INCR AsmLineCtr	END LOOPRETURNOutUninitText:BEGIN LOOP	READ OutBuf	EXIT IF OutBuf="ENDTEXT"	GOSUB OutUninitData	END LOOPRETURNOutInitText:BEGIN LOOP	READ OutBuf	EXIT IF OutBuf="ENDTEXT"	GOSUB OutInitData	END LOOPRETURNValidateParentObject:ParentFlag=$ffGOTO ValidateObject1ValidateObject:ParentFlag=0ValidateObject1:IF ParentFlag=0 THEN; ******??????	GUIArrayFlag=0END IFGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ObjectType=0ELSE	ObjectType=SymTable(SymNdx).DataTypeEND IFIF LAND(SymTable(SymNdx).DataMod,ArrayBit)<>0 AND ParentFlag<>0 THEN	ErrNo=ErrTypMis	RETURNEND IFIF ObjectType=FORM THEN	FormExStyle="0"END IFIF ObjectType=TOOLWINDOW THEN	FormExStyle="WS_EX_TOOLWINDOW"END IFObjectName=SymTable(SymNdx).SymNameIF ObjectType<100 THEN	ErrNo=ErrIVType	RETURNEND IFIF ParentFlag<>0 THEN	ObjectParent="!"+ObjectName+"+HandleOffs"	ObjectParentName="!"+ObjectName	RETURNEND IFGOSUB ProcessObjectRETURNProcessObject:HandleName="edi+HandleOffs"GUIArrayFlag=LAND(SymTable(SymNdx).DataMod,ArrayBit)IF ObjectType=TIMER OR ObjectType=OBCOMM THEN	RETURNEND IFOutBuf="mov edi,!"+ObjectNameGOSUB OutCodeDataIF GUIArrayFlag<>0 THEN	IF NextByte="." THEN; Must be event		RETURN	END IF	GOSUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		RETURN	END IF	IF ParentFlag=0 THEN; ??????????		TArrayDim1=SymTable(SymNdx).ArrayDim1	END IF	IgnoreRightParen=$ff	GUIObjFlag=0	GOSUB GetGUINdx	ErrRet	IF CreateObjectFlag=TRUE THEN		OutBuf="mov [ArrayIndex],eax"		GOSUB OutCodeData	END IF	DecArrayNdx	OutBuf="imul eax,768"	GOSUB OutCodeData	OutBuf="add edi,eax"	GOSUB OutCodeData	INCR SrcNdx; Point past ')'	IgnoreRightParen=0END IFIF GUITargetFlag<>0 THEN	OutBuf="mov [!TargetGUIDesc],edi"	GOSUB OutCodeDataELSE	OutBuf="mov [!SourceGUIDesc],edi"	GOSUB OutCodeDataEND IF	RETURNGetStringOp:GOSUB GetExpErrRetGOSUB ProcOp2ErrRetIF Op2Class<>STRClass THEN	ErrNo=ErrIVTypeEND IFRETURNGetTextOp:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	RETURNEND IFGOSUB GetSymTempIF SymTemp.DataType<>TEXT THEN	ErrNo=ErrIVType	RETURNEND IFIF SymTemp.DataMod=0 THEN	ErrNo=ErrTextNotDefined	RETURNEND IFTSymName=SymTemp.SymNameRETURNRightBracket:FOR I=SrcNdx TO LEN(SrcLine)	IF MID(SrcLine,I,1)="]" THEN BracketFoundNEXT IErrNo=ErrSyntaxRETURNBracketFound:SrcLineMod=IMID(SrcLine,SrcLineMod,1)=CHR(0)RETURNGUIFatal:;TempStr=SrcLine;GOSUB OutPrintTempStr="Fatal Error... GUI statement or declaration in Console program"ErrNo=$ffGOTO MainLoopTimerArray:GOSUB NexTokenIF TokenBuf="." THEN; Must be event	GOSUB UnDoToken	RETURNEND IFIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFIgnoreRightParen=$ffGUIObjFlag=0GOSUB GetGUINdxErrRetOutBuf="mov ebx,eax"GOSUB OutCodeDataOutBuf="shl ebx,16"GOSUB OutCodeDataINCR SrcNdx; Point past ')'IgnoreRightParen=0HasSubscript=TRUERETURNOBCommArray:GOSUB NexTokenIF TokenBuf="." THEN; Must be event	GOSUB UnDoToken	RETURNEND IFIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFIgnoreRightParen=$ffGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxOutBuf="imul eax,100"GOSUB OutCodeDataINCR SrcNdx; Point past ')'IgnoreRightParen=0HasSubscript=TRUERETURNGUITarget:HasSubscript=FALSEIF ObjectType=TIMER THEN	IF ObjectArray<>0 THEN		GOSUB TimerArray	END IF	GOSUB NexToken	IF TokenBuf<>"." THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	GOSUB NexToken	SELECT CASE TokenBuf		CASE "time"			OutBuf="mov eax,"+STR(ObjectDetail)			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add eax,ebx"				GOSUB OutCodeData			END IF			OutBuf="mov [_ArgSafe0],eax"			GOSUB OutCodeData			EqualMain			GOSUB GetIntOp			ErrMain			ImportFcnTable(ptrSetTimer).ImportFcnUse=TRUE			OutBuf="invoke SetTimer,[!OBMain],[_ArgSafe0],eax,NULL"			GOSUB OutCodeData		CASE "stop"			OutBuf="mov eax,"+STR(ObjectDetail)			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add eax,ebx"				GOSUB OutCodeData			END IF			ImportFcnTable(ptrKillTimer).ImportFcnUse=TRUE			OutBuf="invoke KillTimer,[!OBMain],eax"			GOSUB OutCodeData		CASE "timeout"			TempStr=ObjectName+"_"+TokenSaf			SymTemp.SymName=TempStr			GOSUB MakeEvent			ErrMain			IF ObjectArray<>0 THEN				OutBuf="mov ecx,"+STR(ObjectArray)				GOSUB OutInitCode				OutBuf="mov esi,!Timer+"+STR(ObjectDetail*4)				GOSUB OutInitCode				INCR LabelNum				OutBuf="_Lbl"+STR(LabelNum)+":"				GOSUB OutInitCode				OutBuf="mov dword [esi],"+TempStr				GOSUB OutInitCode				OutBuf="add esi,4"				GOSUB OutInitCode				OutBuf="dec ecx"				GOSUB OutInitCode				OutBuf="jne _Lbl"+STR(LabelNum)				GOSUB OutInitCode			ELSE				OutBuf="mov [!Timer+"+STR(ObjectDetail*4)+"],"+TempStr				GOSUB OutInitCode			END IF		CASE ELSE			ErrNo=ErrIVProp			GOTO MainLoop	END SELECT	GOTO MainLoopEND IFIF ObjectType=OBCOMM THEN	IF ObjectArray<>0 THEN		GOSUB OBCommArray	END IF	GOSUB NexToken	IF TokenBuf<>"." THEN		ErrNo=ErrSyntax		GOTO MainLoop	END IF	GOSUB NexToken	SELECT CASE TokenBuf		CASE "open"			OutBuf="mov edi,"+ObjectName			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			OutBuf="mov [!TargetGUIDesc],edi"			GOSUB OutCodeData			OutBuf="add edi,!PortNameOffs"			GOSUB OutCodeData			ImportFcnTable(ptrCreateFile).ImportFcnUse=TRUE			OutBuf="invoke CreateFile,edi,GENERIC_WRITE+GENERIC_READ,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0"			GOSUB OutCodeData			GOSUB SetStatus			GOSUB CallErr			OutBuf="mov edi,[!TargetGUIDesc]"			GOSUB OutCodeData			OutBuf="mov [edi+!HandleOffs],eax"			GOSUB OutCodeData			ImportFcnTable(ptrGetCommState).ImportFcnUse=TRUE			OutBuf="invoke GetCommState,eax,edi"			GOSUB OutCodeData			OutBuf="mov edi,[!TargetGUIDesc]"			GOSUB OutCodeData			OutBuf="xor eax,eax"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserRTSOffs]"			GOSUB OutCodeData			OutBuf="shl eax,12"			GOSUB OutCodeData			OutBuf="mov ebx,[edi+!fBitsOffs]"			GOSUB OutCodeData			OutBuf="and ebx,$cfff"			GOSUB OutCodeData			OutBuf="or ebx,eax"			GOSUB OutCodeData			OutBuf="mov [edi+!fBitsOffs],ebx"			GOSUB OutCodeData			OutBuf="xor eax,eax"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserDTROffs]"			GOSUB OutCodeData			OutBuf="shl eax,4"			GOSUB OutCodeData			OutBuf="mov ebx,[edi+!fBitsOffs]"			GOSUB OutCodeData			OutBuf="and ebx,$ffcf"			GOSUB OutCodeData			OutBuf="or ebx,eax"			GOSUB OutCodeData			OutBuf="mov [edi+!fBitsOffs],ebx"			GOSUB OutCodeData			OutBuf="xor eax,eax"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserParityCheckOffs]"			GOSUB OutCodeData			OutBuf="shl eax,1"			GOSUB OutCodeData			OutBuf="mov ebx,[edi+!fBitsOffs]"			GOSUB OutCodeData			OutBuf="and ebx,$fffd"			GOSUB OutCodeData			OutBuf="or ebx,eax"			GOSUB OutCodeData			OutBuf="mov [edi+!fBitsOffs],ebx"			GOSUB OutCodeData			OutBuf="xor eax,eax"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserDSRCheckOffs]"			GOSUB OutCodeData			OutBuf="shl eax,3"			GOSUB OutCodeData			OutBuf="mov ebx,[edi+!fBitsOffs]"			GOSUB OutCodeData			OutBuf="and ebx,$fff7"			GOSUB OutCodeData			OutBuf="or ebx,eax"			GOSUB OutCodeData			OutBuf="mov [edi+!fBitsOffs],ebx"			GOSUB OutCodeData			OutBuf="xor eax,eax"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserCTSCheckOffs]"			GOSUB OutCodeData			OutBuf="shl eax,2"			GOSUB OutCodeData			OutBuf="mov ebx,[edi+!fBitsOffs]"			GOSUB OutCodeData			OutBuf="and ebx,$fffb"			GOSUB OutCodeData			OutBuf="or ebx,eax"			GOSUB OutCodeData			OutBuf="mov [edi+!fBitsOffs],ebx"			GOSUB OutCodeData						OutBuf="mov dword eax,[edi+!UserBaudRateOffs]"			GOSUB OutCodeData			OutBuf="mov dword [edi+!BaudRateOffs],eax"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserParityOffs]"			GOSUB OutCodeData			OutBuf="mov byte [edi+!ParityOffs],al"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserByteSizeOffs]"			GOSUB OutCodeData			OutBuf="mov byte [edi+!ByteSizeOffs],al"			GOSUB OutCodeData			OutBuf="mov byte al,[edi+!UserStopBitsOffs]"			GOSUB OutCodeData			OutBuf="mov byte [edi+!StopBitsOffs],al"			GOSUB OutCodeData			ImportFcnTable(ptrSetCommState).ImportFcnUse=TRUE			OutBuf="invoke SetCommState, dword [edi+!HandleOffs],edi"			GOSUB OutCodeData			OutBuf="mov edi, dword [!TargetGUIDesc]"			GOSUB OutCodeData			ImportFcnTable(ptrSetCommMask).ImportFcnUse=TRUE			OutBuf="invoke SetCommMask, dword [edi+!HandleOffs],EV_ERR"			GOSUB OutCodeData		CASE "close"			OutBuf="mov edi,"+ObjectName+"+!HandleOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			OutBuf="push edi"			GOSUB OutCodeData			ImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUE			OutBuf="invoke CloseHandle, dword [edi]"			GOSUB OutCodeData			GOSUB SetStatus			OutBuf="pop edi"			GOSUB OutCodeData			OutBuf="mov dword [edi],0"			GOSUB OutCodeData		CASE "binaryinput"			OutBuf="mov edi,"+ObjectName			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			GOSUB NexToken			SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO MainLoop			END IF			IF SymTable(SymNdx).DataType<>BYTEVAR THEN				ErrNo=ErrTypMis				GOTO MainLoop			END IF			VarName=TokenSaf			CommaMain			GOSUB GetIntOp			ErrMain					ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE			IF LAND(VectorBit,SymTable(SymNdx).DataMod)<>VectorBit THEN				OutBuf="invoke ReadFile, dword [edi+!HandleOffs],"+VarName+",eax,XferCount,0"			ELSE				OutBuf="invoke ReadFile, dword [edi+!HandleOffs],["+VarName+"],eax,XferCount,0"			END IF			GOSUB OutCodeData			GOSUB SetStatus			GOSUB CallErrZ		CASE "binaryoutput"			OutBuf="mov edi,"+ObjectName			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			GOSUB NexToken			SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO MainLoop			END IF			IF SymTable(SymNdx).DataType<>BYTEVAR THEN				ErrNo=ErrTypMis				GOTO MainLoop			END IF			VarName=TokenSaf			CommaMain			GOSUB GetIntOp			ErrMain					ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE			IF LAND(VectorBit,SymTable(SymNdx).DataMod)<>VectorBit THEN				OutBuf="invoke WriteFile, dword [edi+!HandleOffs],"+VarName+",eax,XferCount,0"			ELSE				OutBuf="invoke WriteFile, dword [edi+!HandleOffs],["+VarName+"],eax,XferCount,0"			END IF			GOSUB OutCodeData			GOSUB SetStatus			GOSUB CallErrZ		CASE "output"			OutBuf="mov edi,"+ObjectName+"+!HandleOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			OutBuf="push edi"			GOSUB OutCodeData			EqualMain			GOSUB GetStringOp			ErrMain			OutBuf="mov esi,["+TempStr+"]"			GOSUB OutCodeData			OutBuf="mov ebx,esi"			GOSUB OutCodeData			OutBuf="mov edx,["+TempStr+"+4]"			GOSUB OutCodeData			OutBuf="pop edi"			GOSUB OutCodeData			UseWriteOBComm=TRUE			ImportFcnTable(ptrGetLastError).ImportFcnUse=TRUE			OutBuf="call __WriteOBComm"			GOSUB OutCodeData		CASE "baudrate"			OutBuf="mov edi,"+ObjectName+"+!UserBaudRateOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetIntOp			ErrMain			OutBuf="mov dword [edi],eax"			GOSUB OutCodeData		CASE "parity"			OutBuf="mov edi,"+ObjectName+"+!UserParityOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetIntOp			ErrMain			OutBuf="mov byte [edi],al"			GOSUB OutCodeData		CASE "rts"			OutBuf="mov edi,"+ObjectName+"+!UserRTSOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetIntOp			ErrMain			OutBuf="mov byte [edi],al"			GOSUB OutCodeData		CASE "dtr"			OutBuf="mov edi,"+ObjectName+"+!UserDTROffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetIntOp			ErrMain			OutBuf="mov byte [edi],al"			GOSUB OutCodeData		CASE "paritycheck"			OutBuf="mov edi,"+ObjectName+"+!UserParityCheckOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB NexToken			IF TokenBuf="false" THEN				TempStr="0"			ELSE				TempStr="1"			END IF			OutBuf="mov byte [edi],"+TempStr			GOSUB OutCodeData		CASE "dsrcheck"			OutBuf="mov edi,"+ObjectName+"+!UserDSRCheckOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB NexToken			IF TokenBuf="false" THEN				TempStr="0"			ELSE				TempStr="1"			END IF			OutBuf="mov byte [edi],"+TempStr			GOSUB OutCodeData		CASE "ctscheck"			OutBuf="mov edi,"+ObjectName+"+!UserCTSCheckOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB NexToken			IF TokenBuf="false" THEN				TempStr="0"			ELSE				TempStr="1"			END IF			OutBuf="mov byte [edi],"+TempStr			GOSUB OutCodeData		CASE "stopbits"			OutBuf="mov edi,"+ObjectName+"+!UserStopBitsOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetIntOp			ErrMain			OutBuf="mov byte [edi],al"			GOSUB OutCodeData		CASE "databits"			OutBuf="mov edi,"+ObjectName+"+!UserByteSizeOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetIntOp			ErrMain			OutBuf="mov byte [edi],al"			GOSUB OutCodeData				CASE "portname"			OutBuf="mov edi,"+ObjectName+"+!PortNameOffs"			GOSUB OutCodeData			IF ObjectArray<>0 THEN				IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				OutBuf="add edi,eax"				GOSUB OutCodeData			END IF			EqualMain			GOSUB GetStringOp			ErrMain			Op1Name=TempStr			GOSUB GetTmpVec			Op2Name=TempStr			OutBuf="mov ["+TempStr+"],edi"			GOSUB OutCodeData			OutBuf="mov ["+TempStr+"+4],31"			GOSUB OutCodeData			OutBuf="mov ["+TempStr+"+8],0"			GOSUB OutCodeData			OutBuf="mov edi,"+Op2Name			GOSUB OutCodeData			OutBuf="mov esi,"+Op1Name			GOSUB OutCodeData			UseMovStr=TRUE			OutBuf="call __MovStr"			GOSUB OutCodeData		CASE ELSE			ErrNo=ErrIVProp			GOTO MainLoop	END SELECT	GOTO MainLoopEND IFGOSUB NexTokenIF TokenBuf<>"." THEN	ErrNo=ErrSyntax	GOTO MainLoopEND IFGOSUB NexTokenIF TokenBuf="intercept" THEN	TempStr=ObjectName+"_intercept"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	INCR InterceptProcNum	OutBuf="mov dword [!"+ObjectName+"+"+STR(InterceptProcOffs)+"],!InterceptProc"+STR(InterceptProcNum)	GOSUB OutInitCode		OutBuf="proc !InterceptProc"+STR(InterceptProcNum)+",!OBMain,wmsg,wparam,lparam"	GOSUB OutFunction	OutBuf="enter"	GOSUB OutFunction	OutBuf="push ebx esi edi"	GOSUB OutFunction	OutBuf="mov [!PassEvent],0"	GOSUB OutFunction	OutBuf="mov [!Desc],!"+ObjectName	GOSUB OutFunction	OutBuf="call "+ObjectName+"_intercept"	GOSUB OutFunction	OutBuf="cmp [!PassEvent],0"	GOSUB OutFunction	OutBuf="je !NoPass"+STR(InterceptProcNum)	GOSUB OutFunction	ImportFcnTable(ptrCallWindowProc).ImportFcnUse=TRUE	OutBuf="invoke CallWindowProc,[!"+ObjectName+"+492],[!hwnd],[wmsg],[wparam],[lparam]"	GOSUB OutFunction	OutBuf="!NoPass"+STR(InterceptProcNum)+":"	GOSUB OutFunction	OutBuf="jmp !Finish"	GOSUB OutFunction	OutBuf=""	GOSUB OutFunction	GOTO MainLoopEND IFObjectTypeSafe=ObjectType-99SETVEC EventArray=[ObjTable(ObjectTypeSafe).ObjEventTable]I=0BEGIN LOOP	INCR I	IF EventArray(I).EVType="%" THEN NotEvent	IF EventArray(I).EVType=TokenBuf THEN EventFoundEND LOOPEventFound:DescOffs=EventArray(I).EVDescOffsNotifyCode=EventArray(I).EVNotifyTempInt=EventArray(I).EVStatusBitIF TempInt>31 THEN; Notify Event	TempInt=LAND(TempInt,$0000001f)	TGUINotifyEvents=SymTable(GUITargetSymNdx).GUINotifyEvents	IF BITTST(TGUINotifyEvents,TempInt)=TRUE THEN		ErrNo=ErrDupEvent		GOTO MainLoop	ELSE		TGUINotifyEvents=BITSET(TGUINotifyEvents,TempInt)		SymTable(GUITargetSymNdx).GUINotifyEvents=TGUINotifyEvents	END IF	DescOffs=TempInt	DescOffs=SHL(DescOffs,3)	DescOffs=DescOffs+256; ??????????ELSE	TGUIEvents=SymTable(GUITargetSymNdx).GUIEvents	IF BITTST(TGUIEvents,TempInt)=TRUE THEN		ErrNo=ErrDupEvent		GOTO MainLoop	ELSE		TGUIEvents=BITSET(TGUIEvents,TempInt)		SymTable(GUITargetSymNdx).GUIEvents=TGUIEvents	END IFEND IFTempStr=ObjectName+"_"+TokenSafSymTemp.SymName=TempStrGOSUB MakeEventErrMainIF GUIArrayFlag=0 THEN	OutBuf="mov [!"+ObjectName+"+"+STR(DescOffs)+"],"+ObjectName+"_"+TokenSaf	GOSUB OutInitCode	IF DescOffs>=96 AND DescOffs<=380 THEN; Sub code for command event		OutBuf="mov [!"+ObjectName+"+"+STR(DescOffs)+"+4],"+STR(NotifyCode)		GOSUB OutInitCode	END IFELSE	TArrayDim1=SymTable(GUITargetSymNdx).ArrayDim1	OutBuf="mov ecx,"+STR(TArrayDim1)	GOSUB OutInitCode	OutBuf="mov esi,!"+ObjectName	GOSUB OutInitCode	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	GOSUB OutInitCode	OutBuf="mov dword [esi+"+STR(DescOffs)+"],"+ObjectName+"_"+TokenSaf	GOSUB OutInitCode	IF DescOffs>=96 AND DescOffs<=380 THEN; Sub code for command event		OutBuf="mov dword [esi+"+STR(DescOffs)+"+4],"+STR(NotifyCode)		GOSUB OutInitCode	END IF	OutBuf="add esi,768"	GOSUB OutInitCode	OutBuf="dec ecx"	GOSUB OutInitCode	OutBuf="jne _Lbl"+STR(LabelNum)	GOSUB OutInitCode	END IFGOTO MainLoopNotEvent:SETVEC PropArray=[ObjTable(ObjectTypeSafe).ObjPropTable]I=0BEGIN LOOP	INCR I	IF PropArray(I).PropName="%" THEN		ErrNo=ErrIVProp		GOTO MainLoop	END IF		IF PropArray(I).PropName=TokenBuf THEN		GOSUB [PropArray(I).PropSet]		GOTO MainLoop	END IFEND LOOPGUISource:IF ObjectType=OBCOMM THEN	OutBuf="mov edi,"+ObjectName	GOSUB OutCodeData	OutBuf="mov [!SourceGUIDesc],edi"	GOSUB OutCodeData	IF GUIArrayFlag<>0 THEN		GOSUB NexToken		IF TokenBuf<>"(" THEN			ErrNo=ErrSyntax			RETURN		END IF		IgnoreRightParen=$ff		GUIObjFlag=0		GOSUB GetGUINdx		ErrRet		DecArrayNdx		OutBuf="imul eax,100"		GOSUB OutCodeData		INCR SrcNdx; Point past ')'		IgnoreRightParen=0		OutBuf="add edi,eax"		GOSUB OutCodeData		OutBuf="mov [!SourceGUIDesc],edi"		GOSUB OutCodeData	END IF	GOSUB NexToken	IF TokenBuf<>"." THEN		ErrNo=ErrSyntax		RETURN	END IF	GOSUB NexToken	SELECT CASE TokenBuf		CASE "status"			ediUsed=TRUE			OutBuf="mov eax,edi"			GOSUB OutCodeData			OutBuf="add eax,!CommStatusOffs"			GOSUB OutCodeData			ImportFcnTable(ptrClearCommError).ImportFcnUse=TRUE			OutBuf="invoke ClearCommError, dword [edi+!HandleOffs],CommError,eax"			GOSUB OutCodeData			OutBuf="mov edi,[!SourceGUIDesc]"			GOSUB OutCodeData			GOSUB GetIntTmp			ErrRet			OutBuf="mov eax,[edi+!cbInQueOffs]"			GOSUB OutCodeData			GOSUB StoreD0Tmp			GUITempName=TempStr			GUIDataType=LONGVAR		CASE "input"			ediUsed=TRUE			IF CmpOpFlag=FALSE THEN				TempStr="_IOBuffer"			ELSE				TempStr="_PrintBuf"			END IF			ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE			OutBuf="invoke ReadFile, dword [edi+!HandleOffs],["+TempStr+"],1,XferCount,0"			GOSUB OutCodeData			GOSUB SetStatus			OutBuf="mov ["+TempStr+"+13],0"			GOSUB OutCodeData			OutBuf="mov edi,[!TargetGUIDesc]"			GOSUB OutCodeData			GUITempName=TempStr			GUIDataType=STRINGVAR		CASE "inputbuffer"			ediUsed=TRUE			IF CmpOpFlag=FALSE THEN				TempStr="_IOBuffer"			ELSE				TempStr="_PrintBuf"			END IF			OutBuf="mov [XferCount],0"			GOSUB OutCodeData			OutBuf="mov eax,edi"			GOSUB OutCodeData			OutBuf="add eax,!CommStatusOffs"			GOSUB OutCodeData			ImportFcnTable(ptrClearCommError).ImportFcnUse=TRUE			OutBuf="invoke ClearCommError, dword [edi+!HandleOffs],CommError,eax"			GOSUB OutCodeData			OutBuf="mov edi,[!SourceGUIDesc]"			GOSUB OutCodeData			OutBuf="mov eax,[edi+!cbInQueOffs]"			GOSUB OutCodeData			INCR LabelNum			OutBuf="cmp eax,0"			GOSUB OutCodeData			OutBuf="mov ["+TempStr+"+12],0"			GOSUB OutCodeData			OutBuf="je "+"_Lbl"+STR(LabelNum)			GOSUB OutCodeData			ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE			OutBuf="invoke ReadFile, dword [edi+!HandleOffs],["+TempStr+"],eax,XferCount,0"			GOSUB OutCodeData			GOSUB SetStatus			OutBuf="mov eax,"+TempStr+"+13"			GOSUB OutCodeData			OutBuf="add eax,[XferCount]"			GOSUB OutCodeData			OutBuf="mov byte [eax],0"			GOSUB OutCodeData			OutBuf="_Lbl"+STR(LabelNum)+":"			GOSUB OutCodeData			GUITempName=TempStr			GUIDataType=STRINGVAR		CASE ELSE			ErrNo=ErrSyntax	END SELECT	RETURNEND IFGOSUB NexTokenIF TokenBuf<>"." THEN	ErrNo=ErrSyntax	RETURNEND IFGOSUB NexTokenObjectTypeSafe=ObjectType-99SETVEC PropArray=[ObjTable(ObjectTypeSafe).ObjPropTable]I=0BEGIN LOOP	INCR I	IF PropArray(I).PropName="%" THEN		ErrNo=ErrIVProp		RETURN	END IF		IF PropArray(I).PropName=TokenBuf THEN		GOSUB [PropArray(I).PropGet]		GUIDataType=PropArray(I).PropDataType		RETURN	END IFEND LOOPpgMinimized:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrIsIconic).ImportFcnUse=TRUEOutBuf="invoke IsIconic, dword ["+HandleName+"]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgVisible:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrIsWindowVisible).ImportFcnUse=TRUEOutBuf="invoke IsWindowVisible, dword ["+HandleName+"]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsVisible:EqualRetGOSUB NexTokenTempStr=TokenSafSELECT CASE TokenBuf	CASE "true"		TempStr="SW_SHOW"		OutBuf="bts dword [edi+StatusOffs],WinVisible"	CASE "false"		TempStr="SW_HIDE"		OutBuf="btr dword [edi+StatusOffs],WinVisible"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTGOSUB OutCodeDataImportFcnTable(ptrShowWindow).ImportFcnUse=TRUEOutBuf="invoke ShowWindow, dword ["+HandleName+"],"+TempStrGOSUB OutCodeDataRETURN pgCanUndo:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANUNDO,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgCanReDo:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANREDO,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgCanPaste:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANPASTE,CF_TEXT,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgEnabled:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrIsWindowEnabled).ImportFcnUse=TRUEOutBuf="invoke IsWindowEnabled, dword ["+HandleName+"]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsEnabled:EqualRetGOSUB NexTokenTempStr=TokenSafSELECT CASE TokenBuf	CASE "true"		TempStr="TRUE"		OutBuf="bts dword [edi+StatusOffs],WinEnabled"	CASE "false"		TempStr="FALSE"		OutBuf="btr dword [edi+StatusOffs],WinEnabled"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTGOSUB OutCodeDataImportFcnTable(ptrEnableWindow).ImportFcnUse=TRUEOutBuf="invoke EnableWindow, dword ["+HandleName+"],"+TempStrGOSUB OutCodeDataRETURNpsFlashWindow:EqualRetGOSUB NexTokenTempStr=TokenSafSELECT CASE TokenBuf	CASE "true"		TempStr="TRUE"	CASE "false"		TempStr="FALSE"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTImportFcnTable(ptrFlashWindow).ImportFcnUse=TRUEOutBuf="invoke FlashWindow, dword ["+HandleName+"],"+TempStrGOSUB OutCodeDataRETURNpgBackColor:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+BackColorOffs]"GOSUB OutCodeDataOutBuf="cmp eax,$ffffffff"GOSUB OutCodeDataINCR GUILabelNumOutBuf="jne !HaveBackColor"+STR(GUILabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetDC).ImportFcnUse=TRUEOutBuf="invoke GetDC, dword [edi]"GOSUB OutCodeDataOutBuf="mov dword [edi+HDCOffs],eax"GOSUB OutCodeDataOutBuf="mov edi,[!SourceGUIDesc]"GOSUB OutCodeDataOutBuf="invoke GetPixel,eax,3,3"GOSUB OutCodeDataOutBuf="mov edi,[!SourceGUIDesc]"GOSUB OutCodeDataOutBuf="mov [edi+BackColorOffs],eax"GOSUB OutCodeDataOutBuf="!HaveBackColor"+STR(GUILabelNum)+":"GOSUB OutCodeDataOutBuf="mov eax,[edi+BackColorOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="bts dword [edi+StatusOffs],WinChangeBackColor"GOSUB OutCodeDataOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataRETURNpsButtonExBackColor:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBKGRCOL_IN,[_ArgSafe0],0"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBKGRCOL_OUT,[_ArgSafe0],0"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBKGRCOL_FOCUS,[_ArgSafe0],0"GOSUB OutCodeDataRETURNpsButtonExForeColor:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETTEXTCOL_IN,[_ArgSafe0],0"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETTEXTCOL_OUT,[_ArgSafe0],0"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETTEXTCOL_FOCUS,[_ArgSafe0],0"GOSUB OutCodeDataRETURNpsButtonExBitmap:EqualRetGOSUB GetIntOpErrRet;IF TSubType<>BITMAP THEN;	ErrNo=ErrIVType;	RETURN;END IFOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOpErrRet;IF TSubType<>BITMAP THEN;	ErrNo=ErrIVType;	RETURN;END IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBITMAP,[_ArgSafe0],eax"GOSUB OutCodeDataRETURNpsButtonExStyle:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "normal"		TempStr="BTNEXM_SETNORMAL"	CASE "flat"		TempStr="BTNEXM_SETFLAT"	CASE "xpbutton"		TempStr="BTNEXM_SETXPBUTTON"	CASE "default"		TempStr="BTNEXM_SETDEFAULT"	CASE "checkbox"		TempStr="BTNEXM_SETXPCHECKBOX"	CASE "flatcheckbox"		TempStr="BTNEXM_SETFLATCHECKBOX"END SELECTImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],"+TempStr+",0,0"GOSUB OutCodeDataRETURNpsFormBackColor:EqualRetOutBuf="invoke DeleteObject,dword [edi+ControlBrushOffs]"GOSUB OutCodeDataGOSUB GetIntOpErrRetOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUEOutBuf="invoke CreateSolidBrush,eax"GOSUB OutCodeDataOutBuf="mov [edi+ControlBrushOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSetClassLong).ImportFcnUse=TRUEOutBuf="invoke SetClassLong, dword ["+HandleName+"],GCL_HBRBACKGROUND,eax"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataImportFcnTable(ptrUpdateWindow).ImportFcnUse=TRUEOutBuf="invoke UpdateWindow, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpsSBBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETBKCOLOR,0,eax"GOSUB OutCodeDataRETURNpgSBBackColor:ediUsed=TRUERETURNpfSetParts:GOSUB GetIntOpErrRetCommaRetGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).DataType<>LONGVAR OR SymTable(SymNdx).DataMod<>ArrayBit THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETPARTS,eax,"+TokenSafGOSUB OutCodeDataRETURNpfSetSBText:GOSUB GetIntOpErrRetCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETTEXT,eax,["+Op2Name+"]"GOSUB OutCodeDataRETURNpsStyle:EqualRetStyleCode=0TempInt=0SETVEC StyleArray=[ObjTable(ObjectTypeSafe).ObjStyleTable]BEGIN LOOP	GOSUB NexToken	EXIT IF TokenLen=0	IF TokenBuf<>"+" THEN		TempStr=TokenBuf		GOSUB FindStyle		ErrRet		StyleCode=StyleCode+StyleArray(I).StyleValue		INCR TempInt	END IFEND LOOPIF TempInt=0 THEN	ErrNo=ErrSyntax	RETURNEND IFOutBuf="mov eax,$"+HEX$(StyleCode)GOSUB OutCodeDataImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_STYLE,eax"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataRETURNpsGridBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETBACKCOLOR,eax,0"GOSUB OutCodeDataRETURNpsGridForeColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+ForeColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETTEXTCOLOR,eax,0"GOSUB OutCodeDataRETURNpsGridGridColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETGRIDCOLOR,eax,0"GOSUB OutCodeDataRETURNpsRichEditBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETBKGNDCOLOR,0,eax"GOSUB OutCodeDataRETURNpgForeColor:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+ForeColorOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsForeColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="bts dword [edi+StatusOffs],WinChangeForeColor"GOSUB OutCodeDataOutBuf="mov dword [edi+ForeColorOffs],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataRETURNpgStatus:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+StatusOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgHDC:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+HDCOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgAddress:GOSUB GetIntTmpErrRetOutBuf="mov eax,edi"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsInterceptOn:ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_WNDPROC,dword [edi+InterceptProcOffs]"GOSUB OutCodeDataRETURNpsInterceptOff:ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_WNDPROC,dword [edi+InterceptSafeOffs]"GOSUB OutCodeDataRETURNpgID:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+IDOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgHandle:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+HandleOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgLeft:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+LeftOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgTop:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+TopOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgWidth:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+WidthOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgHeight:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+HeightOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgRight:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+RightOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgBottom:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+BottomOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsLeft:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+LeftOffs],eax"; LeftGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,dword [edi+16],dword [edi+20],0,0,5"GOSUB OutCodeDataRETURNpsTop:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+TopOffs],eax"; TopGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,dword [edi+LeftOffs],dword [edi+TopOffs],0,0,5"GOSUB OutCodeDataRETURNpsWidth:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+WidthOffs],eax"; WidthGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,0,0,dword [edi+WidthOffs],dword [edi+HeightOffs],6"GOSUB OutCodeDataRETURNpsHeight:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+HeightOffs],eax"; HeightGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,0,0,dword [edi+WidthOffs],dword [edi+HeightOffs],6"GOSUB OutCodeDataRETURNpsRight:RETURNpsBottom:RETURNpfBringToFront:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos,dword ["+HandleName+"],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect,dword[edi+HandleOffs],NULL,TRUE"GOSUB OutCodeDataRETURNpfInsertTabItem:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFGOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [!TC_ITEMText],eax"GOSUB OutCodeDataOutBuf="mov eax,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="inc eax"GOSUB OutCodeDataOutBuf="mov [!TC_ITEMTextMax],eax"GOSUB OutCodeDataOutBuf="mov [!TC_ITEMmask],TCIF_TEXT"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],TCM_INSERTITEM,[_ArgSafe0],!TC_ITEMmask"GOSUB OutCodeDataRETURNpfDeleteTabItem:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFGOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],TCM_DELETEITEM,eax,0"GOSUB OutCodeDataRETURNpgTabSelect:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_GETCURSEL,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsTabSelect:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETCURSEL,eax,0"GOSUB OutCodeDataRETURNpfSetItemSize:GOSUB GetIntOpErrRetOutBuf="mov ecx,eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetOutBuf="shl eax,16"GOSUB OutCodeDataOutBuf="or eax,ecx"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETITEMSIZE,0,eax"GOSUB OutCodeDataRETURNpgChecked:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BM_GETCHECK,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsPushed:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="1"	CASE "false"		TempStr="0"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUE	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETSTATE,"+TempStr+",0"GOSUB OutCodeDataRETURNpsChecked:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="BST_CHECKED"	CASE "false"		TempStr="BST_UNCHECKED"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUE	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETCHECK,"+TempStr+",0"GOSUB OutCodeDataRETURNpfGridAddCol:GOSUB NexTokenSELECT CASE TokenBuf	CASE "text"		OutBuf="mov [gc_ctype],TYPE_EDITTEXT"		GOSUB OutCodeData		GOSUB AddColCommon		ErrRet		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "combo"		OutBuf="mov [gc_ctype],TYPE_COMBOBOX"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "check"		OutBuf="mov [gc_ctype],TYPE_CHECKBOX"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "long"		OutBuf="mov [gc_ctype],TYPE_EDITLONG"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "hotkey"		OutBuf="mov [gc_ctype],TYPE_HOTKEY"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "button"		OutBuf="mov [gc_ctype],TYPE_BUTTON"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "image"		OutBuf="mov [gc_ctype],TYPE_IMAGE"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "date"		OutBuf="mov [gc_ctype],TYPE_DATE"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "time"		OutBuf="mov [gc_ctype],TYPE_TIME"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_ADDCOL,0,gc_colwt"GOSUB OutCodeDataRETURNAddColCommon:CommaRetGOSUB GetIntOpErrRetOutBuf="mov [gc_colwt],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [gc_lpszhdrtext],eax"GOSUB OutCodeDataGOSUB GetColAlignmentErrRetOutBuf="mov [gc_halign],"+TempStrGOSUB OutCodeDataGOSUB GetColAlignmentErrRetOutBuf="mov [gc_calign],"+TempStrGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetOutBuf="mov [gc_ctextmax],eax"GOSUB OutCodeDataRETURNGetColAlignment:CommaRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "left"		TempStr="GA_ALIGN_LEFT"	CASE "center"		TempStr="GA_ALIGN_CENTER"	CASE "right"		TempStr="GA_ALIGN_RIGHT"	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTRETURNpfGridAddRow:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_ADDROW,0,0"GOSUB OutCodeDataRETURNpfUnDo:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],EM_UNDO,0,0"GOSUB OutCodeDataRETURNpfReDo:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],EM_REDO,0,0"GOSUB OutCodeDataRETURNpfPaste:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],WM_PASTE,0,0"GOSUB OutCodeDataRETURNpfEmptyUndoBuffer:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],EM_EMPTYUNDOBUFFER,0,0"GOSUB OutCodeDataRETURNpfCut:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],WM_CUT,0,0"GOSUB OutCodeDataRETURNpfCopy:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],WM_COPY,0,0"GOSUB OutCodeDataRETURNpsHeaderHeight:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_SETHDRHEIGHT,0,eax"GOSUB OutCodeDataRETURNpsRowHeight:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_SETROWHEIGHT,0,eax"GOSUB OutCodeDataRETURNpfGridComboClear:GOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_COMBOCLEAR,eax,0"GOSUB OutCodeDataRETURNpfGridClear:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_RESETCONTENT,0,0"GOSUB OutCodeDataRETURNpfGridSort:GOSUB GetIntOpErrRetDecArrayNdxCommaRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "ascending"		TempStr="0"	CASE "descending"		TempStr="1"	CASE "inverting"		TempStr="2"	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_COLUMNSORT,eax,"+TempStrGOSUB OutCodeDataRETURNpfGridDeleteRow:GOSUB GetIntOpErrRetOutBuf="push eax"GOSUB OutCodeDataDecArrayNdxOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_DELROW,eax,0"GOSUB OutCodeDataOutBuf="pop eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURSEL,0,eax"GOSUB OutCodeDataRETURNpfGridInsertRow:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_INSROW,eax,0"GOSUB OutCodeDataRETURNpgHiLiteLine:RETURNpfSetHiLiteLine:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="pop ebx"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETHILITELINE,ebx,eax"GOSUB OutCodeDataRETURNpfRAEditGoto:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_LINEINDEX,eax,0"GOSUB OutCodeDataOutBuf="mov [EditcpMin],eax"GOSUB OutCodeDataIF NextByte<>"," THEN NoRangeArgCommaRetGOSUB GetIntOpErrRetOutBuf="add eax,[EditcpMin]"GOSUB OutCodeDataNoRangeArg:OutBuf="mov [EditcpMax],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_EXSETSEL,0,EditcpMin"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpsRAEditBCKCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_BCKCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditTXTCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_TXTCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELBCKCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_SELBCKCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELTXTCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_SELTXTCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditCMNTCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_CMNTCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSTRCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_STRCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditOPRCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_OPRCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditHILITE1:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_HILITE1],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditHILITE2:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_HILITE2],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditHILITE3:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_HILITE3],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELBARCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_BARCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELBARPEN:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_SELBARPEN],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditLNRCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_LNRCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNSetRAEditColors:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETCOLOR,0,!RA_BCKCOLOR"GOSUB OutCodeDataRETURNpfSetHiliteWords:GOSUB GetStringOpErrRetVSymName=TSymNameCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETHILITEWORDS,eax,["+VSymName+"]"GOSUB OutCodeDataRETURNpfSetRAFont:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopEND IFIF SymTable(SymNdx).SubType<>FONT THEN	ErrNo=ErrTypMis	GOTO MainLoopEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETFONT,0,"+TokenSafGOSUB OutCodeDataRETURNpfFind:OutBuf="mov [STATUS],0"GOSUB OutCodeDataOutBuf="bt [FLAGS],6"GOSUB OutCodeDataINCR LabelNumOutBuf="jc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="mov eax,[fr_lpstrFindWhat]"GOSUB OutCodeDataOutBuf="mov [ft_SearchTextPtr],eax"GOSUB OutCodeDataOutBuf="xor ebx,ebx"GOSUB OutCodeDataOutBuf="bt [FLAGS],0"GOSUB OutCodeDataINCR LabelNumOutBuf="jnc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="or ebx,FR_DOWN"GOSUB OutCodeDataOutBuf="mov ecx,[EditcpMax]"GOSUB OutCodeDataOutBuf="dec ecx"GOSUB OutCodeDataOutBuf="mov [ft_SearchMin],ecx"GOSUB OutCodeDataOutBuf="mov [ft_SearchMax],$ffffffff"GOSUB OutCodeDataINCR LabelNumOutBuf="jmp "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum-1)+":"GOSUB OutCodeDataOutBuf="mov ecx,[EditcpMin]"GOSUB OutCodeDataOutBuf="mov [ft_SearchMin],ecx"GOSUB OutCodeDataOutBuf="mov [ft_SearchMax],0"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="bt [FLAGS],1"GOSUB OutCodeDataINCR LabelNumOutBuf="jnc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="or ebx,FR_WHOLEWORD"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="bt [FLAGS],2"GOSUB OutCodeDataINCR LabelNumOutBuf="jnc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="or ebx,FR_MATCHCASE"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="mov edi,!Edit"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_FINDTEXTEX,ebx,ft_SearchMin"GOSUB OutCodeDataGOSUB SetStatusOutBuf="cmp eax,$ffffffff"GOSUB OutCodeDataOutBuf="je "+"_Lbl"+STR(LabelNum-4)GOSUB OutCodeDataOutBuf="mov ebx,[ft_FoundMin]"GOSUB OutCodeDataOutBuf="mov eax,[ft_FoundMax]"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum-4)+":"GOSUB OutCodeDataRETURNpfSetDividerLine:GOSUB GetIntOpErrRetDecArrayNdxCommaRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="1"	CASE "false"		TempStr="0"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETDIVIDERLINE,eax,"+TempStrGOSUB OutCodeDataRETURNpfSelectAll:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,0,-1"GOSUB OutCodeDataImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpfSetFocus:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpsCursorPos:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,eax,eax"GOSUB OutCodeDataRETURNpgCursorPos:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSEL,"+GUITempName+",0"GOSUB OutCodeDataOutBuf="mov eax,["+GUITempName+"]"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpfGetSel:ediUsed=TRUEGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSEL,EditcpMin,EditcpMax"GOSUB OutCodeDataRETURNpfSetSel:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="pop ebx"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"GOSUB OutCodeDataImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpfGridMoveRow:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov ebx,eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_MOVEROW,ebx,eax"GOSUB OutCodeDataRETURNpgLine:ediUsed=TRUEGOSUB GetItemNumberErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFOutBuf="mov [_IOBuffer+12],_BufSize"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETLINE,eax,["+TempStr+"]"GOSUB OutCodeDataOutBuf="mov ebx,_IOBuffer+12"GOSUB OutCodeDataOutBuf="add ebx,eax"GOSUB OutCodeDataOutBuf="dec ebx"GOSUB OutCodeDataOutBuf="mov byte [ebx],0"GOSUB OutCodeDataGUITempName=TempStrRETURNpgText:ediUsed=TRUEIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXT,_BufSize,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpgSelText:ediUsed=TRUEIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSELTEXT,0,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpfInsertText:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,eax,eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataGOSUB OutCodeDataRETURNpfAppendText:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,-1,-1"GOSUB OutCodeDataGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataRETURNpfReplaceSel:GOSUB GetStringOpErrRetOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataRETURNpfReplaceText:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="pop ebx"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataRETURNpfSetTabText:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaMainGOSUB GetStringOpErrRetOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [!TC_ITEMText],eax"GOSUB OutCodeDataOutBuf="mov eax,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="inc eax"GOSUB OutCodeDataOutBuf="mov [!TC_ITEMTextMax],eax"GOSUB OutCodeDataOutBuf="mov [!TC_ITEMmask],TCIF_TEXT"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETITEM,[_ArgSafe0],!TC_ITEMmask"GOSUB OutCodeDataRETURNpsToolTip:OutBuf="add edi,TTTextOffs"GOSUB OutCodeDataEqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeData	OutBuf="add edi,TTTextOffs"	GOSUB OutCodeDataEND IFOp1Name=TSymNameGOSUB GetTmpVecOp2Name=TempStrOutBuf="mov ["+TempStr+"],edi"GOSUB OutCodeDataOutBuf="mov ["+TempStr+"+4],100"GOSUB OutCodeDataOutBuf="mov ["+TempStr+"+8],0"GOSUB OutCodeDataOutBuf="mov edi,"+Op2NameGOSUB OutCodeDataOutBuf="mov esi,"+Op1NameGOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov eax,edi"GOSUB OutCodeDataOutBuf="add eax,TTcbSizeOffs"GOSUB OutCodeDataINCR LabelNumOutBuf="bts dword [edi+StatusOffs],WinTipExists"GOSUB OutCodeDataOutBuf="jc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, [!ToolTip],TTM_ADDTOOL,0,eax"GOSUB OutCodeDataINCR LabelNumOutBuf="jmp "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum-1)+":"GOSUB OutCodeDataOutBuf="invoke SendMessage, [!ToolTip],TTM_UPDATETIPTEXT,0,eax"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataRETURNpsText:EqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETTEXT,0,["+TSymName+"]"GOSUB OutCodeDataRETURNpsIcon:EqualRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETICON,ICON_BIG,eax"GOSUB OutCodeDataRETURNpsButtonBitmap:EqualRetGOSUB GetIntOpErrRetIF TSubType<>BITMAP THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETIMAGE,IMAGE_BITMAP,eax"GOSUB OutCodeDataRETURNpsStaticBitmap:EqualRetGOSUB GetIntOpErrRetIF TSubType<>BITMAP THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],STM_SETIMAGE,IMAGE_BITMAP,eax"GOSUB OutCodeDataRETURNpsButtonIcon:EqualRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETIMAGE,IMAGE_ICON,eax"GOSUB OutCodeDataRETURNpsSTIcon:EqualRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],STM_SETIMAGE,1,eax"GOSUB OutCodeDataRETURNpfSetSBIcon:GOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETICON,[_ArgSafe0],eax"GOSUB OutCodeDataRETURNpfSetGridRowColor:GOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetOutBuf="mov [rc_backcolor],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetOutBuf="mov [rc_textcolor],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETROWCOLOR,[_ArgSafe0],rc_backcolor"GOSUB OutCodeDataRETURNpsFont:EqualRetGOSUB GetIntOpErrRetIF TSubType<>FONT THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETFONT,eax,1"GOSUB OutCodeDataRETURNpgGridText:ediUsed=TRUEGOSUB GetRCErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_CELLCONVERT,ebx,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpsGridText:GOSUB GetRCErrRetEqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,["+TSymName+"]"GOSUB OutCodeDataRETURNpgHeaderText:ediUsed=TRUEGOSUB GetColumnErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETHDRTEXT,ebx,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrGOSUB OutCodeDataRETURNpsHeaderText:GOSUB GetColumnErrRetEqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETHDRTEXT,ebx,["+TSymName+"]"GOSUB OutCodeDataRETURNpfGridComboAddItem:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaMainGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="pop eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_COMBOADDSTRING,eax,["+TSymName+"]"GOSUB OutCodeDataRETURNpsGridValue:GOSUB GetRCErrRetEqualRetGOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,_ArgSafe1"GOSUB OutCodeDataRETURNpgGridValue:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameGOSUB GetRCErrRetImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETCELLDATA,ebx,"+GUITempNameGOSUB OutCodeDataRETURNpsGridComboIndex:GOSUB GetRCErrRetEqualRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,_ArgSafe1"GOSUB OutCodeDataRETURNGetColumn:GOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFIgnoreRightParen=$ffGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxOutBuf="mov ebx,eax"GOSUB OutCodeDataGOSUB NexTokenIF TokenBuf<>")" THEN	ErrNo=ErrSyntax	RETURNEND IFIgnoreRightParen=0RETURNGetItemNumber:IgnoreRightParen=$ffGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxGOSUB NexTokenIF TokenBuf<>")" THEN	ErrNo=ErrSyntax	RETURNEND IFIgnoreRightParen=0RETURNGetRC:GOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNEND IFGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxCommaRetOutBuf="mov ebx,eax"GOSUB OutCodeDataOutBuf="shl ebx,16"GOSUB OutCodeDataIgnoreRightParen=$ffGOSUB GetGUINdxErrRetDecArrayNdxOutBuf="or ebx,eax"GOSUB OutCodeDataGOSUB NexTokenIF TokenBuf<>")" THEN	ErrNo=ErrSyntax	RETURNEND IFIgnoreRightParen=0RETURNpfRAEditLoadFile:GOSUB GetStringOpErrRetImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,["+TSymName+"],GENERIC_READ,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataOutBuf="mov [!FileHandle],eax"GOSUB OutCodeDataOutBuf="cmp eax,-1"GOSUB OutCodeDataINCR OELabelNumOutBuf="jg _OELbl"+STR(OELabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeDataImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUEOutBuf="invoke GetFileSize,[!FileHandle],0"GOSUB OutCodeDataOutBuf="inc eax"GOSUB OutCodeDataOutBuf="mov [!FilBufSiz],eax"GOSUB OutCodeDataImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUEOutBuf="invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE"GOSUB OutCodeDataOutBuf="mov [!FilBufAdr],eax"GOSUB OutCodeDataOutBuf="mov edx,[!FilBufSiz]"GOSUB OutCodeDataOutBuf="add eax,edx"GOSUB OutCodeDataOutBuf="dec eax"GOSUB OutCodeDataImportFcnTable(ptrReadFile).ImportFcnUse=TRUEOutBuf="invoke ReadFile,[!FileHandle],[!FilBufAdr],edx,!FilBufSiz,0"GOSUB OutCodeDataOutBuf="cmp eax,0"GOSUB OutCodeDataINCR OELabelNumOutBuf="jne _OELbl"+STR(OELabelNum)GOSUB OutCodeDataOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeDataImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUEOutBuf="invoke CloseHandle,[!FileHandle]"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETTEXT,0,[!FilBufAdr]"GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,[!FilBufAdr],0,MEM_RELEASE"GOSUB OutCodeDataRETURNpfRAEditSaveFile:GOSUB GetStringOpErrRetImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,["+TSymName+"],GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataOutBuf="mov [!FileHandle],eax"GOSUB OutCodeDataOutBuf="cmp eax,-1"GOSUB OutCodeDataINCR OELabelNumOutBuf="jg _OELbl"+STR(OELabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXTLENGTH,0,0"GOSUB OutCodeDataOutBuf="mov [!FilBufSiz],eax"GOSUB OutCodeDataOutBuf="inc [!FilBufSiz]"GOSUB OutCodeDataImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUEOutBuf="invoke  VirtualAlloc,0,[!FilBufSiz],MEM_COMMIT,PAGE_READWRITE"GOSUB OutCodeDataOutBuf="mov [!FilBufAdr],eax"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXT,[!FilBufSiz],[!FilBufAdr]"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="dec [!FilBufSiz]"GOSUB OutCodeDataImportFcnTable(ptrWriteFile).ImportFcnUse=TRUEOutBuf="invoke WriteFile,[!FileHandle],[!FilBufAdr],[!FilBufSiz],!FilBufSiz,0"GOSUB OutCodeDataOutBuf="cmp eax,0"GOSUB OutCodeDataINCR OELabelNumOutBuf="jne _OELbl"+STR(OELabelNum)GOSUB OutCodeDataOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeData;OutBuf="mov eax,[_CRLF]";GOSUB OutCodeData;OutBuf="mov [_XferAddr],eax";GOSUB OutCodeData;OutBuf="mov [XferCount],1";GOSUB OutCodeData;OutBuf="invoke WriteFile,[!FileHandle],[_XferAddr],[XferCount],XferCount,0";GOSUB OutCodeDataImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUEOutBuf="invoke CloseHandle,[!FileHandle]"GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,[!FilBufAdr],0,MEM_RELEASE"GOSUB OutCodeDataRETURNpgListBoxSelText:ediUsed=TRUEOutBuf="push edi"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETCURSEL,0,0"GOSUB OutCodeDataOutBuf="pop edi"GOSUB OutCodeDataIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTEXT,eax,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpgListBoxSelItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETCURSEL,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpgListBoxItemCount:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETCOUNT,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgComboBoxItemCount:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETCOUNT,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgGridRow:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETCURROW,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsGridRow:EqualRetGOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURROW,eax,0"GOSUB OutCodeDataRETURNpgGridCol:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETCURCOL,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsGridCol:EqualRetGOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURCOL,eax,0"GOSUB OutCodeDataRETURNpfScrollCell:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SCROLLCELL,0,0"GOSUB OutCodeDataRETURNpgGridSel:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETCURSEL,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsGridSel:RETURNpfGridEnterEdit:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_ENTEREDIT,eax,[_ArgSafe0]"GOSUB OutCodeDataRETURNpgGridRows:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETROWCOUNT,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsListBoxSelItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_SETCURSEL,eax,0"GOSUB OutCodeDataRETURNpgListBoxTopItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTOPINDEX,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsListBoxTopItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_SETTOPINDEX,eax,0"GOSUB OutCodeDataRETURNpgComboBoxTopItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETTOPINDEX,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsComboBoxTopItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTOPINDEX,eax,0"GOSUB OutCodeDataRETURNpgComboBoxSelText:ediUsed=TRUEOutBuf="push edi"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETCURSEL,0,0"GOSUB OutCodeDataOutBuf="pop edi"GOSUB OutCodeDataIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETLBTEXT,eax,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpgComboBoxSelItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETCURSEL,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsComboBoxSelItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SETCURSEL,eax,0"GOSUB OutCodeDataRETURNpgTextLength:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXTLENGTH,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsDPMaxValue:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],DP_INIT,0,eax"GOSUB OutCodeDataRETURNpsDPBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],DP_COLORBKG,eax,0"GOSUB OutCodeDataRETURNpsDPFont:EqualRetGOSUB GetIntOpErrRetIF TSubType<>FONT THEN	ErrNo=ErrIVType	RETURNEND IFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],DP_FONT,eax,0"GOSUB OutCodeDataRETURNpsDPText:EqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],DP_TEXT,["+TSymName+"],0"GOSUB OutCodeDataRETURNpsDPValue:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],DP_COUNT,eax,0"GOSUB OutCodeDataRETURNpgSliderValue:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_GETPOS,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsSliderValue:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_SETPOS,TRUE,eax"GOSUB OutCodeDataRETURNpgProgressBarValue:ediUsed=TRUERETURNpsProgressBarValue:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],PBM_SETPOS,eax,0"GOSUB OutCodeDataRETURNpgInterval:ediUsed=TRUERETURNpsInterval:RETURNpfStop:RETURNpfComboAddSorted:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_ADDSTRING,0,["+TSymName+"]"GOSUB OutCodeDataRETURNpfComboAddItem:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_INSERTSTRING,-1,["+TSymName+"]"GOSUB OutCodeDataRETURNpfComboClear:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_RESETCONTENT,0,0"GOSUB OutCodeDataRETURNpsDropped:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="1"	CASE "false"		TempStr="0"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SHOWDROPDOWN,"+TempStr+",0"GOSUB OutCodeDataRETURNpsHiliteComboText:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="$ffff0000"	CASE "false"		TempStr="$0000ffff"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SETEDITSEL,0,"+TempStrGOSUB OutCodeDataRETURNpgDropped:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETDROPPEDSTATE,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpfListBoxAddSorted:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_ADDSTRING,0,["+TSymName+"]"GOSUB OutCodeDataRETURNpfListBoxAddItem:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,-1,["+TSymName+"]"GOSUB OutCodeDataRETURNpfListBoxInsertItem:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,[_ArgSafe0],["+TSymName+"]"GOSUB OutCodeDataRETURNpfComboInsertItem:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,[_ArgSafe0],["+TSymName+"]"GOSUB OutCodeDataRETURNpfListBoxDeleteItem:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_DELETESTRING,eax,0"GOSUB OutCodeDataRETURNpfComboDeleteItem:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_DELETESTRING,eax,0"GOSUB OutCodeDataRETURNpfComboFindItem:GOSUB GetStringOpErrRetFcnName=TSymNameIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_FINDSTRINGEXACT,-1,["+FcnName+"]"GOSUB OutCodeDataIncArrayNdxGOSUB SetStatusRETURNpfListBoxFindItem:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_FINDSTRINGEXACT,-1,["+FcnName+"]"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpfComboReplaceItem:GOSUB GetStringOpErrRetFcnName=TSymNameIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUECommaRetGOSUB GetStringOpErrRetOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_FINDSTRINGEXACT,-1,["+FcnName+"]"GOSUB OutCodeDataOutBuf="or eax,eax"GOSUB OutCodeDataINCR GUILabelNumOutBuf="js !ComboStringNotFound"+STR(GUILabelNum)GOSUB OutCodeDataOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_DELETESTRING,[_ArgSafe0],0"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_INSERTSTRING,[_ArgSafe0],["+TSymName+"]"GOSUB OutCodeDataOutBuf="!ComboStringNotFound"+STR(GUILabelNum)+":"GOSUB OutCodeDataRETURNpfListBoxReplaceItem:GOSUB GetStringOpErrRetFcnName=TSymNameIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUECommaRetGOSUB GetStringOpErrRetOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_FINDSTRINGEXACT,-1,["+FcnName+"]"GOSUB OutCodeDataOutBuf="or eax,eax"GOSUB OutCodeDataOutBuf="js !ListBoxStringNotFound"GOSUB OutCodeDataOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_DELETESTRING,[_ArgSafe0],0"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,[_ArgSafe0],["+TSymName+"]"GOSUB OutCodeDataOutBuf="!ListBoxStringNotFound:"GOSUB OutCodeDataRETURNpgListBoxText:ediUsed=TRUEGOSUB GetItemNumberErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"END IFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTEXT,eax,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpfListBoxClear:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_RESETCONTENT,0,0"GOSUB OutCodeDataRETURNpgBad:ErrNo=ErrIVTypeRETURNpsBad:ErrNo=ErrIVTypeRETURNpfBad:ErrNo=ErrIVTypeRETURNMakeEvent:GOSUB SymSrchIF SymFound=TRUE THEN; Label Found	IF SymTable(SymNdx).DataType<>LABELVAR THEN		ErrNo=ErrDupSym		RETURN	END IF	IF SymTable(SymNdx).Detail=LabelUnresolved THEN		SymTable(SymNdx).Detail=LabelResolved	ELSE		ErrNo=ErrDupSym		RETURN	END IFELSE	GOSUB ClrDatTyp	TDataType=LABELVAR	SymTemp.DataType=LABELVAR	GOSUB ClrSym	SymTemp.DataMod=0	SymTemp.Detail=LabelResolved	GOSUB SymInsert	ErrRetEND IFOutBuf=TempStr+":"GOSUB OutCodeDataGOSUB FcnFlagChkErrRetEventFlag=TRUEProcFcnFlag=TRUERETURNChkForIMM:TempInt=IVAL(TSymName)IF ForDataType=BYTEVAR AND TempInt>254 THEN	ErrNo=ErrOpRange	RETURNEND IFIF ForDataType=WORDVAR AND TempInt>65534 THEN	ErrNo=ErrOpRange	RETURNEND IFIF ForDataType=LONGVAR AND TempInt>$7fffffff THEN	ErrNo=ErrOpRange	RETURNEND IFRETURNSetPos:CommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+LeftOffs],eax"; LeftGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+TopOffs],eax"; TopGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+WidthOffs],eax"; WidthGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataEND IFOutBuf="mov dword [edi+HeightOffs],eax"; HeightGOSUB OutCodeDataRETURNSetPosFromTable:UseSetRightBottom=TRUEOutBuf="call __SetRightBottom"GOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],HWND_TOP, dword [edi+LeftOffs], dword ["OutBuf=OutBuf+"edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs],4"GOSUB OutCodeDataRETURNIncrArrayNdx:IF ArrayBase=1 THEN	OutBuf="inc eax"	GOSUB OutCodeDataEND IFRETURNDecrArrayNdx:IF ArrayBase=1 THEN	OutBuf="dec eax"	GOSUB OutCodeDataEND IFRETURNFormatCompileTime:SETDEFAULTCURSORTempName=STR$((GETTICKCOUNT()-StartTime))SELECT CASE LEN(TempName)	CASE 4		TempStr=LEFT(TempName,1)+"."+RIGHT(TempName,3)	CASE 5		TempStr=LEFT(TempName,2)+"."+RIGHT(TempName,3)	CASE ELSE		TempStr="."+TempNameEND SELECTTempName=TempStr+" Seconds"RETURNShowError:SETDEFAULTCURSORWARNINGBOX "Error",TempStr,MB_OKFOR I=1 TO InpFilPtr	CLOSE InpFile(InpFilPtr)NEXT ICLOSE DeclareFileDELETE "_DeclareFile"CLOSE PreCodeFileDELETE "_PreCodeFile"CLOSE CodeFileDELETE "_CodeFile"CLOSE DataFileDELETE "_DataFile"CLOSE DimFileDELETE "_DimFile"CLOSE DescFileDELETE "_DescFile"CLOSE InitFileDELETE "_InitFile"CLOSE FunctionFileDELETE "_FunctionFile"CLOSE ExportFileDELETE "_ExportFile"CLOSE ResourceFileDELETE "_ResourceFile"GOSUB ShowModeIF BasicLineCtr>0 THEN	TempInt=LEN(SrcLine)	Edit.GOTO BasicLineCtr,TempIntEND IFRETURNShowMode:IF TextMode=TRUE THEN	StatusBarSafe4="Edit Text"	StatusBar.SETTEXT 4,StatusBarSafe4ELSE	StatusBarSafe4="Edit Objects"	StatusBar.SETTEXT 4,StatusBarSafe4END IFRETURNGetDataType:SELECT CASE TempInt	CASE 0		TempStr="CONST"	CASE 1		TempStr="BOOLEAN"	CASE 2		TempStr="BYTE"	CASE 3		TempStr="INT"	CASE 4		TempStr="LONG"	CASE 5		TempStr="FLOAT"	CASE 6		TempStr="STRING"	CASE 7		TempStr="LABEL"	CASE 8		TempStr="MACRO"	CASE 9		TempStr="OPER"	CASE 10		TempStr="FCN"	CASE 11		TempStr="PROC"	CASE 12		TempStr="TYPE"	CASE 13		TempStr="VOID"	CASE 14		TempStr="STRUCT"	CASE 15		TempStr="BUFFER"	CASE 16		TempStr="LBLPTR"	CASE 17		TempStr="MENU"	CASE 18		TempStr="TEXT"	CASE ELSE		TempStr="OBJECT"END SELECTRETURNFormatNumber2:MAKEUPPER TempStrTempName=TempStrTempInt=LEN(TempName)SELECT CASE TempInt	CASE 1		TempStr="0"+TempName	CASE ELSE		TempStr=TempNameEND SELECTRETURNFormatNumber4:MAKEUPPER TempStrTempName=TempStrTempInt=LEN(TempName)SELECT CASE TempInt	CASE 1		TempStr="000"+TempName	CASE 2		TempStr="00"+TempName	CASE 3		TempStr="0"+TempName	CASE ELSE		TempStr=TempNameEND SELECTRETURNFormatNumber8:MAKEUPPER TempStrTempName=TempStrTempInt=LEN(TempName)SELECT CASE TempInt	CASE 1		TempStr="0000000"+TempName	CASE 2		TempStr="000000"+TempName	CASE 3		TempStr="00000"+TempName	CASE 4		TempStr="0000"+TempName	CASE 5		TempStr="000"+TempName	CASE 6		TempStr="00"+TempName	CASE 7		TempStr="0"+TempName	CASE ELSE		TempStr=TempNameEND SELECTRETURNSymbolGrid.HEADERCLICKSymbolGrid.SORT GridCol,INVERTINGEND EVENTTimer1.TIMEOUTTimer1.STOPEditfChanged=0StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSE;// ENABLEMENUITEMMainMenu,mnuSave,FALSEButton(3).ENABLED=FALSEEND EVENTOBMain.SYSTEMIF TextMode=FALSE THEN	IF STATUS=$f060 THEN		GOSUB Button6Pressed		RETURN	END IF	PASSEVENTEND IFSELECT CASE STATUS	CASE $f060		IF Changed=TRUE THEN			TempName=SaveFileName+" Not Saved"			TempStr="Save?"			WARNINGBOX TempName,TempStr,MB_YESNOCANCEL			IF STATUS=IDYES THEN				IF FileName="Untitled" THEN					GOSUB SaveAs					IF STATUS=0 THEN						RETURN					END IF					GOTO Quit				ELSE					Edit.SAVEFILE SaveFileName					;// ENABLEMENUITEMMainMenu,mnuSave,FALSE					Button(3).ENABLED=FALSE					StatusBarSafe5="Not Changed"					StatusBar.SETTEXT 5,StatusBarSafe5					Changed=FALSE					GOTO Quit				END IF			ELSE				SETDEFAULTCURSOR				IF STATUS=IDCANCEL THEN					RETURN				END IF				PASSEVENT			END IF		ELSE			PASSEVENT		END IF	CASE ELSE		PASSEVENTEND SELECTEND EVENTAssemble:SHELL "fasm "+AsmFileName+">_Fasm"GOSUB FormatCompileTime				OPEN "_fasm" FOR INPUT AS StatusFileREAD StatusFile,TempStrREAD StatusFile,TempStrCLOSE StatusFileMSGBOX TempName,TempStr,MB_OKGOSUB ShowModeRETURNCompileToExe:ExpFlag=FALSEAsmOutFlag=FALSENoGen=FALSEIF Extension=".asm" THEN	IF Changed=TRUE THEN		WARNINGBOX "File Not Saved","Save?",MB_YESNO		IF STATUS=IDYES THEN			IF FileName="Untitled" THEN				GOSUB SaveAs			ELSE				Edit.SAVEFILE SaveFileName				;// ENABLEMENUITEMMainMenu,mnuSave,FALSE				Button(3).ENABLED=FALSE				Changed=FALSE				StatusBarSafe5="Not Changed"				StatusBar.SETTEXT 5,StatusBarSafe5			END IF		ELSE			SETDEFAULTCURSOR			RETURN		END IF	END IF	AsmFileName=BareFileName+Extension	StartTime=GETTICKCOUNT()	StatusBarSafe4="Compiling"	StatusBar.SETTEXT 4,StatusBarSafe4	GOSUB Assemble	RETURNEND IFGOSUB CompileCommonRETURNCompileToAsm:ExpFlag=FALSEAsmOutFlag=TRUENoGen=FALSEGOSUB CompileCommonRETURNTestCompile:ExpFlag=FALSEAsmOutFlag=FALSENoGen=TRUEGOSUB CompileCommonRETURNCompileCommon:StatusBarSafe4="Compiling"StatusBar.SETTEXT 4,StatusBarSafe4GOSUB CompileRETURNPostCompile:Edit.SETFOCUSRETURNQuit:invoke DeleteObject, dword [RAFont]invoke DeleteObject, dword [RAFont+4]invoke DeleteObject, dword [RAFont+8]ENDNewCmd:Button(6).ENABLED=FALSE;// ENABLEMENUITEMEditPopUp,emnuViewObject,FALSEIF Changed=TRUE THEN	TempName=SaveFileName+" Not Saved"	TempStr="Save?"	WARNINGBOX TempName,TempStr,MB_YESNOCANCEL	IF STATUS=IDYES THEN		IF FileName="Untitled" THEN			GOSUB SaveAs		ELSE			Edit.SAVEFILE SaveFileName			;// ENABLEMENUITEMMainMenu,mnuSave,FALSE			Button(3).ENABLED=FALSE			StatusBarSafe5="Not Changed"			StatusBar.SETTEXT 5,StatusBarSafe5			Changed=FALSE		END IF	ELSE		SETDEFAULTCURSOR		IF STATUS=IDCANCEL THEN			RETURN		END IF	END IFEND IFEdit.TEXT=""TempStr=ProgramName+"    [Untitled]" OBMain.TEXT=TempStrFileName="Untitled"IF NewWindowConstructed=FALSE THEN	CREATE NewWindow,100,100,350,100 APPWINDOW CHILD	NewWindow.TEXT="New"	NewWindowConstructed=TRUE	CREATE ProjectButton,10,10,100,20 IN NewWindow	ProjectButton.TEXT="Project"	CREATE WindowPgmButton,120,10,100,20 IN NewWindow	WindowPgmButton.TEXT="Windows Pgm"	CREATE ConsolePgmButton,230,10,100,20 IN NewWindow	ConsolePgmButton.TEXT="Console Pgm"	CREATE DLLButton,10,40,100,20 IN NewWindow	DLLButton.TEXT="DLL"	CREATE ControlButton,120,40,100,20 IN NewWindow	ControlButton.TEXT="Control"	CREATE CancelButton,230,40,100,20 IN NewWindow	CancelButton.TEXT="Cancel"ELSE	NewWindow.VISIBLE=TRUEEND IFRETURNClearAll:FormCombo.CLEARControlCombo.CLEAREventCombo1.CLEAREventCombo2.CLEAREventCombo1.TEXT=""EventCombo2.TEXT=""EventCombo1.ENABLED=FALSEEventCombo2.ENABLED=FALSEFor ControlPtr=1 TO ControlTableSize	GOSUB CleanControlNEXT ControlPtrRETURNProjectButton.COMMANDGOSUB ClearAllTempStr="; Dimension Variables"+CHR($0d)+CHR($0d)+"OBMain.CREATE"+CHR($0d)+CHR($0d)+"END EVENT"+CHR($0d)+CHR($0d)Edit.TEXT=TempStr;Edit.SETDIVIDERLINE 3,TRUE;Edit.SETDIVIDERLINE 6,TRUEEdit.GOTO 4Button(6).ENABLED=TRUE;// ENABLEMENUITEMEditPopUp,emnuViewObject,TRUEFOR I=1 TO ControlTableSize	PuppetIDDispenser(I)=FALSENEXT IGOSUB NewDoneEND EVENTWindowPgmButton.COMMANDGOSUB ClearAllTempStr="; Dimension Variables"+CHR($0d)+CHR($0d)+"OBMain.CREATE"+CHR($0d)+CHR($0d)+"END EVENT"+CHR($0d)+CHR($0d)Edit.TEXT=TempStr;Edit.SETDIVIDERLINE 3,TRUE;Edit.SETDIVIDERLINE 6,TRUEEdit.GOTO 4GOSUB NewDoneEND EVENTConsolePgmButton.COMMANDGOSUB ClearAllTempStr="; Dimension Variables"+CHR($0d)+CHR($0d)+"; Code Section"+CHR($0d)Edit.TEXT=TempStrEdit.GOTO 4GOSUB NewDoneEND EVENTDLLButton.COMMANDEND EVENTControlButton.COMMANDEND EVENTCancelButton.COMMANDNewWindow.VISIBLE=FALSEEND EVENTNewWindow.SYSTEMNewWindow.VISIBLE=FALSEEND EVENTNewDone:Edit.EMPTYUNDOBUFFER;// ENABLEMENUITEMMainMenu,mnuSave,FALSEButton(3).ENABLED=FALSEStatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSENewWindow.VISIBLE=FALSEEdit.ENABLED=TRUEEdit.SETFOCUSRETURNOpenCmd:IF Changed=TRUE THEN	TempName=SaveFileName+" Not Saved"	TempStr="Save?"	WARNINGBOX TempName,TempStr,MB_YESNOCANCEL	IF STATUS=IDYES THEN		IF FileName="Untitled" THEN			GOSUB SaveAs		ELSE			Edit.SAVEFILE SaveFileName			;// ENABLEMENUITEMMainMenu,mnuSave,FALSE			Button(3).ENABLED=FALSE			StatusBarSafe5="Not Changed"			StatusBar.SETTEXT 5,StatusBarSafe5			Changed=FALSE		END IF	ELSE		SETDEFAULTCURSOR		IF STATUS=IDCANCEL THEN			RETURN		END IF	END IFEND IFTempStr=FileNameFileName=""OPENDIALOG FileName,FileFilter,InitDir IF STATUS<>0 THEN	Edit.EMPTYUNDOBUFFER	Edit.LOADFILE FileName	SaveFileName=FileName	BareFileName=LEFT(FileName,LEN(FileName)-4)	Extension=RIGHT(FileName,4)	TempStr=ProgramName+"     ["+FileName+"]"	OBMain.TEXT=TempStr	Timer1.TIME=50	StatusBarSafe5="Not Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=FALSEELSE	FileName=TempStrEND IFEdit.ENABLED=TRUEEdit.SETFOCUSRETURNSaveCmd:IF FileName="Untitled" THEN	GOSUB SaveAsELSE	Edit.EMPTYUNDOBUFFER	Edit.SAVEFILE SaveFileName	;// ENABLEMENUITEMMainMenu,mnuSave,FALSE	Button(3).ENABLED=FALSE	StatusBarSafe5="Not Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=FALSEEND IFEdit.SETFOCUSRETURNSaveAsCmd:GOSUB SaveAsEditfChanged=0StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSE;// ENABLEMENUITEMMainMenu,mnuSave,FALSEButton(3).ENABLED=FALSEEdit.SETFOCUSRETURNFindText.CHANGETempStr=FindText.TEXTIF LEN(TempStr)>0 THEN	FindNext.ENABLED=TRUEELSE	FindNext.ENABLED=FALSEEND IFEND EVENTFRFindText.CHANGETempStr=FRFindText.TEXTIF LEN(TempStr)>0 THEN	FRFindNext.ENABLED=TRUE	FRReplace.ENABLED=TRUE	FRReplaceAll.ENABLED=TRUEELSE	FRFindNext.ENABLED=FALSE	FRReplace.ENABLED=FALSE	FRReplaceAll.ENABLED=FALSEEND IFEND EVENTFindNext.COMMANDFindStr=FindText.TEXTfr_lpstrFindWhat=ADDR(FindStr)FLAGS=$08IF DownButton.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,0)END IFIF MatchWholeWord.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,1)END IFIF MatchCase.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,2)END IFEdit.FINDFindStr=FindStr+" Not Found"IF STATUS=-1 THEN	MSGBOX "Find",FindStr,MB_OKELSE	FindText.SETFOCUSEND IFEND EVENTQuickFind.CHANGEFLAGS=$09IF QuickFind.TEXT="" THEN	QuickFindPrev.ENABLED=FALSE	QuickFindNext.ENABLED=FALSE	QuickFind.BACKCOLOR=$ffffff	RETURNELSE	QuickFindPrev.ENABLED=TRUE	QuickFindNext.ENABLED=TRUEEND IFGOSUB QuickFindTextQuickFind.SETFOCUSEND EVENTQuickFindPrev.COMMANDFLAGS=$08GOSUB QuickFindTextEND EVENTQuickFindNext.COMMANDFLAGS=$09GOSUB QuickFindTextEND EVENTQuickFindText:FindStr=QuickFind.TEXTfr_lpstrFindWhat=ADDR(FindStr)Edit.FINDFindStr=FindStr+" Not Found"IF STATUS=-1 THEN	QuickFind.BACKCOLOR=$ff	Timer5.TIME=1000ELSE	QuickFind.BACKCOLOR=$ffffffEND IFRETURNTimer5.TIMEOUTTimer5.STOPQuickFind.BACKCOLOR=$ffffffEND EVENTFRFindNext.COMMANDGOSUB GetTextToReplaceEND EVENTFRReplace.COMMANDSelectStr=Edit.SELTEXTFindStr=SelectStrIF TextFound=FALSE OR FindStr<>SelectStr THEN	GOSUB GetTextToReplace	IF TextFound=FALSE THEN		RETURN	END IFEND IF	TempStr=FRReplaceText.TEXTEdit.REPLACESEL TempStrFindStr=FRFindText.TEXTfr_lpstrFindWhat=ADDR(FindStr)FLAGS=$08FLAGS=BITSET(FLAGS,0); Forces downward searchIF FRMatchWholeWord.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,1)END IFIF FRMatchCase.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,2)END IFEdit.FINDIF STATUS=-1 THEN	TextFound=FALSEELSE	TextFound=TRUEEND IFEND EVENTFRReplaceAll.COMMANDREPEAT	SelectStr=Edit.SELTEXT	FindStr=SelectStr	IF TextFound=FALSE OR FindStr<>SelectStr THEN		GOSUB GetTextToReplace		IF TextFound=FALSE THEN			RETURN		END IF	END IF	TempStr=FRReplaceText.TEXT	Edit.REPLACESEL TempStr	FindStr=FRFindText.TEXT	fr_lpstrFindWhat=ADDR(FindStr)	FLAGS=$08	FLAGS=BITSET(FLAGS,0); Forces downward search	IF FRMatchWholeWord.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,1)	END IF	IF FRMatchCase.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,2)	END IFEdit.FINDUNTIL STATUS=-1TextFound=FALSEEND EVENTCancel.COMMANDFindWindow.VISIBLE=FALSEFindWindowActive=FALSEEND EVENTFindWindow.SYSTEMFindWindow.VISIBLE=FALSEFindWindowActive=FALSEEND EVENTFRCancel.COMMANDFindReplaceWindow.VISIBLE=FALSEEND EVENTFindReplaceWindow.SYSTEMFindReplaceWindow.VISIBLE=FALSEEND EVENTGetFindDialog:IF FindWindowConstructed=FALSE THEN	FindWindowConstructed=TRUE	CREATE FindWindow,400,300,360,125 APPWINDOW CHILD	FindWindow.TEXT="Find"	CREATE UpDown,160,45,100,45 IN FindWindow	UpDown.FONT=Font1	UpDown.Text="Direction"	CREATE UpButton,5,20,40,15 IN UpDown	UpButton.FONT=Font1	UpButton.TEXT="&Up"	CREATE DownButton,45,20,50,15 IN UpDown	DownButton.FONT=Font1	DownButton.TEXT="&Down"	CREATE FindText,70,5,190,20 IN FindWindow	FindText.FONT=Font1	FindText.INTERCEPTON	CREATE FindWhat,5,8,50,15 IN FindWindow	FindWhat.FONT=Font1	FindWhat.TEXT="Fi&nd what:"	CREATE MatchWholeWord,5,50,130,15 IN FindWindow	MatchWholeWord.FONT=Font1	MatchWholeWord.TEXT="Match &whole word only"	CREATE MatchCase,5,75,75,15 IN FindWindow	MatchCase.FONT=Font1	MatchCase.TEXT="Match &case"	CREATE FindNext,270,5,75,25 IN FindWindow	FindNext.TOOLTIP="Find Next"	FindNext.FONT=Font1	FindNext.TEXT="&Find Next" IN FindWindow	CREATE Cancel,270,35,75,25 IN FindWindow	Cancel.TOOLTIP="Cancel"	Cancel.FONT=Font1	Cancel.TEXT="Cancel"	FindText.TEXT=""	DownButton.CHECKED=TRUE	UpButton.CHECKED=FALSE	MatchWholeWord.CHECKED=FALSE	MatchCase.CHECKED=FALSE	FindNext.ENABLED=FALSEELSE	FindWindow.VISIBLE=TRUEEND IFFindWindowActive=TRUEFindText.SETFOCUS;FindText.HILITE=FALSERETURNFindText.INTERCEPTIF wmsg=$102 THEN	IF wparam=$0d THEN		GOSUB FindNext_COMMAND	END IF	IF wparam=$1b THEN		GOSUB Cancel_COMMAND	END IFEND IFPASSEVENTEND EVENTGetFindReplaceDialog:IF FRWindowConstructed=FALSE THEN	FRWindowConstructed=TRUE	CREATE FindReplaceWindow,400,300,360,150 APPWINDOW CHILD	FindReplaceWindow.TEXT="Replace"	CREATE FRFindText,70,5,190,20 IN FindReplaceWindow	FRFindText.FONT=Font1	FRFindText.INTERCEPTON	CREATE FRFindWhat,5,8,60,15 IN FindReplaceWindow	FRFindWhat.FONT=Font1	FRFindWhat.TEXT="Fi&nd what:"	CREATE FRReplaceText,70,35,190,20 IN FindReplaceWindow	FRReplaceText.FONT=Font1	CREATE FRReplaceWith,5,38,60,15 IN FindReplaceWindow	FRReplaceWith.FONT=Font1	FRReplaceWith.TEXT="Re&place with:"	CREATE FRMatchWholeWord,5,75,130,15 IN FindReplaceWindow	FRMatchWholeWord.FONT=Font1	FRMatchWholeWord.TEXT="Match &whole word only"	CREATE FRMatchCase,5,100,75,15 IN FindReplaceWindow	FRMatchCase.FONT=Font1	FRMatchCase.TEXT="Match &case"	CREATE FRFindNext,270,5,75,25 IN FindReplaceWindow	FRFindNext.FONT=Font1	FRFindNext.TEXT="&Find Next" IN FindReplaceWindow	CREATE FRReplace,270,35,75,25 IN FindReplaceWindow	FRReplace.FONT=Font1	FRReplace.TEXT="&Replace"	CREATE FRReplaceAll,270,65,75,25 IN FindReplaceWindow	FRReplaceAll.FONT=Font1	FRReplaceAll.TEXT="Replace &All"		CREATE FRCancel,270,95,75,25 IN FindReplaceWindow	FRCancel.FONT=Font1	FRCancel.TEXT="Cancel"	FRFindText.TEXT=""	FRFindNext.ENABLED=FALSE	FRReplace.ENABLED=FALSE	FRReplaceAll.ENABLED=FALSEELSE	FindReplaceWindow.VISIBLE=TRUEEND IFFRWindowActive=TRUEFRFindText.SETFOCUSRETURNFRFindText.INTERCEPTIF wmsg=$102 THEN	IF wparam=$0d THEN		GOSUB FRFindNext_COMMAND	END IF	IF wparam=$1b THEN		GOSUB FRCancel_COMMAND	END IFEND IFPASSEVENTEND EVENTGetTextToReplace:FindStr=FRFindText.TEXTfr_lpstrFindWhat=ADDR(FindStr)FLAGS=$08FLAGS=BITSET(FLAGS,0); Forces downward searchIF FRMatchWholeWord.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,1)END IFIF FRMatchCase.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,2)END IFEdit.FINDIF STATUS=-1 THEN	TextFound=FALSE	FindStr=FindStr+" Not Found"	MSGBOX "Replace",FindStr,MB_OK	RETURNELSE	TextFound=TRUEEND IFRETURNFindStyle:I=0BEGIN LOOP	INCR I	IF StyleArray(I).StyleName="%" THEN		ErrNo=ErrIVProp		RETURN	END IF		IF StyleArray(I).StyleName=TempStr AND StyleArray(I).StyleType=STYLE THEN		RETURN	END IFEND LOOPRETURNEdit.CONTEXTMENUSHOWPOPUP EditPopUp,CursorPosX,CursorPosYEND EVENTDeleteControl:; Add provision for deleted control being a parent laterTempHandle=ControlArray(ControlPtr).PuppetHandlePuppetIDDispenser(ControlArray(ControlPtr).PuppetID-100)=FALSEGOSUB CleanControlinvoke DestroyWindow,[TempHandle]ControlNameSafe=ControlNameControlName=OwnerNameGOSUB ControlComboAction; Force ControlCombo selection of parentControlName=ControlNameSafeControlCombo.TEXT=OwnerNameControlCombo.FINDITEM ControlNameControlCombo.DELETEITEM STATUSEventCombo1.FINDITEM ControlNameEventCombo1.DELETEITEM STATUSSpider(1).VISIBLE=FALSEGOSUB PaintGridGOSUB RedrawPartsgosub refresh_commandRETURNFindEvent:TempInt=MenuID-evmnu1+1TempStr=ControlName+"."+EventArray(TempInt).EVTypeEdit.GOTO 1fr_lpstrFindWhat=ADDR(TempStr)FLAGS=$09Edit.FINDIF STATUS=-1 THEN	GOSUB AddEventELSE	Edit.GOTO EditLine+1END IFEdit.SETFOCUSGOSUB Button6PressedRETURNEventCombo2.SELECTTempName=EventCombo2.SELTEXTTempStr=EventCombo1.TEXTTempStr=TempStr+"."+TempNameEdit.GOTO 1fr_lpstrFindWhat=ADDR(TempStr)FLAGS=$09Edit.FINDIF STATUS=-1 THEN	GOSUB AddEventELSE	Edit.GOTO EditLine+1END IFEventCombo2.ENABLED=FALSEEventCombo1.TEXT="Select Control"Timer2.TIME=50Edit.SETFOCUSEND EVENTAddEvent:	TempStr=TempStr+CHR($0d)+CHR($0d)+"END EVENT"+CHR($0d)+CHR($0d)	Edit.APPENDTEXT TempStr	;Edit.SETDIVIDERLINE EditLine-4,TRUE	;Edit.SETDIVIDERLINE EditLine-1,TRUE	Edit.goto EditLine-3RETURNTimer2.TIMEOUTTimer2.STOPEventCombo2.TEXT=""END EVENTFormWindow.RBUTTONDOWNRBDown=TRUEControlPtrSafe=ControlPtrControlPtr=OverControlControlName=ControlArray(ControlPtr).PuppetNameOwnerName=ControlArray(ControlArray(ControlPtr).PuppetOwner).PuppetNameFcnName=ControlArray(ControlPtr).PuppetNameSpider(Belly).VISIBLE=TRUEIF ControlArray(ControlPtr).PuppetType<>1 THEN; Not Form	ControlCombo.TEXT=ControlArray(ControlPtr).PuppetName	GOSUB InitSpider	GOSUB PlaceSpiderLegsELSE	ControlCombo.TEXT=FormCombo.TEXT	GOSUB HideSpider	SETPOSITION Spider(Belly),CursorPosX,CursorPosY,0,0END IFControlNdx=ControlPtrToolButtonNdx=ControlArray(ControlPtr).PuppetTypeGOSUB PopulateToolBoxGOSUB ControlArrayToToolBoxGOSUB CleanGOSUB PaintGridEND EVENTFormWindow.RBUTTONUPRBDown=FALSEIF ControlPtr=1 THEN	;// ENABLEMENUITEMFormPopUp,fwmnuDelete,FALSEELSE	;// ENABLEMENUITEMFormPopUp,fwmnuDelete,TRUEEND IFTempInt=ControlArray(ControlPtr).PuppetTypeFOR I=1 TO EventMenuCount	DELETEMENUITEM EventPopUp,evmnu1+I-1NEXT ISETVEC EventArray=[ToolPropMap(TempInt).PropMapEventTable]I=0EventMenuCount=0BEGIN LOOP	INCR I	EXIT IF EventArray(I).EVType="%"	TempStr=EventArray(I).EVType	APPENDMENUITEM EventPopUp,evmnu1+I-1,TempStr	INCR EventMenuCountEND LOOPGETCURSORPOSITIONSHOWPOPUP FormPopUp,CursorPosX,CursorPosYEND EVENTFormWindow.LBUTTONDOWNMouseDown=TRUEControlPtrSafe=ControlPtrControlPtr=OverControlControlName=ControlArray(ControlPtr).PuppetNameSpider(Belly).VISIBLE=TRUEIF PlacePart=TRUE THEN	IF ToolButtonNdx=8 THEN		ComboFlag=TRUE	ELSE		ComboFlag=FALSE	END IF	SpiderLeft=CursorPosX	SpiderTop=CursorPosY	SpiderWidth=0	SpiderHeight=0	OwnerPtr=OverControl	SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight	OwnerName=ControlArray(OverControl).PuppetName	PropGrid.TEXT(2,2)=OwnerName	IF ControlArray(OwnerPtr).PuppetType=1 THEN		TempHandle=FormWindow.HANDLE	ELSE		TempHandle=ControlArray(OwnerPtr).PuppetHandle	END IFELSE	IF SpiderFound=TRUE THEN		ControlPtr=ControlPtrSafe		IF ControlArray(ControlPtr).PuppetType=8 THEN			ComboFlag=TRUE		ELSE			ComboFlag=FALSE		END IF		IF ControlArray(ControlPtr).PuppetType=1 THEN; Bulletproofing			RETURN		END IF		OwnerPtr=ControlArray(ControlPtr).PuppetOwner		SizeSel=SpiderPtr		GOSUB InitSpider		SizeControl=TRUE	ELSE		IF ControlArray(ControlPtr).PuppetType=8 THEN			ComboFlag=TRUE		ELSE			ComboFlag=FALSE		END IF		IF ControlArray(ControlPtr).PuppetType<>1 THEN; Not Form			ControlCombo.TEXT=ControlArray(ControlPtr).PuppetName			OwnerPtr=ControlArray(ControlPtr).PuppetOwner			MoveControl=TRUE			GOSUB InitSpider		ELSE			ControlCombo.TEXT=FormCombo.TEXT			GOSUB HideSpiderLegs			DrawRect=TRUE			SETPOSITION Spider(Belly),CursorPosX,CursorPosY,0,0		END IF	END IF	ControlNdx=ControlPtr	ToolButtonNdx=ControlArray(ControlPtr).PuppetType	GOSUB PopulateToolBox	GOSUB ControlArrayToToolBoxEND IFGOSUB PaintGridgosub refresh_commandEND EVENTInitSpider:IF ControlArray(OwnerPtr).PuppetType=1 THEN	ChildOffsX=0	ChildOffsY=0ELSE	ChildOffsX=ControlArray(OwnerPtr).PuppetLeft	ChildOffsY=ControlArray(OwnerPtr).PuppetTopEND IFMouseOffsX=CursorPosX-ControlArray(ControlPtr).PuppetLeftMouseOffsY=CursorPosY-ControlArray(ControlPtr).PuppetTopSpiderLeft=ControlArray(ControlPtr).PuppetLeft+ChildOffsXSpiderTop=ControlArray(ControlPtr).PuppetTop+ChildOffsYSpiderWidth=ControlArray(ControlPtr).PuppetWidthIF ComboFlag=FALSE THEN	SpiderHeight=ControlArray(ControlPtr).PuppetHeightELSE	SpiderHeight=25END IFSpider(Belly).LEFT=SpiderLeftSpider(Belly).TOP=SpiderTopSpider(Belly).WIDTH=SpiderWidthSpider(Belly).HEIGHT=SpiderHeightRETURNFormWindow.MOUSEMOVEIF RBDown=TRUE THEN	RETURNEND IFGETCURSORPOSITIONIF MouseDown=FALSE THEN	IF CursorPosX<ControlArray(1).PuppetLeft OR CursorPosX>ControlArray(1).PuppetLeft+ControlArray(1).PuppetWidth OR CursorPosY<ControlArray(1).PuppetTop+20 OR CursorPosY>ControlArray(1).PuppetTop+ControlArray(1).PuppetHeight THEN		RELEASECAPTURE		StatusBar.SETTEXT 1,"Off Form"		StatusBar.SETTEXT 2,"Off Form"		StatusBar.SETTEXT 3,"Off Form"		RETURN	ELSE		IF CaptureEnable=TRUE THEN			SETCAPTURE FormWindow		END IF	END IFEND IFSCREENTOCLIENT FormWindowTempStr="X-Pos="+STR(CursorPosX)StatusBar.SETTEXT 1,TempStrTempStr="Y-Pos="+STR(CursorPosY)StatusBar.SETTEXT 2,TempStrIF MoveControl=True THEN	SpiderLeft=CursorPosX-MouseOffsX+ChildOffsX	SpiderTop=CursorPosY-MouseOffsY+ChildOffsY	SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight	GOSUB PlaceSpiderLegs	GOSUB Clean	PropGrid.TEXT(6,2)=STR(CursorPosX-MouseOffsX)	PropGrid.TEXT(7,2)=STR(CursorPosY-MouseOffsY)	GOSUB PaintGrid	RETURNEND IFIF DrawRect=TRUE THEN	TempInt=Spider(Belly).LEFT	Spider(Belly).WIDTH=CursorPosX-TempInt	TempInt=Spider(Belly).TOP	Spider(Belly).HEIGHT=CursorPosY-TempInt	GOSUB Clean	RETURNEND IFIF PlacePart=TRUE AND MouseDown=TRUE THEN	SpiderWidth=CursorPosX-SpiderLeft	Spider(Belly).WIDTH=SpiderWidth	SpiderHeight=CursorPosY-SpiderTop	Spider(Belly).HEIGHT=SpiderHeight	GOSUB Clean	PropGrid.TEXT(6,2)=STR(SpiderLeft)	PropGrid.TEXT(7,2)=STR(SpiderTop)	PropGrid.TEXT(8,2)=STR(SpiderWidth)	PropGrid.TEXT(9,2)=STR(SpiderHeight)	RETURNEND IFIF SizeControl=TRUE THEN	PropGrid.TEXT(6,2)=STR(SpiderLeft)	PropGrid.TEXT(7,2)=STR(SpiderTop)	PropGrid.TEXT(8,2)=STR(SpiderWidth)	PropGrid.TEXT(9,2)=STR(SpiderHeight)	IF SizeSel=E OR SizeSel=SE OR SizeSel=NE THEN		SpiderWidth=CursorPosX-SpiderLeft	END IF	IF SizeSel=S OR SizeSel=SE OR SizeSel=SW THEN		SpiderHeight=CursorPosY-SpiderTop	END IF	IF SizeSel=W OR SizeSel=NW OR SizeSel=SW THEN		SpiderLeft=CursorPosX		SpiderRight=Spider.RIGHT		SpiderWidth=SpiderRight-SpiderLeft	END IF	IF SizeSel=N OR SizeSel=NW OR SizeSel=NE THEN		SpiderTop=CursorPosY		SpiderBottom=Spider.BOTTOM		SpiderHeight=SpiderBottom-SpiderTop	END IF	SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight	GOSUB PlaceSpiderLegs	GOSUB Clean	gosub refresh_command	RETURNEND IFGOSUB FindControlByPositionIF SpiderFound=TRUE THEN	FormWindow.text=str(SpiderPtr)ELSE	IF ControlFound=TRUE THEN		TempStr=ControlArray(ControlNdx).PuppetName		StatusBar.SETTEXT 3,TempStr	ELSE		StatusBar.SETTEXT 3,CurrentFormName	END IFEND IFEND EVENTFormWindow.LBUTTONUPMouseDown=FALSEIF MoveControl=TRUE THEN	TempHandle=ControlArray(ControlPtr).PuppetHandle	SpiderLeft=CursorPosX-MouseOffsX+ChildOffsX	SpiderTop=CursorPosY-MouseOffsY+ChildOffsY	IF SnapToGrid=TRUE THEN		GOSUB SetSnap	END IF	IF ComboFlag=TRUE THEN		SpiderHeight=25	END IF		GOSUB PlaceSpiderLegs	TempLeft=SpiderLeft-ChildOffsX	TempTop=SpiderTop-ChildOffsY	IF ControlArray(ControlPtr).PuppetType=1 THEN; Bulletproofing		RETURN	END IF	ControlArray(ControlPtr).PuppetLeft=TempLeft	ControlArray(ControlPtr).PuppetTop=TempTop	invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[SpiderWidth],[SpiderHeight],$40	invoke SetWindowPos,[TempHandle],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE	ControlNdx=ControlPtr	GOSUB ControlArrayToToolBox	MoveControl=FALSE	FormWindow.VISIBLE=FALSE	FormWindow.VISIBLE=TRUE	GOSUB PaintGrid	GOSUB RedrawParts	RETURNEND IFIF DrawRect=TRUE THEN	DrawRect=FALSE	GOSUB PaintGrid	GOSUB RedrawParts	RETURNEND IFIF SizeControl=TRUE THEN	SizeControl=FALSE	TempHandle=ControlArray(ControlPtr).PuppetHandle	IF SnapToGrid=TRUE THEN		GOSUB SetSnap	END IF	IF ComboFlag=TRUE THEN		SpiderHeight=25	END IF	GOSUB PlaceSpiderLegs	TempLeft=SpiderLeft-ChildOffsX	TempTop=SpiderTop-ChildOffsY	IF ControlArray(ControlPtr).PuppetType=1 THEN; Bulletproofing		RETURN	END IF	ControlArray(ControlPtr).PuppetLeft=TempLeft	ControlArray(ControlPtr).PuppetTop=TempTop	ControlArray(ControlPtr).PuppetWidth=SpiderWidth	IF ComboFlag=FALSE THEN		ControlArray(ControlPtr).PuppetHeight=SpiderHeight	ELSE		ControlArray(ControlPtr).PuppetHeight=200	END IF	invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[SpiderWidth],[SpiderHeight],$40	ControlNdx=ControlPtr	GOSUB ControlArrayToToolBox	GOSUB ScreenRefresh	gosub refresh_command	RETURNEND IFIF PlacePart=TRUE THEN	ControlPtr=PlacePtr	IF SnapToGrid=TRUE THEN		GOSUB SetSnap	END IF	IF ComboFlag=TRUE THEN		SpiderHeight=25	END IF	IF ControlArray(OwnerPtr).PuppetType=1 THEN		TempLeft=SpiderLeft		TempTop=SpiderTop	ELSE		TempLeft=SpiderLeft-ControlArray(OwnerPtr).PuppetLeft		TempTop=SpiderTop-ControlArray(OwnerPtr).PuppetTop	END IF	TempWidth=SpiderWidth	TempHeight=SpiderHeight	ControlArray(PlacePtr).PuppetLeft=TempLeft	ControlArray(PlacePtr).PuppetTop=TempTop	ControlArray(PlacePtr).PuppetWidth=TempWidth	IF ComboFlag=TRUE THEN		ControlArray(PlacePtr).PuppetHeight=200	ELSE		ControlArray(PlacePtr).PuppetHeight=TempHeight	END IF	ControlArray(PlacePtr).PuppetOwner=OwnerPtr	ControlArray(PlacePtr).PuppetOwnerParent=TempOwnerParent	GOSUB PopulateToolBox	ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1	TempStr=STR(ToolPropMap(ToolButtonNdx).PropMapCount)	ControlArray(PlacePtr).PuppetType=ToolButtonNdx	SELECT CASE ToolButtonNdx		CASE 3; BUTTON			ControlArray(PlacePtr).PuppetName="Button"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType2			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 4; STATICTEXT				ControlArray(PlacePtr).PuppetName="StaticText"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType26			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 5; FRAME			ControlArray(PlacePtr).PuppetName="Frame"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType6			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 6; SLIDER			ControlArray(PlacePtr).PuppetName="Slider"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType8			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 7; TEXTBOX			ControlArray(PlacePtr).PuppetName="TextBox"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType5			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 8; COMBOBOX			ControlArray(PlacePtr).PuppetName="Combo"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType4			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 9; LISTBOX			ControlArray(PlacePtr).PuppetName="ListBox"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType7			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 10; RADIOBUTTON					ControlArray(PlacePtr).PuppetName="RB"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType19			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 11; CHECKBOX			ControlArray(PlacePtr).PuppetName="CB"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType18			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 12; PROGRESSBAR			ControlArray(PlacePtr).PuppetName="Progress"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType10			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 13; CALENDAR			ControlArray(PlacePtr).PuppetName="Calendar"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType11			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 14; TABFOLDER			ControlArray(PlacePtr).PuppetName="TabFolder"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType14			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 20; RAEdit			ControlArray(PlacePtr).PuppetName="RAEdit"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType22			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 21; RAGrid			ControlArray(PlacePtr).PuppetName="RAGrid"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType23			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 22; LISTVIEW			ControlArray(PlacePtr).PuppetName="ListView"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType25			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 24; TREEVIEW			ControlArray(PlacePtr).PuppetName="TreeView"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType13			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 25; DATETIMEPICK			ControlArray(PlacePtr).PuppetName="DateTime"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType32			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 26; IMAGE			ControlArray(PlacePtr).PuppetName="Image"+TempStr			TempStr="***"			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType33			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet		CASE 27; DRAWPROGRESS				ControlArray(PlacePtr).PuppetName="DP"+TempStr			TempStr=ControlArray(PlacePtr).PuppetName			ControlArray(PlacePtr).PuppetText=TempStr			mov [TempControlType],!ControlType30			ControlArray(PlacePtr).PuppetControlType=TempControlType			GOSUB CreatePuppet	END SELECT	IF ToolButtonNdx=20 THEN		ControlArray(PlacePtr).PuppetBackColor=$c0f0f0	ELSE		IF ToolButtonNdx=21 THEN			ControlArray(PlacePtr).PuppetBackColor=$ffffff		ELSE			Timer3.TIME=100		END IF	END IF	ControlArray(PlacePtr).PuppetForeColor=0	ControlArray(PlacePtr).PuppetStatus=$07	invoke SetWindowPos,[TempInt],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE	GOSUB PlaceSpiderLegs	ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName	ControlCombo.TEXT=ControlArray(PlacePtr).PuppetName	EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName	EventCombo1.TEXT="Select Control"	EventCombo1.ENABLED=TRUE	GOSUB GetControlID	ControlArray(PlacePtr).PuppetID=ControlID	ControlArray(PlacePtr).PuppetArray=-1	ControlNdx=PlacePtr	;GOSUB PopulateToolBox	GOSUB ControlArrayToToolBox	PlacePart=FALSE	gosub refresh_commandEND IFGOSUB PaintGridGOSUB RedrawPartsEND EVENTCreatePuppet:invoke CreateWindowEx,[TempExStyle],[TempControlType],[TempStr],[TempStyle],[TempLeft],[TempTop],[TempWidth],[TempHeight], dword [TempHandle],dword [TempInt],[!hinstance],0mov [TempInt],eaxControlArray(PlacePtr).PuppetHandle=TempIntIF ControlArray(PlacePtr).PuppetType=8 THEN; ComboBox	invoke GetComboBoxInfo,[TempInt],!cbSize	mov eax,[!hwndCombo]	mov [TempInt2],eax	ControlArray(PlacePtr).PuppethwndCombo=TempInt2	mov eax,[!hwndItem]	mov [TempInt2],eax	ControlArray(PlacePtr).PuppethwndItem=TempInt2	mov eax,[!hwndList]	mov [TempInt2],eax	ControlArray(PlacePtr).PuppethwndList=TempInt2	invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]END IFIF ControlArray(PlacePtr).PuppetType=9 THEN; ListBox	invoke SendMessage, dword [TempInt],LB_INSERTSTRING,-1,[TempStr]END IFIF ControlArray(PlacePtr).PuppetType=12 THEN; ProgressBar	invoke SendMessage, dword [TempInt],PBM_SETPOS,50,0END IFIF ControlArray(PlacePtr).PuppetType=14 THEN; TabFolder	TempStr=ControlArray(PlacePtr).PuppetName	mov eax,[TempStr]	mov [!TC_ITEMText],eax	mov [!TC_ITEMTextMax],10	mov [!TC_ITEMmask],TCIF_TEXT	invoke SendMessage,dword [TempInt],TCM_INSERTITEM,1,!TC_ITEMmask	TempStr="Tab2"	mov eax,[TempStr]	mov [!TC_ITEMText],eax	mov [!TC_ITEMTextMax],5	mov [!TC_ITEMmask],TCIF_TEXT	invoke SendMessage,dword [TempInt],TCM_INSERTITEM,2,!TC_ITEMmask	TempStr="Tab3"	mov eax,[TempStr]	mov [!TC_ITEMText],eax	mov [!TC_ITEMTextMax],5	mov [!TC_ITEMmask],TCIF_TEXT	invoke SendMessage,dword [TempInt],TCM_INSERTITEM,3,!TC_ITEMmaskEND IFIF ControlArray(PlacePtr).PuppetType=20 THEN; RAEdit	invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]END IFIF ControlArray(PlacePtr).PuppetType=21 THEN; RAGrid	invoke SendMessage,[TempInt],GM_SETHDRHEIGHT,0,21	TempStr=ControlArray(PlacePtr).PuppetName	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	mov [gc_ctype],TYPE_EDITTEXT	mov eax,100	mov [gc_colwt],eax	mov eax,[_TmpVec1]	mov [gc_halign],GA_ALIGN_CENTER	mov [gc_calign],GA_ALIGN_LEFT	mov eax,31	mov [gc_ctextmax],eax	mov [gc_lpszformat],0	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 2"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 3"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 4"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 5"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 6"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 7"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 8"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 9"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	TempStr="Header 10"	mov eax,[TempStr]	mov [gc_lpszhdrtext],eax	invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt	FOR I=1 TO 100		invoke SendMessage,dword [TempInt],GM_ADDROW,0,0	NEXT IEND IFIF ControlArray(PlacePtr).PuppetType=27 THEN; Image	;invoke SendMessage, dword [TempHandle],STM_SETIMAGE,IMAGE_BITMAP,[ImageBMP]END IFRETURNScreenRefresh:FormWindow.VISIBLE=FALSEFormWindow.VISIBLE=TRUEGOSUB PaintGridGOSUB RedrawPartsRETURNTimer3.TIMEOUTTimer3.STOPTempInt=ControlArray(PlacePtr).PuppetHandleinvoke GetDC,[TempInt]invoke GetPixel,eax,2,2mov [TempInt2],eaxControlArray(PlacePtr).PuppetBackColor=TempInt2TempStr="$"+HEX(TempInt2)PropGrid.TEXT(10,2)=TempStrEND EVENTClean:FormWindow.BACKCOLOR=FormWindow.BACKCOLORGOSUB PaintGridRETURNFindControlByPosition:SpiderFound=FALSEControlFound=FALSEIF SpiderPlaced=TRUE THEN	FOR SpiderNdx=2 TO 9		IF CursorPosX>=Spider(SpiderNdx).LEFT AND CursorPosX<=Spider(SpiderNdx).RIGHT AND CursorPosY>=Spider(SpiderNdx).TOP AND CursorPosY<=Spider(SpiderNdx).BOTTOM THEN			SpiderPtr=SpiderNdx			SpiderFound=TRUE			RETURN		END IF	NEXT SpiderNdxEND IFControlNdx=LastControl+1BEGIN LOOP	DECR ControlNdx	IF ControlNdx=1 THEN		OverControl=1		RETURN	END IF	GOSUB GetPuppetPosition	IF TempLeft<>$ffffffff THEN		;IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinVisible)=TRUE THEN			IF CursorPosX>=TempLeft AND CursorPosX<=TempLeft+TempWidth AND CursorPosY>=TempTop AND CursorPosY<=TempTop+TempHeight THEN				ControlFound=TRUE'''				OverControl=ControlNdx				RETURN			END IF		;END IF	END IFEND LOOPRETURNToolButton.COMMANDToolButtonNdx=ArrayIndexGOSUB ToolButtonActionEND EVENTPopulateToolBox:GOSUB PopulatePropGridGOSUB PopulateStyleGridGOSUB PopulateExStyleGridRETURNPopulatePropGrid:PropGrid.GRIDCLEARSETVEC PropArray=[ToolPropMap(ToolButtonNdx).PropMapPropTable]FOR I=1 TO 15	PropGrid.ADDROW	TempStr=UCASE(PropArray(I).PropName)	PropGrid.TEXT(I,1)=TempStr	IF PropArray(I).PropValid=TRUE THEN		PropValidTable(I)=TRUE	ELSE		PropValidTable(I)=FALSE		PropGrid.TEXT(I,2)="***"	END IFNEXT IRETURNPopulateStyleGrid:StyleGrid.GRIDCLEARIF PlacePart=TRUE THEN	TempStyle=0ELSE	TempStyle=ControlArray(ControlPtr).PuppetStyleEND IFSETVEC StyleArray=[ToolPropMap(ToolButtonNdx).PropMapStyleTable]I=2StyleGridRow=0DisplayStyleLoop:INCR IIF StyleArray(I).StyleName="%" THEN	RETURNEND IFIF StyleArray(I).StyleType=EXSTYLE THEN DisplayStyleLoopStyleGrid.ADDROWINCR StyleGridRowTempStr=UCASE(StyleArray(I).StyleName)StyleGrid.TEXT(StyleGridRow,1)=TempStrIF PlacePart=TRUE THEN	IF StyleArray(I).StyleDefault=TRUE THEN		StyleGrid.VALUE(StyleGridRow,2)=1		TempStyle=TempStyle+StyleArray(I).StyleValue		ControlArray(PlacePtr).PuppetStyle=TempStyle	END IFELSE	TempInt=StyleArray(I).StyleValue	IF LAND(TempInt,TempStyle)=TempInt THEN		StyleGrid.VALUE(StyleGridRow,2)=1	END IFEND IFGOSUB MakeHex8TempStr=TempStr+HEX(StyleArray(I).StyleValue)StyleGrid.TEXT(StyleGridRow,3)=TempStrGOTO DisplayStyleLoopRETURNPopulateExStyleGrid:ExStyleGrid.GRIDCLEARIF PlacePart=TRUE THEN	TempExStyle=0ELSE	TempExStyle=ControlArray(ControlPtr).PuppetExStyleEND IFSETVEC StyleArray=[ToolPropMap(ToolButtonNdx).PropMapStyleTable]I=2ExStyleGridRow=0DisplayExStyleLoop:INCR IIF StyleArray(I).StyleName="%" THEN	RETURNEND IFIF StyleArray(I).StyleType=STYLE THEN DisplayExStyleLoopExStyleGrid.ADDROWINCR ExStyleGridRowTempStr=UCASE(StyleArray(I).StyleName)ExStyleGrid.TEXT(ExStyleGridRow,1)=TempStrIF PlacePart=TRUE THEN	IF StyleArray(I).StyleDefault=TRUE THEN		ExStyleGrid.VALUE(ExStyleGridRow,2)=1		TempExStyle=TempExStyle+StyleArray(I).StyleValue		ControlArray(PlacePtr).PuppetExStyle=TempExStyle	END IFELSE	TempInt=StyleArray(I).StyleValue	IF LAND(TempInt,TempStyle)=TempInt THEN		ExStyleGrid.VALUE(ExStyleGridRow,2)=1	END IFEND IFGOSUB MakeHex8TempStr=TempStr+HEX(StyleArray(I).StyleValue)ExStyleGrid.TEXT(ExStyleGridRow,3)=TempStrGOTO DisplayExStyleLoopRETURNMakeHex8:SELECT CASE LEN(HEX(StyleArray(I).StyleValue))	CASE 1		TempStr="   $0000000"	CASE 2		TempStr="   $000000"	CASE 3		TempStr="   $00000"	CASE 4		TempStr="   $0000"	CASE 5		TempStr="   $000"	CASE 6		TempStr="   $00"	CASE 7		TempStr="   $0"	CASE 8		TempStr="   $"	END SELECTRETURNColorChangeTrap:cmp [!Desc],0je NotDescPASSEVENTretNotDesc:FOR PI=2 TO LastControl	IF ControlArray(PI).PuppetHandle=lparam OR ControlArray(PI).PuppethwndCombo=lparam OR ControlArray(PI).PuppethwndItem=lparam OR ControlArray(PI).PuppethwndList=lparam THEN		PTempInt=ControlArray(PI).PuppetStatus		PTempInt=LAND(PTempInt,$18)		IF PTempInt<>0 THEN			IF PTempInt=$08 THEN				PTempInt=ControlArray(PI).PuppetBackColor				mov eax,[PTempInt]				mov [!dsBackColor],eax				call !BackColorChange				jmp !Finish			ELSE						IF PTempInt=$10 OR PTempInt=$18 THEN					PTempInt=ControlArray(PI).PuppetBackColor					mov eax,[PTempInt]					mov [!dsBackColor],eax					PTempInt=ControlArray(PI).PuppetForeColor					mov eax,[PTempInt]					mov [!dsForeColor],eax					call !BothColorChange					jmp !Finish									END IF			END IF			RETURN		END IF	END IFNEXT PIPASSEVENTRETURNToolButtonAction:INCR ControlCountIF ControlCount>ControlTableSize THEN	DECR ControlCount	WARNINGBOX "OmniBasic","Out of Control Space",MB_OK	RETURNEND IFSELECT CASE ToolButtonNdx	CASE 1; Form		IF FormWindowConstructed=FALSE THEN			CREATE FormWindow,340,150,640,480, CHILD			FormWindowConstructed=TRUE			PlacePtr=1			LastControl=1			CurrentFormPtr=1			CurrentFormName="OBMain"			TrapColorChangeEvent ColorChangeTrap			ControlArray(PlacePtr).PuppetName="OBMain"			FormCombo.CLEAR			ControlCombo.CLEAR			CREATE Spider(Belly),0,0,0,0,BASE+BLACKFRAME IN FormWindow			Spider(Belly).BACKCOLOR=$ffffffff			Spider(Belly).VISIBLE=FALSE			FOR I=2 TO 9				CREATE Spider(I),0,0,0,0 IN FormWindow				Spider(I).BACKCOLOR=0				Spider(I).VISIBLE=FALSE			NEXT I			GOSUB PaintGrid			GOSUB RedrawParts		ELSE			GOSUB FindEmptyControlSlot			ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1			SETPOSITION FormWindow,340,150,640,480					ControlArray(PlacePtr).PuppetName="Form"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)			CurrentFormName=ControlArray(PlacePtr).PuppetName		END IF		GOSUB HideObjects		CurrentFormPtr=PlacePtr		ControlArray(PlacePtr).PuppetHandle=$ffffffff		ControlArray(PlacePtr).PuppetType=1		ControlArray(PlacePtr).PuppetStyle=$10cf0000		TempInt=FormWindow.BACKCOLOR		ControlArray(1).PuppetBackColor=TempInt		FormWindow.TEXT=ControlArray(PlacePtr).PuppetName		ControlArray(PlacePtr).PuppetText=ControlArray(PlacePtr).PuppetName		FormCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetText		FormCombo.TEXT=ControlArray(PlacePtr).PuppetText		ControlCombo.CLEAR		ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName		EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName		EventCombo1.ENABLED=TRUE		EventCombo1.TEXT="Select Control"		ControlCombo.TEXT=ControlArray(PlacePtr).PuppetText		ControlArray(PlacePtr).PuppetArray=-1		ControlArray(PlacePtr).PuppetLeft=340		ControlArray(PlacePtr).PuppetTop=150		ControlArray(PlacePtr).PuppetWidth=640		ControlArray(PlacePtr).PuppetHeight=480		GOSUB ControlArrayToToolBox	CASE 2; ToolWindow		return		CASE 3; BUTTON	CASE 4; STATICTEXT	CASE 5; FRAME	CASE 6; SLIDER	CASE 7; TEXTBOX	CASE 8; COMBOBOX	CASE 9; LISTBOX	CASE 10; RADIOBUTTON	CASE 11; CHECKBOX	CASE 12; PROGRESSBAR	CASE 13; CALENDAR		CASE 14; TABFOLDER	CASE 16; STATUSBAR		GOSUB CreateStatusBar		RETURN	CASE 20; RAEdit	CASE 21; RAGrid		CASE 22; LISTVIEW		CASE 23; TOOLBAR		GOSUB CreateToolBar		RETURN	CASE 24; TREEVIEW		CASE 25; DATETIMEPICK		CASE 26; IMAGE	CASE 27; DRAWPROGRESS				CASE ELSE		RETURNEND SELECTGOSUB FindEmptyControlSlotPlacePart=TRUERETURNCreateStatusBar:GOSUB FindEmptyControlSlotToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1		ControlArray(PlacePtr).PuppetName="Status"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)ControlArray(PlacePtr).PuppetText="***"ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1GOSUB GetControlIDControlArray(PlacePtr).PuppetID=ControlIDControlArray(PlacePtr).PuppetArray=-1ControlArray(PlacePtr).PuppetType=16ControlArray(PlacePtr).PuppetOwner=1; Change to CurrentFormPtr laterinvoke CreateWindowEx,0,!ControlType17,NULL,$50000810,0,0,0,0, dword [!FormWindow],dword [TempInt],[!hinstance],0mov [TempHandle],eaxControlArray(PlacePtr).PuppetHandle=TempHandleControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetNameEventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetNameControlCombo.TEXT=ControlArray(PlacePtr).PuppetNameinvoke GetClientRect,[TempHandle],RectLeftControlArray(PlacePtr).PuppetLeft=RectLeftControlArray(PlacePtr).PuppetTop=RectTopTempInt2=RectRight-RectLeftControlArray(PlacePtr).PuppetWidth=TempInt2TempInt2=RectBottom-RectTopControlArray(PlacePtr).PuppetHeight=TempInt2ControlArray(PlacePtr).PuppetForeColor=0ControlArray(PlacePtr).PuppetStatus=$07ControlNdx=PlacePtrGOSUB ControlArrayToToolBoxRETURNCreateToolBar:GOSUB FindEmptyControlSlotToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1		ControlArray(PlacePtr).PuppetName="ToolBar"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)ControlArray(PlacePtr).PuppetText="***"ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1GOSUB GetControlIDControlArray(PlacePtr).PuppetID=ControlIDControlArray(PlacePtr).PuppetArray=-1ControlArray(PlacePtr).PuppetType=23ControlArray(PlacePtr).PuppetOwner=1; Change to CurrentFormPtr laterinvoke CreateWindowEx,0,!ControlType16,NULL,$50000810,0,0,0,0, dword [!FormWindow],dword [TempInt],[!hinstance],0mov [TempHandle],eaxControlArray(PlacePtr).PuppetHandle=TempHandleControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetNameEventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetNameControlCombo.TEXT=ControlArray(PlacePtr).PuppetNameinvoke GetClientRect,[TempHandle],RectLeftControlArray(PlacePtr).PuppetLeft=0; TemporaryControlArray(PlacePtr).PuppetTop=0; TemporaryTempInt2=RectRight-RectLeftControlArray(PlacePtr).PuppetWidth=TempInt2TempInt2=RectBottom-RectTopControlArray(PlacePtr).PuppetHeight=TempInt2ControlArray(PlacePtr).PuppetForeColor=0ControlArray(PlacePtr).PuppetStatus=$07ControlNdx=PlacePtrGOSUB ControlArrayToToolBoxRETURNFindEmptyControlSlot:FOR PlacePtr=1 TO LastControl+1	IF ControlArray(PlacePtr).PuppetHandle=0 THEN		IF PlacePtr>LastControl THEN			INCR LastControl		END IF		IF LastControl>ControlTableSize THEN			LastControl=ControlTableSize			ControlNdx=0		END IF		RETURN	END IFNEXT PlacePtrPlacePtr=0RETURNFormWindow.MOVEControlPtr=1GetWindowRect FormWindowControlArray(ControlPtr).PuppetLeft=RectLeftControlArray(ControlPtr).PuppetTop=RectTopControlCombo.TEXT=FormCombo.TEXTControlNdx=ControlPtrGOSUB ControlArrayToToolBoxGOSUB PaintGridGOSUB RedrawPartsEND EVENTFormWindow.RESIZEControlPtr=1GetWindowRect FormWindowControlArray(ControlPtr).PuppetWidth=RectRight-RectLeftControlArray(ControlPtr).PuppetHeight=RectBottom-RectTopControlCombo.TEXT=FormCombo.TEXTControlNdx=ControlPtrGOSUB ControlArrayToToolBoxGOSUB PaintGridGOSUB RedrawPartsEND EVENTCleanControl:ControlArray(ControlPtr).PuppetHandle=0ControlArray(ControlPtr).PuppetID=0ControlArray(ControlPtr).PuppetOwner=0ControlArray(ControlPtr).PuppetArray=-1ControlArray(ControlPtr).PuppetLeft=0ControlArray(ControlPtr).PuppetTop=0ControlArray(ControlPtr).PuppetWidth=0ControlArray(ControlPtr).PuppetHeight=0ControlArray(ControlPtr).PuppetBackColor=0ControlArray(ControlPtr).PuppetForeColor=0ControlArray(ControlPtr).PuppetType=0ControlArray(ControlPtr).PuppetStatus=0ControlArray(ControlPtr).PuppetFont=0ControlArray(ControlPtr).PuppetOwnerParent=0ControlArray(ControlPtr).PuppethwndCombo=0ControlArray(ControlPtr).PuppethwndItem=0ControlArray(ControlPtr).PuppethwndList=0ControlArray(ControlPtr).PuppetIcon=0ControlArray(ControlPtr).PuppetStyle=0ControlArray(ControlPtr).PuppetText=""ControlArray(ControlPtr).PuppetName=""RETURNControlArrayToToolBox:PropGrid.TEXT(1,2)=ControlArray(ControlNdx).PuppetNameIF ControlArray(ControlNdx).PuppetOwner=0 THEN	PropGrid.TEXT(2,2)="None"ELSE	PropGrid.TEXT(2,2)=ControlArray(ControlArray(ControlNdx).PuppetOwner).PuppetNameEND IFIF ControlArray(ControlNdx).PuppetArray<1 THEN	PropGrid.TEXT(3,2)="***"ELSE	PropGrid.TEXT(3,2)=STR(ControlArray(ControlNdx).PuppetArray)END IFIF BITTST(ControlArray(ControlNdx).PuppetStatus,WinVisible)=TRUE THEN	PropGrid.TEXT(4,2)="TRUE"ELSE	PropGrid.TEXT(4,2)="FALSE"END IFIF BITTST(ControlArray(ControlNdx).PuppetStatus,WinEnabled)=TRUE THEN	PropGrid.TEXT(5,2)="TRUE"ELSE	PropGrid.TEXT(5,2)="FALSE"END IFPropGrid.TEXT(6,2)=STR(ControlArray(ControlNdx).PuppetLeft)PropGrid.TEXT(7,2)=STR(ControlArray(ControlNdx).PuppetTop)PropGrid.TEXT(8,2)=STR(ControlArray(ControlNdx).PuppetWidth)PropGrid.TEXT(9,2)=STR(ControlArray(ControlNdx).PuppetHeight)TempStr="$"+HEX(ControlArray(ControlNdx).PuppetBackColor)PropGrid.TEXT(10,2)=TempStrTempStr="$"+HEX(ControlArray(ControlNdx).PuppetForeColor)PropGrid.TEXT(11,2)=TempStrPropGrid.TEXT(12,2)=ControlArray(ControlNdx).PuppetTextPropGrid.TEXT(14,2)=ControlArray(ControlNdx).PuppetImageRETURNControlArrayToControl:RETURNPropGrid.BUTTONCLICKSELECT CASE GridRow	TempHandle=ControlArray(ControlPtr).PuppetHandle	CASE 4; Visible		TempStr=PropGrid.TEXT(GridRow,2)		IF RIGHT$(TempStr,4)="TRUE" THEN			PropGrid.TEXT(GridRow,2)="FALSE"			ControlArray(ControlPtr).PuppetStatus=BITCLR(ControlArray(ControlPtr).PuppetStatus,WinVisible)			invoke ShowWindow, dword [TempHandle],SW_HIDE		ELSE			PropGrid.TEXT(GridRow,2)="TRUE"			ControlArray(ControlPtr).PuppetStatus=BITSET(ControlArray(ControlPtr).PuppetStatus,WinVisible)			invoke ShowWindow, dword [TempHandle],SW_SHOW		END IF	CASE 5; Enabled		TempStr=PropGrid.TEXT(GridRow,2)		IF RIGHT$(TempStr,4)="TRUE" THEN			PropGrid.TEXT(GridRow,2)="FALSE"			ControlArray(ControlPtr).PuppetStatus=BITCLR(ControlArray(ControlPtr).PuppetStatus,WinEnabled)			invoke EnableWindow, dword [TempHandle],FALSE			ELSE			PropGrid.TEXT(GridRow,2)="TRUE"			ControlArray(ControlPtr).PuppetStatus=BITSET(ControlArray(ControlPtr).PuppetStatus,WinEnabled)			invoke EnableWindow, dword [TempHandle],TRUE		END IF	CASE 10; BackColor		IF PropValidTable(10)=FALSE THEN			RETURN		END IF		CaptureEnable=FALSE		COLORDIALOG RGB		IF RGB<>$ffffffff THEN			GOSUB SetBackColor		END IF		CaptureEnable=TRUE	CASE 11; ForeColor		IF PropValidTable(11)=FALSE THEN			RETURN		END IF		CaptureEnable=FALSE		COLORDIALOG RGB		IF RGB<>$ffffffff THEN			GOSUB SetForeColor		END IF		CaptureEnable=TRUE	CASE 14; BITMAP		IF PropValidTable(14)=FALSE THEN			RETURN		END IF		CaptureEnable=FALSE		BMPInitDir="C:\"		BMPFileFilter="Bitmap",0,"*.bmp",0,"JPG",0,"*.jpg",0,"GIF",0,"*.gif",0,"WMF",0,"*.wmf",0,0		OPENDIALOG BMPFileName,BMPFileFilter,BMPInitDir 		IF STATUS<>0 THEN			LOADIMAGE ToolBitmap,BMPFileName			invoke SendMessage, dword [TempHandle],STM_SETIMAGE,IMAGE_BITMAP,eax			PropGrid.TEXT(14,2)=BMPFileName			ControlArray(ControlPtr).PuppetImage=BMPFileName		END IF		CaptureEnable=TRUEEND SELECTEND EVENTStyleGrid.CHECKCLICKTempStr=StyleGrid.TEXT(GridRow,3)TempStr=RIGHT(TempStr,9)IF StyleGrid.VALUE(GridRow,2)=0 THEN	ControlArray(ControlPtr).PuppetStyle=ControlArray(ControlPtr).PuppetStyle+VAL(TempStr)ELSE	ControlArray(ControlPtr).PuppetStyle=ControlArray(ControlPtr).PuppetStyle-VAL(TempStr)END IFTempInt=ControlArray(ControlPtr).PuppetStyleIF ControlArray(ControlPtr).PuppetType=1 THEN; Form	RETURN	END IFTempHandle=ControlArray(ControlPtr).PuppetHandleinvoke SetWindowLong, dword [TempHandle],GWL_STYLE,[TempInt]invoke InvalidateRect, dword [TempHandle],NULL,TRUEEND EVENTExStyleGrid.CHECKCLICKTempStr=ExStyleGrid.TEXT(GridRow,3)TempStr=RIGHT(TempStr,9)IF ExStyleGrid.VALUE(GridRow,2)=0 THEN	ControlArray(ControlPtr).PuppetExStyle=ControlArray(ControlPtr).PuppetExStyle+VAL(TempStr)ELSE	ControlArray(ControlPtr).PuppetExStyle=ControlArray(ControlPtr).PuppetExStyle-VAL(TempStr)END IFEND EVENTStyleGrid.HEADERCLICKIF GridCol=1 THEN	StyleGrid.VISIBLE=FALSE	ExStyleGrid.VISIBLE=TRUEEND IFEND EVENTExStyleGrid.HEADERCLICKIF GridCol=1 THEN	ExStyleGrid.VISIBLE=FALSE	StyleGrid.VISIBLE=TRUEEND IFEND EVENTPropGrid.BEFOREEDITIF GridCol=2 THEN	; Need to check here if form or control ***********************	TempHandle=ControlArray(ControlPtr).PuppetHandle	SELECT CASE GridRow		CASE 1			ControlName=PropGrid.text(1,2)			ControlNameSafe=ControlArray(ControlPtr).PuppetName			IF ControlName=ControlNameSafe THEN				RETURN			END IF			GOSUB FindControlByName			IF ControlFound=TRUE THEN				PropGrid.text(1,2)=ControlName			END IF			ControlArray(ControlPtr).PuppetName=ControlName			ControlCombo.REPLACEITEM ControlNameSafe,ControlName			ControlCombo.TEXT=ControlName			EventCombo1.REPLACEITEM ControlNameSafe,ControlName		CASE 2			TempStr=PropGrid.text(2,2)		CASE 3			TempStr=PropGrid.text(3,2)		CASE 4			TempStr=PropGrid.text(4,2)		CASE 5			TempStr=PropGrid.text(5,2)		CASE 6			GOSUB UpdatePosition		CASE 7			GOSUB UpdatePosition		CASE 8			GOSUB UpdatePosition		CASE 9			GOSUB UpdatePosition		CASE 10			TempStr=PropGrid.text(10,2)			RGB=VAL(TempStr)			GOSUB SetBackColor		CASE 11			TempStr=PropGrid.text(11,2)			RGB=VAL(TempStr)			GOSUB SetForeColor		CASE 12			TempStr=PropGrid.text(12,2)			ControlArray(ControlPtr).PuppetText=TempStr			IF ControlArray(ControlPtr).PuppetType=1 THEN; Form				FormWindow.TEXT=TempStr			ELSE				invoke SendMessage,[TempHandle],WM_SETTEXT,0,[TempStr]			END IF		CASE 13			TempStr=PropGrid.text(13,2)		CASE 14			TempStr=PropGrid.text(14,2)		END SELECTEND IFgosub refresh_commandEND EVENTSetBackColor:TempStr="$"+HEX(RGB)PropGrid.TEXT(10,2)=TempStrIF ControlArray(ControlPtr).PuppetType=1 THEN; Form	ControlArray(1).PuppetBackColor=VAL(TempStr)	FormWindow.BACKCOLOR=RGBELSE	ControlArray(ControlPtr).PuppetBackColor=RGB	IF ControlArray(ControlPtr).PuppetType=21 THEN; RAGrid		TempInt=ControlArray(ControlPtr).PuppetBackColor		invoke SendMessage, dword [TempHandle],GM_SETBACKCOLOR,[TempInt],0	ELSE		IF ControlArray(ControlPtr).PuppetType=20 THEN; RAEdit			;invoke SendMessage, dword [TempHandle],REM_SETCOLOR,0,!RA_BCKCOLOR		ELSE			IF ControlArray(ControlPtr).PuppetType>=4 AND ControlArray(ControlPtr).PuppetType<=11 THEN				TempInt=ControlArray(ControlPtr).PuppetStatus				ControlArray(ControlPtr).PuppetStatus=BITSET(TempInt,WinChangeBackColor)				invoke InvalidateRect, dword [TempHandle],NULL,TRUE			END IF		END IF	END IFEND IFGOSUB ScreenRefreshRETURNSetForeColor:TempStr="$"+HEX(RGB)PropGrid.TEXT(11,2)=TempStrControlArray(ControlPtr).PuppetForeColor=RGBIF ControlArray(ControlPtr).PuppetType=21 THEN; RAGrid	TempInt=ControlArray(ControlPtr).PuppetBackColor	invoke SendMessage, dword [TempHandle],GM_SETTEXTCOLOR,[TempInt],0ELSE	IF ControlArray(ControlPtr).PuppetType>=4 AND ControlArray(ControlPtr).PuppetType<=11 THEN		TempInt=ControlArray(ControlPtr).PuppetStatus		ControlArray(ControlPtr).PuppetStatus=BITSET(TempInt,WinChangeForeColor)		invoke InvalidateRect, dword [TempHandle],NULL,TRUE	END IFEND IFGOSUB ScreenRefreshRETURNUpdatePosition:TempStr=PropGrid.text(6,2)TempLeft=VAL(TempStr)ControlArray(ControlPtr).PuppetLeft=TempLeftTempStr=PropGrid.text(7,2)TempTop=VAL(TempStr)ControlArray(ControlPtr).PuppetTop=TempTopTempStr=PropGrid.text(8,2)TempWidth=VAL(TempStr)ControlArray(ControlPtr).PuppetWidth=TempWidthTempStr=PropGrid.text(9,2)IF ControlArray(ControlPtr).PuppetType=8 THEN	TempHeight=25ELSE	TempHeight=VAL(TempStr)	ControlArray(ControlPtr).PuppetHeight=TempHeightEND IFIF ControlArray(ControlPtr).PuppetType=1 THEN; Form	SETPOSITION FormWindow,TempLeft,TempTop,TempWidth,TempHeightELSE	TempHandle=ControlArray(ControlPtr).PuppetHandle	invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[TempWidth],[TempHeight],4END IFGOSUB PlaceSpiderGOSUB PaintGridGOSUB RedrawPartsgosub refresh_commandRETURNToolBox.SYSTEM;IF STATUS=$f060 THEN;	ToolBox.VISIBLE=FALSE;END IFIF STATUS=$f030 THEN	IF MinMaxFlag=FALSE THEN		GOSUB MakeMax	ELSE		GOSUB MakeMin	END IFEND IFMinMaxFlag=NOT(MinMaxFlag)END EVENTMakeMax:SETPOSITION ToolBox,3,85,300,631SETPOSITION FormCombo,0,184,235,160SETPOSITION ControlCombo,0,210,235,160;ToolBox.HEIGHT=605;FormCombo.TOP=184;MinMax.TOP=184FOR I=1 TO 30	ToolButton(I).VISIBLE=TRUENEXT IRETURNMakeMin:SETPOSITION ToolBox,3,85,300,77SETPOSITION FormCombo,0,0,245,160SETPOSITION ControlCombo,0,26,290,160;ToolBox.HEIGHT=50;FormCombo.TOP=0;MinMax.TOP=0FOR I=1 TO 30	ToolButton(I).VISIBLE=FALSENEXT IRETURNEventCombo1.SELECTEventCombo2.ENABLED=TRUEControlName=EventCombo1.SELTEXTGOSUB FindControlByNameTempInt=ControlArray(ControlNdx).PuppetTypeEventCombo2.CLEAREventCombo2.TEXT="Select Event"SETVEC EventArray=[ToolPropMap(TempInt).PropMapEventTable]I=0BEGIN LOOP	INCR I	EXIT IF EventArray(I).EVType="%"	TempStr=EventArray(I).EVType	EventCombo2.ADDITEMSORTED TempStrEND LOOPEND EVENTControlCombo.SELECTControlName=ControlCombo.SELTEXTGOSUB ControlComboActionEND EVENTFormCombo.SELECTControlName=FormCombo.SELTEXTIF ControlName<>CurrentFormName THEN	GOSUB HideObjects	ControlCombo.TEXT=ControlName	ControlCombo.ADDITEM ControlName	CurrentFormName=ControlName	GOSUB FindFormByName	GOSUB ShowObjectsEND IFEND EVENTFindFormByName:FOR ControlNdx=1 TO LastControl	IF ControlArray(ControlNdx).PuppetName=ControlName THEN		CurrentFormPtr=ControlNdx		RETURN	END IFNEXT ControlNdxRETURNControlComboAction:GOSUB FindControlByNameControlPtrSafe=ControlPtrControlPtr=ControlNdxGOSUB GetPuppetPositionToolButtonNdx=ControlArray(ControlPtr).PuppetTypeGOSUB PopulateToolBoxGOSUB ControlArrayToToolBoxGOSUB SetSpiderGOSUB RedrawPartsgosub refresh_commandRETURNPlaceSpider:ControlNdx=ControlPtrGOSUB GetPuppetPositionFOR I=2 TO 9	Spider(I).VISIBLE=FALSENEXT IGOSUB SetSpiderRETURNSetSpider:IF ControlNdx>1 THEN	SETPOSITION Spider(Belly),TempLeft,TempTop,TempWidth,TempHeight	SETPOSITION Spider(NW),TempLeft-6,TempTop-6,6,6	SETPOSITION Spider(N),TempLeft+TempWidth/2-3,TempTop-6,6,6	SETPOSITION Spider(NE),TempLeft+TempWidth,TempTop-6,6,6	SETPOSITION Spider(W),TempLeft-6,TempTop+TempHeight/2-3,6,6	SETPOSITION Spider(E),TempLeft+TempWidth,TempTop+TempHeight/2-3,6,6	SETPOSITION Spider(SW),TempLeft-6,TempTop+TempHeight,6,6	SETPOSITION Spider(S),TempLeft+TempWidth/2-3,TempTop+TempHeight,6,6	SETPOSITION Spider(SE),TempLeft+TempWidth,TempTop+TempHeight,6,6	GOSUB ShowSpiderLegs	SpiderPlaced=TRUEELSE	GOSUB HideSpiderLegs	SpiderPlaced=FALSEEND IFRETURNPlaceSpiderLegs:SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeightSETPOSITION Spider(NW),SpiderLeft-6,SpiderTop-6,6,6SETPOSITION Spider(N),SpiderLeft+SpiderWidth/2-3,SpiderTop-6,6,6SETPOSITION Spider(NE),SpiderLeft+SpiderWidth,SpiderTop-6,6,6SETPOSITION Spider(W),SpiderLeft-6,SpiderTop+SpiderHeight/2-3,6,6SETPOSITION Spider(E),SpiderLeft+SpiderWidth,SpiderTop+SpiderHeight/2-3,6,6SETPOSITION Spider(SW),SpiderLeft-6,SpiderTop+SpiderHeight,6,6SETPOSITION Spider(S),SpiderLeft+SpiderWidth/2-3,SpiderTop+SpiderHeight,6,6SETPOSITION Spider(SE),SpiderLeft+SpiderWidth,SpiderTop+SpiderHeight,6,6GOSUB ShowSpiderLegsSpiderPlaced=TRUERETURNHideSpider:Spider(Belly).VISIBLE=FALSEGOSUB HideSpiderLegsSpiderPlaced=FALSERETURNHideSpiderLegs:FOR I=2 TO 9	Spider(I).VISIBLE=FALSENEXT IRETURNShowSpiderLegs:FOR I=2 TO 9	Spider(I).VISIBLE=TRUENEXT IRETURNGetPuppetPosition:TempLeft=ControlArray(ControlNdx).PuppetLeftTempTop=ControlArray(ControlNdx).PuppetTopOwnerPtr=ControlArray(ControlNdx).PuppetOwnerIF ControlArray(OwnerPtr).PuppetType<>1 THEN	TempInt=ControlArray(OwnerPtr).PuppetLeft	TempLeft=TempLeft+TempInt	TempInt=ControlArray(OwnerPtr).PuppetTop	TempTop=TempTop+TempIntEND IF		TempWidth=ControlArray(ControlNdx).PuppetWidthIF ControlArray(ControlNdx).PuppetType=8 THEN; ComboBox	TempHeight=25ELSE	TempHeight=ControlArray(ControlNdx).PuppetHeightEND IFRETURNFindControlByName:FOR ControlNdx=1 TO LastControl	IF ControlArray(ControlNdx).PuppetName=ControlName THEN		ControlFound=TRUE		GOSUB ControlArrayToToolBox		RETURN	END IFNEXT ControlNdxControlFound=FALSERETURNrefresh.commandcontrolndx.text=str(ControlNdx)controlptr.text=str(ControlPtr)controlcount.text=str(ControlCount)controlname.text=ControlNamecontrolptrsafe.text=str(ControlPtrSafe)grid.gridclearfor I=1 to LastControl	grid.addrow	grid.value(I,1)=I	grid.value(I,2)=ControlArray(I).PuppetHandle	grid.value(I,3)=ControlArray(I).PuppetID	grid.value(I,4)=ControlArray(I).PuppetOwner	grid.value(I,5)=ControlArray(I).PuppetArray	grid.value(I,6)=ControlArray(I).PuppetLeft	grid.value(I,7)=ControlArray(I).PuppetTop	grid.value(I,8)=ControlArray(I).PuppetWidth	grid.value(I,9)=ControlArray(I).PuppetHeight	grid.value(I,10)=ControlArray(I).PuppetBackColor	grid.value(I,11)=ControlArray(I).PuppetForeColor	grid.value(I,12)=ControlArray(I).PuppetType	grid.value(I,13)=ControlArray(I).PuppetStatus	grid.value(I,14)=ControlArray(I).PuppetFont	grid.value(I,15)=ControlArray(I).PuppetIcon	grid.text(I,16)=ControlArray(I).PuppetText	grid.text(I,17)=ControlArray(I).PuppetNamenext Iend eventPaintGrid:IF ShowGrid=TRUE THEN	I=-GridSize	J=0	GETCLIENTRECT FormWindow	GETDC FormWindow	BEGIN LOOP		I=I+GridSize		IF I>=RectRight THEN			I=0			J=J+GridSize			IF J>=RectBottom THEN				RELEASEDC FormWindow				RETURN			END IF		END IF		SETPIXEL FormWindow,I,J,GridColor	END LOOPEND IFRETURNRedrawParts:FOR I=2 TO LastControl	IF ControlArray(I).PuppetHandle<>0 THEN		TempHandle=ControlArray(I).PuppetHandle		invoke InvalidateRect, dword [TempHandle],NULL,TRUE	END IFNEXT IRETURNSetSnap:TempInt=MOD(SpiderLeft,GridSize)IF TempInt<>0 THEN	IF TempInt<GridSize/2 THEN		SpiderLeft=SpiderLeft-TempInt	ELSE		TempInt=GridSize-TempInt		SpiderLeft=SpiderLeft+TempInt	END IFEND IFTempInt=MOD(SpiderTop,GridSize)IF TempInt<>0 THEN	IF TempInt<GridSize/2 THEN		SpiderTop=SpiderTop-TempInt	ELSE		TempInt=GridSize-TempInt		SpiderTop=SpiderTop+TempInt	END IFEND IFTempInt=MOD(SpiderWidth,GridSize)IF TempInt<>0 THEN	IF TempInt<GridSize/2 THEN		SpiderWidth=SpiderWidth-TempInt	ELSE		TempInt=GridSize-TempInt		SpiderWidth=SpiderWidth+TempInt	END IFEND IFTempInt=MOD(SpiderHeight,GridSize)IF TempInt<>0 THEN	IF TempInt<GridSize/2 THEN		SpiderHeight=SpiderHeight-TempInt	ELSE		TempInt=GridSize-TempInt		SpiderHeight=SpiderHeight+TempInt	END IFEND IFRETURNSetGridSize:GridSize=TempIntGOSUB PaintGridGOSUB RedrawPartsRETURNUnCheckGridSize:CHECKMENUITEM GridSizePopUp,gsmnu5,FALSECHECKMENUITEM GridSizePopUp,gsmnu10,FALSECHECKMENUITEM GridSizePopUp,gsmnu15,FALSECHECKMENUITEM GridSizePopUp,gsmnu20,FALSECHECKMENUITEM GridSizePopUp,gsmnu25,FALSECHECKMENUITEM GridSizePopUp,gsmnu30,FALSECHECKMENUITEM GridSizePopUp,gsmnu35,FALSECHECKMENUITEM GridSizePopUp,gsmnu40,FALSECHECKMENUITEM GridSizePopUp,gsmnu45,FALSECHECKMENUITEM GridSizePopUp,gsmnu50,FALSERETURNUnCheckGridColor:CHECKMENUITEM GridColorPopUp,gcmnuBlack,FALSECHECKMENUITEM GridColorPopUp,gcmnuWhite,FALSECHECKMENUITEM GridColorPopUp,gcmnuRed,FALSECHECKMENUITEM GridColorPopUp,gcmnuGreen,FALSECHECKMENUITEM GridColorPopUp,gcmnuBlue,FALSECHECKMENUITEM GridColorPopUp,gcmnuYellow,FALSECHECKMENUITEM GridColorPopUp,gcmnuMagenta,FALSECHECKMENUITEM GridColorPopUp,gcmnuDkRed,FALSECHECKMENUITEM GridColorPopUp,gcmnuDkGreen,FALSECHECKMENUITEM GridColorPopUp,gcmnuDkBlue,FALSERETURNUnCheckGripColor:CHECKMENUITEM GripColorPopUp,gpcmnuBlack,FALSECHECKMENUITEM GripColorPopUp,gpcmnuWhite,FALSECHECKMENUITEM GripColorPopUp,gpcmnuRed,FALSECHECKMENUITEM GripColorPopUp,gpcmnuGreen,FALSECHECKMENUITEM GripColorPopUp,gpcmnuBlue,FALSECHECKMENUITEM GripColorPopUp,gpcmnuYellow,FALSECHECKMENUITEM GripColorPopUp,gpcmnuMagenta,FALSECHECKMENUITEM GripColorPopUp,gpcmnuDkRed,FALSECHECKMENUITEM GripColorPopUp,gpcmnuDkGreen,FALSECHECKMENUITEM GripColorPopUp,gpcmnuDkBlue,FALSERETURNSetGridColor:GridColor=TempIntGOSUB PaintGridGOSUB RedrawPartsRETURNSetGripColor:FOR I=2 TO 9	Spider(I).BACKCOLOR=TempIntNEXT IRETURNNudgePosButton.COMMANDEND EVENTNudgeSizeButton.COMMANDEND EVENTGetControlID:FOR I=1 TO ControlTableSize	IF PuppetIDDispenser(I)=FALSE THEN		PuppetIDDispenser(I)=TRUE		ControlID=I+100		RETURN		END IFNEXT IControlID=0RETURNHideObjects:ControlCombo.ClearGOSUB HideSpiderFOR ControlNdx=2 TO LastControl	IF ControlArray(ControlNdx).PuppetOwner=CurrentFormPtr OR ControlArray(ControlNdx).PuppetOwnerParent=CurrentFormPtr THEN		TempHandle=ControlArray(ControlNdx).PuppetHandle		invoke ShowWindow, dword [TempHandle],SW_HIDE	END IFNEXT ControlNdxRETURNShowObjects:GOSUB HideSpiderFOR ControlNdx=2 TO LastControl	IF ControlArray(ControlNdx).PuppetOwner=CurrentFormPtr OR ControlArray(ControlNdx).PuppetOwnerParent=CurrentFormPtr THEN		TempHandle=ControlArray(ControlNdx).PuppetHandle		TempStr=ControlArray(ControlNdx).PuppetName		ControlCombo.ADDITEM TempStr		IF BITTST(ControlArray(ControlPtr).PuppetStatus,WinVisible)=TRUE THEN			invoke ShowWindow, dword [TempHandle],SW_SHOW		END IF	END IFNEXT ControlNdxRETURNScratchPadWindow.RESIZEGETCLIENTRECT ScratchPadWindowSETPOSITION ScratchPadText,RectLeft,RectTop,RectRight-RectLeft,RectBottom-RectTopEND EVENT;OBMain.PAINT;mov eax,[wparam];mov [TempInt],eax;IF FormWindow.HDC=TempInt THEN;	GOSUB PaintGrid;END IF;END EVENT