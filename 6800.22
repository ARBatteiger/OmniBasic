DIM ImmFlag AS BOOLEANDIM PCRegSet AS BOOLEANDIM RunFlag AS BOOLEANDIM StepFlag AS BOOLEANDIM TargetMem(65536) AS BYTEDIM I AS LONGDIM CycleCtr AS LONGDIM TempInt AS LONGDIM TempByte AS BYTEDIM TempStr AS STRING*256DIM TempStr2 AS STRING*256DIM TempHexData AS STRING*256DIM HexData AS STRING*256DIM TempLabel AS LABELDIM BinFile AS FILEDIM InstReg AS BYTEDIM OperandReg AS LONGDIM KeyReg AS BYTEDIM ScanReg AS BYTEDIM StoreData AS BYTEDIM IFlag AS BOOLEANDIM NFlag AS BOOLEANDIM ZFlag AS BOOLEANDIM VFlag AS BOOLEANDIM CFlag AS BOOLEANDIM SymFlag AS BOOLEANDIM PwrFlag AS BOOLEANDIM Vial AS BOOLEANDIM DacBtFlag AS BOOLEANDIM DataRdyFlag AS BOOLEANDIM PrevInst AS STRING*256DIM TraceAddr AS STRING*5DIM Symbolic AS STRING*32DIM SymTableSize AS LONGDIM SymFound AS BOOLEANDIM IOFlag AS BOOLEANDIM IOCode AS BYTEDIM CPUBackground AS RECTANGLEDIM ResetButton AS BUTTONDIM RunButton AS BUTTONDIM StepButton AS BUTTONDIM LoadButton AS BUTTONDIM AddrReg AS LONGDIM AddrRegDisplay AS TEXTBOXDIM AddrRegLabel AS STATICTEXTDIM DecAddr AS BUTTONDIM IncAddr AS BUTTONDIM DataReg AS BYTEDIM DataRegDisplay AS TEXTBOXDIM DataRegLabel AS STATICTEXTDIM SetData AS BUTTONDIM PCReg AS LONGDIM PCRegDisplay AS TEXTBOXDIM PCRegLabel AS STATICTEXTDIM SetPCReg AS BUTTONDIM SPReg AS LONGDIM SPRegDisplay AS TEXTBOXDIM SPRegLabel AS STATICTEXTDIM SetSPReg AS BUTTONDIM IndexReg AS LONGDIM IndexRegDisplay AS TEXTBOXDIM IndexRegLabel AS STATICTEXTDIM SetIndexReg AS BUTTONDIM AccA AS BYTEDIM AccADisplay AS TEXTBOXDIM AccALabel AS STATICTEXTDIM SetAccA AS BUTTONDIM AccB AS BYTEDIM AccBDisplay AS TEXTBOXDIM AccBLabel AS STATICTEXTDIM SetAccB AS BUTTONDIM CCReg AS BYTEDIM BPReg AS LONGDIM BPRegDisplay AS TEXTBOXDIM BPRegLabel AS STATICTEXTDIM SetBPReg AS BUTTONDIM IRQButton AS BUTTONDIM NMIButton AS BUTTONDIM NextInst AS STATICTEXTDIM TimerFlag AS BOOLEANDIM TimerLight AS STATICTEXTDIM ILight AS STATICTEXTDIM NLight AS STATICTEXTDIM ZLight AS STATICTEXTDIM VLight AS STATICTEXTDIM CLight AS STATICTEXTDIM SymLight AS STATICTEXTDIM RunLight AS STATICTEXTDIM RamLight AS RECTANGLEDIM RomLight AS RECTANGLEDIM IOLight AS RECTANGLEDIM KbdBackground AS RECTANGLEDIM Line1 AS RECTANGLEDIM Line2 AS RECTANGLEDIM Key(16) AS BUTTONDIM PrinterBackground AS RECTANGLEDIM PrinterList AS LISTBOXDIM TearButton AS BUTTONDIM PwrSwitch AS STATICTEXTDIM IOBackground AS RECTANGLEDIM AtoD AS TEXTBOXDIM AtoDLabel AS RECTANGLEDIM Ref AS TEXTBOXDIM RefLabel AS RECTANGLEDIM Sig AS TEXTBOXDIM SigLabel AS RECTANGLEDIM Gnd AS TEXTBOXDIM GndLabel AS RECTANGLEDIM LampInt AS TEXTBOXDIM LampIntLabel AS RECTANGLEDIM Switch  AS STATICTEXTDIM Mux AS TEXTBOXDIM MuxLabel AS RECTANGLEDIM DtoAHi AS TEXTBOXDIM DtoAHiReg AS LONGDIM DtoAHiLabel AS RECTANGLEDIM DtoALo AS TEXTBOXDIM DtoALoReg AS LONGDIM DtoALoLabel AS RECTANGLEDIM ControlRegDisplay AS TEXTBOXDIM ControlReg AS LONGDIM ControlRegLabel AS RECTANGLEDIM StatusRegDisplay AS TEXTBOXDIM StatusReg AS LONGDIM StatusRegLabel AS RECTANGLEDIM GAX AS RECTANGLEDIM GBX AS RECTANGLEDIM GCX AS RECTANGLEDIM GainLabel AS RECTANGLEDIM DataRdy AS STATICTEXTDIM DacBt AS STATICTEXTDIM RunBit AS RECTANGLEDIM TestBit AS RECTANGLEDIM StartBit AS RECTANGLEDIM KeyDisplay AS TEXTBOXDIM KeyLabel AS RECTANGLEDIM ScanDisplay AS TEXTBOXDIM ScanLabel AS RECTANGLEDIM TraceBackground AS RECTANGLEDIM TraceList AS LISTBOXDIM TraceClear AS BUTTONDIM SymBackground AS RECTANGLEDIM SymList1 AS LISTBOXDIM SymList2 AS LISTBOXENUM 0 LdaaCode LdabCode StaaCode StabCodeEND ENUMENUM 0 TRAPMODE INHERENTMODE IMM1MODE IMM2MODE DIRECTMODE INDEXEDMODE EXTENDEDMODE RELATIVEMODEEND ENUMTYPE SymData	SymAddr AS LONG	SymName AS STRING*32END TYPETABLE SymTable AS SymData $0ed2,"LampErr" $d04d,"Init1" $d086,"Init2" $d052,"BlkMov1" $d058,"MovLop1" $d08c,"MovLop2" $d0a2,"MovLop3"END TABLETYPE OpCodeData	OpInstDispatch AS LABEL	OpModeDispatch AS LABEL	OpMode AS LONG	OpName AS STRING*8END TYPETABLE OpCode AS OpCodeData TrapX,TrapX,TRAPMODE,"Trap" NopX,InherentX,INHERENTMODE,"NOP" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TapX,InherentX,INHERENTMODE,"TAP" TpaX,InherentX,INHERENTMODE,"TPA" InxX,InherentX,INHERENTMODE,"INX" DexX,InherentX,INHERENTMODE,"DEX" ClvX,InherentX,INHERENTMODE,"CLV" SevX,InherentX,INHERENTMODE,"SEV" ClcX,InherentX,INHERENTMODE,"CLC" SecX,InherentX,INHERENTMODE,"SEC" CliX,InherentX,INHERENTMODE,"CLI" SeiX,InherentX,INHERENTMODE,"SEI" SbaX,InherentX,INHERENTMODE,"SBA" CbaX,InherentX,INHERENTMODE,"CBA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TabX,InherentX,INHERENTMODE,"TAB" TbaX,InherentX,INHERENTMODE,"TBA" TrapX,TrapX,TRAPMODE,"Trap" DaaX,InherentX,INHERENTMODE,"DAA" TrapX,TrapX,TRAPMODE,"Trap" AbaX,InherentX,INHERENTMODE,"ABA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" BraX,RelX,RELATIVEMODE,"BRA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" BlsX,RelX,RELATIVEMODE,"BLS" BccX,RelX,RELATIVEMODE,"BCC" BcsX,RelX,RELATIVEMODE,"BCS" BneX,RelX,RELATIVEMODE,"BNE" BeqX,RelX,RELATIVEMODE,"BEQ" BvcX,RelX,RELATIVEMODE,"BVC" BvsX,RelX,RELATIVEMODE,"BVS" BplX,RelX,RELATIVEMODE,"BPL" BmiX,RelX,RELATIVEMODE,"BMI" BgeX,RelX,RELATIVEMODE,"BGE" BltX,RelX,RELATIVEMODE,"BLT" BgtX,RelX,RELATIVEMODE,"BGT" BleX,RelX,RELATIVEMODE,"BLE" TsxX,InherentX,INHERENTMODE,"TSX" InsX,InherentX,INHERENTMODE,"INS" PulaX,InherentX,INHERENTMODE,"PULA" PulbX,InherentX,INHERENTMODE,"PULB" DesX,InherentX,INHERENTMODE,"DES" TxsX,InherentX,INHERENTMODE,"TSX" PshaX,InherentX,INHERENTMODE,"PSHA" PshbX,InherentX,INHERENTMODE,"PSHB" TrapX,TrapX,TRAPMODE,"Trap" RtsX,InherentX,INHERENTMODE,"RTS" TrapX,TrapX,TRAPMODE,"Trap" RtiX,InherentX,INHERENTMODE,"RTI" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" WaiX,InherentX,INHERENTMODE,"WAI" SwiX,InherentX,INHERENTMODE,"SWI" NegaX,InherentX,INHERENTMODE,"NEGA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComaX,InherentX,INHERENTMODE,"COMA" LsraX,InherentX,INHERENTMODE,"LSRA" TrapX,TrapX,TRAPMODE,"Trap" RoraX,InherentX,INHERENTMODE,"RORA" AsraX,InherentX,INHERENTMODE,"ASRA" AslaX,InherentX,INHERENTMODE,"ASLA" RolaX,InherentX,INHERENTMODE,"ROLA" DecaX,InherentX,INHERENTMODE,"DECA" TrapX,TrapX,TRAPMODE,"Trap" IncaX,InherentX,INHERENTMODE,"INCA" TstaX,InherentX,INHERENTMODE,"TSTA" TrapX,TrapX,TRAPMODE,"Trap" ClraX,InherentX,INHERENTMODE,"CLRA" NegbX,InherentX,INHERENTMODE,"NEGB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" CombX,InherentX,INHERENTMODE,"COMB" LsrbX,InherentX,INHERENTMODE,"LSRB" TrapX,TrapX,TRAPMODE,"Trap" RorbX,InherentX,INHERENTMODE,"RORB" AsrbX,InherentX,INHERENTMODE,"ASRB" AslbX,InherentX,INHERENTMODE,"ASLB" RolbX,InherentX,INHERENTMODE,"ROLB" DecbX,InherentX,INHERENTMODE,"DECB" TrapX,TrapX,TRAPMODE,"Trap" IncbX,InherentX,INHERENTMODE,"INCB" TstbX,InherentX,INHERENTMODE,"TSTB" TrapX,TrapX,TRAPMODE,"Trap" ClrbX,InherentX,INHERENTMODE,"CLRB" NegX,IndexX,INDEXEDMODE,"NEGB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComX,IndexX,INDEXEDMODE,"COM" LsrX,IndexX,INDEXEDMODE,"LSR" TrapX,TrapX,TRAPMODE,"Trap" RorX,IndexX,INDEXEDMODE,"ROR" AsrX,IndexX,INDEXEDMODE,"ASR" AslX,IndexX,INDEXEDMODE,"ASL" RolX,IndexX,INDEXEDMODE,"ROL" DecX,IndexX,INDEXEDMODE,"DEC" TrapX,TrapX,TRAPMODE,"Trap" IncX,IndexX,INDEXEDMODE,"INC" TstX,IndexX,INDEXEDMODE,"TST" JmpX,IndexX,INDEXEDMODE,"JMP" ClrX,IndexX,INDEXEDMODE,"CLR" NegX,ExtX,EXTENDEDMODE,"NEG" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComX,ExtX,EXTENDEDMODE,"COM" LsrX,ExtX,EXTENDEDMODE,"LSR" TrapX,TrapX,TRAPMODE,"Trap" RorX,ExtX,EXTENDEDMODE,"ROR" TrapX,TrapX,TRAPMODE,"Trap" AslX,ExtX,EXTENDEDMODE,"ASL" RolX,ExtX,EXTENDEDMODE,"ROL" DecX,ExtX,EXTENDEDMODE,"DEC" TrapX,TrapX,TRAPMODE,"Trap" IncX,ExtX,EXTENDEDMODE,"INC" TstX,ExtX,EXTENDEDMODE,"TST" JmpX,ExtX,EXTENDEDMODE,"JMP" ClrX,ExtX,EXTENDEDMODE,"CLR" SubaX,Imm1X,IMM1MODE,"SUBA" CmpaX,Imm1X,IMM1MODE,"CMPA" SbcaX,Imm1X,IMM1MODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,Imm1X,IMM1MODE,"ANDA" BitaX,Imm1X,IMM1MODE,"BITA" LdaaX,Imm1X,IMM1MODE,"LDAA" TrapX,TrapX,TRAPMODE,"Trap" EoraX,Imm1X,IMM1MODE,"EORA" AdcaX,Imm1X,IMM1MODE,"ADCA" OraaX,Imm1X,IMM1MODE,"ORAA" AddaX,Imm1X,IMM1MODE,"ADDA" CpxX,Imm2X,IMM2MODE,"CPX" BsrX,RelX,RELATIVEMODE,"BSR" LdsX,Imm2X,IMM2MODE,"LDS" TrapX,TrapX,TRAPMODE,"Trap" SubaX,DirX,DIRECTMODE,"SUBA" CmpaX,DirX,DIRECTMODE,"CMPA" SbcaX,DirX,DIRECTMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,DirX,DIRECTMODE,"ANDA" BitaX,DirX,DIRECTMODE,"BITA" LdaaX,DirX,DIRECTMODE,"LDAA" StaaX,DirX,DIRECTMODE,"STAA" EoraX,DirX,DIRECTMODE,"EORA" AdcaX,DirX,DIRECTMODE,"ADCA" OraaX,DirX,DIRECTMODE,"ORAA" AddaX,DirX,DIRECTMODE,"ADDA" CpxX,DirX,DIRECTMODE,"CPX" StsX,DirX,DIRECTMODE,"STS" LdsX,DirX,DIRECTMODE,"LDS" TrapX,TrapX,TRAPMODE,"Trap" SubaX,IndexX,INDEXEDMODE,"SUBA" CmpaX,IndexX,INDEXEDMODE,"CMPA" SbcaX,IndexX,INDEXEDMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,IndexX,INDEXEDMODE,"ANDA" BitaX,IndexX,INDEXEDMODE,"BITA" LdaaX,IndexX,INDEXEDMODE,"LDAA" StaaX,IndexX,INDEXEDMODE,"STAA" EoraX,IndexX,INDEXEDMODE,"EORA" AdcaX,IndexX,INDEXEDMODE,"ADCA" OraaX,IndexX,INDEXEDMODE,"ORAA" AddaX,IndexX,INDEXEDMODE,"ADDA" CpxX,IndexX,INDEXEDMODE,"CPX" JsrX,IndexX,INDEXEDMODE,"JSR" LdsX,IndexX,INDEXEDMODE,"LDS" StsX,IndexX,INDEXEDMODE,"STS" SubaX,ExtX,EXTENDEDMODE,"SUBA" CmpaX,ExtX,EXTENDEDMODE,"CMPX" SbcaX,ExtX,EXTENDEDMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,ExtX,EXTENDEDMODE,"ANDA" BitaX,ExtX,EXTENDEDMODE,"BITA" LdaaX,ExtX,EXTENDEDMODE,"LDAA" StaaX,ExtX,EXTENDEDMODE,"STAA" EoraX,ExtX,EXTENDEDMODE,"EORA" AdcaX,ExtX,EXTENDEDMODE,"ADCA" OraaX,ExtX,EXTENDEDMODE,"ORAA" AddaX,ExtX,EXTENDEDMODE,"ADDA" CpxX,ExtX,EXTENDEDMODE,"CPX" JsrX,ExtX,EXTENDEDMODE,"JSR" LdsX,ExtX,EXTENDEDMODE,"LDS" StsX,ExtX,EXTENDEDMODE,"STS" SubbX,Imm1X,IMM1MODE,"SUBB" CmpbX,Imm1X,IMM1MODE,"CMPB" SbcbX,Imm1X,IMM1MODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,Imm1X,IMM1MODE,"ANDB" BitbX,Imm1X,IMM1MODE,"BITB" LdabX,Imm1X,IMM1MODE,"LDAB" TrapX,TrapX,TRAPMODE,"Trap" EorbX,Imm1X,IMM1MODE,"EORB" AdcbX,Imm1X,IMM1MODE,"ADCB" OrabX,Imm1X,IMM1MODE,"ORAB" AddbX,Imm1X,IMM1MODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,Imm2X,IMM2MODE,"LDX" TrapX,TrapX,TRAPMODE,"Trap" SubbX,DirX,DIRECTMODE,"SUBB" CmpbX,DirX,DIRECTMODE,"CMPB" SbcbX,DirX,DIRECTMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,DirX,DIRECTMODE,"ANDB" BitbX,DirX,DIRECTMODE,"BITB" LdabX,DirX,DIRECTMODE,"LDAB" StabX,DirX,DIRECTMODE,"STAB" EorbX,DirX,DIRECTMODE,"EORB" AdcbX,DirX,DIRECTMODE,"ADCB" OrabX,DirX,DIRECTMODE,"ORAB" AddbX,DirX,DIRECTMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,DirX,DIRECTMODE,"LDX" StxX,DirX,DIRECTMODE,"STX" SubbX,IndexX,INDEXEDMODE,"SUBB" CmpbX,IndexX,INDEXEDMODE,"CMPB" SbcbX,IndexX,INDEXEDMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,IndexX,INDEXEDMODE,"ANDB" BitbX,IndexX,INDEXEDMODE,"BITB" LdabX,IndexX,INDEXEDMODE,"LDAB" StabX,IndexX,INDEXEDMODE,"STAB" EorbX,IndexX,INDEXEDMODE,"EORB" AdcbX,IndexX,INDEXEDMODE,"ADCB" OrabX,IndexX,INDEXEDMODE,"ORAB" AddbX,IndexX,INDEXEDMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,IndexX,INDEXEDMODE,"LDX" StxX,IndexX,INDEXEDMODE,"STX" SubbX,ExtX,EXTENDEDMODE,"SUBB" CmpbX,ExtX,EXTENDEDMODE,"CMPB" SbcbX,ExtX,EXTENDEDMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,ExtX,EXTENDEDMODE,"ANDB" BitbX,ExtX,EXTENDEDMODE,"BITB" LdabX,ExtX,EXTENDEDMODE,"LDAB" StabX,ExtX,EXTENDEDMODE,"STAB" EorbX,ExtX,EXTENDEDMODE,"EORB" AdcbX,ExtX,EXTENDEDMODE,"ADCB" OrabX,ExtX,EXTENDEDMODE,"ORAB" AddbX,ExtX,EXTENDEDMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,ExtX,EXTENDEDMODE,"LDX" StxX,ExtX,EXTENDEDMODE,"STX"END TABLEOBMain.createSETPOSITION OBMain,0,0,1024,740OBMain.TEXT="6800 Emulator"PCRegSet=FALSERunFlag=FALSEStepFlag=FALSEVial=FALSESymFlag=TRUEPwrFlag=TRUEControlReg=0StatusReg=$1dKeyReg=0ScanReg=0IndexReg=0BPReg=0AccA=0AccB=0SPReg=0BPReg=0Symbolic=""SymFound=FALSESymTableSize=TABLESIZE(SymTable)CONSTRUCT CPUBackground,5,280,280,400CPUBackground.BACKCOLOR=$ff0000CONSTRUCT ResetButton,10,650,60,20ResetButton.TEXT="RESET"CONSTRUCT RunButton,80,650,60,20RunButton.TEXT="RUN"CONSTRUCT StepButton,150,650,60,20StepButton.TEXT="STEP"CONSTRUCT LoadButton,220,650,60,20LoadButton.TEXT="LOAD"CONSTRUCT NextInst,10,620,270,20NextInst.BACKCOLOR=$ffffffCONSTRUCT DecAddr,120,580,15,20DecAddr.TEXT="<"CONSTRUCT IncAddr,135,580,15,20IncAddr.TEXT=">"CONSTRUCT AddrRegLabel,50,600,60,20CONSTRUCT AddrRegDisplay,50,580,60,20AddrRegLabel.TEXT="Addr"AddrRegLabel.BACKCOLOR=$ff0000AddrRegLabel.FORECOLOR=$ffffffCONSTRUCT IRQButton,170,580,60,20IRQButton.TEXT="IRQ"CONSTRUCT NMIButton,170,540,60,20NMIButton.TEXT="NMI"CONSTRUCT TimerLight,170,500,60,20TimerLight.BACKCOLOR=$80TimerLight.FORECOLOR=$ffffTimerLight.TEXT="TIMER"CONSTRUCT ILight,170,460,60,20ILight.BACKCOLOR=$80ILight.FORECOLOR=$ffffILight.TEXT="INT"CONSTRUCT NLight,170,420,60,20NLight.BACKCOLOR=$80NLight.FORECOLOR=$ffffNLight.TEXT="NEG"CONSTRUCT ZLight,170,380,60,20ZLight.BACKCOLOR=$80ZLight.FORECOLOR=$ffffZLight.TEXT="ZERO"CONSTRUCT VLight,170,340,60,20VLight.BACKCOLOR=$80VLight.FORECOLOR=$ffffVLight.TEXT="OVF"CONSTRUCT CLight,170,300,60,20CLight.BACKCOLOR=$80CLight.FORECOLOR=$ffffCLight.TEXT="CARRY"CONSTRUCT SymLight,245,460,30,20SymLight.BACKCOLOR=$ffSymLight.FORECOLOR=$ffffSymLight.TEXT="SYM"CONSTRUCT RunLight,245,300,30,20RunLight.BACKCOLOR=$80RunLight.FORECOLOR=$ffffRunLight.TEXT="RUN"CONSTRUCT RamLight,245,340,30,20RamLight.BACKCOLOR=$80RamLight.FORECOLOR=$ffffRamLight.TEXT="RAM"CONSTRUCT RomLight,245,380,30,20RomLight.BACKCOLOR=$80RomLight.FORECOLOR=$ffffRomLight.TEXT="ROM"CONSTRUCT IOLight,245,420,30,20IOLight.BACKCOLOR=$80IOLight.FORECOLOR=$ffffIOLight.TEXT="IO"CONSTRUCT DataRegLabel,50,560,60,20CONSTRUCT DataRegDisplay,50,540,60,20DataRegLabel.TEXT="Data"DataRegLabel.BACKCOLOR=$ff0000DataRegLabel.FORECOLOR=$ffffffCONSTRUCT SetData,120,540,30,20SetData.TEXT="Set"CONSTRUCT PCRegLabel,50,520,60,20CONSTRUCT PCRegDisplay,50,500,60,20PCRegLabel.TEXT="Pgm Ctr"PCRegLabel.BACKCOLOR=$ff0000PCRegLabel.FORECOLOR=$ffffffCONSTRUCT SetPCReg,120,500,30,20SetPCReg.TEXT="Set"CONSTRUCT IndexRegLabel,50,480,60,20CONSTRUCT IndexRegDisplay,50,460,60,20IndexRegLabel.TEXT="Ndx Reg"IndexRegLabel.BACKCOLOR=$ff0000IndexRegLabel.FORECOLOR=$ffffffCONSTRUCT SetIndexReg,120,460,30,20SetIndexReg.TEXT="Set"CONSTRUCT AccALabel,50,440,60,20CONSTRUCT AccADisplay,50,420,60,20AccALabel.TEXT="Acc A"AccALabel.BACKCOLOR=$ff0000AccALabel.FORECOLOR=$ffffffCONSTRUCT SetAccA,120,420,30,20SetAccA.TEXT="Set"CONSTRUCT AccBLabel,50,400,60,20CONSTRUCT AccBDisplay,50,380,60,20AccBLabel.TEXT="Acc B"AccBLabel.BACKCOLOR=$ff0000AccBLabel.FORECOLOR=$ffffffCONSTRUCT SetAccB,120,380,30,20SetAccB.TEXT="Set"CONSTRUCT BPRegLabel,50,360,60,20CONSTRUCT BPRegDisplay,50,340,60,20BPRegLabel.TEXT="BP Reg"BPRegLabel.BACKCOLOR=$ff0000BPRegLabel.FORECOLOR=$ffffffBPRegDisplay.TEXT="0000"CONSTRUCT SetBPReg,120,340,30,20SetBPReg.TEXT="Set"CONSTRUCT SPRegLabel,50,320,60,20CONSTRUCT SPRegDisplay,50,300,60,20SPRegLabel.TEXT="SP Reg"SPRegLabel.BACKCOLOR=$ff0000SPRegLabel.FORECOLOR=$ffffffCONSTRUCT SetSPReg,120,300,30,20SetSPReg.TEXT="Set"CONSTRUCT BPRegLabel,170,320,60,20CONSTRUCT BPRegDisplay,170,300,60,20CONSTRUCT PrinterBackground,730,10,280,260PrinterBackground.BACKCOLOR=$808080CONSTRUCT PrinterList,735,15,270,230CONSTRUCT TearButton,735,245,205,20TearButton.TEXT="TEAR OFF PAPER"CONSTRUCT PwrSwitch,945,245,60,20PwrSwitch.BACKCOLOR=$ffPwrSwitch.FORECOLOR=$ffffPwrSwitch.TEXT="POWER"CONSTRUCT KbdBackground,730,280,280,400KbdBackground.BACKCOLOR=$808080CONSTRUCT Line1,740,290,260,20Line1.BACKCOLOR=$c0c0c0CONSTRUCT Line2,740,310,260,20Line2.BACKCOLOR=$c0c0c0CONSTRUCT Key(1),740,350,75,20Key(1).TEXT="^"CONSTRUCT Key(2),832,350,75,20Key(2).TEXT="^"CONSTRUCT Key(3),924,350,75,20Key(3).TEXT="^"CONSTRUCT Key(4),740,380,75,20Key(4).TEXT="1"CONSTRUCT Key(5),832,380,75,20Key(5).TEXT="2"CONSTRUCT Key(6),924,380,75,20Key(6).TEXT="3"CONSTRUCT Key(7),740,410,75,20Key(7).TEXT="4"CONSTRUCT Key(8),832,410,75,20Key(8).TEXT="5"CONSTRUCT Key(9),924,410,75,20Key(9).TEXT="6"CONSTRUCT Key(10),740,440,75,20Key(10).TEXT="7"CONSTRUCT Key(11),832,440,75,20Key(11).TEXT="8"CONSTRUCT Key(12),924,440,75,20Key(12).TEXT="9"CONSTRUCT Key(13),740,470,75,20Key(13).TEXT="-"CONSTRUCT Key(14),832,470,75,20Key(14).TEXT="0"CONSTRUCT Key(15),924,470,75,20Key(15).TEXT="."CONSTRUCT Key(16),740,500,260,20Key(16).TEXT="ENTER"CONSTRUCT IOBackground,300,280,415,400IOBackground.BACKCOLOR=$ffff00CONSTRUCT AtoD,320,300,60,20AtoD.ENABLED=FALSEAtoD.TEXT="000"CONSTRUCT AtoDLabel,320,320,60,20AtoDLabel.BACKCOLOR=$ffff00AtoDLabel.TEXT="A/D"CONSTRUCT Ref,320,340,60,20Ref.TEXT="003"CONSTRUCT RefLabel,320,360,60,20RefLabel.BACKCOLOR=$ffff00RefLabel.TEXT="REF"CONSTRUCT Sig,320,380,60,20Sig.TEXT="002"CONSTRUCT SigLabel,320,400,60,20SigLabel.BACKCOLOR=$ffff00SigLabel.TEXT="SIG"CONSTRUCT LampInt,320,420,60,20LampInt.TEXT="001"CONSTRUCT LampIntLabel,320,440,60,20LampIntLabel.BACKCOLOR=$ffff00LampIntLabel.TEXT="LAMPINT"CONSTRUCT Gnd,320,460,60,20Gnd.TEXT="000"CONSTRUCT GndLabel,320,480,60,20GndLabel.BACKCOLOR=$ffff00GndLabel.TEXT="GND"CONSTRUCT Switch,320,500,60,20Switch.FORECOLOR=$ffffSwitch.TEXT="VIAL"Switch.BACKCOLOR=$80CONSTRUCT Mux,320,540,60,20Mux.ENABLED=FALSEMux.text="Not Set"CONSTRUCT MuxLabel,320,560,60,20MuxLabel.BACKCOLOR=$ffff00MuxLabel.TEXT="MUX"CONSTRUCT DtoAHi,320,580,60,20DtoAHi.ENABLED=FALSEDtoAHi.TEXT="00"CONSTRUCT DtoAHiLabel,320,600,60,20DtoAHiLabel.BACKCOLOR=$ffff00DtoAHiLabel.TEXT="D/A HIGH"CONSTRUCT DtoALo,320,620,60,20DtoALo.ENABLED=FALSEDtoALo.TEXT="00"CONSTRUCT DtoALoLabel,320,640,60,20DtoALoLabel.BACKCOLOR=$ffff00DtoALoLabel.TEXT="D/A LOW"CONSTRUCT ControlRegDisplay,400,300,60,20ControlRegDisplay.ENABLED=FALSEControlRegDisplay.TEXT="00"CONSTRUCT ControlRegLabel,400,320,60,20ControlRegLabel.BACKCOLOR=$ffff00ControlRegLabel.TEXT="CNTL"CONSTRUCT StatusRegDisplay,400,340,60,20StatusRegDisplay.ENABLED=FALSECONSTRUCT StatusRegLabel,400,360,60,20StatusRegLabel.BACKCOLOR=$ffff00StatusRegLabel.TEXT="STAT"StatusRegDisplay.TEXT="1d"CONSTRUCT GAX,400,380,20,20GAX.TEXT="A"GAX.FORECOLOR=$ffffGAX.BACKCOLOR=$80CONSTRUCT GBX,420,380,20,20GBX.TEXT="B"GBX.FORECOLOR=$ffffGBX.BACKCOLOR=$80CONSTRUCT GCX,440,380,20,20GCX.TEXT="C"GCX.FORECOLOR=$ffffGCX.BACKCOLOR=$80CONSTRUCT GainLabel,400,400,60,20GainLabel.BACKCOLOR=$ffff00GainLabel.TEXT="GAIN"CONSTRUCT DataRdy,400,420,60,20DataRdy.BACKCOLOR=$80DataRdy.FORECOLOR=$ffffDataRdy.TEXT="D Rdy"CONSTRUCT DacBt,400,460,60,20DacBt.BACKCOLOR=$80DacBt.FORECOLOR=$ffffDacBt.TEXT="DAC"CONSTRUCT RunBit,400,500,60,20RunBit.BACKCOLOR=$80RunBit.FORECOLOR=$ffffRunBit.TEXT="RUN"CONSTRUCT TestBit,400,540,60,20TestBit.BACKCOLOR=$80TestBit.FORECOLOR=$ffffTestBit.TEXT="TEST"CONSTRUCT StartBit,400,580,60,20StartBit.BACKCOLOR=$80StartBit.FORECOLOR=$ffffStartBit.TEXT="START"CONSTRUCT KeyDisplay,400,620,60,20KeyDisplay.TEXT="00"CONSTRUCT KeyLabel,400,640,60,20KeyLabel.BACKCOLOR=$ffff00KeyLabel.TEXT="KEY"CONSTRUCT ScanDisplay,480,620,60,20ScanDisplay.TEXT="00"CONSTRUCT ScanLabel,480,640,60,20ScanLabel.BACKCOLOR=$ffff00ScanLabel.TEXT="SCAN"CONSTRUCT TraceBackground,5,10,280,260TraceBackground.BACKCOLOR=$8000CONSTRUCT TraceList,10,15,270,230CONSTRUCT TraceClear,10,245,270,20TraceClear.TEXT="CLEAR LIST"CONSTRUCT SymBackground,300,10,415,260SymBackground.BACKCOLOR=$80CONSTRUCT SymList1,305,15,200,250CONSTRUCT SymList2,510,15,200,250FOR I=1 TO SymTableSize	HexData=HEX(SymTable(I).SymAddr)	GOSUB Pad4	Symbolic=SymTable(I).SymName	TempStr=HexData+" "+Symbolic	SymList1.ADDITEMSORTED TempStr	TempStr=Symbolic+" "+HexData	SymList2.ADDITEMSORTED TempStrNEXT IGOSUB LoadBinGOSUB ResetButton_COMMANDEND EVENTAbaX:mov bl,[AccA]add bl,[AccB]mov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAddaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]add bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAddbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]add bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAdcaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]add bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAdcbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]add bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAndaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]and bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSEsete [ZFlag]RETURNAndbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]and bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNBitaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]and bl,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNBitbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]and bl,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNClrX:TargetMem(OperandReg+1)=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNClraX:AccA=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNClrbX:AccB=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNCmpaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]sub bl,alsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNCmpbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]sub bl,alsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNCbaX:mov bl,[AccA]sub bl,[AccB]setc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNComX:TempByte=TargetMem(OperandReg+1)not alsets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteCFlag=TRUEVFlag=FALSERETURNComaX:mov al,[AccA]not alsets [NFlag]sete [ZFlag]mov [AccA], alCFlag=TRUEVFlag=FALSERETURNCombX:mov al,[AccB]not alsets [NFlag]sete [ZFlag]mov [AccB], alCFlag=TRUEVFlag=FALSERETURNNegX:TempByte=TargetMem(OperandReg+1)neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNNegaX:mov al,[AccA]neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [AccA], alRETURNNegbX:mov al,[AccB]neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [AccB], alRETURNDaaX:; Don't needRETURNDecX:TempByte=TargetMem(OperandReg+1)sub al,1sets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNDecaX:mov al,[AccA]sub al,1sets [NFlag]sete [ZFlag]mov [AccA], alRETURNDecbX:mov al,[AccB]sub al,1sets [NFlag]sete [ZFlag]mov [AccB], alRETURNEoraX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]xor bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNEorbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]xor bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNIncX:TempByte=TargetMem(OperandReg+1)add al,1sets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNIncaX:mov al,[AccA]add al,1sets [NFlag]sete [ZFlag]mov [AccA], alRETURNIncbX:mov al,[AccB]add al,1sets [NFlag]sete [ZFlag]mov [AccB], alRETURNLdaaX:IF ImmFlag=False THEN	IF IOFlag=FALSE THEN		AccA=TargetMem(OperandReg+1)	ELSE		IOCode=LdaaCode		GOSUB ProcIO	ENDIFELSE	AccA=OperandRegENDIFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNLdabX:IF ImmFlag=False THEN	IF IOFlag=FALSE THEN		AccB=TargetMem(OperandReg+1)	ELSE		IOCode=LdabCode		GOSUB ProcIO	ENDIFELSE	AccA=OperandRegENDIFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNOraaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]or bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNOrabX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]or bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNPshaX:TargetMem(SPReg+1)=AccADECR SPRegRETURNPshbX:TargetMem(SPReg+1)=AccBDECR SPRegRETURNPulaX:INCR SPRegAccA=TargetMem(SPReg+1)RETURNPulbX:INCR SPRegAccB=TargetMem(SPReg+1)RETURNRolX:IF CFlag=FALSE THEN	clcELSE	stcENDIFTempByte=TargetMem(OperandReg+1)rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNRolaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNRolbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNRorX:IF CFlag=FALSE THEN	clcELSE	stcENDIFTempByte=TargetMem(OperandReg+1)rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNRoraX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNRorbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNAslX:TempByte=TargetMem(OperandReg+1)shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNAslaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNAslbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNAsrX:TempByte=TargetMem(OperandReg+1)sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNAsraX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNAsrbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNLsrX:TempByte=TargetMem(OperandReg+1)shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNLsraX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNLsrbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNStaaX:IF IOFlag=FALSE THEN	TargetMem(OperandReg+1)=AccAELSE	IOCode=StaaCode	GOSUB ProcIOENDIFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNStabX:IF IOFlag=FALSE THEN	TargetMem(OperandReg+1)=AccBELSE	IOCode=StabCode	GOSUB ProcIOENDIFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNSubaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]sub bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSubbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]sub bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbaX:mov bl,[AccA]sub bl,[AccB]mov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbcaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]sub bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbcbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]sub bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNTabX:AccB=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNTbaX:AccA=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNTstX:TempByte=OperandRegor al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNTstaX:mov al,[AccA]or al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNTstbX:mov al,[AccB]or al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNCpxX:IF ImmFlag=False THEN	GOSUB GetData2ENDIFIF IndexReg=OperandReg THEN	ZFlag=TRUEELSE	ZFlag=FALSEENDIFVFlag=FALSENFlag=FALSECFlag=FALSE	RETURNDexX:DECR IndexRegsete [ZFlag]CFlag=FALSEVFlag=FALSENFlag=FALSERETURNDesX:DECR SPRegRETURNInxX:INCR IndexRegsete [ZFlag]CFlag=FALSEVFlag=FALSENFlag=FALSERETURNInsX:INCR SPRegRETURNLdxX:IF ImmFlag=False THEN	GOSUB GetData2	IndexReg=OperandRegELSE	IndexReg=OperandRegENDIFVFlag=FALSERETURNLdsX:IF ImmFlag=False THEN	GOSUB GetData2	SPReg=OperandRegELSE	SPReg=OperandRegENDIFVFlag=FALSERETURNStxX:StoreData=IndexReg/256or al,alsets [NFlag]mov [TempByte],alTargetMem(OperandReg+1)=StoreDataStoreData=IndexRegadd al,[TempByte]sete [ZFlag]TargetMem(OperandReg+2)=StoreDataRETURNStsX:StoreData=SPReg/256or al,alsets [NFlag]mov [TempByte],alTargetMem(OperandReg+1)=StoreDataStoreData=IndexRegadd al,[TempByte]sete [ZFlag]TargetMem(OperandReg+2)=StoreDataRETURNTxsX:SPReg=IndexRegRETURNTsxX:IndexReg=SPRegRETURNBraX:PCReg=OperandRegRETURNBccX:IF CFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBcsX:IF CFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBeqX:IF ZFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBgeX:IF NFlag=TRUE AND VFlag=TRUE THEN	PCReg=OperandRegENDIFIF NFlag=FALSE AND VFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBgtX:IF ZFlag=TRUE THEN	RETURNENDIFIF NFlag=TRUE AND VFlag=TRUE THEN	PCReg=OperandRegENDIFIF NFlag=FALSE AND VFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBhiX:IF ZFlag=TRUE AND CFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBleX:IF ZFlag=TRUE THEN	PCReg=OperandRegENDIFIF NFlag=TRUE AND VFlag=TRUE THEN	RETURNENDIFIF NFlag=FALSE AND VFlag=FALSE THEN	RETURNENDIFPCReg=OperandRegRETURNBlsX:IF ZFlag=TRUE OR CFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBltX:IF NFlag=TRUE AND VFlag=TRUE THEN	RETURNENDIFIF NFlag=FALSE AND VFlag=FALSE THEN	RETURNENDIFPCReg=OperandRegRETURNBmiX:IF NFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBneX:IF ZFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBvcX:IF VFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBvsX:IF VFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBplX:IF NFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNJmpX:PCReg=OperandReg+1RETURNBsrX:DECR PCRegStoreData=PCReg/256TargetMem(SPReg)=StoreDataStoreData=PCRegTargetMem(SPReg+1)=StoreDataPCReg=OperandRegSPReg=SPReg-2RETURNJsrX:DECR PCRegStoreData=PCReg/256TargetMem(SPReg)=StoreDataStoreData=PCRegTargetMem(SPReg+1)=StoreDataPCReg=OperandReg+1SPReg=SPReg-2RETURNNopX:; Do NothingRETURNRtiX:RETURNRtsX:SPReg=SPReg+2TempInt=TargetMem(SPReg)*256OperandReg=TempInt+TargetMem(SPReg+1)PCReg=OperandReg+1RETURNSwiX:RETURNWaiX:RETURNClcX:CFlag=FALSERETURNCliX:IFlag=FALSERETURNClvX:VFlag=FALSERETURNSecX:CFlag=TRUERETURNSeiX:IFlag=TRUERETURNSevX:VFlag=TRUERETURNTapX:; Don't needRETURNTpaX:; Don't needRETURNImm1X:SymFound=FALSESymbolic=""ImmFlag=TRUEGOSUB GetOp1PCReg=PCReg+2RETURNImm2X:ImmFlag=TRUEGOSUB GetImmOp2PCReg=PCReg+3RETURNDirX:ImmFlag=FALSEGOSUB GetOp1PCReg=PCReg+2RETURNExtX:ImmFlag=FALSEGOSUB GetOp2PCReg=PCReg+3RETURNIndexX:ImmFlag=FALSEGOSUB GetOp1OperandReg=OperandReg+IndexRegPCReg=PCReg+2RETURNInherentX:ImmFlag=FALSEINCR PCRegRETURNRelX:ImmFlag=FALSEGOSUB GetOp1IF OperandReg<128 THEN; Branch Forward	OperandReg=OperandReg+2+PCRegELSE	TempByte=$fe-OperandReg; Branch Backward	OperandReg=PCReg-TempByteENDIFPCReg=PCReg+2RETURNFindSym:IF SymFlag=TRUE THEN	FOR I=1 TO SymTableSize		IF SymTable(I).SymAddr=OperandReg THEN			SymFound=TRUE			Symbolic=SymTable(I).SymName			RETURN		ENDIF	NEXT IENDIFRETURNTrapX:SymFound=FALSESymbolic=""Timer1.STOPRunFlag=FALSERunLight.BACKCOLOR=$80RunButton.TEXT="RUN"GOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexData;PCReg=PCReg+1RETURNPwrSwitch.COMMANDIF PwrFlag=FALSE THEN	PwrSwitch.BACKCOLOR=$ffELSE	PwrSwitch.BACKCOLOR=$80ENDIFPwrFlag=NOT(PwrFlag)END EVENTTimerLight.COMMANDIF TimerFlag=FALSE THEN	TimerLight.BACKCOLOR=$ffELSE	TimerLight.BACKCOLOR=$80ENDIFTimerFlag=NOT(TimerFlag)END EVENTVLight.COMMANDIF VFlag=FALSE THEN	VLight.BACKCOLOR=$ffELSE	VLight.BACKCOLOR=$80ENDIFVFlag=NOT(VFlag)END EVENTILight.COMMANDIF IFlag=FALSE THEN	ILight.BACKCOLOR=$ffELSE	ILight.BACKCOLOR=$80ENDIFIFlag=NOT(IFlag)END EVENTNLight.COMMANDIF NFlag=FALSE THEN	NLight.BACKCOLOR=$ffELSE	NLight.BACKCOLOR=$80ENDIFNFlag=NOT(NFlag)END EVENTZLight.COMMANDIF ZFlag=FALSE THEN	ZLight.BACKCOLOR=$ffELSE	ZLight.BACKCOLOR=$80ENDIFZFlag=NOT(ZFlag)END EVENTCLight.COMMANDIF CFlag=FALSE THEN	CLight.BACKCOLOR=$ffELSE	CLight.BACKCOLOR=$80ENDIFCFlag=NOT(CFlag)END EVENTSymLight.COMMANDIF SymFlag=FALSE THEN	SymLight.BACKCOLOR=$ffELSE	SymLight.BACKCOLOR=$80ENDIFSymFlag=NOT(SymFlag)GOSUB DisplayInstEND EVENTRunButton.COMMANDIF RunFlag=FALSE THEN	RunFlag=TRUE	RunLight.BACKCOLOR=$80	RunButton.TEXT="HALT"	Timer1.INTERVAL=1ELSE	Timer1.STOP	RunFlag=FALSE	RunLight.BACKCOLOR=$80	RunButton.TEXT="RUN"	GOSUB DisplayInst	HexData=HEX(PCReg-1)	GOSUB Pad4	PCRegDisplay.TEXT=HexDataENDIFEND EVENTTimer1.TIMERGOSUB DisplayInstIF RunFlag=FALSE THEN	RETURNENDIFInstReg=TargetMem(PCReg)GOSUB [OpCode(InstReg+1).OpModeDispatch]GOSUB ClassMemGOSUB [OpCode(InstReg+1).OpInstDispatch]IF PCReg-1=BPReg THEN	Timer1.STOP		RunFlag=FALSE	RunLight.BACKCOLOR=$80	RunButton.TEXT="RUN"	GOSUB DisplayInst	HexData=HEX(PCReg-1)	GOSUB Pad4	PCRegDisplay.TEXT=HexData	RETURN;;ENDIFEND EVENTAddrRegDisplay.CHANGEGOSUB ChangeAddrEND EVENTChangeAddr:TempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)+1TempInt=TargetMem(AddrReg)HexData=HEX(TempInt)GOSUB Pad2DataRegDisplay.TEXT=HexDataRETURNSetPCReg.COMMANDPCRegSet=TRUETempStr=PCRegDisplay.TEXTHexData="$"+TempStrPCReg=VAL(HexData)+1HexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetData.COMMANDTempStr=DataRegDisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)TargetMem(AddrReg)=DataRegGOSUB IncAddr_COMMANDGOSUB ChangeAddrEND EVENTSetAccA.COMMANDTempStr=AccADisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)AccA=DataRegEND EVENTSetAccB.COMMANDTempStr=AccBDisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)AccB=DataRegEND EVENTSetIndexReg.COMMANDTempStr=IndexRegDisplay.TEXTHexData="$"+TempStrIndexReg=VAL(HexData)HexData=HEX(IndexReg)GOSUB Pad4IndexRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetBPReg.COMMANDTempStr=BPRegDisplay.TEXTHexData="$"+TempStrBPReg=VAL(HexData)HexData=HEX(BPReg)GOSUB Pad4BPRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetSPReg.COMMANDTempStr=SPRegDisplay.TEXTHexData="$"+TempStrSPReg=VAL(HexData)HexData=HEX(SPReg)GOSUB Pad4SPRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTPad2:IF LEN(HexData)=1 THEN	TempHexData="0"+HexData	HexData=TempHexDataENDIFRETURNPad4:TempInt=LEN(HexData)SELECT CASE TempInt	CASE 1		TempHexData="000"+HexData	CASE 2		TempHexData="00"+HexData	CASE 3		TempHexData="0"+HexData	CASE 4		TempHexData=HexDataEND SELECTHexData=TempHexDataRETURNIncAddr.COMMANDTempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)INCR AddrRegHexData=HEX(AddrReg)GOSUB Pad4AddrRegDisplay.TEXT=HexDataEND EVENTDecAddr.COMMANDTempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)DECR AddrRegHexData=HEX(AddrReg)GOSUB Pad4AddrRegDisplay.TEXT=HexDataEND EVENTKey.COMMANDTempStr=str(ArrayIndex)RunButton.text=TempStrEND EVENTLoadButton.COMMANDGOSUB LoadBinEND EVENTLoadBin:OPEN BinFile,"Romer.bin":READGET BinFile,TargetMemCLOSE BinFileRETURNDisplayInst:TraceAddr=hex(PCReg-1)InstReg=TargetMem(PCReg)TempStr=TraceAddr+" "+OpCode(InstReg+1).OpNameGOSUB ClassMemTempInt=OpCode(InstReg+1).OpModeSymFound=FALSESymbolic=""SELECT CASE TempInt	CASE TRAPMODE	CASE INHERENTMODE		CASE IMM1MODE		GOSUB GetOp1		HexData=HEX(OperandReg)		GOSUB Pad2		TempStr=TempStr+" #$"+HexData	CASE IMM2MODE		GOSUB GetOp2		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad4			TempStr=TempStr+" #$"+HexData		ELSE			TempStr=TempStr+" #"+Symbolic		ENDIF				CASE DIRECTMODE		GOSUB GetOp1		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad2			TempStr=TempStr+" $00"+HexData		ELSE			TempStr=TempStr+" "+Symbolic		ENDIF	CASE INDEXEDMODE		GOSUB GetOp1		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad2			TempStr=TempStr+"  $"+HexData+",X"		ELSE			TempStr=TempStr+" "+Symbolic+",X"		ENDIF		CASE EXTENDEDMODE		GOSUB GetOp2		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad4			TempStr=TempStr+" $"+HexData		ELSE			TempStr=TempStr+" "+Symbolic		ENDIF	CASE RELATIVEMODE		GOSUB GetOp1		IF OperandReg<128 THEN; Branch Forward			OperandReg=OperandReg+1+PCReg		ELSE			TempByte=$ff-OperandReg			OperandReg=PCReg-TempByte		ENDIF		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad2			TempStr=TempStr+" $"+HexData		ELSE			TempStr=TempStr+" "+Symbolic		ENDIFEND SELECTPrevInst=NextInst.TEXTNextInst.TEXT=TempStrIF StepFlag=TRUE OR RunFlag=TRUE THEN	TraceList.ADDITEM PrevInstENDIFTempInt=TraceList.ITEMCOUNTIF TempInt>14 THEN	TraceList.DELETEITEM 1ENDIFHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataHexData=HEX(IndexReg)GOSUB Pad4IndexRegDisplay.TEXT=HexDataHexData=HEX(SPReg)GOSUB Pad4SPRegDisplay.TEXT=HexDataHexData=HEX(AccA)GOSUB Pad2AccADisplay.TEXT=HexDataHexData=HEX(AccB)GOSUB Pad2AccBDisplay.TEXT=HexDataIF IFlag=FALSE THEN	ILight.BACKCOLOR=$80ELSE	ILight.BACKCOLOR=$ffENDIFIF NFlag=FALSE THEN	NLight.BACKCOLOR=$80ELSE	NLight.BACKCOLOR=$ffENDIFIF ZFlag=FALSE THEN	ZLight.BACKCOLOR=$80ELSE	ZLight.BACKCOLOR=$ffENDIFIF VFlag=FALSE THEN	VLight.BACKCOLOR=$80ELSE	VLight.BACKCOLOR=$ffENDIFIF CFlag=FALSE THEN	CLight.BACKCOLOR=$80ELSE	CLight.BACKCOLOR=$ffENDIFRETURNGetOp1:OperandReg=TargetMem(PCReg+1)RETURNGetOp2:OperandReg=TargetMem(PCReg+1)*256OperandReg=OperandReg+TargetMem(PCReg+2)RETURNGetImmOp2:OperandReg=TargetMem(PCReg+1)*256or ax,axsets [NFlag]OperandReg=OperandReg+TargetMem(PCReg+2)or ax,axsete [ZFlag]RETURNGetData2:TempInt=TargetMem(OperandReg+1)*256or ax,axsets [NFlag]OperandReg=TempInt+TargetMem(OperandReg+2)or ax,axsete [ZFlag]RETURNGetData2a:TempInt=TargetMem(OperandReg+1)*256OperandReg=TempInt+TargetMem(OperandReg+2)RETURNStepButton.COMMANDIF PCRegSet=False THEN	WARNINGBOX "Program Counter Not Set",TempStr,MB_OK	RETURNENDIFTimer1.STOPRunFlag=FALSERunLight.BACKCOLOR=$80RunButton.TEXT="RUN"GOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB StepCodeStepFlag=FALSEEND EVENTStepCode:InstReg=TargetMem(PCReg)GOSUB [OpCode(InstReg+1).OpModeDispatch]GOSUB ClassMemGOSUB [OpCode(InstReg+1).OpInstDispatch]StepFlag=TRUEGOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataRETURNResetButton.COMMANDTimer1.STOPRunFlag=FALSERunLight.BACKCOLOR=$80RunButton.TEXT="RUN"TraceList.CLEARPCRegSet=TRUEPCReg=TargetMem($ffff)*256PCReg=PCReg+TargetMem($10000)INCR PCRegHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB DisplayInst		RamLight.BACKCOLOR=$80		RomLight.BACKCOLOR=$ff		IOLight.BACKCOLOR=$80END EVENTSwitch.COMMANDIF Vial=FALSE THEN	Switch.BACKCOLOR=$ff	StatusReg=BITSET(StatusReg,5)ELSE	Switch.BACKCOLOR=$80	StatusReg=BITCLR(StatusReg,5)ENDIFVial=NOT(Vial)HexData=HEX(StatusReg)GOSUB Pad2StatusRegDisplay.TEXT=HexDataEND EVENTDataRdy.COMMANDIF DataRdyFlag=FALSE THEN	DataRdy.BACKCOLOR=$ff	StatusReg=BITSET(StatusReg,6)ELSE	DataRdy.BACKCOLOR=$80	StatusReg=BITCLR(StatusReg,6)ENDIFDataRdyFlag=NOT(DataRdyFlag)HexData=HEX(StatusReg)GOSUB Pad2StatusRegDisplay.TEXT=HexDataEND EVENTDacBt.COMMANDIF DacBtFlag=FALSE THEN	DacBt.BACKCOLOR=$ff	StatusReg=BITSET(StatusReg,7)ELSE	DacBt.BACKCOLOR=$80	StatusReg=BITCLR(StatusReg,7)ENDIFDacBtFlag=NOT(DacBtFlag)HexData=HEX(StatusReg)GOSUB Pad2StatusRegDisplay.TEXT=HexDataEND EVENTTraceClear.COMMANDTraceList.CLEAREND EVENTClassMem:IF ImmFlag=FALSE THEN	IF OperandReg>=$6000 AND OperandReg<$8000 THEN		RamLight.BACKCOLOR=$80		RomLight.BACKCOLOR=$80		IOLight.BACKCOLOR=$ff		IOFlag=TRUE	ELSE		IF OperandReg>=$0000 AND OperandReg<$2000 THEN			RamLight.BACKCOLOR=$ff			RomLight.BACKCOLOR=$80			IOLight.BACKCOLOR=$80			IOFlag=FALSE		ELSE			RamLight.BACKCOLOR=$80			RomLight.BACKCOLOR=$ff			IOLight.BACKCOLOR=$80			IOFlag=FALSE		ENDIF	ENDIFELSE	RamLight.BACKCOLOR=$80	RomLight.BACKCOLOR=$ff	IOLight.BACKCOLOR=$80	IOFlag=FALSE	ENDIFRETURNProcIO:SELECT CASE OperandReg	CASE $7007		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				ControlReg=AccA			ELSE				ControlReg=AccB					ENDIF			HexData=HEX(ControlReg)			GOSUB Pad2			ControlRegDisplay.TEXT=HexData			TempByte=LAND(ControlReg,$f0)			IF TempByte=0 THEN				Mux.TEXT="Gnd"				AtoD.TEXT=Gnd.TEXT			ELSE				IF TempByte=$30 THEN					Mux.TEXT="Lamp"					AtoD.TEXT=LampInt.TEXT				ELSE					IF TempByte=$50 THEN						Mux.TEXT="Sig"						AtoD.TEXT=Sig.TEXT					ELSE						IF TempByte=$90 THEN							Mux.TEXT="Ref"							AtoD.TEXT=Ref.TEXT						ELSE							Mux.TEXT="BAD"						ENDIF					ENDIF				ENDIF			ENDIF			IF BITTST(ControlReg,0)=TRUE THEN				GAX.BACKCOLOR=$ff			ELSE				GAX.BACKCOLOR=$80			ENDIF			IF BITTST(ControlReg,1)=TRUE THEN				GBX.BACKCOLOR=$ff			ELSE				GBX.BACKCOLOR=$80			ENDIF			IF BITTST(ControlReg,2)=TRUE THEN				GCX.BACKCOLOR=$ff			ELSE				GCX.BACKCOLOR=$80			ENDIF		ENDIF	CASE $7001		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				DtoALoReg=AccA			ELSE				DtoALoReg=AccB					ENDIF			HexData=HEX(DtoALoReg)			GOSUB Pad2			DtoALo.TEXT=HexData		ENDIF	CASE $7002		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				DtoAHiReg=AccA			ELSE				DtoAHiReg=AccB					ENDIF			HexData=HEX(DtoAHiReg)			GOSUB Pad2			DtoAHi.TEXT=HexData			IF BITTST(DtoAHiReg,5)=FALSE THEN				RunBit.BACKCOLOR=$ff			ELSE				RunBit.BACKCOLOR=$80			ENDIF			IF BITTST(DtoAHiReg,6)=TRUE THEN				TestBit.BACKCOLOR=$ff			ELSE				TestBit.BACKCOLOR=$80			ENDIF			IF BITTST(DtoAHiReg,7)=TRUE THEN				StartBit.BACKCOLOR=$ff			ELSE				StartBit.BACKCOLOR=$80			ENDIF					ENDIF		IF IOCode=LdaaCode OR IOCode=LdabCode THEN			IF IOCode=LdaaCode THEN				AccA=StatusReg			ELSE				AccB=StatusReg				ENDIF		ENDIF	CASE $7003		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				ScanReg=AccA			ELSE				ScanReg=AccB					ENDIF			HexData=HEX(ScanReg)			GOSUB Pad2			ScanDisplay.TEXT=HexData		ENDIF		IF IOCode=LdaaCode OR IOCode=LdabCode THEN			IF IOCode=LdaaCode THEN				AccA=KeyReg			ELSE				AccB=KeyReg				ENDIF		ENDIFEND SELECTRETURNRef.CHANGEEND EVENTSig.CHANGEEND EVENTGnd.CHANGEEND EVENTLampInt.CHANGEEND EVENTKeyDisplay.CHANGETempStr2=KeyDisplay.TEXTTempStr="$"+TempStr2KeyReg=VAL(TempStr)END EVENTScanDisplay.CHANGETempStr2=ScanDisplay.TEXTTempStr="$"+TempStr2ScanReg=VAL(TempStr)END EVENT