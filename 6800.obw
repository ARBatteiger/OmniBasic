DIM ImmFlag AS BOOLEANDIM PCRegSet AS BOOLEANDIM RunFlag AS BOOLEANDIM StepFlag AS BOOLEANDIM TargetMem(65536) AS BYTEDIM I AS LONGDIM CycleCtr AS LONGDIM TempInt AS LONGDIM TempByte AS BYTEDIM TempStr AS STRING*256DIM TempStr2 AS STRING*256DIM TempHexData AS STRING*256DIM HexData AS STRING*256DIM TempLabel AS LABELDIM BinFile AS FILEDIM InstReg AS BYTEDIM OperandReg AS LONGDIM KeyReg AS BYTEDIM ScanReg AS BYTEDIM StoreData AS BYTEDIM IFlag AS BOOLEANDIM NFlag AS BOOLEANDIM ZFlag AS BOOLEANDIM VFlag AS BOOLEANdebug.watch VFlagDIM CFlag AS BOOLEANDIM SymFlag AS BOOLEANDIM PwrFlag AS BOOLEANDIM Vial AS BOOLEANDIM DacBtFlag AS BOOLEANDIM DataRdyFlag AS BOOLEANDIM PrevInst AS STRING*256DIM TraceAddr AS STRING*5DIM Symbolic AS STRING*32DIM SymTableSize AS LONGDIM SymFound AS BOOLEANDIM IOFlag AS BOOLEANDIM IOCode AS BYTEDIM Captured AS BOOLEANDIM Descriptor(125) AS LONG VECTORDIM DescAddr AS LONGDIM K AS LONGDIM KeyHandle AS HANDLEDIM KeyDown AS LONGDIM Timer1 AS TIMERDIM CPUBackground AS RECTANGLEDIM ResetButton AS BUTTONDIM RunButton AS BUTTONDIM StepButton AS BUTTONDIM LoadButton AS BUTTONDIM AddrReg AS LONGDIM AddrRegDisplay AS TEXTBOXDIM AddrRegLabel AS STATICTEXTDIM DecAddr AS BUTTONDIM IncAddr AS BUTTONDIM DataReg AS BYTEDIM DataRegDisplay AS TEXTBOXDIM DataRegLabel AS STATICTEXTDIM SetData AS BUTTONDIM PCReg AS LONGDIM PCRegDisplay AS TEXTBOXDIM PCRegLabel AS STATICTEXTDIM SetPCReg AS BUTTONDIM SPReg AS LONGDIM SPRegDisplay AS TEXTBOXDIM SPRegLabel AS STATICTEXTDIM SetSPReg AS BUTTONDIM IndexReg AS LONGDIM IndexRegDisplay AS TEXTBOXDIM IndexRegLabel AS STATICTEXTDIM SetIndexReg AS BUTTONDIM AccA AS BYTEDIM AccADisplay AS TEXTBOXDIM AccALabel AS STATICTEXTDIM SetAccA AS BUTTONDIM AccB AS BYTEDIM AccBDisplay AS TEXTBOXDIM AccBLabel AS STATICTEXTDIM SetAccB AS BUTTONDIM CCReg AS BYTEDIM BPReg AS LONGDIM BPRegDisplay AS TEXTBOXDIM BPRegLabel AS STATICTEXTDIM SetBPReg AS BUTTONDIM IRQButton AS BUTTONDIM NMIButton AS BUTTONDIM NextInst AS STATICTEXTDIM TimerFlag AS BOOLEANDIM TimerLight AS STATICTEXTDIM ILight AS STATICTEXTDIM NLight AS STATICTEXTDIM ZLight AS STATICTEXTDIM VLight AS STATICTEXTDIM CLight AS STATICTEXTDIM SymLight AS STATICTEXTDIM RunLight AS STATICTEXTDIM RamLight AS RECTANGLEDIM RomLight AS RECTANGLEDIM IOLight AS RECTANGLEDIM KbdBackground AS RECTANGLEDIM Line1 AS RECTANGLEDIM Line2 AS RECTANGLEDIM Key(16) AS BUTTONDIM PrinterBackground AS RECTANGLEDIM PrinterList AS LISTBOXDIM TearButton AS BUTTONDIM PwrSwitch AS STATICTEXTDIM IOBackground AS RECTANGLEDIM AtoD AS TEXTBOXDIM AtoDLabel AS RECTANGLEDIM Ref AS TEXTBOXDIM RefLabel AS RECTANGLEDIM Sig AS TEXTBOXDIM SigLabel AS RECTANGLEDIM Gnd AS TEXTBOXDIM GndLabel AS RECTANGLEDIM LampInt AS TEXTBOXDIM LampIntLabel AS RECTANGLEDIM Switch  AS STATICTEXTDIM Mux AS TEXTBOXDIM MuxLabel AS RECTANGLEDIM DtoAHi AS TEXTBOXDIM DtoAHiReg AS LONGDIM DtoAHiLabel AS RECTANGLEDIM DtoALo AS TEXTBOXDIM DtoALoReg AS LONGDIM DtoALoLabel AS RECTANGLEDIM ControlRegDisplay AS TEXTBOXDIM ControlReg AS LONGDIM ControlRegLabel AS RECTANGLEDIM StatusRegDisplay AS TEXTBOXDIM StatusReg AS LONGDIM StatusRegLabel AS RECTANGLEDIM GAX AS RECTANGLEDIM GBX AS RECTANGLEDIM GCX AS RECTANGLEDIM GainLabel AS RECTANGLEDIM DataRdy AS STATICTEXTDIM DacBt AS STATICTEXTDIM RunBit AS RECTANGLEDIM TestBit AS RECTANGLEDIM StartBit AS RECTANGLEDIM KeyDisplay AS TEXTBOXDIM KeyLabel AS RECTANGLEDIM ScanDisplay AS TEXTBOXDIM ScanLabel AS RECTANGLEDIM TraceBackground AS RECTANGLEDIM TraceList AS LISTBOXDIM TraceClear AS BUTTONDIM SymBackground AS RECTANGLEDIM SymList1 AS LISTBOXDIM SymList2 AS LISTBOXENUM 0 LdaaCode LdabCode StaaCode StabCodeEND ENUMENUM 0 TRAPMODE INHERENTMODE IMM1MODE IMM2MODE DIRECTMODE INDEXEDMODE EXTENDEDMODE RELATIVEMODEEND ENUMTYPE SymData	SymAddr AS LONG	SymName AS STRING*32END TYPETABLE SymTable AS SymData $0ed2,"LampErr" $d04d,"Init1" $d086,"Init2" $d052,"BlkMov1" $d058,"MovLop1" $d08c,"MovLop2" $d0a2,"MovLop3" $7001,"DtoALo" $7002,"DtoAHi" $7003,"KeyScan" $7007,"Mux" $6010,"RTCControl" $6011,"RTCData" $7005,"LCDStat" $7006,"LCDData" $6020,"StatRegA" $6023,"DataA" $6029,"StatRegB" $602b,"DataB"END TABLETYPE OpCodeData	OpInstDispatch AS LABEL	OpModeDispatch AS LABEL	OpMode AS LONG	OpName AS STRING*8END TYPETABLE OpCode AS OpCodeData TrapX,TrapX,TRAPMODE,"Trap" NopX,InherentX,INHERENTMODE,"NOP" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TapX,InherentX,INHERENTMODE,"TAP" TpaX,InherentX,INHERENTMODE,"TPA" InxX,InherentX,INHERENTMODE,"INX" DexX,InherentX,INHERENTMODE,"DEX" ClvX,InherentX,INHERENTMODE,"CLV" SevX,InherentX,INHERENTMODE,"SEV" ClcX,InherentX,INHERENTMODE,"CLC" SecX,InherentX,INHERENTMODE,"SEC" CliX,InherentX,INHERENTMODE,"CLI" SeiX,InherentX,INHERENTMODE,"SEI" SbaX,InherentX,INHERENTMODE,"SBA" CbaX,InherentX,INHERENTMODE,"CBA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TabX,InherentX,INHERENTMODE,"TAB" TbaX,InherentX,INHERENTMODE,"TBA" TrapX,TrapX,TRAPMODE,"Trap" DaaX,InherentX,INHERENTMODE,"DAA" TrapX,TrapX,TRAPMODE,"Trap" AbaX,InherentX,INHERENTMODE,"ABA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" BraX,RelX,RELATIVEMODE,"BRA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" BlsX,RelX,RELATIVEMODE,"BLS" BccX,RelX,RELATIVEMODE,"BCC" BcsX,RelX,RELATIVEMODE,"BCS" BneX,RelX,RELATIVEMODE,"BNE" BeqX,RelX,RELATIVEMODE,"BEQ" BvcX,RelX,RELATIVEMODE,"BVC" BvsX,RelX,RELATIVEMODE,"BVS" BplX,RelX,RELATIVEMODE,"BPL" BmiX,RelX,RELATIVEMODE,"BMI" BgeX,RelX,RELATIVEMODE,"BGE" BltX,RelX,RELATIVEMODE,"BLT" BgtX,RelX,RELATIVEMODE,"BGT" BleX,RelX,RELATIVEMODE,"BLE" TsxX,InherentX,INHERENTMODE,"TSX" InsX,InherentX,INHERENTMODE,"INS" PulaX,InherentX,INHERENTMODE,"PULA" PulbX,InherentX,INHERENTMODE,"PULB" DesX,InherentX,INHERENTMODE,"DES" TxsX,InherentX,INHERENTMODE,"TSX" PshaX,InherentX,INHERENTMODE,"PSHA" PshbX,InherentX,INHERENTMODE,"PSHB" TrapX,TrapX,TRAPMODE,"Trap" RtsX,InherentX,INHERENTMODE,"RTS" TrapX,TrapX,TRAPMODE,"Trap" RtiX,InherentX,INHERENTMODE,"RTI" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" WaiX,InherentX,INHERENTMODE,"WAI" SwiX,InherentX,INHERENTMODE,"SWI" NegaX,InherentX,INHERENTMODE,"NEGA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComaX,InherentX,INHERENTMODE,"COMA" LsraX,InherentX,INHERENTMODE,"LSRA" TrapX,TrapX,TRAPMODE,"Trap" RoraX,InherentX,INHERENTMODE,"RORA" AsraX,InherentX,INHERENTMODE,"ASRA" AslaX,InherentX,INHERENTMODE,"ASLA" RolaX,InherentX,INHERENTMODE,"ROLA" DecaX,InherentX,INHERENTMODE,"DECA" TrapX,TrapX,TRAPMODE,"Trap" IncaX,InherentX,INHERENTMODE,"INCA" TstaX,InherentX,INHERENTMODE,"TSTA" TrapX,TrapX,TRAPMODE,"Trap" ClraX,InherentX,INHERENTMODE,"CLRA" NegbX,InherentX,INHERENTMODE,"NEGB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" CombX,InherentX,INHERENTMODE,"COMB" LsrbX,InherentX,INHERENTMODE,"LSRB" TrapX,TrapX,TRAPMODE,"Trap" RorbX,InherentX,INHERENTMODE,"RORB" AsrbX,InherentX,INHERENTMODE,"ASRB" AslbX,InherentX,INHERENTMODE,"ASLB" RolbX,InherentX,INHERENTMODE,"ROLB" DecbX,InherentX,INHERENTMODE,"DECB" TrapX,TrapX,TRAPMODE,"Trap" IncbX,InherentX,INHERENTMODE,"INCB" TstbX,InherentX,INHERENTMODE,"TSTB" TrapX,TrapX,TRAPMODE,"Trap" ClrbX,InherentX,INHERENTMODE,"CLRB" NegX,IndexX,INDEXEDMODE,"NEGB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComX,IndexX,INDEXEDMODE,"COM" LsrX,IndexX,INDEXEDMODE,"LSR" TrapX,TrapX,TRAPMODE,"Trap" RorX,IndexX,INDEXEDMODE,"ROR" AsrX,IndexX,INDEXEDMODE,"ASR" AslX,IndexX,INDEXEDMODE,"ASL" RolX,IndexX,INDEXEDMODE,"ROL" DecX,IndexX,INDEXEDMODE,"DEC" TrapX,TrapX,TRAPMODE,"Trap" IncX,IndexX,INDEXEDMODE,"INC" TstX,IndexX,INDEXEDMODE,"TST" JmpX,IndexX,INDEXEDMODE,"JMP" ClrX,IndexX,INDEXEDMODE,"CLR" NegX,ExtX,EXTENDEDMODE,"NEG" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComX,ExtX,EXTENDEDMODE,"COM" LsrX,ExtX,EXTENDEDMODE,"LSR" TrapX,TrapX,TRAPMODE,"Trap" RorX,ExtX,EXTENDEDMODE,"ROR" TrapX,TrapX,TRAPMODE,"Trap" AslX,ExtX,EXTENDEDMODE,"ASL" RolX,ExtX,EXTENDEDMODE,"ROL" DecX,ExtX,EXTENDEDMODE,"DEC" TrapX,TrapX,TRAPMODE,"Trap" IncX,ExtX,EXTENDEDMODE,"INC" TstX,ExtX,EXTENDEDMODE,"TST" JmpX,ExtX,EXTENDEDMODE,"JMP" ClrX,ExtX,EXTENDEDMODE,"CLR" SubaX,Imm1X,IMM1MODE,"SUBA" CmpaX,Imm1X,IMM1MODE,"CMPA" SbcaX,Imm1X,IMM1MODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,Imm1X,IMM1MODE,"ANDA" BitaX,Imm1X,IMM1MODE,"BITA" LdaaX,Imm1X,IMM1MODE,"LDAA" TrapX,TrapX,TRAPMODE,"Trap" EoraX,Imm1X,IMM1MODE,"EORA" AdcaX,Imm1X,IMM1MODE,"ADCA" OraaX,Imm1X,IMM1MODE,"ORAA" AddaX,Imm1X,IMM1MODE,"ADDA" CpxX,Imm2X,IMM2MODE,"CPX" BsrX,RelX,RELATIVEMODE,"BSR" LdsX,Imm2X,IMM2MODE,"LDS" TrapX,TrapX,TRAPMODE,"Trap" SubaX,DirX,DIRECTMODE,"SUBA" CmpaX,DirX,DIRECTMODE,"CMPA" SbcaX,DirX,DIRECTMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,DirX,DIRECTMODE,"ANDA" BitaX,DirX,DIRECTMODE,"BITA" LdaaX,DirX,DIRECTMODE,"LDAA" StaaX,DirX,DIRECTMODE,"STAA" EoraX,DirX,DIRECTMODE,"EORA" AdcaX,DirX,DIRECTMODE,"ADCA" OraaX,DirX,DIRECTMODE,"ORAA" AddaX,DirX,DIRECTMODE,"ADDA" CpxX,DirX,DIRECTMODE,"CPX" StsX,DirX,DIRECTMODE,"STS" LdsX,DirX,DIRECTMODE,"LDS" TrapX,TrapX,TRAPMODE,"Trap" SubaX,IndexX,INDEXEDMODE,"SUBA" CmpaX,IndexX,INDEXEDMODE,"CMPA" SbcaX,IndexX,INDEXEDMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,IndexX,INDEXEDMODE,"ANDA" BitaX,IndexX,INDEXEDMODE,"BITA" LdaaX,IndexX,INDEXEDMODE,"LDAA" StaaX,IndexX,INDEXEDMODE,"STAA" EoraX,IndexX,INDEXEDMODE,"EORA" AdcaX,IndexX,INDEXEDMODE,"ADCA" OraaX,IndexX,INDEXEDMODE,"ORAA" AddaX,IndexX,INDEXEDMODE,"ADDA" CpxX,IndexX,INDEXEDMODE,"CPX" JsrX,IndexX,INDEXEDMODE,"JSR" LdsX,IndexX,INDEXEDMODE,"LDS" StsX,IndexX,INDEXEDMODE,"STS" SubaX,ExtX,EXTENDEDMODE,"SUBA" CmpaX,ExtX,EXTENDEDMODE,"CMPX" SbcaX,ExtX,EXTENDEDMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,ExtX,EXTENDEDMODE,"ANDA" BitaX,ExtX,EXTENDEDMODE,"BITA" LdaaX,ExtX,EXTENDEDMODE,"LDAA" StaaX,ExtX,EXTENDEDMODE,"STAA" EoraX,ExtX,EXTENDEDMODE,"EORA" AdcaX,ExtX,EXTENDEDMODE,"ADCA" OraaX,ExtX,EXTENDEDMODE,"ORAA" AddaX,ExtX,EXTENDEDMODE,"ADDA" CpxX,ExtX,EXTENDEDMODE,"CPX" JsrX,ExtX,EXTENDEDMODE,"JSR" LdsX,ExtX,EXTENDEDMODE,"LDS" StsX,ExtX,EXTENDEDMODE,"STS" SubbX,Imm1X,IMM1MODE,"SUBB" CmpbX,Imm1X,IMM1MODE,"CMPB" SbcbX,Imm1X,IMM1MODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,Imm1X,IMM1MODE,"ANDB" BitbX,Imm1X,IMM1MODE,"BITB" LdabX,Imm1X,IMM1MODE,"LDAB" TrapX,TrapX,TRAPMODE,"Trap" EorbX,Imm1X,IMM1MODE,"EORB" AdcbX,Imm1X,IMM1MODE,"ADCB" OrabX,Imm1X,IMM1MODE,"ORAB" AddbX,Imm1X,IMM1MODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,Imm2X,IMM2MODE,"LDX" TrapX,TrapX,TRAPMODE,"Trap" SubbX,DirX,DIRECTMODE,"SUBB" CmpbX,DirX,DIRECTMODE,"CMPB" SbcbX,DirX,DIRECTMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,DirX,DIRECTMODE,"ANDB" BitbX,DirX,DIRECTMODE,"BITB" LdabX,DirX,DIRECTMODE,"LDAB" StabX,DirX,DIRECTMODE,"STAB" EorbX,DirX,DIRECTMODE,"EORB" AdcbX,DirX,DIRECTMODE,"ADCB" OrabX,DirX,DIRECTMODE,"ORAB" AddbX,DirX,DIRECTMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,DirX,DIRECTMODE,"LDX" StxX,DirX,DIRECTMODE,"STX" SubbX,IndexX,INDEXEDMODE,"SUBB" CmpbX,IndexX,INDEXEDMODE,"CMPB" SbcbX,IndexX,INDEXEDMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,IndexX,INDEXEDMODE,"ANDB" BitbX,IndexX,INDEXEDMODE,"BITB" LdabX,IndexX,INDEXEDMODE,"LDAB" StabX,IndexX,INDEXEDMODE,"STAB" EorbX,IndexX,INDEXEDMODE,"EORB" AdcbX,IndexX,INDEXEDMODE,"ADCB" OrabX,IndexX,INDEXEDMODE,"ORAB" AddbX,IndexX,INDEXEDMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,IndexX,INDEXEDMODE,"LDX" StxX,IndexX,INDEXEDMODE,"STX" SubbX,ExtX,EXTENDEDMODE,"SUBB" CmpbX,ExtX,EXTENDEDMODE,"CMPB" SbcbX,ExtX,EXTENDEDMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,ExtX,EXTENDEDMODE,"ANDB" BitbX,ExtX,EXTENDEDMODE,"BITB" LdabX,ExtX,EXTENDEDMODE,"LDAB" StabX,ExtX,EXTENDEDMODE,"STAB" EorbX,ExtX,EXTENDEDMODE,"EORB" AdcbX,ExtX,EXTENDEDMODE,"ADCB" OrabX,ExtX,EXTENDEDMODE,"ORAB" AddbX,ExtX,EXTENDEDMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,ExtX,EXTENDEDMODE,"LDX" StxX,ExtX,EXTENDEDMODE,"STX"END TABLEOBMain.createSETPOSITION OBMain,0,0,1024,740OBMain.TEXT="6800 Emulator"PCRegSet=FALSERunFlag=FALSEStepFlag=FALSEVial=FALSESymFlag=TRUEPwrFlag=TRUECaptured=FALSEKeyHandle=0ControlReg=0AddrReg=0StatusReg=$1dKeyReg=0KeyDown=0ScanReg=0IndexReg=0BPReg=0AccA=0AccB=0SPReg=0BPReg=0Symbolic=""SymFound=FALSESymTableSize=TABLESIZE(SymTable)CREATE CPUBackground,5,280,280,400CPUBackground.BACKCOLOR=$ff0000CREATE ResetButton,10,650,60,20ResetButton.TEXT="RESET"CREATE RunButton,80,650,60,20RunButton.TEXT="RUN"CREATE StepButton,150,650,60,20StepButton.TEXT="STEP"CREATE LoadButton,220,650,60,20LoadButton.TEXT="LOAD"CREATE NextInst,10,620,270,20NextInst.BACKCOLOR=$ffffffCREATE DecAddr,120,580,15,20DecAddr.TEXT="<"CREATE IncAddr,135,580,15,20IncAddr.TEXT=">"CREATE AddrRegLabel,50,600,60,20CREATE AddrRegDisplay,50,580,60,20AddrRegDisplay.TEXT="0000"AddrRegLabel.TEXT="Addr"AddrRegLabel.BACKCOLOR=$ff0000AddrRegLabel.FORECOLOR=$ffffffCREATE IRQButton,170,580,60,20IRQButton.TEXT="IRQ"CREATE NMIButton,170,540,60,20NMIButton.TEXT="NMI"CREATE TimerLight,170,500,60,20TimerLight.BACKCOLOR=$80TimerLight.FORECOLOR=$ffffTimerLight.TEXT="TIMER"CREATE ILight,170,460,60,20ILight.BACKCOLOR=$80ILight.FORECOLOR=$ffffILight.TEXT="INT"CREATE NLight,170,420,60,20NLight.BACKCOLOR=$80NLight.FORECOLOR=$ffffNLight.TEXT="NEG"CREATE ZLight,170,380,60,20ZLight.BACKCOLOR=$80ZLight.FORECOLOR=$ffffZLight.TEXT="ZERO"CREATE VLight,170,340,60,20VLight.BACKCOLOR=$80VLight.FORECOLOR=$ffffVLight.TEXT="OVF"CREATE CLight,170,300,60,20CLight.BACKCOLOR=$80CLight.FORECOLOR=$ffffCLight.TEXT="CARRY"CREATE SymLight,245,460,30,20SymLight.BACKCOLOR=$ffSymLight.FORECOLOR=$ffffSymLight.TEXT="SYM"CREATE RunLight,245,300,30,20RunLight.BACKCOLOR=$80RunLight.FORECOLOR=$ffffRunLight.TEXT="RUN"CREATE RamLight,245,340,30,20RamLight.BACKCOLOR=$80RamLight.FORECOLOR=$ffffRamLight.TEXT="RAM"CREATE RomLight,245,380,30,20RomLight.BACKCOLOR=$80RomLight.FORECOLOR=$ffffRomLight.TEXT="ROM"CREATE IOLight,245,420,30,20IOLight.BACKCOLOR=$80IOLight.FORECOLOR=$ffffIOLight.TEXT="IO"CREATE DataRegLabel,50,560,60,20CREATE DataRegDisplay,50,540,60,20,default+centerDataRegLabel.TEXT="Data"DataRegLabel.BACKCOLOR=$ff0000DataRegLabel.FORECOLOR=$ffffffCREATE SetData,120,540,30,20SetData.TEXT="Set"CREATE PCRegLabel,50,520,60,20CREATE PCRegDisplay,50,500,60,20,default+centerPCRegLabel.TEXT="Pgm Ctr"PCRegLabel.BACKCOLOR=$ff0000PCRegLabel.FORECOLOR=$ffffffCREATE SetPCReg,120,500,30,20SetPCReg.TEXT="Set"CREATE IndexRegLabel,50,480,60,20CREATE IndexRegDisplay,50,460,60,20,default+centerIndexRegLabel.TEXT="Ndx Reg"IndexRegLabel.BACKCOLOR=$ff0000IndexRegLabel.FORECOLOR=$ffffffCREATE SetIndexReg,120,460,30,20SetIndexReg.TEXT="Set"CREATE AccALabel,50,440,60,20CREATE AccADisplay,50,420,60,20,default+centerAccALabel.TEXT="Acc A"AccALabel.BACKCOLOR=$ff0000AccALabel.FORECOLOR=$ffffffCREATE SetAccA,120,420,30,20SetAccA.TEXT="Set"CREATE AccBLabel,50,400,60,20CREATE AccBDisplay,50,380,60,20,default+centerAccBLabel.TEXT="Acc B"AccBLabel.BACKCOLOR=$ff0000AccBLabel.FORECOLOR=$ffffffCREATE SetAccB,120,380,30,20SetAccB.TEXT="Set"CREATE BPRegLabel,50,360,60,20CREATE BPRegDisplay,50,340,60,20,default+centerBPRegLabel.TEXT="BP Reg"BPRegLabel.BACKCOLOR=$ff0000BPRegLabel.FORECOLOR=$ffffffBPRegDisplay.TEXT="0000"CREATE SetBPReg,120,340,30,20SetBPReg.TEXT="Set"CREATE SPRegLabel,50,320,60,20CREATE SPRegDisplay,50,300,60,20,default+centerSPRegLabel.TEXT="SP Reg"SPRegLabel.BACKCOLOR=$ff0000SPRegLabel.FORECOLOR=$ffffffCREATE SetSPReg,120,300,30,20SetSPReg.TEXT="Set"CREATE PrinterBackground,730,10,280,260PrinterBackground.BACKCOLOR=$808080CREATE PrinterList,735,15,270,230CREATE TearButton,735,245,205,20TearButton.TEXT="TEAR OFF PAPER"CREATE PwrSwitch,945,245,60,20PwrSwitch.BACKCOLOR=$ffPwrSwitch.FORECOLOR=$ffffPwrSwitch.TEXT="POWER"CREATE KbdBackground,730,280,280,400KbdBackground.BACKCOLOR=$808080CREATE Line1,740,290,260,20Line1.BACKCOLOR=$c0c0c0CREATE Line2,740,310,260,20Line2.BACKCOLOR=$c0c0c0CREATE Key(1),740,350,75,20Key(1).TEXT="^"CREATE Key(2),832,350,75,20Key(2).TEXT="^"CREATE Key(3),924,350,75,20Key(3).TEXT="^"CREATE Key(4),740,380,75,20Key(4).TEXT="1"CREATE Key(5),832,380,75,20Key(5).TEXT="2"CREATE Key(6),924,380,75,20Key(6).TEXT="3"CREATE Key(7),740,410,75,20Key(7).TEXT="4"CREATE Key(8),832,410,75,20Key(8).TEXT="5"CREATE Key(9),924,410,75,20Key(9).TEXT="6"CREATE Key(10),740,440,75,20Key(10).TEXT="7"CREATE Key(11),832,440,75,20Key(11).TEXT="8"CREATE Key(12),924,440,75,20Key(12).TEXT="9"CREATE Key(13),740,470,75,20Key(13).TEXT="-"CREATE Key(14),832,470,75,20Key(14).TEXT="0"CREATE Key(15),924,470,75,20Key(15).TEXT="."CREATE Key(16),740,500,260,20Key(16).TEXT="ENTER"CREATE IOBackground,300,280,415,400IOBackground.BACKCOLOR=$ffff00CREATE AtoD,320,300,60,20AtoD.ENABLED=FALSEAtoD.TEXT="000"CREATE AtoDLabel,320,320,60,20AtoDLabel.BACKCOLOR=$ffff00AtoDLabel.TEXT="A/D"CREATE Ref,320,340,60,20Ref.TEXT="003"CREATE RefLabel,320,360,60,20RefLabel.BACKCOLOR=$ffff00RefLabel.TEXT="REF"CREATE Sig,320,380,60,20Sig.TEXT="002"CREATE SigLabel,320,400,60,20SigLabel.BACKCOLOR=$ffff00SigLabel.TEXT="SIG"CREATE LampInt,320,420,60,20LampInt.TEXT="001"CREATE LampIntLabel,320,440,60,20LampIntLabel.BACKCOLOR=$ffff00LampIntLabel.TEXT="LAMPINT"CREATE Gnd,320,460,60,20Gnd.TEXT="000"CREATE GndLabel,320,480,60,20GndLabel.BACKCOLOR=$ffff00GndLabel.TEXT="GND"CREATE Switch,320,500,60,20Switch.FORECOLOR=$ffffSwitch.TEXT="VIAL"Switch.BACKCOLOR=$80CREATE Mux,320,540,60,20Mux.ENABLED=FALSEMux.text="Not Set"CREATE MuxLabel,320,560,60,20MuxLabel.BACKCOLOR=$ffff00MuxLabel.TEXT="MUX"CREATE DtoAHi,320,580,60,20DtoAHi.ENABLED=FALSEDtoAHi.TEXT="00"CREATE DtoAHiLabel,320,600,60,20DtoAHiLabel.BACKCOLOR=$ffff00DtoAHiLabel.TEXT="D/A HIGH"CREATE DtoALo,320,620,60,20DtoALo.ENABLED=FALSEDtoALo.TEXT="00"CREATE DtoALoLabel,320,640,60,20DtoALoLabel.BACKCOLOR=$ffff00DtoALoLabel.TEXT="D/A LOW"CREATE ControlRegDisplay,400,300,60,20ControlRegDisplay.ENABLED=FALSEControlRegDisplay.TEXT="00"CREATE ControlRegLabel,400,320,60,20ControlRegLabel.BACKCOLOR=$ffff00ControlRegLabel.TEXT="CNTL"CREATE StatusRegDisplay,400,340,60,20StatusRegDisplay.ENABLED=FALSECREATE StatusRegLabel,400,360,60,20StatusRegLabel.BACKCOLOR=$ffff00StatusRegLabel.TEXT="STAT"StatusRegDisplay.TEXT="1d"CREATE GAX,400,380,20,20GAX.TEXT="A"GAX.FORECOLOR=$ffffGAX.BACKCOLOR=$80CREATE GBX,420,380,20,20GBX.TEXT="B"GBX.FORECOLOR=$ffffGBX.BACKCOLOR=$80CREATE GCX,440,380,20,20GCX.TEXT="C"GCX.FORECOLOR=$ffffGCX.BACKCOLOR=$80CREATE GainLabel,400,400,60,20GainLabel.BACKCOLOR=$ffff00GainLabel.TEXT="GAIN"CREATE DataRdy,400,420,60,20DataRdy.BACKCOLOR=$80DataRdy.FORECOLOR=$ffffDataRdy.TEXT="D Rdy"CREATE DacBt,400,460,60,20DacBt.BACKCOLOR=$80DacBt.FORECOLOR=$ffffDacBt.TEXT="DAC"CREATE RunBit,400,500,60,20RunBit.BACKCOLOR=$80RunBit.FORECOLOR=$ffffRunBit.TEXT="RUN"CREATE TestBit,400,540,60,20TestBit.BACKCOLOR=$80TestBit.FORECOLOR=$ffffTestBit.TEXT="TEST"CREATE StartBit,400,580,60,20StartBit.BACKCOLOR=$80StartBit.FORECOLOR=$ffffStartBit.TEXT="START"CREATE KeyDisplay,400,620,60,20KeyDisplay.TEXT="00"CREATE KeyLabel,400,640,60,20KeyLabel.BACKCOLOR=$ffff00KeyLabel.TEXT="KEY"CREATE ScanDisplay,480,620,60,20ScanDisplay.TEXT="00"CREATE ScanLabel,480,640,60,20ScanLabel.BACKCOLOR=$ffff00ScanLabel.TEXT="SCAN"CREATE TraceBackground,5,10,280,260TraceBackground.BACKCOLOR=$8000CREATE TraceList,10,15,270,230CREATE TraceClear,10,245,270,20TraceClear.TEXT="CLEAR LIST"CREATE SymBackground,300,10,415,260SymBackground.BACKCOLOR=$80CREATE SymList1,305,15,200,250CREATE SymList2,510,15,200,250FOR I=1 TO SymTableSize	HexData=HEX(SymTable(I).SymAddr)	GOSUB Pad4	Symbolic=SymTable(I).SymName	TempStr=HexData+" "+Symbolic	SymList1.ADDITEMSORTED TempStr	TempStr=Symbolic+" "+HexData	SymList2.ADDITEMSORTED TempStrNEXT IGOSUB LoadBinGOSUB ResetButton_COMMANDSETSTYLE SPRegDisplay,$01,TRUEGOSUB ChangeAddr;;;END EVENTAbaX:mov bl,[AccA]add bl,[AccB]mov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAddaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]add bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAddbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]add bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAdcaX:IF CFlag=FALSE THEN	clcELSE	stcEND IFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]add bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAdcbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]add bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAndaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]and bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSEsete [ZFlag]RETURNAndbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]and bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNBitaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]and bl,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNBitbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]and bl,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNClrX:TargetMem(OperandReg+1)=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNClraX:AccA=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNClrbX:AccB=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNCmpaX:IF CFlag=FALSE THEN	clcELSE	stcEND IFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]sub bl,alsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNCmpbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]sub bl,alsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNCbaX:mov bl,[AccA]sub bl,[AccB]setc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNComX:TempByte=TargetMem(OperandReg+1)not alsets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteCFlag=TRUEVFlag=FALSERETURNComaX:mov al,[AccA]not alsets [NFlag]sete [ZFlag]mov [AccA], alCFlag=TRUEVFlag=FALSERETURNCombX:mov al,[AccB]not alsets [NFlag]sete [ZFlag]mov [AccB], alCFlag=TRUEVFlag=FALSERETURNNegX:TempByte=TargetMem(OperandReg+1)neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNNegaX:mov al,[AccA]neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [AccA], alRETURNNegbX:mov al,[AccB]neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [AccB], alRETURNDaaX:; Don't needRETURNDecX:TempByte=TargetMem(OperandReg+1)sub al,1sets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNDecaX:mov al,[AccA]sub al,1sets [NFlag]sete [ZFlag]mov [AccA], alRETURNDecbX:mov al,[AccB]sub al,1sets [NFlag]sete [ZFlag]mov [AccB], alRETURNEoraX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]xor bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNEorbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]xor bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNIncX:TempByte=TargetMem(OperandReg+1)add al,1sets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNIncaX:mov al,[AccA]add al,1sets [NFlag]sete [ZFlag]mov [AccA], alRETURNIncbX:mov al,[AccB]add al,1sets [NFlag]sete [ZFlag]mov [AccB], alRETURNLdaaX:IF ImmFlag=False THEN	IF IOFlag=FALSE THEN		AccA=TargetMem(OperandReg+1)	ELSE		IOCode=LdaaCode		GOSUB ProcIO	END IFELSE	AccA=OperandRegEND IFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNLdabX:IF ImmFlag=False THEN	IF IOFlag=FALSE THEN		AccB=TargetMem(OperandReg+1)	ELSE		IOCode=LdabCode		GOSUB ProcIO	END IFELSE	AccA=OperandRegEND IFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNOraaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]or bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNOrabX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]or bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNPshaX:TargetMem(SPReg+1)=AccADECR SPRegRETURNPshbX:TargetMem(SPReg+1)=AccBDECR SPRegRETURNPulaX:INCR SPRegAccA=TargetMem(SPReg+1)RETURNPulbX:INCR SPRegAccB=TargetMem(SPReg+1)RETURNRolX:IF CFlag=FALSE THEN	clcELSE	stcEND IFTempByte=TargetMem(OperandReg+1)rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNRolaX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccA]rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNRolbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccB]rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNRorX:IF CFlag=FALSE THEN	clcELSE	stcEND IFTempByte=TargetMem(OperandReg+1)rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNRoraX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccA]rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNRorbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccB]rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNAslX:TempByte=TargetMem(OperandReg+1)shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNAslaX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccA]shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNAslbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccB]shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNAsrX:TempByte=TargetMem(OperandReg+1)sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNAsraX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccA]sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNAsrbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccB]sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNLsrX:TempByte=TargetMem(OperandReg+1)shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNLsraX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccA]shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNLsrbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFmov al,[AccB]shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNStaaX:IF IOFlag=FALSE THEN	TargetMem(OperandReg+1)=AccAELSE	IOCode=StaaCode	GOSUB ProcIOEND IFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNStabX:IF IOFlag=FALSE THEN	TargetMem(OperandReg+1)=AccBELSE	IOCode=StabCode	GOSUB ProcIOEND IFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNSubaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]sub bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSubbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]sub bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbaX:mov bl,[AccA]sub bl,[AccB]mov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbcaX:IF CFlag=FALSE THEN	clcELSE	stcEND IFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccA]sub bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbcbX:IF CFlag=FALSE THEN	clcELSE	stcEND IFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegEND IFmov bl,[AccB]sub bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNTabX:AccB=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNTbaX:AccA=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNTstX:TempByte=OperandRegor al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNTstaX:mov al,[AccA]or al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNTstbX:mov al,[AccB]or al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNCpxX:IF ImmFlag=False THEN	GOSUB GetData2END IFIF IndexReg=OperandReg THEN	ZFlag=TRUEELSE	ZFlag=FALSEEND IFVFlag=FALSENFlag=FALSECFlag=FALSE	RETURNDexX:DECR IndexRegsete [ZFlag]CFlag=FALSEVFlag=FALSENFlag=FALSERETURNDesX:DECR SPRegRETURNInxX:INCR IndexRegsete [ZFlag]CFlag=FALSEVFlag=FALSENFlag=FALSERETURNInsX:INCR SPRegRETURNLdxX:IF ImmFlag=False THEN	GOSUB GetData2	IndexReg=OperandRegELSE	IndexReg=OperandRegEND IFVFlag=FALSERETURNLdsX:IF ImmFlag=False THEN	GOSUB GetData2	SPReg=OperandRegELSE	SPReg=OperandRegEND IFVFlag=FALSERETURNStxX:StoreData=IndexReg/256or al,alsets [NFlag]mov [TempByte],alTargetMem(OperandReg+1)=StoreDataStoreData=IndexRegadd al,[TempByte]sete [ZFlag]TargetMem(OperandReg+2)=StoreDataRETURNStsX:StoreData=SPReg/256or al,alsets [NFlag]mov [TempByte],alTargetMem(OperandReg+1)=StoreDataStoreData=IndexRegadd al,[TempByte]sete [ZFlag]TargetMem(OperandReg+2)=StoreDataRETURNTxsX:SPReg=IndexRegRETURNTsxX:IndexReg=SPRegRETURNBraX:PCReg=OperandRegRETURNBccX:IF CFlag=FALSE THEN	PCReg=OperandRegEND IFRETURNBcsX:IF CFlag=TRUE THEN	PCReg=OperandRegEND IFRETURNBeqX:IF ZFlag=TRUE THEN	PCReg=OperandRegEND IFRETURNBgeX:IF NFlag=TRUE AND VFlag=TRUE THEN	PCReg=OperandRegEND IFIF NFlag=FALSE AND VFlag=FALSE THEN	PCReg=OperandRegEND IFRETURNBgtX:IF ZFlag=TRUE THEN	RETURNEND IFIF NFlag=TRUE AND VFlag=TRUE THEN	PCReg=OperandRegEND IFIF NFlag=FALSE AND VFlag=FALSE THEN	PCReg=OperandRegEND IFRETURNBhiX:IF ZFlag=TRUE AND CFlag=TRUE THEN	PCReg=OperandRegEND IFRETURNBleX:IF ZFlag=TRUE THEN	PCReg=OperandRegEND IFIF NFlag=TRUE AND VFlag=TRUE THEN	RETURNEND IFIF NFlag=FALSE AND VFlag=FALSE THEN	RETURNEND IFPCReg=OperandRegRETURNBlsX:IF ZFlag=TRUE OR CFlag=TRUE THEN	PCReg=OperandRegEND IFRETURNBltX:IF NFlag=TRUE AND VFlag=TRUE THEN	RETURNEND IFIF NFlag=FALSE AND VFlag=FALSE THEN	RETURNEND IFPCReg=OperandRegRETURNBmiX:IF NFlag=TRUE THEN	PCReg=OperandRegEND IFRETURNBneX:IF ZFlag=FALSE THEN	PCReg=OperandRegEND IFRETURNBvcX:IF VFlag=FALSE THEN	PCReg=OperandRegEND IFRETURNBvsX:IF VFlag=TRUE THEN	PCReg=OperandRegEND IFRETURNBplX:IF NFlag=FALSE THEN	PCReg=OperandRegEND IFRETURNJmpX:PCReg=OperandReg+1RETURNBsrX:DECR PCRegStoreData=PCReg/256TargetMem(SPReg)=StoreDataStoreData=PCRegTargetMem(SPReg+1)=StoreDataPCReg=OperandRegSPReg=SPReg-2RETURNJsrX:DECR PCRegStoreData=PCReg/256TargetMem(SPReg)=StoreDataStoreData=PCRegTargetMem(SPReg+1)=StoreDataPCReg=OperandReg+1SPReg=SPReg-2RETURNNopX:; Do NothingRETURNRtiX:RETURNRtsX:SPReg=SPReg+2TempInt=TargetMem(SPReg)*256OperandReg=TempInt+TargetMem(SPReg+1)PCReg=OperandReg+1RETURNSwiX:RETURNWaiX:RETURNClcX:CFlag=FALSERETURNCliX:IFlag=FALSERETURNClvX:VFlag=FALSERETURNSecX:CFlag=TRUERETURNSeiX:IFlag=TRUERETURNSevX:VFlag=TRUERETURNTapX:; Don't needRETURNTpaX:; Don't needRETURNImm1X:SymFound=FALSESymbolic=""ImmFlag=TRUEGOSUB GetOp1PCReg=PCReg+2RETURNImm2X:ImmFlag=TRUEGOSUB GetImmOp2PCReg=PCReg+3RETURNDirX:ImmFlag=FALSEGOSUB GetOp1PCReg=PCReg+2RETURNExtX:ImmFlag=FALSEGOSUB GetOp2PCReg=PCReg+3RETURNIndexX:ImmFlag=FALSEGOSUB GetOp1OperandReg=OperandReg+IndexRegPCReg=PCReg+2RETURNInherentX:ImmFlag=FALSEINCR PCRegRETURNRelX:ImmFlag=FALSEGOSUB GetOp1IF OperandReg<128 THEN; Branch Forward	OperandReg=OperandReg+2+PCRegELSE	TempByte=$fe-OperandReg; Branch Backward	OperandReg=PCReg-TempByteEND IFPCReg=PCReg+2RETURNFindSym:IF SymFlag=TRUE THEN	FOR I=1 TO SymTableSize		IF SymTable(I).SymAddr=OperandReg THEN			SymFound=TRUE			Symbolic=SymTable(I).SymName			RETURN		END IF	NEXT IEND IFRETURNTrapX:SymFound=FALSESymbolic=""Timer1.STOPRunFlag=FALSERunLight.BACKCOLOR=$80RunButton.TEXT="RUN"GOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexData;PCReg=PCReg+1RETURNPwrSwitch.COMMANDIF PwrFlag=FALSE THEN	PwrSwitch.BACKCOLOR=$ffELSE	PwrSwitch.BACKCOLOR=$80END IFPwrFlag=NOT(PwrFlag)END EVENTTimerLight.COMMANDIF TimerFlag=FALSE THEN	TimerLight.BACKCOLOR=$ffELSE	TimerLight.BACKCOLOR=$80END IFTimerFlag=NOT(TimerFlag)END EVENTVLight.COMMANDIF VFlag=FALSE THEN	VLight.BACKCOLOR=$ffELSE	VLight.BACKCOLOR=$80END IFVFlag=NOT(VFlag)END EVENTILight.COMMANDIF IFlag=FALSE THEN	ILight.BACKCOLOR=$ffELSE	ILight.BACKCOLOR=$80END IFIFlag=NOT(IFlag)END EVENTNLight.COMMANDIF NFlag=FALSE THEN	NLight.BACKCOLOR=$ffELSE	NLight.BACKCOLOR=$80END IFNFlag=NOT(NFlag)END EVENTZLight.COMMANDIF ZFlag=FALSE THEN	ZLight.BACKCOLOR=$ffELSE	ZLight.BACKCOLOR=$80END IFZFlag=NOT(ZFlag)END EVENTCLight.COMMANDIF CFlag=FALSE THEN	CLight.BACKCOLOR=$ffELSE	CLight.BACKCOLOR=$80END IFCFlag=NOT(CFlag)END EVENTSymLight.COMMANDIF SymFlag=FALSE THEN	SymLight.BACKCOLOR=$ffELSE	SymLight.BACKCOLOR=$80END IFSymFlag=NOT(SymFlag)GOSUB DisplayInstEND EVENTRunButton.COMMANDIF RunFlag=FALSE THEN	RunFlag=TRUE	RunLight.BACKCOLOR=$80	RunButton.TEXT="HALT"	Timer1.TIME=1ELSE	Timer1.STOP	RunFlag=FALSE	RunLight.BACKCOLOR=$80	RunButton.TEXT="RUN"	GOSUB DisplayInst	HexData=HEX(PCReg-1)	GOSUB Pad4	PCRegDisplay.TEXT=HexDataEND IFEND EVENTTimer1.TIMEOUTGOSUB DisplayInstIF RunFlag=FALSE THEN	RETURNEND IFInstReg=TargetMem(PCReg)GOSUB [OpCode(InstReg+1).OpModeDispatch]GOSUB ClassMemGOSUB [OpCode(InstReg+1).OpInstDispatch]IF PCReg-1=BPReg THEN	Timer1.STOP		RunFlag=FALSE	RunLight.BACKCOLOR=$80	RunButton.TEXT="RUN"	GOSUB DisplayInst	HexData=HEX(PCReg-1)	GOSUB Pad4	PCRegDisplay.TEXT=HexData	RETURN;;END IFEND EVENTAddrRegDisplay.CHANGEGOSUB ChangeAddrEND EVENTChangeAddr:TempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)+1TempInt=TargetMem(AddrReg)HexData=HEX(TempInt)GOSUB Pad2DataRegDisplay.TEXT=HexDataRETURNSetPCReg.COMMANDPCRegSet=TRUETempStr=PCRegDisplay.TEXTHexData="$"+TempStrPCReg=VAL(HexData)+1HexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetData.COMMANDTempStr=DataRegDisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)TargetMem(AddrReg)=DataRegGOSUB IncAddr_COMMANDGOSUB ChangeAddrEND EVENTSetAccA.COMMANDTempStr=AccADisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)AccA=DataRegEND EVENTSetAccB.COMMANDTempStr=AccBDisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)AccB=DataRegEND EVENTSetIndexReg.COMMANDTempStr=IndexRegDisplay.TEXTHexData="$"+TempStrIndexReg=VAL(HexData)HexData=HEX(IndexReg)GOSUB Pad4IndexRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetBPReg.COMMANDTempStr=BPRegDisplay.TEXTHexData="$"+TempStrBPReg=VAL(HexData)HexData=HEX(BPReg)GOSUB Pad4BPRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetSPReg.COMMANDTempStr=SPRegDisplay.TEXTHexData="$"+TempStrSPReg=VAL(HexData)HexData=HEX(SPReg)GOSUB Pad4SPRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTPad2:IF LEN(HexData)=1 THEN	TempHexData="0"+HexData	HexData=TempHexDataEND IFRETURNPad4:TempInt=LEN(HexData)SELECT CASE TempInt	CASE 1		TempHexData="000"+HexData	CASE 2		TempHexData="00"+HexData	CASE 3		TempHexData="0"+HexData	CASE 4		TempHexData=HexDataEND SELECTHexData=TempHexDataRETURNIncAddr.COMMANDTempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)INCR AddrRegHexData=HEX(AddrReg)GOSUB Pad4AddrRegDisplay.TEXT=HexDataEND EVENTDecAddr.COMMANDTempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)DECR AddrRegHexData=HEX(AddrReg)GOSUB Pad4AddrRegDisplay.TEXT=HexDataEND EVENT;Key.COMMANDTempInt=ArrayIndexSELECT CASE ScanReg	CASE 1	BPRegDisplay.text=hex(TempInt)		IF TempInt=4 THEN; 1			KeyReg=$08		ELSE			IF TempInt=9 THEN; 6				KeyReg=$04			ELSE				IF TempInt=15 THEN; .					KeyReg=$02				ELSE					IF TempInt=13 THEN; -						KeyReg=$01					END IF				END IF			END IF		END IF	CASE 2		IF TempInt=5 THEN; 2			KeyReg=$08		ELSE			IF TempInt=10 THEN; 7				KeyReg=$04			ELSE				IF TempInt=1 THEN; F1					KeyReg=$02				ELSE					IF TempInt=16 THEN; ENTER						KeyReg=$01					END IF				END IF			END IF		END IF	CASE 4		IF TempInt=6 THEN; 3			KeyReg=$08		ELSE			IF TempInt=11 THEN; 8				KeyReg=$04			ELSE				IF TempInt=2 THEN; F2					KeyReg=$02				END IF			END IF		END IF	CASE 8		IF TempInt=7 THEN; 4			KeyReg=$08		ELSE			IF TempInt=12 THEN; 9				KeyReg=$04			ELSE				IF TempInt=3 THEN; F3					KeyReg=$02				END IF			END IF		END IF	CASE 16		IF TempInt=8 THEN; 5			KeyReg=$08		ELSE			IF TempInt=14 THEN; 0				KeyReg=$04			END IF		END IFEND SELECTHexData=HEX(KeyReg)GOSUB Pad2KeyDisplay.TEXT=HexData;END EVENTLoadButton.COMMANDGOSUB LoadBinEND EVENTLoadBin:OPEN "Romer.bin" FOR INPUT AS BinFileGET BinFile,TargetMemCLOSE BinFileRETURNDisplayInst:TraceAddr=hex(PCReg-1)InstReg=TargetMem(PCReg)TempStr=TraceAddr+" "+OpCode(InstReg+1).OpNameGOSUB ClassMemTempInt=OpCode(InstReg+1).OpModeSymFound=FALSESymbolic=""SELECT CASE TempInt	CASE TRAPMODE	CASE INHERENTMODE		CASE IMM1MODE		GOSUB GetOp1		HexData=HEX(OperandReg)		GOSUB Pad2		TempStr=TempStr+" #$"+HexData	CASE IMM2MODE		GOSUB GetOp2		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad4			TempStr=TempStr+" #$"+HexData		ELSE			TempStr=TempStr+" #"+Symbolic		END IF				CASE DIRECTMODE		GOSUB GetOp1		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad2			TempStr=TempStr+" $00"+HexData		ELSE			TempStr=TempStr+" "+Symbolic		END IF	CASE INDEXEDMODE		GOSUB GetOp1		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad2			TempStr=TempStr+"  $"+HexData+",X"		ELSE			TempStr=TempStr+" "+Symbolic+",X"		END IF		CASE EXTENDEDMODE		GOSUB GetOp2		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad4			TempStr=TempStr+" $"+HexData		ELSE			TempStr=TempStr+" "+Symbolic		END IF	CASE RELATIVEMODE		GOSUB GetOp1		IF OperandReg<128 THEN; Branch Forward			OperandReg=OperandReg+1+PCReg		ELSE			TempByte=$ff-OperandReg			OperandReg=PCReg-TempByte		END IF		GOSUB FindSym		IF SymFound=FALSE THEN			HexData=HEX(OperandReg)			GOSUB Pad2			TempStr=TempStr+" $"+HexData		ELSE			TempStr=TempStr+" "+Symbolic		END IFEND SELECTPrevInst=NextInst.TEXTNextInst.TEXT=TempStrIF StepFlag=TRUE OR RunFlag=TRUE THEN	TraceList.ADDITEM PrevInstEND IFTempInt=TraceList.ITEMCOUNTIF TempInt>14 THEN	TraceList.DELETEITEM 1END IFHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataHexData=HEX(IndexReg)GOSUB Pad4IndexRegDisplay.TEXT=HexDataHexData=HEX(SPReg)GOSUB Pad4SPRegDisplay.TEXT=HexDataHexData=HEX(AccA)GOSUB Pad2AccADisplay.TEXT=HexDataHexData=HEX(AccB)GOSUB Pad2AccBDisplay.TEXT=HexDataIF IFlag=FALSE THEN	ILight.BACKCOLOR=$80ELSE	ILight.BACKCOLOR=$ffEND IFIF NFlag=FALSE THEN	NLight.BACKCOLOR=$80ELSE	NLight.BACKCOLOR=$ffEND IFIF ZFlag=FALSE THEN	ZLight.BACKCOLOR=$80ELSE	ZLight.BACKCOLOR=$ffEND IFIF VFlag=FALSE THEN	VLight.BACKCOLOR=$80ELSE	VLight.BACKCOLOR=$ffEND IFIF CFlag=FALSE THEN	CLight.BACKCOLOR=$80ELSE	CLight.BACKCOLOR=$ffEND IFRETURNGetOp1:OperandReg=TargetMem(PCReg+1)RETURNGetOp2:OperandReg=TargetMem(PCReg+1)*256OperandReg=OperandReg+TargetMem(PCReg+2)RETURNGetImmOp2:OperandReg=TargetMem(PCReg+1)*256or ax,axsets [NFlag]OperandReg=OperandReg+TargetMem(PCReg+2)or ax,axsete [ZFlag]RETURNGetData2:TempInt=TargetMem(OperandReg+1)*256or ax,axsets [NFlag]OperandReg=TempInt+TargetMem(OperandReg+2)or ax,axsete [ZFlag]RETURNGetData2a:TempInt=TargetMem(OperandReg+1)*256OperandReg=TempInt+TargetMem(OperandReg+2)RETURNStepButton.COMMANDIF PCRegSet=False THEN	WARNINGBOX "Program Counter Not Set",TempStr,MB_OK	RETURNEND IFTimer1.STOPRunFlag=FALSERunLight.BACKCOLOR=$80RunButton.TEXT="RUN"GOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB StepCodeStepFlag=FALSEEND EVENTStepCode:InstReg=TargetMem(PCReg)GOSUB [OpCode(InstReg+1).OpModeDispatch]GOSUB ClassMemGOSUB [OpCode(InstReg+1).OpInstDispatch]StepFlag=TRUEGOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataRETURNResetButton.COMMANDTimer1.STOPRunFlag=FALSERunLight.BACKCOLOR=$80RunButton.TEXT="RUN"TraceList.CLEARPCRegSet=TRUEPCReg=TargetMem($ffff)*256PCReg=PCReg+TargetMem($10000)INCR PCRegHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB DisplayInst		RamLight.BACKCOLOR=$80		RomLight.BACKCOLOR=$ff		IOLight.BACKCOLOR=$80END EVENTSwitch.COMMANDIF Vial=FALSE THEN	Switch.BACKCOLOR=$ff	StatusReg=BITSET(StatusReg,5)ELSE	Switch.BACKCOLOR=$80	StatusReg=BITCLR(StatusReg,5)END IFVial=NOT(Vial)HexData=HEX(StatusReg)GOSUB Pad2StatusRegDisplay.TEXT=HexDataEND EVENTDataRdy.COMMANDIF DataRdyFlag=FALSE THEN	DataRdy.BACKCOLOR=$ff	StatusReg=BITSET(StatusReg,6)ELSE	DataRdy.BACKCOLOR=$80	StatusReg=BITCLR(StatusReg,6)END IFDataRdyFlag=NOT(DataRdyFlag)HexData=HEX(StatusReg)GOSUB Pad2StatusRegDisplay.TEXT=HexDataEND EVENTDacBt.COMMANDIF DacBtFlag=FALSE THEN	DacBt.BACKCOLOR=$ff	StatusReg=BITSET(StatusReg,7)ELSE	DacBt.BACKCOLOR=$80	StatusReg=BITCLR(StatusReg,7)END IFDacBtFlag=NOT(DacBtFlag)HexData=HEX(StatusReg)GOSUB Pad2StatusRegDisplay.TEXT=HexDataEND EVENTTraceClear.COMMANDTraceList.CLEAREND EVENTClassMem:IF ImmFlag=FALSE THEN	IF OperandReg>=$6000 AND OperandReg<$8000 THEN		RamLight.BACKCOLOR=$80		RomLight.BACKCOLOR=$80		IOLight.BACKCOLOR=$ff		IOFlag=TRUE	ELSE		IF OperandReg>=$0000 AND OperandReg<$2000 THEN			RamLight.BACKCOLOR=$ff			RomLight.BACKCOLOR=$80			IOLight.BACKCOLOR=$80			IOFlag=FALSE		ELSE			RamLight.BACKCOLOR=$80			RomLight.BACKCOLOR=$ff			IOLight.BACKCOLOR=$80			IOFlag=FALSE		END IF	END IFELSE	RamLight.BACKCOLOR=$80	RomLight.BACKCOLOR=$ff	IOLight.BACKCOLOR=$80	IOFlag=FALSE	END IFRETURNProcIO:SELECT CASE OperandReg	CASE $7007		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				ControlReg=AccA			ELSE				ControlReg=AccB					END IF			HexData=HEX(ControlReg)			GOSUB Pad2			ControlRegDisplay.TEXT=HexData			TempByte=LAND(ControlReg,$f0)			IF TempByte=0 THEN				Mux.TEXT="Gnd"				AtoD.TEXT=Gnd.TEXT			ELSE				IF TempByte=$30 THEN					Mux.TEXT="Lamp"					AtoD.TEXT=LampInt.TEXT				ELSE					IF TempByte=$50 THEN						Mux.TEXT="Sig"						AtoD.TEXT=Sig.TEXT					ELSE						IF TempByte=$90 THEN							Mux.TEXT="Ref"							AtoD.TEXT=Ref.TEXT						ELSE							Mux.TEXT="BAD"						END IF					END IF				END IF			END IF			IF BITTST(ControlReg,0)=TRUE THEN				GAX.BACKCOLOR=$ff			ELSE				GAX.BACKCOLOR=$80			END IF			IF BITTST(ControlReg,1)=TRUE THEN				GBX.BACKCOLOR=$ff			ELSE				GBX.BACKCOLOR=$80			END IF			IF BITTST(ControlReg,2)=TRUE THEN				GCX.BACKCOLOR=$ff			ELSE				GCX.BACKCOLOR=$80			END IF		END IF	CASE $7001		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				DtoALoReg=AccA			ELSE				DtoALoReg=AccB					END IF			HexData=HEX(DtoALoReg)			GOSUB Pad2			DtoALo.TEXT=HexData		END IF	CASE $7002		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				DtoAHiReg=AccA			ELSE				DtoAHiReg=AccB					END IF			HexData=HEX(DtoAHiReg)			GOSUB Pad2			DtoAHi.TEXT=HexData			IF BITTST(DtoAHiReg,5)=FALSE THEN				RunBit.BACKCOLOR=$ff			ELSE				RunBit.BACKCOLOR=$80			END IF			IF BITTST(DtoAHiReg,6)=TRUE THEN				TestBit.BACKCOLOR=$ff			ELSE				TestBit.BACKCOLOR=$80			END IF			IF BITTST(DtoAHiReg,7)=TRUE THEN				StartBit.BACKCOLOR=$ff			ELSE				StartBit.BACKCOLOR=$80			END IF					END IF		IF IOCode=LdaaCode OR IOCode=LdabCode THEN			IF IOCode=LdaaCode THEN				AccA=StatusReg			ELSE				AccB=StatusReg				END IF		END IF	CASE $7003		IF IOCode=StaaCode OR IOCode=StabCode THEN			IF IOCode=StaaCode THEN				ScanReg=AccA			ELSE				ScanReg=AccB					END IF			HexData=HEX(ScanReg)			GOSUB Pad2			ScanDisplay.TEXT=HexData		END IF		IF IOCode=LdaaCode OR IOCode=LdabCode THEN			IF IOCode=LdaaCode THEN				AccA=KeyReg			ELSE				AccB=KeyReg				END IF		END IFEND SELECTRETURNRef.CHANGEEND EVENTSig.CHANGEEND EVENTGnd.CHANGEEND EVENTLampInt.CHANGEEND EVENTKeyDisplay.CHANGETempStr2=KeyDisplay.TEXTTempStr="$"+TempStr2KeyReg=VAL(TempStr)END EVENTScanDisplay.CHANGETempStr2=ScanDisplay.TEXTTempStr="$"+TempStr2ScanReg=VAL(TempStr)END EVENTOBMain.MOUSEMOVEGETCURSORPOSITIONScreenToClient OBMainIF CursorPosX>730 AND CursorPosX<1010 THEN	IF CursorPosY>280 AND CursorPosY<680 THEN		OBMain.SETCAPTURE		Captured=TRUE		;ResetButton.text="capture"	END IFEND IFIF Captured=FALSE THEN	RETURNEND IFIF CursorPosX<730 OR CursorPosX>1010 OR CursorPosY<280 OR CursorPosY>680 THEN	RELEASECAPTURE	Captured=FALSE	;ResetButton.text="release"	RETURNEND IFmov eax,!Keymov [DescAddr],eaxFOR K=1 TO 16	SETVECTOR Descriptor=DescAddr+(K-1)*768	IF CursorPosX<Descriptor(5) OR CursorPosY<Descriptor(6) OR CursorPosX>Descriptor(7) OR CursorPosY>Descriptor(8) THEN		KeyHandle=0	ELSE		KeyHandle=Descriptor(1)		GOTO KeyFound	END IFNEXT KKeyFound:END EVENTOBMain.LBUTTONDOWNIF KeyHandle<>0 THEN	Key(K).PUSHED=TRUE	KeyDown=K	Line1.text=str(K)END IFEND EVENTOBMain.LBUTTONUPIF KeyHandle<>0 THEN	Key(K).PUSHED=FALSE	KeyDown=0	Line1.text="0"END IFEND EVENT