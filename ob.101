; OmniBasic Copyright 1995-2006 Innomation Systems, Inc.; All Rights Reserved;; This source file is provided for educational, documentary, and porting; purposes only. The recipient agrees to hold this information in strict; confidence. The recipient agrees to these terms by accepting this software; source code. Violations may result in criminal and/or civil penalties under; the copyright and trade secret laws of the United States of America.; Edition History; 10-19-02 OmniBasic release 1.44 as base for adaptation; 11-16-02 Began conversion to x86 asm; 01-22-05 Converted to IDE$exok; ************************************ IDE DIM's Here ********************************************MACRO DestroyWindow	invoke DestroyWindow,[~1] END MACRODECLARE FCN Root(STRING) AS STRINGDIM RootPtr AS LONGDIM EditPopUp AS MENUDIM FormPopUp AS MENUDIM EventPopUp AS MENUDIM GridSizePopUp AS MENUDIM GridColorPopUp AS MENUdim dbgwin as formdim dbggrid as ragriddim controlndx AS textboxdim controlptr AS textboxdim controlcount AS textboxdim controlname AS textboxdim controlptrsafe AS textboxdim lastcontrol as textboxdim controlndxlbl AS statictextdim controlptrlbl AS statictextdim controlcountlbl AS statictextdim controlnamelbl AS statictextdim controlptrsafelbl AS statictextdim lastcontrollbl as statictextdim refresh as buttondim showcclipboard as checkboxTYPE PuppetData	PuppetHandle AS LONG	PuppetID AS LONG	PuppetOwner AS LONG	PuppetArrayNdx AS LONG	PuppetLeft AS LONG	PuppetTop AS LONG	PuppetWidth AS LONG	PuppetHeight AS LONG	PuppetBackColor AS LONG	PuppetForeColor AS LONG	PuppetType AS LONG	PuppetStatus AS LONG	PuppetFamily AS LONG	PuppetGroup AS LONG	PuppetChildXOffs AS LONG	PuppetChildYOffs AS LONG	PuppetReserved AS LONG	PuppetEars(4) AS LONG	PuppetControlType AS LONG	PuppetArraySize AS LONG	PuppetFont AS LONG	PuppetForm AS LONG	PuppethwndCombo AS LONG	PuppethwndItem AS LONG	PuppethwndList AS LONG	PuppetIcon AS LONG	PuppetStyle AS LONG	PuppetExStyle AS LONG	PuppetText AS STRING*32	PuppetName AS STRING*32	PuppetImage AS STRING*32	PuppetToolTip AS STRING*32END TYPECONST ControlTableSize=800DIM ControlArray(ControlTableSize) AS PuppetDataDIM ToolBlockSize AS LONGDIM ClipBoard(ControlTableSize) AS PuppetDataDIM ClipBoardPtr AS LONGDIM ClipBoardNdx AS LONGDIM ClipBoardItemCount AS LONGDIM PasteX AS LONGDIM PasteY AS LONGDIM LowestClipBoardX AS LONGDIM LowestClipBoardY AS LONG;Spider ConstantsCONST Belly=1CONST NW=2CONST N=3CONST NE=4CONST W=5CONST E=6CONST SW=7CONST S=8CONST SE=9CONST MoveCount=10DIM FirstArrayPtr AS LONGDIM HighestArrayNdx AS LONGDIM ArrayNdx AS LONGDIM ControlID AS LONGDIM PuppetIDDispenser(ControlTableSize) AS BOOLEANDIM ControlNdx AS LONG; For lookupsDIM ControlPtr AS LONG; For referencesDIM ControlPtrSafe AS LONGDIM DeletePtr AS LONGDIM PlacePtr AS LONGDIM ControlNamePtr AS LONGDIM ControlCount AS LONGDIM ControlFound AS BOOLEANDIM MoveControl AS BOOLEANDIM MultiItemMove AS BOOLEANDIM MultiDelete AS BOOLEANDIM DrawBox AS BOOLEANDIM PlacePart AS BOOLEANDIM PlaceArray AS BOOLEANDIM FormNotChanged AS BOOLEANDIM SnapToGrid AS BOOLEANDIM ShowGrid AS BOOLEANDIM SizeControl AS BOOLEANDIM ComboFlag AS BOOLEANDIM CaptureEnabled AS BOOLEANDIM GridSize AS LONGDIM GridColor AS LONGDIM SizeSel AS LONGDIM ControlName AS STRING*32DIM TempControlName AS STRING*32DIM HiliteControlName AS STRING*32DIM ControlNameSafe AS STRING*32DIM OwnerName AS STRING*32DIM OwnerPtr AS LONGDIM DeleteOwnerPtr AS LONGDIM CurrentFormPtr AS LONGDIM CurrentFormName AS STRING*32DIM LastControl AS LONGDIM OverControl AS LONGDIM TempStyle AS LONGDIM TempExStyle AS LONGDIM TempHandle AS LONGDIM EarHandle AS LONGDIM EarLeft AS LONGDIM EarTop AS LONGDIM TempOwner AS LONGDIM TempOwnerForm AS LONGDIM TempControlType AS LONGDIM TempLeft AS LONGDIM TempTop AS LONGDIM TempWidth AS LONGDIM TempHeight AS LONGDIM ChildXOffs AS LONGDIM ChildYOffs AS LONGDIM SpiderLeft AS LONGDIM SpiderTop AS LONGDIM SpiderWidth AS LONGDIM SpiderHeight AS LONGDIM SpiderRight AS LONGDIM SpiderBottom AS LONGDIM BoxLeft AS LONGDIM BoxTop AS LONGDIM BoxRight AS LONGDIM BoxBottom AS LONGDIM MultiSelectItemCount AS LONGDIM LeftButtonX AS LONGDIM LeftButtonY AS LONGDIM DeltaX AS LONGDIM DeltaY AS LONGDIM ControlLeft AS LONGDIM ControlTop AS LONGDIM ControlRight AS LONGDIM ControlBottom AS LONGDIM MouseOffsX AS LONGDIM MouseOffsY AS LONGDIM CleanCtr AS LONGDIM EventMenuCount AS LONGDIM Timer1 AS TIMERDIM Timer2 AS TIMERDIM Timer3 AS TIMERDIM Timer4 AS TIMERDIM Timer5 AS TIMERDIM MoveCtr AS LONGDIM LBDown AS BOOLEANDIM RBDown AS BOOLEANDIM Spider(9) AS STATICTEXTDIM SpiderNdx AS LONGDIM SpiderPtr AS LONGDIM SpiderPlaced AS BOOLEANDIM SpiderFound AS BOOLEANDIM MultiFrame AS STATICTEXTDIM MultiFrameLeft AS LONGDIM MultiFrameTop AS LONGDIM MultiFrameWidth AS LONGDIM MultiFrameHeight AS LONGDIM MultiFrameDeltaX AS LONGDIM MultiFrameDeltaY AS LONGDIM CursorSafe AS CURSORDIM NewWindow AS TOOLWINDOWDIM NewButtonCode AS LONGDIM NewButton(8) AS BUTTONDIM CancelButton AS BUTTONDIM NewName AS TEXTBOXDIM NewLabel AS STATICTEXTDIM NewOKButton AS BUTTONDIM NewCancelButton AS BUTTONDIM ArrayWindow AS FORMDIM ArrayName AS TEXTBOXDIM ArrayNameLbl AS STATICTEXTDIM ArrayCancel AS ButtonExDIM ArrayPlace AS ButtonExDIM ArrayRows AS TEXTBOXDIM ArrayCols AS TEXTBOXDIM ArrayHSpacing AS TEXTBOXDIM ArrayRowsLbl AS STATICTEXTDIM HeightLbl AS STATICTEXTDIM ArrayVSpacing AS TEXTBOXDIM HSpaceLbl AS STATICTEXTDIM VSpaceLbl AS STATICTEXTDIM GotoWindow AS TOOLWINDOWDIM GotoText AS TEXTBOXDIM GotoButton AS BUTTONDIM ScratchPadWindow AS TOOLWINDOWDIM ScratchPadText AS TEXTBOXDIM ViewAutoCodeWindow AS TOOLWINDOWDIM ViewAutoCodeText AS TEXTBOXDIM FindWindow AS TOOLWINDOWDIM FindWindowActive AS BOOLEANDIM UpDown AS FRAMEDIM UpButton AS RADIOBUTTONDIM DownButton AS RADIOBUTTONDIM MatchWholeWord AS CHECKBOXDIM MatchCase AS CHECKBOXDIM FindNext AS BUTTONDIM Cancel AS BUTTONDIM FindText AS TEXTBOXDIM FindWhat AS STATICTEXTDIM FindReplaceWindow AS TOOLWINDOWDIM FRWindowActive AS BOOLEANDIM FRMatchWholeWord AS CHECKBOXDIM FRMatchCase AS CHECKBOXDIM FRFindNext AS BUTTONDIM FRReplace AS BUTTONDIM FRReplaceAll AS BUTTONDIM FRCancel AS BUTTONDIM FRFindText AS TEXTBOXDIM FRReplaceText AS TEXTBOXDIM FRFindWhat AS STATICTEXTDIM FRReplaceWith AS STATICTEXTDIM Button(23) AS BUTTONDIM EventCombo1 AS COMBOBOXDIM EventCombo2 AS COMBOBOXDIM QuickFind AS TEXTBOXDIM QuickFindPrev AS BUTTONDIM QuickFindNext AS BUTTONDIM sbParts(5) AS LONGDIM ClearToolsFlag AS BOOLEANDIM LoadToolsFlag AS BOOLEANDIM ProjectFlag AS BOOLEANDIM ToolBox AS FORMDIM ToolButton(40) AS BUTTONDIM FormCombo AS COMBOBOXDIM ControlCombo AS COMBOBOXDIM PropGrid AS RAGRIDDIM StyleGrid AS RAGRIDDIM ExStyleGrid AS RAGRIDDIM FormWindow AS FORMDIM ProcWindow AS TOOLWINDOWDIM ProcList AS LISTBOXDIM ProcType AS LONGDIM MinMaxFlag AS BOOLEANDIM StyleGridRow AS LONGDIM ExStyleGridRow AS LONGDIM UnDoFlag AS BOOLEANDIM ReDoFlag AS BOOLEANDIM OpenFlag AS BOOLEANDim lf As LOGFONTDim lRet AS LONGDim szFont AS STRINGDIM szRegs AS STRING*1000DIM szAsmInst AS STRING*1000DIM szBasicInst AS STRING*1000DIM szGUIInst AS STRING*1000DIM szGUIProps AS STRING*1000DIM szGUIProps2 AS STRING*1000DIM szMasm AS STRING*1000DIM szFcns AS STRING*1000DIM szDataType AS STRING*1000DIM szDirective AS STRING*1000DIM szControlNames AS STRING*10000DIM LF1 AS LOGFONTDIM Font1 AS FONTDIM GridFont AS FONTDIM OmniIcon AS ICONDIM ToolBitmap AS BITMAPDIM ToolIcon AS ICONDIM FormBMP AS BITMAPDIM ButtonBMP AS BITMAPDIM StaticTextBMP AS BITMAPDIM FrameBMP AS BITMAPDIM SliderBMP AS BITMAPDIM TextBoxBMP AS BITMAPDIM ComboBoxBMP AS BITMAPDIM ListBoxBMP AS BITMAPDIM RadioButtonBMP AS BITMAPDIM CheckBoxBMP AS BITMAPDIM ProgressBarBMP AS BITMAPDIM CalendarBMP AS BITMAPDIM TabFolderBMP AS BITMAPDIM SpinnerBMP AS BITMAPDIM StatusBarBMP AS BITMAPDIM HeaderBMP AS BITMAPDIM AnimateBMP AS BITMAPDIM RichEditBMP AS BITMAPDIM RAEditBMP AS BITMAPDIM RAGridBMP AS BITMAPDIM ListViewBMP AS BITMAPDIM ToolBarBMP AS BITMAPDIM TreeViewBMP AS BITMAPDIM DateTimePickBMP AS BITMAPDIM ImageBMP AS BITMAPDIM DrawProgressBMP AS BITMAPDIM NewBMP AS BITMAPDIM OpenBMP AS BITMAPDIM SaveBMP AS BITMAPDIM SaveAsBMP AS BITMAPDIM PrintBMP AS BITMAPDIM ToolBMP AS BITMAPDIM EditBMP AS BITMAPDIM UndoBMP AS BITMAPDIM RedoBMP AS BITMAPDIM DeleteBMP AS BITMAPDIM CutBMP AS BITMAPDIM CopyBMP AS BITMAPDIM PasteBMP AS BITMAPDIM GotoBMP AS BITMAPDIM FindBMP AS BITMAPDIM ReplaceBMP AS BITMAPDIM CompileToExeBMP AS BITMAPDIM CompileToAsmBMP AS BITMAPDIM CompileForErrBMP AS BITMAPDIM CompileForDebugBMP AS BITMAPDIM SymbolsBMP AS BITMAPDIM UnusedSymBMP AS BITMAPDIM RunBMP AS BITMAPDIM HelpBMP AS BITMAPDIM QFindNextBMP AS BITMAPDIM QFindPrevBMP AS BITMAPDIM font AS FONTDIM RAFont(3) AS FONTDIM Edit AS RAEDITDIM SymbolGrid AS RAGRIDDIM BackGround AS STATICTEXTDIM StatusBar AS STATUSBARDIM ToolBar AS TOOLBARDIM FileName AS STRINGDIM FileNameSafe AS STRINGDIM BMPFileName AS STRINGDIM SaveFileName AS STRINGDIM SourceFileName AS STRINGDIM FileFilter AS TEXTDIM BMPFileFilter AS TEXTDIM Extension AS STRING*4DIM InitDir AS STRINGDIM BMPInitDir AS STRINGDIM Changed AS BOOLEANDIM BasicAsm AS BOOLEANDIM TempBool AS BOOLEANDIM TextMode AS BOOLEANDIM ToolView AS BOOLEANDIM PropView AS BOOLEANDIM StyleView AS BOOLEANDIM ShowSymbols AS BOOLEANDIM FindStr AS STRINGDIM SelectStr AS STRINGDIM ReplaceStr AS STRINGDIM FontStr AS STRINGDIM RGB AS LONGDIM row AS LONGDIM col AS LONGDIM StatusBarSafe1 AS STRING*32DIM StatusBarSafe2 AS STRING*32DIM StatusBarSafe3 AS STRING*32DIM StatusBarSafe4 AS STRING*32;*********************************** Compiler Macros, DIM's, CONST's etc *************************; MACROSMACRO GenConst	CONST ~2=~3	CONST ptr~2=~3-99	OutBuf="!~1_~2 equ ~3"	CALL SUB OutUninitDataEND MACROMACRO IncArrayNdx	CALL SUB IncrArrayNdxEND MACROMACRO DecArrayNdx	CALL SUB DecrArrayNdxEND MACROMACRO GenEquate	CONST ~1=~2	OutBuf="~1 equ ~2"	CALL SUB OutDeclareEND MACROMACRO IncExpNdx	INCR ExpNdx	ExpLen=ExpNdxEND MACROMACRO CommaRet	CALL SUB GetComma	ErrRetEND MACROMACRO CommaMain	CALL SUB GetComma	ErrMainEND MACROMACRO ColonRet	CALL SUB GetColon	ErrRetEND MACROMACRO ColonMain	CALL SUB GetColon	ErrMainEND MACROMACRO EqualRet	CALL SUB GetEqual	ErrRetEND MACROMACRO EqualMain	CALL SUB GetEqual	ErrMainEND MACROMACRO MakeLong	IF LAND(TDataMod,PointerBit)=PointerBit THEN		TDataType=LONGVAR	END IFEND MACROMACRO ErrRet	IF ErrNo<>0 THEN		RETURN	END IFEND MACROMACRO ErrMain	IF ErrNo<>0 THEN MainLoopEND MACROMACRO ErrGUI	IF GUIFlag=FALSE THEN GUIFatalEND MACROENUM 1	ErrUDSym	ErrIVSNam	ErrTypMis	ErrIVExp	ErrSyntax	ErrDupSym	ErrSymFul	ErrUDFcn	ErrIVType	ErrIVMod	ErrMacArg	ErrIVDir	ErrDupMac	ErrEndStr	ErrMacNst	ErrMacBuf	ErrIVMac	ErrEndm	ErrUBCon	ErrNDeep	ErrDecFcn	ErrIVParm	ErrParam	ErrCpxExp	ErrIVFunc	ErrTmpUse	ErrParen	ErrFcn	ErrIVTarget	ErrFSNest	ErrTblArr	ErrEndFcn	ErrArrSub	ErrEndProc	ErrEndTbl	ErrTblArgs	ErrFcnArgs	ErrTypeFcn	ErrDupEvent	ErrIVProp	ErrEndEvent	ErrOpRange	ErrTextArray	ErrTextDefined	ErrTextNotDefined	ErrEndTask	ErrEndSub	ErrExitEvent	ErrExitProc	ErrExitTask	ErrExitSub	ErrExitSeg	ErrEndSeg	ErrSegInSeg	ErrDeviceEND ENUMENUM 0	COMPVAR	BOOLVAR	BYTEVAR	WORDVAR	LONGVAR	FLOATVAR	STRINGVAR	LABELVAR	MACROVAR	OPER	FCN	PROC	TYPE	VOIDX	COMPLEX	BUFFER	LABELPTR	TEXT	OBCOMM	TIMEDIF	QUADVAREND ENUMENUM 0	NONE	FILE	DEVICE	FONT	ICON	CURSOR	BITMAP	HANDLE	MENU	TASK	PIPE	IMAGELIST	SOLIDBRUSH	HATCHBRUSH	PATTERNBRUSH	PENEND ENUMCONST STYLE=1CONST EXSTYLE=2ENUM 1	STDCTL	COMCTL	CUSCTL	DLLCTL	TIMCTL	OCXCTLEND ENUM; Must keep this ENUM in sync with ImportLibTableENUM 1	ptrkernel32	ptruser32	ptrgdi	ptrcomctl	ptrcomdlg	ptrshell	ptradvapi	ptrwinmm	ptrmsvcrt	ptrcsmdll	ptrrichedit	ptrimagelib	ptrziplibEND ENUM; Must keep this ENUM in sync with ImportFcnTableENUM 1	ptrBeep	ptrSetThreadPriority	ptrSleep	ptrCreateThread	ptrSuspendThread	ptrResumeThread	ptrClearCommError	ptrCloseHandle	ptrCreateDirectory	ptrCreateFile	ptrCreatePipe	ptrCreateProcess	ptrDeleteFile	ptrExitProcess	ptrGetCommandLine	ptrGetCurrentProcess	ptrGetCurrentDirectory	ptrGetFileSize	ptrGetFileType	ptrGetFullPathName	ptrGetLastError	ptrGetModuleHandle	ptrGetStdHandle	ptrGetTickCount	ptrGetSystemTime	ptrGetLocalTime	ptrGetDateFormat	ptrGetTimeFormat	ptrFileTimeToSystemTime	ptrSystemTimeToFileTime	ptrLoadLibrary	ptrReadConsole	ptrReadFile	ptrRemoveDirectory	ptrSetCurrentDirectory	ptrSetCommMask	ptrGetCommState	ptrSetCommState	ptrSetFilePointer	ptrSetEndOfFile	ptrVirtualAlloc	ptrVirtualFree	ptrWinExec	ptrWriteConsole	ptrWriteFile	ptrAppendMenu	ptrBeginPaint	ptrEndPaint	ptrDrawTextEx	ptrGetDC	ptrGetFocus	ptrGetSysColor	ptrReleaseDC	ptrCallWindowProc	ptrCheckDlgButton	ptrCheckMenuItem	ptrCheckRadioButton	ptrChildWindowFromPoint	ptrCreateIconFromResourceEx	ptrCreateMenu	ptrCreatePopupMenu	ptrCreateWindowEx	ptrDefWindowProc	ptrDeleteMenu	ptrDestroyWindow	ptrDispatchMessage	ptrDrawMenuBar	ptrEnableMenuItem	ptrEnableWindow	ptrFlashWindow	ptrGetAncestor	ptrGetClientRect	ptrGetComboBoxInfo	ptrGetCursorPos	ptrSetCursorPos	ptrGetCursor	ptrSetCursor	ptrGetMessage	ptrGetActiveWindow	ptrGetParent	ptrGetWindowRect	ptrIsIconic	ptrHiliteMenuItem	ptrInvalidateRect	ptrInsertMenu	ptrInsertMenuItem	ptrIsWindowEnabled	ptrIsWindowVisible	ptrKillTimer	ptrLoadCursor	ptrLoadIcon	ptrLoadImage	ptrLoadMenu	ptrMessageBox	ptrModifyMenu	ptrPostMessage	ptrMoveWindow	ptrPostQuitMessage	ptrRedrawWindow	ptrRegisterClass	ptrRegisterWindowMessage	ptrReleaseCapture	ptrRemoveMenu	ptrScreenToClient	ptrSendMessage	ptrSetCapture	ptrSetClassLong	ptrSetFocus	ptrSetMenu	ptrSetMenuItemBitmaps	ptrSetTimer	ptrGetWindowLong	ptrSetWindowLong	ptrSetWindowPos	ptrShowWindow	ptrUpdateWindow	ptrTrackPopupMenuEx	ptrTranslateMessage	ptrCreateCompatibleDC	ptrCreateDIBSection	ptrCreateFontIndirect	ptrCreateSolidBrush	ptrCreateHatchBrush	ptrCreatePatternBrush	ptrGetBrushOrgEx	ptrSetBrushOrgEx	ptrDeleteObject	ptrGetPixel	ptrSetPixel	ptrCreatePen	ptrLineTo	ptrEllipse	ptrRectangle	ptrRoundRect	ptrSelectObject	ptrMoveToEx	ptrAngleArc	ptrArc	ptrArcTo	ptrGetDirection	ptrPolyBezier	ptrPolyBezierTo	ptrPolyDraw	ptrPolyline	ptrPolylineTo	ptrPolyPolyline	ptrSetArcDirection	ptrGetBkColor	ptrSetBkColor	ptrSetBkMode	ptrGetStockObject	ptrSetTextColor	ptrInitCommonControlsEx	ptrImageListCreate	ptrImageListAdd	ptrImageListAddIcon	ptrTrackMouseEvent	ptrChooseFont	ptrChooseColor	ptrGetOpenFileName	ptrGetSaveFileName	ptrFindText	ptrReplaceText	ptrDragAcceptFiles	ptrShellExecute	ptrShellNotifyIcon	ptrRegCreateKeyEx	ptrRegCloseKey	ptrsndPlaySound	ptrabs	ptratol	ptrltoa	ptrprintf	ptrputs	ptrsprintf	ptrsystem	ptrCSMGetDriveHandle	ptrCSMDriveStatus	ptrCSMReadBlock	ptrCSMReleaseDriveHandle	ptrCSMWriteBlock	ptrCreateTextServices	ptrBitmapFromFile	ptrBitmapFromMemory	ptrBitmapFromPicture	ptrBitmapFromResource	ptrzOpenZipFile	ptrzCloseZipFile	ptrzGetTotalFiles	ptrzGetTotalBytes	ptrzGetSelectedFiles	ptrzGetSelectedBytes	ptrzGetLastErrorAsText	ptrzGetSkippedFiles	ptrzGetRunTimeInfo	ptrzCancelOperation	ptrzExtractOne	ptrzExtractSelected	ptrzExtractAll	ptrzGetFileName	ptrzGetFileExt	ptrzGetFilePath	ptrzGetFileDate	ptrzGetFileTime	ptrzGetFileSize	ptrzGetCompressedFileSize	ptrzFileIsEncrypted	ptrzGetLastOperResult	ptrzFileIsSelected	ptrzSelectFile	ptrzUnselectAll	ptrzSelectByWildcards	ptrzCreateNewZip	ptrzOrderFile	ptrzOrderByWildcards	ptrzCompressFiles	ptrzDeleteFiles	ptrzGetOrderedFiles	ptrzGetOrderedBytes	ptrzGetComment	ptrzIsSpannedEND ENUMCONST ArrayBit=$00000001CONST PointerBit=$00000002CONST ConstBit=$00000004CONST MultiBit=$00000008CONST MemberBit=$00000010CONST VectorBit=$00000020CONST TempBit=$00000040CONST DataBit=$00000080CONST ReDimBit=$00000100CONST UsrFcnBit=$00000200CONST CalledBit=$00000400CONST SubClassedBit=$00000800CONST DateTimeBit=$00001000CONST TextDefinedBit=$00002000CONST LogFontBit=$00004000CONST InitDataBit=$00008000CONST LocalBit=$00010000CONST TmpVec=$60CONST ArrayMsk=$fffeCONST evActivateUsed=0CONST evCommandUsed=1CONST evLBDownUsed=2CONST evSpareUsed=3CONST evLButtonDownUsed=4CONST evLButtonUpUsed=5CONST evScrollUsed=6CONST evSysCommandUsed=7CONST evKeyDownUsed=8CONST evKeyUpUsed=9CONST evClickUsed=10CONST evChangeUsed=11CONST evSelectUsed=12CONST evCreateUsed=13CONST evResizeUsed=14CONST evMoveUsed=15CONST evMouseActivateUsed=16CONST evPaintUsed=17CONST evSpareUsed=18CONST evMouseMoveUsed=19CONST evMouseWheelUsed=20CONST evDestroyUsed=21CONST evDblClickUsed=22CONST evRButtonDownUsed=23CONST evRButtonUpUsed=24CONST evContextMenuUsed=25CONST evKeyStruckUsed=26CONST evReserved3Used=27CONST evReserved4Used=28CONST evReserved5Used=29CONST evReserved6Used=30CONST evReserved7Used=31CONST evNotify1Used=32CONST evNotify2Used=33CONST evNotify3Used=34CONST evNotify4Used=35CONST evNotify5Used=36CONST evNotify6Used=37CONST evNotify7Used=38CONST evNotify8Used=39CONST evNotify9Used=40CONST evNotify10Used=41CONST evNotify11Used=42CONST evNotify12Used=43CONST evNotify13Used=44CONST evNotify14Used=45CONST evNotify15Used=46CONST evNotify16Used=47CONST evNotify17Used=48CONST evNotify18Used=49CONST evNotify19Used=50CONST evNotify20Used=51CONST evNotify21Used=52CONST evNotify22Used=53CONST evNotify23Used=54CONST evNotify24Used=55CONST evNotify25Used=56CONST evNotify260Used=57CONST evNotify271Used=58CONST evNotify28Used=59CONST evNotify29Used=60CONST evNotify30Used=61CONST evNotify31Used=62CONST evNotify32Used=63CONST NULLClass=0CONST INTClass=1CONST STRClass=2CONST ARRClass=3CONST CPXClass=4CONST FLTClass=5CONST BOOLClass=6CONST OBJClass=7CONST FRMClass=8CONST LBLClass=9CONST TTypRelOp=1CONST TTypPunct=2CONST TTypMath=3CONST TTypQuote=4CONST TTypSym=5CONST TTypInt=6CONST TTypHex=7CONST TTypParen=8CONST TTypMisc=9CONST TTypFloat=10CONST TTypOct=11CONST TTypBin=12CONST PTArrOpn=3CONST PTArrCls=4CONST PTFcnOpn=5CONST PTFcnCls=6CONST PTCpxOpn=24CONST PTFCpxCls=25CONST NumTemps=15CONST OBQUOTE=$22CONST LabelResolved=$ffCONST LabelUnresolved=0CONST _BufSize=1000CONST MacBufSiz=50000CONST ExpTabSiz=300CONST UserSym=307;  set to first user symbol in PreDefinedCONST SymTabSiz=4000; Asm Constants and VariablesTYPE IconDirData	idReserved AS INTEGER	idType AS INTEGER	idCount AS INTEGEREND TYPETYPE IconEntryData	bWidth AS BYTE	bHeight AS BYTE	bColorCount AS BYTE	bReserved AS BYTE	wPlanes AS INTEGER	wBitCount AS INTEGER	dwBytesInRes AS LONG	dwImageOffset AS LONGEND TYPEDIM ToolPropMapCount(50) AS LONGDIM IconDir AS IconDirDataDIM IconEntry AS IconEntryDataDIM IconDirEntries AS LONGDIM ErrLineNum AS LONGDIM IconSize AS BYTEDIM TextFound AS BOOLEANDIM ResourceFlag AS BOOLEANDIM ExportFlag AS BOOLEANDIM IconCursorFlag AS BOOLEANDIM DeferFlag AS BOOLEANDIM ediUsed AS BOOLEANDIM ExclamationOK AS BOOLEANDIM ExistingSym AS BOOLEANDIM DataLabel AS BOOLEANDIM CmpOpFlag AS BOOLEANDIM HasSubscript AS BOOLEANDIM FindReplaceFlag AS BYTEDIM ByteArray(1) AS BYTE VECTORDIM MenuOp AS BYTEDIM FindReplace AS BYTEDIM OpenSave AS BYTEDIM TConst AS BYTEDIM D0Const AS BYTEDIM D1Const AS BYTEDIM FormExStyle AS STRING*100DIM ObjectCtr AS LONGDIM EnumVal AS LONGDIM EnumStep AS LONGDIM MenuIDNum AS LONGDIM TConstVal AS LONGDIM D0ConstVal AS LONGDIM D1ConstVal AS LONGDIM StartTime AS LONGDIM GUITempName AS STRING*28DIM GUIDataType AS INTEGERDIM GUITargetFlag AS BYTE;//DIM GUIObjFlag AS BYTE;//DIM GUIArrayFlag AS BYTEDIM TextFlag AS BYTEDIM ParentFlag AS BYTEDIM NotifyCode AS LONGDIM DescOffs AS LONGDIM SrcLineMod AS LONGDIM StyleCode AS LONGDIM TempStyleStr AS STRING*10DIM TempExStyleStr AS STRING*100DIM ObjectParent AS STRING*32DIM ObjectParentName AS STRING*30DIM HandleName AS STRING*28DIM ObjectType AS LONGDIM ObjectTypeSafe AS LONGDIM IgnoreRightParen AS BYTEDIM FcnTypes(8) AS BYTEDIM EndSegFlag AS BOOLEANDIM SegFlag AS BOOLEANDIM SubFlag AS BOOLEANDIM TaskFlag AS BOOLEANDIM ProcFlag AS BOOLEANDIM FcnFlag AS BOOLEANDIM ProcFcnFlag AS BOOLEANDIM CodeBlockFlag AS BOOLEANDIM EventFlag AS BOOLEANDIM ProcFcn AS BYTEDIM InitTrue AS BYTEDIM HasFcn AS BYTEDIM SimpleCmp AS BYTEDIM ComplexCmp AS BYTEDIM PathIsVector AS BYTEDIM RepeatFlag AS BYTEDIM RepeatCnt AS LONGDIM ArrayDetail AS LONGDIM ArrayDataType AS INTEGERDIM CpxArrayOffset AS LONGDIM OpSizeStr AS STRING*16DIM ForDataType AS INTEGERDIM D1Cleared AS BYTEDIM TableNdx AS LONGDIM TableTypeNdx AS LONGDIM TableName AS STRING*28DIM TableElements AS LONGDIM TableCounter AS LONGDIM CommaCounter AS LONGDIM ObjectDetail AS LONGDIM ObjectArray AS LONGDIM ObjectName AS STRING*28DIM ObjectNameSafe AS STRING*28DIM MenuWindowName AS STRING*28DIM MenuBarName AS STRING*28DIM MenuTitleName AS STRING*28DIM MenuItemName AS STRING*28DIM I AS LONGDIM J AS LONGDIM K AS LONGDIM PI AS LONGDIM PTempInt AS LONGDIM FirstValidChar AS BOOLEANDIM InFlag AS BOOLEANDIM ChildFlag AS BOOLEANDIM CreateObjectFlag AS BOOLEANDIM FilBufSiz AS LONGDIM FilBufAdr AS LONGDIM ANSIArgCtr AS LONGDIM GUIFlag AS BOOLEANDIM SubClassFlag AS BOOLEANDIM GUITargetSymNdx AS LONGDIM AsmOutFlag AS BOOLEANDIM DLLFlag AS BOOLEANDIM FloatFlag AS BYTEDIM ExpFlag AS BOOLEANDIM SubCtr AS BYTEDIM SubCtrSaf AS BYTEDIM MultiFlag AS BYTEDIM SubValue(3) AS LONGDIM SubValSaf(3) AS LONGDIM PrintPathFlag AS BYTEDIM Comment AS STRING*64DIM StatFlag AS BYTEDIM LopCtrNum AS LONGDIM LastSym AS LONGDIM LastKey AS LONGDIM LastImportFcn AS LONGDIM LastImportLib AS LONGDIM LastObj AS LONGDIM StartFlag AS BOOLEANDIM RAEditFlag AS BOOLEANDIM OBZipFlag AS BOOLEANDIM DataFlag AS BOOLEANDIM SelectFlag AS BOOLEANDIM CaseFlag AS BOOLEANDIM CaseElseFlag AS BOOLEANDIM CaseToFlag AS BOOLEANDIM XBufSize AS LONGDIM B AS STRING*10DIM BufRWFlg AS BYTEDIM NewLine AS BYTEDIM Fmt AS STRING*79DIM StringNum AS LONGDIM VectorFlag AS BYTEDIM VectorName AS STRING*28DIM DtaRegNum AS BYTEDIM LoopVars(100) AS STRING*28DIM LopVarNdx AS LONGDIM FcnName AS STRING*28DIM ProcName AS STRING*28DIM GUIFcnName AS STRING*28DIM ErrOpCode AS STRING*5DIM FcnDataMod AS LONGDIM FcnSymNdx AS LONGDIM NumArgs AS LONGDIM TFcnArgs AS LONGDIM FloatOK AS BOOLEANDIM OneDot AS BOOLEANDIM LastExpression AS LONGDIM NoGen AS BOOLEANDIM OptNdx AS LONGDIM Opt AS STRING*1DIM CondValid AS BYTEDIM CondOp1 AS LONGDIM CondOp2 AS LONGDIM GenFlag(20) AS BYTEDIM GFNdx AS LONGDIM AddInst AS STRING*5DIM DecInc AS STRING*3DIM ArgStr AS STRING*28DIM VarSize AS LONGDIM SetMask AS BYTEDIM ArrayBase AS BYTEDIM TmpMax AS BYTEDIM TmpVecMax AS BYTEDIM FTmpMax AS BYTEDIM ChrTmpMax AS BYTEDIM StrTmpMax AS BYTEDIM PrintFlag AS BYTEDIM TabFlag AS BYTEDIM DevFlag AS BYTEDIM LastStmt AS STRING*8DIM FcnCode AS BYTEDIM OpenMode AS BYTEDIM DiskIO AS BYTEDIM FileIO AS BYTEDIM ReadFlag AS BYTEDIM AndOrFlag AS BYTEDIM CompFlag AS BYTEDIM Promote AS BYTEDIM Demote AS BYTEDIM DataOp AS BYTEDIM MathOp AS BYTEDIM LdRegName AS STRING*16DIM Reg0Name AS STRING*16DIM Reg1Name AS STRING*16DIM DataTypeName AS STRING*16DIM DWSafe AS STRING*3DIM D0Loaded AS BYTEDIM Target AS BYTEDIM TmpUse AS LONGDIM TmpVecUse AS LONGDIM FTmpUse AS LONGDIM ChrTmpUse AS LONGDIM StrTmpUse AS LONGDIM Op1Class AS BYTEDIM Operator AS BYTEDIM Op2Class AS BYTEDIM OpClass AS BYTEDIM Op1Type AS INTEGERDIM Op1Mod AS LONGDIM Op1Detail AS LONGDIM Op2Type AS INTEGERDIM Op2Mod AS LONGDIM Op2Detail AS LONGDIM Op1Name AS STRING*42DIM Op2Name AS STRING*42DIM SwitchClass AS BYTEDIM Op1DataSize AS LONGDIM Op2DataSize AS LONGDIM VarName AS STRING*28DIM BufName AS STRING*28DIM BufDataSize AS LONGDIM PathVar AS STRING*42DIM PathName AS STRING*28DIM ToSubFlag AS BYTEDIM ToSub AS STRING*5DIM DigDec AS BYTEDIM TFcnDataType AS BYTEDIM FcnSpec AS BYTEDIM JmpArgs AS LONGDIM TimerNum AS LONGDIM FamilyNum AS LONGDIM GroupNum AS LONGDIM SegNum AS LONGDIM LabelNum AS LONGDIM BitmapNum AS LONGDIM OELabelNum AS LONGDIM SCLabelNum AS LONGDIM GUILabelNum AS LONGDIM TableNum AS LONGDIM ObjectID AS LONGDIM ProcNum AS LONGDIM InterceptProcNum AS LONGTYPE ConStruct	TermLabel AS LONG	ContLabel AS LONG	LoopName AS STRING*28	ConType AS BYTE	ConLine AS LONG	LoopVec AS LONG	LoopLabel AS LONG	NoStep AS BYTE	ImmTo AS BYTE	ImmToVal AS STRING*10	ImmStep AS BYTE	ImmStepVal AS STRING*10	NegImmStep AS BYTEEND TYPEDIM ConStk(40) AS ConStructDIM ConStkPtr AS LONGDIM ToolFile AS FILEDIM TestFile AS FILEDIM EditFile AS FILEDIM StatusFile AS FILEDIM InpFile(20) AS FILEDIM FormFile AS FILEDIM InpFilPtr AS LONGDIM DeclareFile AS FILEDIM CodeFile AS FILEDIM PreCodeFile AS FILEDIM DataFile AS FILEDIM DimFile AS FILEDIM DescFile AS FILEDIM InitFile AS FILEDIM FunctionFile AS FILEDIM LibFile AS FILEDIM ProcFile AS FILEDIM ImportFile AS FILEDIM ExportFile AS FILEDIM ResourceFile AS FILEDIM BitMapFile AS FILEDIM ImageFile AS FILEDIM OutFile AS FILEDIM RawData AS STRING*1DIM LastRawData AS STRING*1DIM Handles(100) AS STRING*28DIM TempStr AS STRING*_BufSizeDIM FcnOp1Nam AS STRING*28DIM FcnOp2Nam AS STRING*28DIM TempName AS STRING*28DIM ToolButtonNdx AS LONGDIM DbgCtr AS LONGDIM TempInt AS LONGDIM TempInt2 AS LONGDIM TempLabel AS LABELDIM TempLabel2 AS LABELDIM StringLength AS LONGDIM TempByte AS STRING*1DIM ErrNo AS LONGDIM NextByte AS STRING*1DIM AsciiByte AS BYTEDIM Konstant AS LONGDIM StringCnt AS LONGDIM StringLen AS LONGDIM LoopNum AS LONGTYPE Symbol	SymName AS STRING*28	DataType AS INTEGER	SubType AS INTEGER	DataMod AS LONG	Detail AS LONG	DataAddr AS LONG	DataSize AS LONG	ArrayDim1 AS LONG	ArrayDim2 AS LONG	ArrayDim3 AS LONG	GUIEvents AS LONG	GUINotifyEvents AS LONG	ArrayDims AS BYTE	Misc AS BYTE	FcnDataType AS BYTE	FcnArgs AS BYTE	UseCount AS BYTEEND TYPEDIM SymTable(SymTabSiz) AS SymbolDIM SymTableKey(SymTabSiz) AS LONGTYPE KeyData	KeyCheckWord AS LONG	KeyName AS STRING*25	KeyLabel AS LABELEND TYPETYPE ObjData	ObjCheckWord AS LONG	ObjSource AS LONG	ObjName AS STRING*32	ObjTypeName AS STRING*32	ObjExStyle AS STRING*32	ObjPropTable AS LABEL	ObjStyleTable AS LABEL	ObjEventTable AS LABELEND TYPETYPE PropData	PropName AS STRING*32	PropGet AS LABEL	PropSet AS LABEL	PropDataType AS INTEGER	PropValid AS BOOLEANEND TYPEDIM PropArray(1) AS PropData VECTORDIM PropValidTable(15) AS BOOLEANTYPE StyleData	StyleName AS STRING*32	StyleValue AS LONG	StyleType AS BYTE	StyleDefault AS BOOLEANEND TYPEDIM StyleArray(1) AS StyleData VECTORTYPE EventData	EVType AS STRING*32	EVStatusBit AS LONG	EVDescOffs AS LONG	EVNotify AS LONGEND TYPEDIM EventArray(1) AS EventData VECTORTYPE ImportFcnData	ImportLibUseNdx AS BYTE	ImportFcnAlias AS STRING*28	ImportFcnName AS STRING*28	ImportFcnUse AS BOOLEAN	ImportFcnLastUsed AS BOOLEANEND TYPETYPE ImportLibData	ImportLibAlias AS STRING*28	ImportLibName AS STRING*28	ImportLibUse AS BOOLEAN	ImportLibLastUsed AS BOOLEANEND TYPE; Use FlagsDIM UseReadFile AS BOOLEANDIM UseWriteFile AS BOOLEANDIM UseWriteOBComm AS BOOLEANDIM UseSetStrConst AS BOOLEANDIM UseTrmStr AS BOOLEANDIM UseData AS BOOLEANDIM UseMovStr AS BOOLEANDIM UseCmpStr AS BOOLEANDIM UseStrLen AS BOOLEANDIM UseSubStr AS BOOLEANDIM UseMidStr AS BOOLEANDIM UseRightStr AS BOOLEANDIM UseClrConv AS BOOLEANDIM UseAtoD AS BOOLEANDIM UseAtoL AS BOOLEANDIM UseNumScan AS BOOLEANDIM UseZLtoH AS BOOLEANDIM UseZLtoA AS BOOLEANDIM UseLtoA AS BOOLEANDIM UseDtoA AS BOOLEANDIM UseLtoH AS BOOLEANDIM UsePrintStr AS BOOLEANDIM UsePrintTab AS BOOLEANDIM UseInpData AS BOOLEANDIM UseBtoA AS BOOLEANDIM UseLCase AS BOOLEANDIM UseUCase AS BOOLEANDIM UseTailStr AS BOOLEANDIM UseSetRightBottom AS BOOLEANDIM UseShowHideFamily AS BOOLEANDIM UseEnableDisableFamily AS BOOLEANDIM UsePad AS BOOLEANDIM UseTrim AS BOOLEANDIM RichEdLibUsed AS BOOLEANDIM RAEditLibUsed AS BOOLEANDIM RAGridLibUsed AS BOOLEANDIM CsmdllLibUsed AS BOOLEANDIM DrawProgressLibUsed AS BOOLEANDIM ImageLibUsed AS BOOLEANDIM SprShtLibUsed AS BOOLEANDIM ButtonExLibUsed AS BOOLEANDIM WebBrowserLibUsed AS BOOLEANDIM ZipLibUsed AS BOOLEANDIM UMFlag AS BYTEDIM CVTemp AS LONGDIM CVOp AS STRING*2DIM NeedComma AS BOOLEANDIM MacExFlag AS BYTEDIM MacBuf(MacBufSiz) AS BYTEDIM MacDefNdx AS LONGDIM MacExNdx AS LONGDIM MacTblPtr AS LONGDIM MacArgBuf(16) AS STRING*100DIM MacArgPtr AS LONGDIM MaxArgNum AS BYTEDIM PoolCtr AS LONGDIM SymNdx AS LONGDIM SymNdxSaf AS LONGDIM DataSymNdx AS LONGDIM SymType AS STRING*32DIM SimpleOp AS STRING*8DIM SimpleStructOp AS STRING*8DIM ArraySize AS LONGDIM ForNdx AS LONGDIM DataTemp AS BYTEDIM TSymName AS STRING*28DIM VSymName AS STRING*28DIM TDataType AS INTEGERDIM AliasDataType AS INTEGERDIM TSubType AS INTEGERDIM TblDataType AS INTEGERDIM TDataMod AS LONGDIM VDataMod AS LONGDIM TDetail AS LONGDIM VDetail AS LONGDIM TDataAddr AS LONGDIM VDataAddr AS LONGDIM TDataSize AS LONGDIM TArrayDims AS BYTEDIM TArrayDim1 AS LONGDIM TArrayDim2 AS LONGDIM TArrayDim2Safe AS LONGDIM TArrayDim3 AS LONGDIM TGUIEvents AS LONGDIM TGUINotifyEvents AS LONGDIM ExpTable(ExpTabSiz) AS LONGDIM TypePtr AS LONGDIM TypeFlag AS BYTEDIM AliasFlag AS BYTEDIM LastEntry AS SymbolDIM SymTemp AS SymbolDIM SrcLine AS STRING*_BufSizeDIM SrcLineSaf AS STRING*_BufSizeDIM OutBuf AS STRING*_BufSizeDIM TokenBuf AS STRING*_BufSizeDIM ExpEnd AS BYTEDIM TokenLen AS LONGDIM ExpLen AS LONGDIM LastGroup AS BYTEDIM TokenType AS BYTEDIM LastByte AS BYTEDIM IsOperator AS BYTEDIM WasOperator AS BYTEDIM TokenSaf AS STRING*_BufSizeDIM RootSymbol AS STRING*29DIM Subscript(3) AS STRING*28DIM SubscrErr AS BYTEDIM KeyWord AS STRING*29DIM KeyNdx AS LONGDIM ObjNdx AS LONGDIM SymbolSaf AS STRING*29DIM NumberOK AS BYTEDIM HexOK AS BOOLEANDIM SymbolValid AS BOOLEANDIM IntOK AS BOOLEANDIM DimFlag AS BYTEDIM DimOK AS BYTEDIM GetBaseFlag AS BOOLEANDIM BldOffsFlag AS BOOLEANDIM BasicLineCtr AS LONGDIM AsmLineCtr AS LONGDIM QuoteFlag AS BYTEDIM EscSeq AS BYTEDIM ParenStk(100) AS BYTEDIM ParenCnt AS BYTEDIM FcnCtr AS BYTEDIM AECtr AS BYTEDIM LevelCnt AS BYTEDIM SymFull AS BYTEDIM SymFound AS BOOLEANDIM ErrCnt AS LONGDIM VarBytRem AS LONGDIM TypeBytes AS LONGDIM TypeVars AS LONGDIM TypeNdx AS LONGDIM LabelFlag AS BYTEDIM DMTemp AS BYTEDIM DMVector AS BYTEDIM DMMember AS BYTEDIM DMMulti AS BYTEDIM DMConst AS BYTEDIM DMAddr AS BYTEDIM DMArray AS BYTEDIM DMReDim AS BYTEDIM DMSubClassed AS BYTEDIM EndFound AS BOOLEANDIM AsmFileName AS STRINGDIM BareFileName AS STRINGDIM UseFilNam AS STRINGDIM Ctr1 AS LONGDIM Ctr2 AS LONGDIM Ctr3 AS LONGDIM WhiteSpaceCtr AS LONGDIM SrcNdx AS LONGDIM EndNdx AS LONGDIM SrcLineChars AS LONGDIM SrcNdxCpy AS LONGDIM SrcNdxSaf AS LONGDIM ExpEndSaf AS BYTEDIM NumberNdx AS LONGDIM ValidNdx AS LONGDIM LabNdx AS LONGDIM ExpNdx AS LONGDIM ExpLeft AS LONGDIM ExpRight AS LONGDIM PType AS LONG; OBComm Control Block StructureCONST !DCBlengthOffs=0; rd 1CONST !BaudRateOffs=4; rd 1CONST !fBitsOffs=8; rd 1CONST !fBinaryBit=0CONST !fParityBit=1CONST !fOutxCtsFlowBit=2CONST !fOutxDsrFlowBit=3CONST !fDtrControlLoBit=4CONST !fDtrControlHiBit=5CONST !fDsrSensitivityBit=6CONST !fTXContinueOnXoffBit=7CONST !fOutXBit=8CONST !fInXBit=9CONST !fErrorCharBit=10CONST !fNullBit=11CONST !fRtsControlLoBit=12CONST !fRtsControlHiBit=13CONST !fAbortOnErrorBit=14CONST !wReservedOffs=12; rw 1CONST !XonLimOffs=14; rw 1CONST !XoffLimOffs=16; rw 1CONST !ByteSizeOffs=18; rb 1CONST !ParityOffs=19;  rb 1CONST !StopBitsOffs=20; rb 1CONST !XonCharOffs=21; rb 1CONST !XoffCharOffs=22; rb 1CONST !ErrorCharOffs=23; rb 1CONST !EofCharOffs=24; rb 1CONST !EvtCharOffs=25; rb 1CONST !wReserved1Offs=26; rw 1CONST !HandleOffs=28; rd 1CONST !StatusOffs=32; rd 1CONST !ArrayOffs=36; rd 1CONST !CommReserved1Offs=40; rb 1CONST !CommReserved2Offs=41; rb 1CONST !CommReserved3Offs=42; rb 1CONST !CommReserved4Offs=43; rb 1CONST !UserBaudRateOffs=44; rd 1CONST !UserParityOffs=48; rb 1CONST !UserByteSizeOffs=49; rb 1CONST !UserStopBitsOffs=50; rb 1CONST !UserRTSOffs=51; rb 1CONST !UserDSRCheckOffs=52; rb 1CONST !UserParityCheckOffs=53; rb 1CONST !UserDTROffs=54; rb 1CONST !UserCTSCheckOffs=55; rb 1CONST !PortNameOffs=56; rb 32CONST !CommStatusOffs=88; rd 1CONST !cbInQueOffs=92; rd 1CONST !cbOutQueOffs=96; rd 1;Object Descriptor StructureCONST HandleOffs=0CONST IDOffs=4CONST OwnerOffs=8CONST ArrayOffs=12CONST LeftOffs=16CONST TopOffs=20CONST RightOffs=24CONST BottomOffs=28CONST BackColorOffs=32CONST ForeColorOffs=36CONST TypeOffs=40CONST StatusOffs=44CONST evActivateOffs=48CONST evCommandOffs=52CONST evMouseActivateOffs=56CONST evPaintOffs=60CONST HDCOffs=64CONST evMouseMoveOffs=68CONST evMouseWheelOffs=72CONST evScrollOffs=76CONST evCreateOffs=80CONST evDestroy=84CONST evKeyDownOffs=88CONST evKeyUpOffs=92CONST evDblClickOffs=96CONST cdDblClickOffs=100CONST evClickOffs=104CONST cdClickOffs=108CONST evChangeOffs=112CONST cdChangeOffs=116CONST evSelectOffs=120CONST cdSelectOffs=124CONST evNotify1Offs=128CONST cdNotify1Offs=132CONST evNotify2Offs=136CONST cdNotify2Offs=140CONST evNotify3Offs=144CONST cdNotify3Offs=148CONST evNotify4Offs=152CONST cdNotify4Offs=156CONST evNotify5Offs=160CONST cdNotify5Offs=164CONST evNotify6Offs=168CONST cdNotify6Offs=172CONST evNotify7Offs=176CONST cdNotify7Offs=180CONST evNotify8Offs=184CONST cdNotify8Offs=188CONST evNotify9Offs=192CONST cdNotify9Offs=196CONST evNotify10Offs=200CONST cdNotify10Offs=204CONST evNotify11Offs=208CONST cdNotify11Offs=212CONST evNotify12Offs=216CONST cdNotify12Offs=220CONST evNotify13Offs=224CONST cdNotify13Offs=228CONST evNotify14Offs=232CONST cdNotify14Offs=236CONST evNotify15Offs=240CONST cdNotify15Offs=244CONST evNotify16Offs=248CONST cdNotify16Offs=252CONST evNotify17Offs=256CONST cdNotify17Offs=260CONST evNotify18Offs=264CONST cdNotify18Offs=268CONST evNotify19Offs=272CONST cdNotify19Offs=276CONST evNotify20Offs=280CONST cdNotify20Offs=284CONST evNotify21Offs=288CONST cdNotify21Offs=292CONST evNotify22Offs=296CONST cdNotify22Offs=300CONST evNotify23Offs=304CONST cdNotify23Offs=308CONST evNotify24Offs=312CONST cdNotify24Offs=316CONST evNotify25Offs=320CONST cdNotify25Offs=324CONST evNotify26Offs=328CONST cdNotify26Offs=332CONST evNotify27Offs=336CONST cdNotify27Offs=340CONST evNotify28Offs=344CONST cdNotify28Offs=348CONST evNotify29Offs=352CONST cdNotify29Offs=356CONST evNotify30Offs=360CONST cdNotify30Offs=364CONST evNotify31Offs=368CONST cdNotify31Offs=372CONST evNotify32Offs=376CONST cdNotify32Offs=380CONST evSysCommandOffs=384CONST evResizeOffs=388CONST evMoveOffs=392CONST evLButtonDownOffs=396CONST evLButtonUpOffs=400CONST evRButtonDownOffs=404CONST evRButtonUpOffs=408CONST CursorOffs=412CONST evContextMenuOffs=416CONST evKeyStruckOffs=420CONST evReserved3Offs=424CONST evReserved4Offs=428CONST evReserved5Offs=432CONST evReserved6Offs=436CONST evReserved7Offs=440CONST Reserved1Offs=444CONST Reserved2Offs=448CONST ScrollBarPageOffsOffs=452CONST ScrollBarMinOffs=456CONST ScrollBarMaxOffs=460CONST ScrollBarPosOffs=464CONST GridColorOffs=468CONST FamilyOffs=472CONST OldProcOffs=476CONST WidthOffs=480CONST HeightOffs=484CONST ControlBrushOffs=488CONST InterceptSafeOffs=492CONST InterceptProcOffs=496CONST StyleOffs=500CONST Extra2Offs=504CONST DoNotUseOffs=508CONST TTcbSizeOffs=512CONST TTuFlagsOffs=516CONST TThwndOffs=520CONST TTuIDOffs=524CONST TTRectLeftOffs=528CONST TTRectTopOffs=532CONST TTRectRightOffs=536CONST TTRectBottomOffs=540CONST TThinstOffs=544CONST TTlpszTextOffs=548CONST TTlparamOffs=552CONST TTTextOffs=556CONST NextOffs=656;******************************************* IDE Code Starts Here ********************************OBMain.CREATE	BasicAsm=TRUE	TextMode=TRUE	ToolView=TRUE	PropView=TRUE	StyleView=TRUE	OpenFlag=FALSE	FormNotChanged=FALSE	PlacePart=FALSE	PlaceArray=FALSE	MultiSelectItemCount=0	ClipBoardItemCount=0	ToolBlockSize=SIZE(ControlArray)+SIZE(ToolPropMapCount)+30	POPUPMENU EventPopUp		RESERVEITEMS evmnu1,20	END MENU	POPUPMENU GridSizePopUp		MENUITEM gsmnu5,"5"		MENUITEM gsmnu10,"10"		MENUITEM gsmnu15,"15"		MENUITEM gsmnu20,"20"		MENUITEM gsmnu25,"25"		MENUITEM gsmnu30,"30"		MENUITEM gsmnu35,"35"		MENUITEM gsmnu40,"40"		MENUITEM gsmnu45,"45"		MENUITEM gsmnu50,"50"	END MENU	CHECKMENUITEM GridSizePopUp,gsmnu10,TRUE	POPUPMENU GridColorPopUp		MENUITEM gcmnuBlack,"Black"		MENUITEM gcmnuWhite,"White"		MENUITEM gcmnuRed,"Red"		MENUITEM gcmnuGreen,"Green"		MENUITEM gcmnuBlue,"Blue"		MENUITEM gcmnuYellow,"Yellow"		MENUITEM gcmnuMagenta,"Magenta"		MENUITEM gcmnuDkRed,"DkRed"		MENUITEM gcmnuDkGreen,"DkGreen"		MENUITEM gcmnuDkBlue,"DkBlue"	END MENU	CHECKMENUITEM GridColorPopUp,gcmnuBlack,TRUE	POPUPMENU FormPopUp		MENUITEM fwmnuCut,"Cut"		MENUITEM fwmnuCopy,"Copy"		MENUITEM fwmnuPaste,"Paste"		MENUSEPARATOR		MENUITEM fwmnuGroup,"Group"		MENUITEM fwmnuUngroup,"Ungroup"		MENUSEPARATOR		MENUITEM fwmnuDelete,"Delete"		MENUSEPARATOR		MENUITEM fwmnuShowGrid,"Show Grid"		MENUITEM fwmnuSnapToGrid,"Snap To Grid"		SUBMENU GridSizePopUp,"Grid Size"		SUBMENU GridColorPopUp,"Grid Color"		MENUSEPARATOR		MENUITEM fwmnuBringToFront,"Bring To front"		MENUITEM fwmnuSendToBack,"Send To Back"		MENUSEPARATOR		SUBMENU EventPopUp,"Events"		MENUSEPARATOR		MENUITEM fwmnuViewCode,"View Code"		MENUSEPARATOR		MENUITEM fwmnuViewAutoCode,"View AutoCode"	END MENU	POPUPMENU EditPopUp		MENUITEM emnuUnDo,"Undo"		MENUITEM emnuReDo,"Redo",		MENUSEPARATOR		MENUITEM emnuDelete,"Delete"		MENUITEM emnuCut,"Cut"		MENUITEM emnuCopy,"Copy"		MENUITEM emnuPaste,"Paste"		MENUSEPARATOR		MENUITEM emnuSelectAll,"Select All",		MENUSEPARATOR		MENUITEM emnuGotoLine,"Goto Line"		MENUITEM emnuGotoTop,"Goto Top"		MENUITEM emnuGotoBottom,"Goto Bottom"		MENUSEPARATOR		MENUITEM emnuFind,"Find"		MENUITEM emnuReplace,"Replace"		MENUSEPARATOR		MENUITEM emnuViewObject,"View Objects"		MENUSEPARATOR		MENUITEM emnuReturnToSource,"Return To Source"		MENUSEPARATOR		MENUITEM emnuViewSegs,"View Segs"		MENUSEPARATOR		MENUITEM emnuViewSubs,"View Subs"		MENUSEPARATOR		MENUITEM emnuViewProcs,"View Procs"		MENUSEPARATOR		MENUITEM emnuViewFcns,"View Fcns"	END MENU	BEGIN MENU OBMain		MENUBAR MainMenu			MENUTITLE FileMenu,"File"				MENUITEM mnuNew,"New"				MENUITEM mnuOpen,"Open"				MENUITEM mnuSave,"Save"				MENUITEM mnuSaveAs,"Save As"				MENUSEPARATOR				MENUITEM mnuPrint,"Print"				MENUSEPARATOR				MENUITEM mnuExit,"Exit"			MENUTITLE EditMenu,"Edit"				MENUITEM mnuUnDo,"Undo"				MENUITEM mnuReDo,"Redo",				MENUSEPARATOR				MENUITEM mnuDelete,"Delete"				MENUITEM mnuCut,"Cut"				MENUITEM mnuCopy,"Copy"				MENUITEM mnuPaste,"Paste"				MENUSEPARATOR				MENUITEM mnuSelectAll,"Select All",				MENUSEPARATOR				MENUITEM mnuGotoLine,"Goto Line"				MENUSEPARATOR				MENUITEM mnuFind,"Find"				MENUITEM mnuReplace,"Replace"			MENUTITLE ViewMenu,"View"				MENUITEM mnuToolBox,"ToolBox"				MENUITEM mnuPropertyBox,"PropertyBox"				MENUITEM mnuStyleBox,"StyleView"			MENUTITLE OptionMenu,"Option"				MENUITEM mnuPreferences,"Preferences"				MENUSEPARATOR				MENUITEM mnuFont,"Font"			MENUTITLE ColorMenu,"Colors"				MENUITEM mnuStatement,"Statements"				MENUSEPARATOR				MENUITEM mnuFunctions,"Functions"				MENUSEPARATOR				MENUITEM mnuRegisters,"Registers"				MENUSEPARATOR				MENUITEM mnuAsm,"Asm"				MENUSEPARATOR				MENUITEM mnuDataType,"DataType"			MENUTITLE CompileMenu,"Compile"				MENUITEM mnuCompile,"Compile To EXE"				MENUITEM mnuAssemble,"Compile To .ASM"				MENUITEM mnuTestCompile,"Compile Errors"				MENUSEPARATOR				MENUITEM mnuRun,"Run"			MENUTITLE DebugMenu,"Debug"				MENUITEM mnuStart,"Start"				MENUITEM mnuStop,"Stop"				MENUITEM mnuStep,"Step"				MENUITEM mnuEnd,"End"			MENUTITLE HelpMenu,"Help"				MENUITEM mnuHelp,"Help"				MENUSEPARATOR				MENUITEM mnuAbout,"About"								END MENU	ENABLEMENUITEM MainMenu,mnuSave,FALSE	ENABLEMENUITEM EditPopUp,emnuReturnToSource,FALSE	ENABLEMENUITEM FormPopUp,fwmnuCut,FALSE	ENABLEMENUITEM FormPopUp,fwmnuCopy,FALSE	ENABLEMENUITEM FormPopUp,fwmnuPaste,FALSE	ENABLEMENUITEM FormPopUp,fwmnuGroup,FALSE	ENABLEMENUITEM FormPopUp,fwmnuUngroup,FALSE	SETPOSITION OBMain,0,0,1024,740	CREATE StatusBar,0,0,0,0	sbParts(1)=100	sbParts(2)=200	sbParts(3)=300	sbParts(4)=400	sbParts(5)=500	StatusBar.SETPARTS 5,sbParts	;CREATE ToolBar,0,0,0,0		CREATE ProcWindow,100,100,300,400 APPWINDOW CHILD	ProcWindow.VISIBLE=FALSE	CREATE ProcList,0,0,300,390 IN ProcWindow	CREATE Edit,0,50,1015,622	Edit.ENABLED=FALSE	Edit.LINENUMBERWIDTH=50	Edit.SETCHARTABLE $2e,OPER	CREATE BackGround,0,42,1015,630	BackGround.VISIBLE=FALSE	BackGround.BACKCOLOR=$b0a080	CREATE EventCombo1,0,25,505,400	EventCombo1.ENABLED=FALSE	CREATE EventCombo2,510,25,505,400	EventCombo2.ENABLED=FALSE	CREATE QuickFind,810,0,205,20	CREATE QuickFindNext,760,0,20,20,VISIBLE+CHILD+BITMAP	QuickFindNext.ENABLED=FALSE	CREATE QFindNextBMP,OBCQFindNext.bmp	QuickFindNext.BITMAP=QFindNextBMP	CREATE QuickFindPrev,785,0,20,20,VISIBLE+CHILD+BITMAP	QuickFindPrev.ENABLED=FALSE	CREATE QFindPrevBMP,OBCQFindPrev.bmp	QuickFindPrev.BITMAP=QFindPrevBMP	lf.lfHeight=-12	lf.lfFaceName="Courier New"	CREATE RAFont(1),lf	lf.lfItalic=1	CREATE RAFont(2),lf	lf.lfHeight=-10	lf.lfFaceName="Terminal"	lf.lfItalic=0	CREATE RAFont(3),lf	Edit.setfont RAFont	szRegs="AH AL AX BH BL BP BX CH CL CR0 CR2 CR3 CS CX DH DI DL DR0 DR1 DR2 DR3 DR6 DR7 DS DX EAX EBP EBX ECX EDI EDX ES ESI ESP FS GS MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7 SI SP SS ST TR3 TR4 TR5 TR6 TR7 XMM0 XMM1 XMM2 XMM3"	Edit.SETHILITEWORDS szRegs,$0080ff	szGUIInst="APPWINDOW CHILD MINIMIZED SUSPEND SETTASKPRIORITY RESUME SETTOOLTIPCOLORS PASSEVENT EVENT GETDATETIME TIMEADD SETDEFAULTCURSOR SETSTOCKCURSOR SETCURSOR LOAD CHECKMENUITEM HILITEMENUITEM BITMAPS PRINTDIALOG PAGEDIALOG FONTDIALOG COLORDIALOG REPLACEDIALOG SHOW DESTROY GETDC SETCAPTURE RELEASECAPTURE RELEASEDC INVALIDATERECT GETCURSORPOSITION SCREENTOCLIENT GETWINDOWRECT MENUBAR MENUTITLE SELECTOBJECT MENUITEM MENUSEPARATOR TRAPCOLORCHANGEEVENT SETPOSITION FIND SETSTYLE MSGBOX WARNINGBOX INFOBOX QUESTIONBOX ERRORBOX ENABLEMENUITEM FINDDIALOG OPENDIALOG SAVEDIALOG APPENDMENUITEM CONTINUE SETBKCOLOR SETTEXTCOLOR DELETEOBJECT DELETEMENUITEM EXIT GETCLIENTRECT MOVEWINDOW ROUNDRECT RECTANGLE ELLIPSE LINETO MOVETO ARCTO POLYLINE"	Edit.SETHILITEWORDS szGUIInst,$ff	szGUIProps="ADDRESS INTERCEPTON INTERCEPTOFF ID VISIBLE ENABLED TOP WIDTH HEIGHT BOTTOM BACKCOLOR FLASHWINDOW RESIZE FLAT 3D MOVE MOUSEMOVE LBUTTONDOWN LBUTTONUP RBUTTONDOWN RBUTTONUP BACKCOLOR FORECOLOR COMMAND ADDITEM ADDITEMSORTED INSERTITEM CLEAR SELITEM TOPITEM SELTEXT ITEMCOUNT CHANGE SCROLL AUTOTICKS BOTH ENABLESELRANGE FIXEDLENGTH NOTICKS NOTHUMB VERT VALUE CHECKED INTERVAL STOP SETFOCUS LINE LOADFILE SETDIVIDERLINE SAVEFILE TEXTCOLOR SELBACKCOLOR SELTEXTCOLOR COMMENTCOLOR STRINGCOLOR OPERATORCOLOR HILITE1COLOR HILITE2COLOR HILITE3COLOR SELBARCOLOR SELBARPENCOLOR LINENUMCOLOR SETFONT GRIDCOLOR HEADERTEXT ADDROW ADDCOL DELETEROW INSERTROW MOVEROW HEADERHEIGHT ROWHEIGHT GRIDCLEAR COMBOCLEAR SORT CLICK HEADERCLICK BUTTONCLICK CHECKCLICK IMAGECLICK BEFORESELCHANGE AFTERSELCHANGE BEFOREEDIT AFTEREDIT USERCONVERT DROPPED SELECTALL SETSEL GETSEL INSERTTEXT APPENDTEXT REPLACETEXT REPLACESEL CURSORPOS SYSTEM"	Edit.SETHILITEWORDS szGUIProps,$FF	szGUIProps2=" CREATE CUT COPY PASTE UNDO REDO SETHILITEWORDS"	Edit.SETHILITEWORDS szGUIProps2,$FF	szAsmInst="AAA AAD AAM AAS ADC ADD AND CALL CBW CLC CLD CLI CMC CMP CMPS CMPSB CMPSW CWD DAS DEC DIV DAA ESC HLT IDIV IMUL IN INC INT INTO IRET JA JAE JB JBE JC JCXZ JE JG JGE JL JLE JMP JNA JNAE JNB JNBE JNC JNE JNG JNGE JNL JNLE JNO JNP JNS JNZ JO JP JPE JPO JS JZ LAHF LDS LEA LES LODS LODSB LODSW LOOP LOOPE LOOPEW LOOPNE LOOPNEW LOOPNZ LOOPNZW LOOPW LOOPZ LOOPZW MOV MOVS MOVSB MOVSW MUL NEG NOP NOT OR OUT POP POPF PUSH PUSHF RCL RCR RET RETF RETN ROL ROR SAHF SAL SAR SBB SCAS SCASB SCASW SETE SETNE SHL SHR STC STD STI STOS STOSB STOSW SUB TEST WAIT XCHG XLAT XLATB XOR"	Edit.SETHILITEWORDS szAsmInst,$FF	szBasicInst="GETDATEFORMAT GETTIMEFORMAT READCARD WRITECARD USEIMPORT IMPORTFUNCTION EXPORTFUNCTION SHOWPOPUP POPUPMENU SUBMENU RESERVEITEMS TEXTBLOCK ENDTEXT MAKELOWER MAKEUPPER PROGRAM PROC FCN DECLARE CALL CHDIR MKDIR RMDIR INCLUDE DIGITS SETPIXEL REDIM ENDWXIT DECIMAL EXCHANGE BEEP BUFREAD BUFWRITE BASE SHELL SETVECTOR FPRINT FINPUT UNTIL REPEAT BUFFER REM WHILE OPEN OUTPUT APPEND SCRATCH UPDATE GET PUT READ INPUT SEEK TRUE FALSE AS GOTO GOSUB FOR TO END IF PRINT ELSE IF THEN PAINT BEGIN LOOP END DATA TABLE SELECT CASE DIM TYPE LET CONST MACRO INCR DECR NEXT RESTORE TEXT WRITE RETURN CLOSE AND DELETE ON ERROR OR ENUM SEG ENTER"	Edit.SETHILITEWORDS szBasicInst,$FF	szFcns="TABLESIZE TAIL UCASE LCASE TIMEDIFF GETTICKCOUNT RND OCT BIN RCR RCL SAR SAL SUBSTR BITSET BITCLR BITCHG ROR ROL SHR SHL BITTST CHKWORD HEX LOG10 LOG ATN ACS ASN TAN COS SIN INT SQR FILPOS LOF PAD TRIM FVAL IVAL SIZE INDEX NOT LNOT EOF LAND LOR LXOR LEN STR VAL ADDR MID LEFT RIGHT ABS MOD CHR ASC NOT BUFADR BUFSIZ TAB"	Edit.SETHILITEWORDS szFcns,$FF00FF	szDataType="RAEDIT RAGRID TASK TOOLWINDOW TIMER FAMILY SPRSHT IMAGE LISTVIEW HANDLE BITMAP IMAGELIST SOLIDBRUSH HATCHBRUSH PATTERNBRUSH PEN CURSOR ICON FONT LOGFONT DEVICE MENU PIPE FILE BYTE INTEGER LONG FLOAT LABEL POINTER DATETIME ALIAS BOOLEAN STRING WORD DWORD BUTTON FORM COMBOBOX LISTBOX TEXTBOX STATICBOX STATICTEXT CHECKBOX FRAME RADIOBUTTON SLIDER STATUSBAR SCROLLBAR PROGRESSBAR WEBBROWSER ANIMATE BUTTONEX OBCOMM DRAWPROGRESS IMAGE DATETIMEPICK TOOLBAR SPINNER CALENDAR HEADER TREEVIEW TABFOLDER RICHEDIT ICONBUTTON STATICICON OBZIP WEB_BROWSER"	Edit.SETHILITEWORDS szDataType,$808000	szDirective="DB DW DD DF RB RW RD RF EQU ALIGN EQU INVOKE CINVOKE"	Edit.SETHILITEWORDS szDirective,$FF0080	szControlNames="OBMain"	Edit.SETHILITEWORDS szControlNames,$FF00FF	Edit.backcolor=$ffffff	Edit.linenumcolor=$0000a0	SaveFileName=""	EditfChanged=0	Changed=FALSE	InitDir="C:\nb"	FileFilter="OB Project",0,"*.obp",0,"OB Window",0,"*.obw",0,"OB Console",0,"*.obc",0,"Assembler",0,"*.asm",0,"OB DLL",0,"*.obd",0,"OB Library",0,"*.obl",0,"OB Object",0,"*.obo",0,"Include File",0,"*.inc",0,"All Files",0,"*.*",0,0 	OBMain.TEXT=ProgramName+"    [Untitled]"	FileName="Untitled"	Edit.SETFOCUS	CREATE Button(1),5,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(1).TOOLTIP="New"	CREATE Button(2),30,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(2).TOOLTIP="Open"	CREATE Button(3),55,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(3).TOOLTIP="Save"	CREATE Button(4),80,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(4).TOOLTIP="Save As"	CREATE Button(5),105,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(5).TOOLTIP="Print"	CREATE Button(6),135,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(6).TOOLTIP="Graphic"	CREATE Button(7),165,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(7).TOOLTIP="Undo"	CREATE Button(8),190,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(8).TOOLTIP="Redo"	CREATE Button(9),215,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(9).TOOLTIP="Delete"	CREATE Button(10),240,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(10).TOOLTIP="Cut"	CREATE Button(11),265,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(11).TOOLTIP="Copy"	CREATE Button(12),290,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(12).TOOLTIP="Paste"	CREATE Button(13),315,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(13).TOOLTIP="Goto Line"	CREATE Button(14),340,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(14).TOOLTIP="Find"	CREATE Button(15),365,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(15).TOOLTIP="Replace"	CREATE Button(16),395,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(16).TOOLTIP="Compile To .Exe"	CREATE Button(17),420,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(17).TOOLTIP="Compile To .Asm"	CREATE Button(18),445,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(18).TOOLTIP="Compile For Errors"	CREATE Button(19),470,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(19).TOOLTIP="Compile For Debug"	CREATE Button(20),500,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(20).TOOLTIP="Symbol Table"	CREATE Button(21),525,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(21).TOOLTIP="Unused"	CREATE Button(22),550,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(22).TOOLTIP="Run Program"	CREATE Button(23),575,0,20,20,VISIBLE+CHILD+BITMAP+FLAT	Button(23).TOOLTIP="Help"	LF1.lfHeight=10	LF1.lfFaceName="MS Sans Serif"	CREATE Font1,LF1	Button(3).ENABLED=FALSE	Button(6).ENABLED=FALSE	Button(7).ENABLED=FALSE	Button(8).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	CREATE OmniIcon,Colref.ico	OBMain.ICON=OmniIcon	CREATE NewBMP,OBCNew.bmp	SETMENUITEMBITMAPS FileMenu,mnuNew,NewBMP,NewBMP	Button(1).BITMAP=NewBMP	CREATE OpenBMP,OBCOpen.bmp	SETMENUITEMBITMAPS FileMenu,mnuOpen,OpenBMP,OpenBMP	Button(2).BITMAP=OpenBMP	CREATE SaveBMP,OBCSave1.bmp	SETMENUITEMBITMAPS FileMenu,mnuSave,SaveBMP,SaveBMP	Button(3).BITMAP=SaveBMP	CREATE SaveAsBMP,OBCSave2.bmp	SETMENUITEMBITMAPS FileMenu,mnuSaveAs,SaveAsBMP,SaveAsBMP	Button(4).BITMAP=SaveAsBMP	CREATE PrintBMP,OBCPrint.bmp	Button(5).BITMAP=PrintBMP	CREATE ToolBMP,OBCTools.bmp	CREATE EditBMP,OBCEdit.bmp	Button(6).BITMAP=ToolBMP	CREATE UndoBMP,OBCUndo.bmp	Button(7).BITMAP=UndoBMP	CREATE RedoBMP,OBCRedo.bmp	Button(8).BITMAP=RedoBMP	CREATE DeleteBMP,OBCDelete.bmp	Button(9).BITMAP=DeleteBMP	CREATE CutBMP,OBCCut.bmp	Button(10).BITMAP=CutBMP	CREATE CopyBMP,OBCCopy.bmp	Button(11).BITMAP=CopyBMP	CREATE PasteBMP,OBCPaste.bmp	Button(12).BITMAP=PasteBMP	CREATE  GotoBMP,OBCGoto.bmp	Button(13).BITMAP=GotoBMP	CREATE FindBMP,OBCFind.bmp	Button(14).BITMAP=FindBMP	CREATE ReplaceBMP,OBCReplace.bmp	Button(15).BITMAP=ReplaceBMP	CREATE CompileToExeBMP,OBCCompExe.bmp	Button(16).BITMAP=CompileToExeBMP	;CREATE CompileToAsmIcon,asmicon	;Button(17).ICON=CompileToAsmIcon	;CREATE CompileForErrIcon,prop0	;Button(18).ICON=CompileForErrIcon	CREATE CompileForDebugBMP,OBCDebug.bmp	Button(19).BITMAP=CompileForDebugBMP	;CREATE SymbolsIcon,qrlist	;Button(20).ICON=SymbolsIcon	;CREATE UnusedSymIcon,question	;Button(21).ICON=UnusedSymIcon	CREATE RunBMP,OBCRun.bmp	Button(22).BITMAP=RunBMP	CREATE HelpBMP,OBCHelp.bmp	Button(23).BITMAP=HelpBMP	LF1.lfHeight=10	LF1.lfFaceName="MS Sans Serif"	CREATE Font1,LF1	MinMaxFlag=TRUE	CaptureEnabled=TRUE	ShowGrid=TRUE	CHECKMENUITEM FormPopUp,fwmnuShowGrid,TRUE	SnapToGrid=TRUE	CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,TRUE	GridSize=10	GridColor=0	EventMenuCount=0	lf.lfHeight=-9	lf.lfFaceName="Verdana"	CREATE GridFont,lfEND EVENTMENU.COMMANDIF MenuID>=evmnu1 AND MenuID<=evmnu1+19 THEN; FormPopUp Event	CALL SUB FindEvent	EXIT EVENTEND IFSELECT CASE MenuID	CASE mnuNew		CALL SUB NewCmd	CASE mnuOpen		CALL SUB OpenCmd	CASE mnuSave		CALL SUB SaveCmd	CASE mnuSaveAs		CALL SUB SaveAsCmd	CASE mnuPrint	CASE mnuExit		IF Changed=TRUE THEN			TempName=SaveFileName+" Not Saved"			TempStr="Save?"			WARNINGBOX TempName,TempStr,MB_YESNOCANCEL			IF STATUS=IDYES THEN				IF FileName="Untitled" THEN					CALL SUB SaveAs					IF STATUS=0 THEN						RETURN					END IF					END				ELSE					SETDEFAULTCURSOR					CALL SUB SaveEdit					IF LCASE(Extension)=".obp" THEN						CALL SUB WriteTools					END IF					END				END IF			ELSE				IF STATUS=IDNO THEN					END				ELSE					RETURN				END IF			END IF		END IF		END	CASE mnuUnDo		Edit.UNDO	CASE mnuReDo		Edit.REDO	CASE mnuCut		Edit.CUT	CASE mnuCopy		Edit.COPY	CASE mnuPaste		Edit.PASTE	CASE mnuSelectAll		Edit.SELECTALL	CASE mnuGotoLine		CALL SUB GotoLine		GotoText.SETFOCUS	CASE mnuFind		CALL SUB GetFindDialog	CASE mnuReplace		CALL SUB GetFindReplaceDialog	CASE mnuPreferences			CASE mnuToolBox	CASE mnuPropertyBox	CASE mnuStyleBox	CASE mnuFont		FONTDIALOG FontStr	CASE mnuStatement		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szBasicInst,RGB		Edit.sethilitewords szGUIInst,RGB		Edit.visible=false		Edit.visible=true	CASE mnuFunctions		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szFcns,RGB		Edit.visible=false		Edit.visible=true	CASE mnuRegisters		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szRegs,RGB		Edit.visible=false		Edit.visible=true	CASE mnuAsm		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szAsmInst,RGB		Edit.visible=false		Edit.visible=true	CASE mnuDataType		COLORDIALOG RGB		EXIT IF RGB=$ffffffff		Edit.sethilitewords szDataType,RGB		Edit.visible=false		Edit.visible=true	CASE mnuCompile		CALL SUB CompileToExe	CASE mnuAssemble		CALL SUB CompileToAsm	CASE mnuTestCompile		CALL SUB TestCompile	CASE mnuStart	CASE mnuStop	CASE mnuStep	CASE mnuEnd	CASE mnuHelp	CASE mnuAbout		CASE fwmnuCut		ClipBoardPtr=1		IF MultiSelectItemCount=0 THEN			ClipBoardItemCount=1			CALL SUB CopyToClipBoard			CALL SUB DeleteControl		ELSE			ClipBoardItemCount=MultiSelectItemCount			FOR ControlPtr=2 TO LastControl				IF ControlArray(ControlPtr).PuppetEars(1)<>0 THEN					CALL SUB CopyToClipBoard					INCR ClipBoardPtr				END IF			NEXT ControlPtr			FOR ControlPtr=2 TO LastControl				IF ControlArray(ControlPtr).PuppetEars(1)<>0 THEN					CALL SUB DeleteControl				END IF			NEXT ControlPtr			CALL SUB RemoveEars		END IF		CALL SUB SetClipBoardXY		SpiderPlaced=FALSE	CASE fwmnuCopy		ClipBoardPtr=1		IF MultiSelectItemCount=0 THEN			ClipBoardItemCount=1			CALL SUB CopyToClipBoard		ELSE			ClipBoardItemCount=MultiSelectItemCount			FOR ControlPtr=2 TO LastControl				IF ControlArray(ControlPtr).PuppetEars(1)<>0 THEN					CALL SUB CopyToClipBoard					INCR ClipBoardPtr				END IF			NEXT ControlPtr			CALL SUB RemoveEars		END IF		CALL SUB SetClipBoardXY	CASE fwmnuPaste		FOR ClipBoardPtr=1 TO ClipBoardItemCount			CALL SUB PasteControl		NEXT ClipBoardPtr		ControlNdx=PlacePtr		CALL SUB ControlArrayToToolBox		ControlCombo.TEXT=ControlArray(PlacePtr).PuppetName		;CALL SUB refresh_command	CASE fwmnuShowGrid		IF ShowGrid=FALSE THEN			CHECKMENUITEM FormPopUp,fwmnuShowGrid,TRUE			INVALIDATERECT FormWindow			CALL SUB PaintGrid			CALL SUB RedrawParts		ELSE			CHECKMENUITEM FormPopUp,fwmnuShowGrid,FALSE			INVALIDATERECT FormWindow			CALL SUB RedrawParts		END IF		ShowGrid=NOT(ShowGrid)	CASE fwmnuSnapToGrid		IF SnapToGrid=FALSE THEN			CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,TRUE			StatusBar.SETTEXT 5,"Snap On"		ELSE			CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,FALSE			StatusBar.SETTEXT 5,"Snap Off"		END IF		SnapToGrid=NOT(SnapToGrid)	CASE fwmnuDelete		IF MultiSelectItemCount=0 THEN			CALL SUB DeleteControl		ELSE			FOR ControlPtr=2 TO LastControl				IF ControlArray(ControlPtr).PuppetEars(1)<>0 THEN					CALL SUB DeleteControl				END IF			NEXT ControlPtr			CALL SUB RemoveEars		END IF	CASE fwmnuViewCode		CALL SUB ModeChange	CASE fwmnuViewAutoCode		CALL SUB ViewAutoCode	CASE emnuReturnToSource		ENABLEMENUITEM EditPopUp,emnuReturnToSource,FALSE		FileName=SourceFileName		SaveFileName=FileName		Extension=LCASE(RIGHT(FileName,4))		OBMain.TEXT=ProgramName+"     ["+FileName+"]"		CALL SUB LoadSource	CASE emnuViewSegs		ProcType=1		CALL SUB ViewProcs	CASE emnuViewSubs		ProcType=2		CALL SUB ViewProcs	CASE emnuViewProcs		ProcType=3		CALL SUB ViewProcs	CASE emnuViewFcns		ProcType=4		CALL SUB ViewProcs	CASE emnuUnDo		Edit.UNDO	CASE emnuReDo		Edit.REDO	CASE emnuCut		Edit.CUT	CASE emnuCopy		Edit.COPY	CASE emnuPaste		Edit.PASTE	CASE emnuSelectAll		Edit.SELECTALL	CASE emnuGotoLine		CALL SUB GotoLine		GotoText.SETFOCUS	CASE emnuGotoTop		Edit.GOTO 1		Edit.SETFOCUS	CASE emnuGotoBottom		Edit.GOTO EditnLines		Edit.SETFOCUS	CASE emnuFind		CALL SUB GetFindDialog	CASE emnuReplace		CALL SUB GetFindReplaceDialog	CASE emnuViewObject		CALL SUB ModeChange	CASE fwmnuBringToFront		TempHandle=ControlArray(ControlPtr).PuppetHandle		invoke SetWindowPos,[TempHandle],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE		invoke InvalidateRect,[TempHandle],NULL,TRUE		CALL SUB ShowSpiderLegs	CASE fwmnuSendToBack		TempHandle=ControlArray(ControlPtr).PuppetHandle		invoke SetWindowPos,[TempHandle],HWND_BOTTOM,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE		invoke InvalidateRect,[TempHandle],NULL,TRUE	CASE gsmnu5		GridSize=5		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu5,TRUE		CALL SUB SetGridSize	CASE gsmnu10		GridSize=10		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu10,TRUE		CALL SUB SetGridSize	CASE gsmnu15		GridSize=15		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu15,TRUE		CALL SUB SetGridSize	CASE gsmnu20		GridSize=20		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu20,TRUE		CALL SUB SetGridSize	CASE gsmnu25		GridSize=25		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu25,TRUE		CALL SUB SetGridSize	CASE gsmnu30		GridSize=30		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu30,TRUE		CALL SUB SetGridSize	CASE gsmnu35		GridSize=35		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu35,TRUE		CALL SUB SetGridSize	CASE gsmnu40		GridSize=40		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu40,TRUE		CALL SUB SetGridSize	CASE gsmnu45		GridSize=45		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu45,TRUE		CALL SUB SetGridSize	CASE gsmnu50		GridSize=50		CALL SUB UnCheckGridSize		CHECKMENUITEM GridSizePopUp,gsmnu50,TRUE		CALL SUB SetGridSize	CASE gcmnuBlack		GridColor=$000000		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuBlack,TRUE		CALL SUB SetGridColor	CASE gcmnuWhite		GridColor=$ffffff		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuWhite,TRUE		CALL SUB SetGridColor	CASE gcmnuRed		GridColor=$0000ff		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuRed,TRUE		CALL SUB SetGridColor	CASE gcmnuGreen		GridColor=$00ff00		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuGreen,TRUE		CALL SUB SetGridColor	CASE gcmnuBlue		GridColor=$ff0000		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuBlue,TRUE		CALL SUB SetGridColor	CASE gcmnuYellow		GridColor=$00ffff		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuYellow,TRUE		CALL SUB SetGridColor	CASE gcmnuMagenta		GridColor=$ff00ff		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuMagenta,TRUE		CALL SUB SetGridColor	CASE gcmnuDkRed		GridColor=$0000c0		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuDkRed,TRUE		CALL SUB SetGridColor	CASE gcmnuDkGreen		GridColor=$00c000		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuDkGreen,TRUE		CALL SUB SetGridColor	CASE gcmnuDkBlue		GridColor=$c00000		CALL SUB UnCheckGridColor		CHECKMENUITEM GridColorPopUp,gcmnuDkBlue,TRUE		CALL SUB SetGridColorEND SELECTEND EVENTBEGIN SUB ViewProcs	ProcWindow.VISIBLE=TRUE	ProcList.CLEAR	SELECT CASE ProcType		CASE 1			TempStr="Segs"			FindStr="begin seg"		CASE 2			TempStr="Subs"			FindStr="begin sub"		CASE 3			TempStr="Procs"			FindStr="begin proc"		CASE 4			TempStr="Fcns"			FindStr="begin fcn"	END SELECT	ProcWindow.TEXT=TempStr	fr_lpstrFindWhat=ADDR(FindStr)	FLAGS=$09	EditcpMin=1	BEGIN LOOP		Edit.find;SEARCH		IF STATUS=-1 THEN			EXIT SUB		ELSE			TempStr=Edit.line(EditLine)			ProcList.ADDITEMSORTED TempStr		END IF		END LOOPEND SUBProcWindow.SYSTEM	ProcWindow.VISIBLE=FALSEEND EVENTBEGIN SUB SaveAs	CaptureEnabled=FALSE	RELEASECAPTURE	FileName=SaveFileName	SAVEDIALOG FileName,FileFilter,InitDir	IF STATUS<>0 THEN		Edit.EMPTYUNDOBUFFER		SaveFileName=FileName		CALL SUB SaveEdit		SourceFileName=SaveFileName		BareFileName=LEFT(FileName,LEN(FileName)-4)		Extension=LCASE(RIGHT(FileName,4))		IF LCASE(Extension)=".obp" THEN			CALL SUB WriteTools		END IF		OBMain.TEXT=ProgramName+"     ["+FileName+"]"	END IF	CaptureEnabled=TRUEEND SUBEdit.CHANGE	StatusBarSafe1="Line "+STR(EditLine)	StatusBar.SETTEXT 1,StatusBarSafe1	StatusBarSafe2="Column "+STR(EditcpLine)	StatusBar.SETTEXT 2,StatusBarSafe2	StatusBarSafe3=STR(EditnLines)+" Lines"	StatusBar.SETTEXT 3,StatusBarSafe3	StatusBarSafe4="Edit Text"	StatusBar.SETTEXT 4,StatusBarSafe4	IF EditfChanged<>0 THEN		CALL SUB SetChanged	END IF	IF Edit.CANUNDO=TRUE THEN		;// ENABLEMENUITEMMainMenu,mnuUnDo,TRUE		Button(7).ENABLED=TRUE	ELSE		;// ENABLEMENUITEMMainMenu,mnuUnDo,FALSE		Button(7).ENABLED=FALSE		StatusBar.SETTEXT 5,"Not Changed"		Changed=FALSE		ENABLEMENUITEM MainMenu,mnuSave,FALSE		Button(3).ENABLED=FALSE	END IF	IF Edit.CANREDO=TRUE THEN		;// ENABLEMENUITEMMainMenu,mnuReDo,TRUE		Button(8).ENABLED=TRUE	ELSE		;// ENABLEMENUITEMMainMenu,mnuReDo,FALSE		Button(8).ENABLED=FALSE	END IF	;IF Edit.CANPASTE=TRUE THEN	;	;// ENABLEMENUITEMMainMenu,mnuPaste	;ELSE	;	DISABLEMENUITEM MainMenu,mnuPaste	;END IFEND EVENTGotoText.CHANGE	TempStr=GotoText.TEXT	IF LEN(TempStr)=0 THEN	GotoButton.ENABLED=FALSE	ELSE		GotoButton.ENABLED=TRUE	END IFEND EVENTGotoButton.COMMAND	TempStr=GotoText.TEXT	TempInt=VAL(TempStr)	Edit.GOTO TempInt	GotoText.TEXT=""	GotoWindow.VISIBLE=FALSEEND EVENTGotoWindow.SYSTEM	GotoWindow.VISIBLE=FALSEEND EVENTScratchPadWindow.SYSTEM	ScratchPadWindow.VISIBLE=FALSEEND EVENTButton.COMMANDRELEASECAPTURECALL SUB RemoveEarsSELECT CASE ArrayIndex	CASE 1		CALL SUB NewCmd	CASE 2		CALL SUB OpenCmd	CASE 3		CALL SUB SaveCmd	CASE 4		CALL SUB SaveAsCmd	CASE 5	CASE 6		CALL SUB ModeChange	CASE 7		Edit.UNDO	CASE 8		Edit.REDO	CASE 9					CASE 10		Edit.CUT		CASE 11		Edit.COPY		CASE 12		Edit.PASTE		CASE 13		CALL SUB GotoLine		GotoText.SETFOCUS	CASE 14		CALL SUB GetFindDialog	CASE 15		CALL SUB GetFindReplaceDialog			CASE 16		IF TextMode=FALSE THEN			CALL SUB ModeChange		END IF		CALL SUB CompileToExe		CALL SUB PostCompile		CASE 17		IF TextMode=FALSE THEN			CALL SUB ModeChange		END IF		CALL SUB CompileToAsm		CALL SUB PostCompile		CASE 18		IF TextMode=FALSE THEN			CALL SUB ModeChange		END IF		CALL SUB TestCompile		CALL SUB PostCompile		CASE 19		IF TextMode=FALSE THEN			CALL SUB ModeChange		END IF		;Edit.APPENDTEXT "Havis"		;OBMain.text=TempStr	CASE 20		IF ShowSymbols=TRUE THEN			ShowSymbols=FALSE			DESTROY SymbolGrid			Edit.ENABLED=TRUE			EventCombo1.VISIBLE=TRUE			EventCombo2.VISIBLE=TRUE		ELSE			IF UserSym>=LastSym THEN				SETDEFAULTCURSOR				WARNINGBOX "Symbol Table","No Symbols In Table",MB_OK				RETURN			END IF			ShowSymbols=TRUE			Edit.ENABLED=FALSE			EventCombo1.VISIBLE=FALSE			EventCombo2.VISIBLE=FALSE			CREATE SymbolGrid,0,42,1015,630			SymbolGrid.FONT=GridFont			SymbolGrid.BACKCOLOR=$800000			SymbolGrid.FORECOLOR=$ffffff			SymbolGrid.HEADERHEIGHT=18			SymbolGrid.ROWHEIGHT=15			SymbolGrid.ADDCOL TEXT,35,"#",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,165,"Symbol Name",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,70,"DataType",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,35,"Sub",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Modifer",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Detail",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Addr",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Size",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Dim1",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Dim2",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Dim3",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Events",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,61,"Notify",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,28,"Dim",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,25,"Msc",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,25,"Fdt",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,25,"Arg",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,35,"Use",CENTER,LEFT,31			FOR I=UserSym TO LastSym				J=I-UserSym+1				SymbolGrid.ADDROW				TempStr=STR(J)				CALL SUB FormatNumber4				SymbolGrid.TEXT(J,1)=TempStr				TempStr=SymTable(I).SymName				SymbolGrid.TEXT(J,2)=TempStr				TempInt=SymTable(I).DataType				CALL SUB GetDataTypeString				SymbolGrid.TEXT(J,3)=TempStr				TempStr=HEX(SymTable(I).SubType)				CALL SUB FormatNumber4				SymbolGrid.TEXT(J,4)=TempStr				TempStr=HEX(SymTable(I).DataMod)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,5)=TempStr				TempStr=HEX(SymTable(I).Detail)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,6)=TempStr				TempStr=HEX(SymTable(I).DataAddr)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,7)=TempStr				TempStr=HEX(SymTable(I).DataSize)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,8)=TempStr				TempStr=HEX(SymTable(I).ArrayDim1)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,9)=TempStr				TempStr=HEX(SymTable(I).ArrayDim2)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,10)=TempStr				TempStr=HEX(SymTable(I).ArrayDim3)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,11)=TempStr				TempStr=HEX(SymTable(I).GUIEvents)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,12)=TempStr				TempStr=HEX(SymTable(I).GUINotifyEvents)				CALL SUB FormatNumber8				SymbolGrid.TEXT(J,13)=TempStr				TempStr=HEX(SymTable(I).ArrayDims)				CALL SUB FormatNumber2				SymbolGrid.TEXT(J,14)=TempStr				TempStr=HEX(SymTable(I).Misc)				CALL SUB FormatNumber2				SymbolGrid.TEXT(J,15)=TempStr				TempStr=HEX(SymTable(I).FcnDataType)				CALL SUB FormatNumber2				SymbolGrid.TEXT(J,16)=TempStr				TempStr=HEX(SymTable(I).FcnArgs)				CALL SUB FormatNumber2				SymbolGrid.TEXT(J,17)=TempStr				TempStr=STR(SymTable(I).UseCount)				CALL SUB FormatNumber4				;TempStr="0000"				SymbolGrid.TEXT(J,18)=TempStr			NEXT I		END IF		CASE 21		CALL SUB ScratchPad	CASE 22		LAUNCH BareFileName	CASE 23		; Help button		launch "DIRECTX.CHM"END SELECTEND EVENTBEGIN SUB ModeChangeIF TextMode=TRUE THEN	CaptureEnabled=TRUE	StatusBar.SETTEXT 1,""	StatusBar.SETTEXT 2,""	StatusBar.SETTEXT 3,""	StatusBar.SETTEXT 4,""	IF SnapToGrid=TRUE THEN		StatusBar.SETTEXT 5,"Snap On"		CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,TRUE	ELSE		StatusBar.SETTEXT 5,"Snap Off"		CHECKMENUITEM FormPopUp,fwmnuSnapToGrid,FALSE	END IF	FOR I=1 TO 23		IF I=5 OR I=13 OR I=14 OR I=15 OR I=20 OR I=21 THEN			Button(I).ENABLED=FALSE		END IF	NEXT I	IF Button(7).ENABLED=TRUE THEN		UnDoFlag=TRUE	ELSE		UnDoFlag=FALSE	END IF	Button(7).ENABLED=FALSE	IF Button(8).ENABLED=TRUE THEN		ReDoFlag=TRUE	ELSE		ReDoFlag=FALSE	END IF	Button(8).ENABLED=FALSE	;// ENABLEMENUITEMMainMenu,mnuExit,FALSE	IF dbgwin.created=FALSE THEN		CREATE dbgwin,0,740,1024,255 child		CREATE refresh,10,5,80,20 in dbgwin		refresh.text="Refresh"		create showcclipboard,10,30,80,20 in dbgwin		showcclipboard.text="ClpBrd"		CREATE controlndx,100,5,80,20 in dbgwin		CREATE controlptr,180,5,80,20 in dbgwin		CREATE controlcount,270,5,80,20 in dbgwin		CREATE controlname,360,5,80,20 in dbgwin		CREATE controlptrsafe,440,5,80,20 in dbgwin		create lastcontrol,520,5,80,20 in dbgwin		CREATE controlndxlbl,95,30,85,20 in dbgwin		controlndxlbl.text="ControlNdx"		CREATE controlptrlbl,175,30,85,20 in dbgwin		controlptrlbl.text="ControlPtr"		CREATE controlcountlbl,265,30,85,20 in dbgwin		controlcountlbl.text="ControlCount"		CREATE controlnamelbl,355,30,85,20 in dbgwin		controlnamelbl.text="ControlName"		CREATE controlptrsafelbl,440,30,80,20 in dbgwin		controlptrsafelbl.text="PtrSafe"		create lastcontrollbl,520,30,80,20 in dbgwin		lastcontrollbl.text="LastControl"		CREATE dbggrid,0,50,1015,180 in dbgwin		dbggrid.addcol LONG,35,"#",LEFT,LEFT,31		dbggrid.addcol TEXT,80,"Handle",LEFT,LEFT,31		dbggrid.addcol LONG,30,"ID",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Own",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Arr",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Left",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Top",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Wid",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Hgt",LEFT,LEFT,31		dbggrid.addcol TEXT,50,"BColor",LEFT,LEFT,31		dbggrid.addcol TEXT,50,"FColor",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Type",LEFT,LEFT,31		dbggrid.addcol text,50,"Status",LEFT,LEFT,31		dbggrid.addcol LONG,50,"Font",LEFT,LEFT,31		dbggrid.addcol LONG,50,"Icon",LEFT,LEFT,31		dbggrid.addcol TEXT,50,"CT",LEFT,LEFT,31		dbggrid.addcol TEXT,100,"Text",LEFT,LEFT,31		dbggrid.addcol TEXT,100,"Name",LEFT,LEFT,31		dbggrid.addcol LONG,30,"Own",LEFT,LEFT,31		dbggrid.addcol TEXT,80,"Ear",LEFT,LEFT,31		dbggrid.addcol LONG,50,"ArrMax",LEFT,LEFT,31		dbggrid.FONT=GridFont		dbggrid.HEADERHEIGHT=18		dbggrid.ROWHEIGHT=15					CREATE ToolBox,3,85,300,631 CHILD		ToolBox.TEXT="Toolbox"		ToolBox.VISIBLE=FALSE		CREATE ToolButton(1),10,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(1).TOOLTIP="Form"		CREATE FormBMP,OBTForm.bmp		ToolButton(1).BITMAP=FormBMP		CREATE ToolButton(2),45,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(2).TOOLTIP="ToolWindow"		ToolButton(2).BITMAP=FormBMP		CREATE ToolButton(3),80,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(3).TOOLTIP="Button"		CREATE ButtonBMP,OBTButton.bmp		ToolButton(3).BITMAP=ButtonBMP		CREATE ToolButton(4),115,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(4).TOOLTIP="StaticText"		CREATE StaticTextBMP,OBTStaticText.bmp		ToolButton(4).BITMAP=StaticTextBMP		CREATE ToolButton(5),150,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(5).TOOLTIP="Frame"		CREATE FrameBMP,OBTFrame.bmp		ToolButton(5).BITMap=FrameBMP		CREATE ToolButton(6),185,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(6).TOOLTIP="Slider"		CREATE SliderBMP,OBTSlider.bmp		ToolButton(6).BITMAP=SliderBMP		CREATE ToolButton(7),220,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(7).TOOLTIP="TextBox"		CREATE TextBoxBMP,OBTTextBox.bmp		ToolButton(7).BITMAP=TextBoxBMP		CREATE ToolButton(8),255,5,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(8).TOOLTIP="ComboBox"		CREATE ComboBoxBMP,OBTComboBox.bmp		ToolButton(8).BITMAP=ComboBoxBMP		CREATE ToolButton(9),10,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(9).TOOLTIP="ListBox"		CREATE ListBoxBMP,OBTListBox.bmp		ToolButton(9).BITMAP=ListBoxBMP		CREATE ToolButton(10),45,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(10).TOOLTIP="RadioButton"		CREATE RadioButtonBMP,OBTRadioButton.bmp		ToolButton(10).BITMAP=RadioButtonBMP		CREATE ToolButton(11),80,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(11).TOOLTIP="CheckBox"		CREATE CheckBoxBMP,OBTCheckBox.bmp		ToolButton(11).BITMAP=CheckBoxBMP		CREATE ToolButton(12),115,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(12).TOOLTIP="ProgressBar"		CREATE ProgressBarBMP,OBTProgressBar.bmp		ToolButton(12).BITMAP=ProgressBarBMP		CREATE ToolButton(13),150,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(13).TOOLTIP="Calendar"		CREATE CalendarBMP,OBTCalendar.bmp		ToolButton(13).BITMAP=CalendarBMP		CREATE ToolButton(14),185,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(14).TOOLTIP="TabFolder"		CREATE TabFolderBMP,OBTTabFolder.bmp		ToolButton(14).BITMAP=TabFolderBMP		CREATE ToolButton(15),220,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE SpinnerBMP,OBTVScroll.bmp		ToolButton(15).BITMAP=SpinnerBMP		CREATE ToolButton(16),255,35,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(16).TOOLTIP="Statusbar"		CREATE StatusBarBMP,OBTStatusBar.bmp		ToolButton(16).BITMAP=StatusBarBMP		CREATE ToolButton(17),10,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE HeaderBMP,OBTHeader.bmp		ToolButton(17).BITMAP=HeaderBMP		CREATE ToolButton(18),45,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE AnimateBMP,OBTAnimate.bmp		ToolButton(18).BITMAP=AnimateBMP		CREATE ToolButton(19),80,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		CREATE RichEditBMP,OBTRichEdit.bmp		ToolButton(19).BITMAP=RichEditBMP		CREATE ToolButton(20),115,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(20).TOOLTIP="RAEdit"		CREATE RAEditBMP,OBTRAEdit.bmp		ToolButton(20).BITMAP=RAEditBMP		CREATE ToolButton(21),150,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(21).TOOLTIP="RAGrid"		CREATE RAGridBMP,OBTGrid.bmp		ToolButton(21).BITMAP=RAGridBMP		CREATE ToolButton(22),185,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(22).TOOLTIP="ListView"		CREATE ListViewBMP,OBTListView.bmp		ToolButton(22).BITMAP=ListViewBMP		CREATE ToolButton(23),220,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(23).TOOLTIP="ToolBar"		CREATE ToolBarBMP,OBTToolBar.bmp		ToolButton(23).BITMAP=ToolBarBMP		CREATE ToolButton(24),255,65,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(24).TOOLTIP="TreeView"		CREATE TreeViewBMP,OBTTreeView.bmp		ToolButton(24).BITMAP=TreeViewBMP		CREATE ToolButton(25),10,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(25).TOOLTIP="DateTimePick"		CREATE DateTimePickBMP,OBTDateTimePick.bmp		ToolButton(25).BITMAP=DateTimePickBMP		CREATE ToolButton(26),45,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(26).TOOLTIP="Image"		CREATE ImageBMP,OBTImage.bmp		ToolButton(26).BITMAP=ImageBMP		CREATE ToolButton(27),80,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(27).TOOLTIP="DrawProgress"		CREATE DrawProgressBMP,OBTDrawProgress.bmp		ToolButton(27).BITMAP=DrawProgressBMP		CREATE ToolButton(28),115,95,25,25,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		ToolButton(28).TOOLTIP="ButtonEx"		ToolButton(28).BITMAP=ButtonBMP		;ToolButton(29).TEXT=""		;CREATE ToolButton(30),196,166,98,18,VISIBLE+CHILD+BITMAP+FLAT IN ToolBox		;ToolButton(30).TEXT=""		CREATE FormCombo,0,184,295,160 IN ToolBox		CREATE ControlCombo,0,210,295,160 IN ToolBox		CREATE PropGrid,0,236,295,185 IN ToolBox		PropGrid.FONT=GridFont		PropGrid.HEADERHEIGHT=18		PropGrid.ROWHEIGHT=15		PropGrid.ADDCOL TEXT,100,"Property",CENTER,LEFT,32		PropGrid.ADDCOL TEXT,156,"Value",CENTER,LEFT,32		PropGrid.ADDCOL BUTTON,18,"",CENTER,CENTER,32		CREATE StyleGrid,0,421,295,185 IN ToolBox		StyleGrid.FONT=GridFont		StyleGrid.HEADERHEIGHT=18		StyleGrid.ROWHEIGHT=15		StyleGrid.ADDCOL TEXT,114,"Style",CENTER,LEFT,32		StyleGrid.ADDCOL CHECK,60,"On/Off",CENTER,CENTER,32		StyleGrid.ADDCOL TEXT,100,"Value",CENTER,LEFT,32		CREATE ExStyleGrid,0,421,295,185 IN ToolBox		ExStyleGrid.FONT=GridFont		ExStyleGrid.HEADERHEIGHT=18		ExStyleGrid.ROWHEIGHT=15		ExStyleGrid.ADDCOL TEXT,114,"ExStyle",CENTER,LEFT,32		ExStyleGrid.ADDCOL CHECK,60,"On/Off",CENTER,CENTER,32		ExStyleGrid.ADDCOL TEXT,100,"Value",CENTER,LEFT,32		ExStyleGrid.VISIBLE=FALSE	ELSE		BackGround.VISIBLE=TRUE		ToolBox.VISIBLE=TRUE		FormWindow.VISIBLE=TRUE	END IF	TextMode=FALSE	FindWindow.VISIBLE=FALSE	FindReplaceWindow.VISIBLE=FALSE	Edit.VISIBLE=FALSE	QuickFindPrev.VISIBLE=FALSE	QuickFindNext.VISIBLE=FALSE	QuickFind.VISIBLE=FALSE	EventCombo1.VISIBLE=FALSE	EventCombo2.VISIBLE=FALSE	GotoWindow.VISIBLE=FALSE	ScratchPadWindow.VISIBLE=FALSE	BackGround.VISIBLE=TRUE	IF ToolView=TRUE THEN		ToolBox.VISIBLE=TRUE	END IF	IF ClearToolsFlag=TRUE OR LoadToolsFlag=TRUE THEN		ToolButtonNdx=1		PlacePart=TRUE		CALL SUB PopulateToolBox		CALL SUB ToolButtonAction		PlacePart=FALSE		ClearToolsFlag=FALSE	END IF	IF LoadToolsFlag=TRUE THEN		szControlNames="OBMain"		FOR PlacePtr=2 TO LastControl			TempControlType=ControlArray(PlacePtr).PuppetControlType			TempExStyle=ControlArray(PlacePtr).PuppetExStyle			TempStr=ControlArray(PlacePtr).PuppetText			TempStyle=ControlArray(PlacePtr).PuppetStyle			TempLeft=ControlArray(PlacePtr).PuppetLeft			TempTop=ControlArray(PlacePtr).PuppetTop					TempWidth=ControlArray(PlacePtr).PuppetWidth			TempHeight=ControlArray(PlacePtr).PuppetHeight			OwnerPtr=ControlArray(PlacePtr).PuppetOwner			CALL SUB GetControlID			IF ControlArray(PlacePtr).PuppetArrayNdx=-1 THEN							EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName				HiliteControlName=ControlArray(PlacePtr).PuppetName				CALL SUB AddHiliteName			ELSE				IF ControlArray(PlacePtr).PuppetArraySize>0 THEN					TempControlName=Root(ControlArray(PlacePtr).PuppetName)					EventCombo1.ADDITEMSORTED TempControlName					HiliteControlName=TempControlName					CALL SUB AddHiliteName				END IF			END IF			IF ControlArray(PlacePtr).PuppetHandle>0 THEN				TempStr=ControlArray(PlacePtr).PuppetName				CALL SUB CreatePuppet				TempStr=ControlArray(PlacePtr).PuppetText				invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]				IF ControlArray(PlacePtr).PuppetForm<>1 THEN					invoke ShowWindow, dword [TempInt],SW_HIDE				ELSE					IF BITTST(ControlArray(PlacePtr).PuppetStatus,2)=FALSE THEN						invoke ShowWindow, dword [TempInt],SW_HIDE					END IF					IF BITTST(ControlArray(PlacePtr).PuppetStatus,1)=FALSE THEN						invoke EnableWindow, dword [TempInt],FALSE					END IF					ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName				END IF				ControlArray(PlacePtr).PuppetHandle=TempInt				TempHandle=TempInt				ControlPtr=PlacePtr				RGB=ControlArray(ControlPtr).PuppetBackColor				CALL SUB SetBackColor				RGB=ControlArray(ControlPtr).PuppetForeColor				TempHandle=ControlArray(PlacePtr).PuppetHandle				CALL SUB SetForeColor				IF ControlArray(PlacePtr).PuppetType=26 THEN					IF ControlArray(PlacePtr).PuppetImage<>"" THEN						LOAD ToolBitmap,ControlArray(PlacePtr).PuppetImage						invoke SendMessage, dword [TempHandle],STM_SETIMAGE,IMAGE_BITMAP,eax					END IF				END IF			ELSE				FormCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName			END IF		NEXT PlacePtr		ControlCombo.TEXT="OBMain"		EventCombo1.TEXT="Select Control"		LoadToolsFlag=FALSE	END IF	StatusBarSafe4="Edit Objects"	StatusBar.SETTEXT 4,StatusBarSafe4	Button(6).BITMAP=EditBMP	CALL SUB PaintGrid	CALL SUB RedrawParts	ControlPtr=1	ControlNdx=1	CALL SUB ControlArrayToToolBox	;CALL SUB refresh_commandELSE	CaptureEnabled=FALSE	RELEASECAPTURE	StatusBar.SETTEXT 1,StatusBarSafe1	StatusBar.SETTEXT 2,StatusBarSafe2	StatusBar.SETTEXT 3,StatusBarSafe3	StatusBar.SETTEXT 4,StatusBarSafe4	IF Changed=TRUE THEN		StatusBar.SETTEXT 5,"Changed"		Button(3).ENABLED=TRUE	ELSE		StatusBar.SETTEXT 5,"Not Changed"		Button(3).ENABLED=FALSE		END IF		FOR I=1 TO 22		IF I=5 OR I=13 OR I=14 OR I=15 OR I=20 OR I=21 THEN			Button(I).ENABLED=TRUE		END IF		NEXT I	IF UnDoFlag=TRUE THEN		Button(7).ENABLED=TRUE	ELSE						Button(7).ENABLED=FALSE	END IF	IF ReDoFlag=TRUE THEN		Button(8).ENABLED=TRUE	ELSE		Button(8).ENABLED=FALSE	END IF	;// ENABLEMENUITEMMainMenu,mnuExit,TRUE	TextMode=TRUE	IF FindWindowActive THEN		FindWindow.VISIBLE=TRUE	END IF	IF FRWindowActive THEN		FindReplaceWindow.VISIBLE=TRUE	END IF	Edit.VISIBLE=TRUE	Edit.ENABLED=TRUE	QuickFindPrev.VISIBLE=TRUE	QuickFindNext.VISIBLE=TRUE	QuickFind.VISIBLE=TRUE	EventCombo1.VISIBLE=TRUE	EventCombo2.VISIBLE=TRUE	BackGround.VISIBLE=FALSE	ToolBox.VISIBLE=FALSE	FormWindow.VISIBLE=FALSE	ViewAutoCodeWindow.VISIBLE=FALSE	StatusBarSafe4="Edit Text"	StatusBar.SETTEXT 4,StatusBarSafe4	Button(6).BITMAP=ToolBMPEND IFEND SUBBEGIN SUB GotoLine	IF GotoWindow.CREATED=FALSE THEN		CREATE GotoWindow,100,100,110,90 APPWINDOW CHILD		GotoWindow.TEXT="Goto Line"		CREATE GotoText,10,10,80,20 IN GotoWindow		GotoText.INTERCEPTON		CREATE GotoButton,10,40,80,20 IN GotoWindow		GotoButton.TEXT="Goto Line"	ELSE		GotoWindow.VISIBLE=TRUE	END IF	GotoText.SETFOCUS	GotoButton.ENABLED=FALSEEND SUBGotoText.INTERCEPT	IF wmsg=$102 THEN		IF wparam=$0d THEN			CALL SUB GotoButton_COMMAND		END IF	END IF	PASSEVENTEND EVENTBEGIN SUB ScratchPad	IF ScratchPadWindow.CREATED=FALSE THEN		CREATE ScratchPadWindow,400,100,400,300 APPWINDOW CHILD		ScratchPadWindow.TEXT="ScratchPad"		CREATE ScratchPadText,0,0,395,275,default+multiline+autovscroll+autohscroll+vscroll+hscroll IN ScratchPadWindow	ELSE		ScratchPadWindow.VISIBLE=TRUE	END IF	ScratchPadText.SETFOCUSEND SUBBEGIN SUB ViewAutoCode	IF ViewAutoCodeWindow.CREATED=FALSE THEN		CREATE ViewAutoCodeWindow,3,85,300,631 APPWINDOW CHILD		ViewAutoCodeWindow.TEXT="View AutoCode"		CREATE ViewAutoCodeText,0,0,293,607,default+multiline+autovscroll+autohscroll+vscroll+hscroll IN ViewAutoCodeWindow	ELSE		ViewAutoCodeWindow.VISIBLE=TRUE	END IF	CALL SUB GenToolCode	OPEN "_OBMainFormFile.INC" FOR INPUT AS ToolFile	FilBufSiz=LOF(ToolFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD ToolFile,FilBufAdr,FilBufSiz	CLOSE ToolFile	ViewAutoCodeText.LOADFILE "_OBMainFormFile.INC"	BUFFER FileBuf=0END SUBViewAutoCodeWindow.RESIZE	GETCLIENTRECT ViewAutoCodeWindow	SETPOSITION ViewAutoCodeText,RectLeft,RectTop,RectRight-RectLeft,RectBottom-RectTopEND EVENTViewAutoCodeWindow.SYSTEM	ViewAutoCodeWindow.VISIBLE=FALSEEND EVENTFormWindow.SYSTEM	; Do NothingEND EVENTToolBox.RESIZE	;SETPOSITION ToolBox,3,85,300,155END EVENTTABLE ImportLibTable AS ImportLibData	"kernel32","kernel32.dll",FALSE,FALSE	"user32","User32.dll",FALSE,FALSE	"gdi","GDI32.DLL",FALSE,FALSE	"comctl","COMCTL32.DLL",FALSE,FALSE	"comdlg","COMDLG32.DLL",FALSE,FALSE	"shell","SHELL32.DLL",FALSE,FALSE	"advapi","ADVAPI32.DLL",FALSE,FALSE	"winmm","WINMM.DLL",FALSE,FALSE	"msvcrt","msvcrt.dll",FALSE,FALSE	"csmdll","csmdll.dll",FALSE,FALSE	"richedit","RichEd20.dll",FALSE,FALSE	"imagelib","ImageLib.dll",FALSE,FALSE	"ziplib","bszip.dll",FALSE,FALSEEND TABLETABLE ImportFcnTable AS ImportFcnData	ptrkernel32,"Beep","Beep",FALSE,FALSE	ptrkernel32,"SetThreadPriority","SetThreadPriority",FALSE,FALSE	ptrkernel32,"Sleep","Sleep",FALSE,FALSE	ptrkernel32,"CreateThread","CreateThread",FALSE,FALSE	ptrkernel32,"SuspendThread","SuspendThread",FALSE,FALSE	ptrkernel32,"ResumeThread","ResumeThread",FALSE,FALSE	ptrkernel32,"ClearCommError","ClearCommError",FALSE,FALSE	ptrkernel32,"CloseHandle","CloseHandle",FALSE,FALSE	ptrkernel32,"CreateDirectory","CreateDirectoryA",FALSE,FALSE	ptrkernel32,"CreateFile","CreateFileA",FALSE,FALSE	ptrkernel32,"CreatePipe","CreatePipe",FALSE,FALSE	ptrkernel32,"CreateProcess","CreateProcessA",FALSE,FALSE	ptrkernel32,"DeleteFile","DeleteFileA",FALSE,FALSE	ptrkernel32,"ExitProcess","ExitProcess",FALSE,FALSE	ptrkernel32,"GetCommandLine","GetCommandLineA",FALSE,FALSE	ptrkernel32,"GetCurrentProcess","GetCurrentProcess",FALSE,FALSE	ptrkernel32,"GetCurrentDirectory","GetCurrentDirectoryA",FALSE,FALSE	ptrkernel32,"GetFileSize","GetFileSize",FALSE,FALSE	ptrkernel32,"GetFileType","GetFileType",FALSE,FALSE	ptrkernel32,"GetFullPathName","GetFullPathNameA",FALSE,FALSE	ptrkernel32,"GetLastError","GetLastError",FALSE,FALSE	ptrkernel32,"GetModuleHandle","GetModuleHandleA",FALSE,FALSE	ptrkernel32,"GetStdHandle","GetStdHandle",FALSE,FALSE	ptrkernel32,"GetTickCount","GetTickCount",FALSE,FALSE	ptrkernel32,"GetSystemTime","GetSystemTime",FALSE,FALSE	ptrkernel32,"GetLocalTime","GetLocalTime",FALSE,FALSE	ptrkernel32,"GetDateFormat","GetDateFormatA",FALSE,FALSE	ptrkernel32,"GetTimeFormat","GetTimeFormatA",FALSE,FALSE	ptrkernel32,"FileTimeToSystemTime","FileTimeToSystemTime",FALSE,FALSE	ptrkernel32,"SystemTimeToFileTime","SystemTimeToFileTime",FALSE,FALSE	ptrkernel32,"LoadLibrary","LoadLibraryA",FALSE,FALSE	ptrkernel32,"ReadConsole","ReadConsoleA",FALSE,FALSE	ptrkernel32,"ReadFile","ReadFile",FALSE,FALSE	ptrkernel32,"RemoveDirectory","RemoveDirectoryA",FALSE,FALSE	ptrkernel32,"SetCurrentDirectory","SetCurrentDirectoryA",FALSE,FALSE	ptrkernel32,"SetCommMask","SetCommMask",FALSE,FALSE	ptrkernel32,"GetCommState","GetCommState",FALSE,FALSE	ptrkernel32,"SetCommState","SetCommState",FALSE,FALSE	ptrkernel32,"SetFilePointer","SetFilePointer",FALSE,FALSE	ptrkernel32,"SetEndOfFile","SetEndOfFile",FALSE,FALSE	ptrkernel32,"VirtualAlloc","VirtualAlloc",FALSE,FALSE	ptrkernel32,"VirtualFree","VirtualFree",FALSE,FALSE	ptrkernel32,"WinExec","WinExec",FALSE,FALSE	ptrkernel32,"WriteConsole","WriteConsoleA",FALSE,FALSE	ptrkernel32,"WriteFile","WriteFile",FALSE,FALSE	ptruser32,"AppendMenu","AppendMenuA",FALSE,FALSE	ptruser32,"BeginPaint","BeginPaint",FALSE,FALSE	ptruser32,"EndPaint","EndPaint",FALSE,FALSE	ptruser32,"DrawTextEx","DrawTextExA",FALSE,FALSE	ptruser32,"GetDC","GetDC",FALSE,FALSE	ptruser32,"GetFocus","GetFocus",FALSE,FALSE	ptruser32,"GetSysColor","GetSysColor",FALSE,FALSE	ptruser32,"ReleaseDC","ReleaseDC",FALSE,FALSE	ptruser32,"CallWindowProc","CallWindowProcA",FALSE,FALSE	ptruser32,"CheckDlgButton","CheckDlgButton",FALSE,FALSE	ptruser32,"CheckMenuItem","CheckMenuItem",FALSE,FALSE	ptruser32,"CheckRadioButton","CheckRadioButton",FALSE,FALSE	ptruser32,"ChildWindowFromPoint","ChildWindowFromPoint",FALSE,FALSE	ptruser32,"CreateIconFromResourceEx","CreateIconFromResourceEx",FALSE,FALSE	ptruser32,"CreateMenu","CreateMenu",FALSE,FALSE	ptruser32,"CreatePopupMenu","CreatePopupMenu",FALSE,FALSE	ptruser32,"CreateWindowEx","CreateWindowExA",FALSE,FALSE	ptruser32,"DefWindowProc","DefWindowProcA",FALSE,FALSE	ptruser32,"DeleteMenu","DeleteMenu",FALSE,FALSE	ptruser32,"DestroyWindow","DestroyWindow",FALSE,FALSE	ptruser32,"DispatchMessage","DispatchMessageA",FALSE,FALSE	ptruser32,"DrawMenuBar","DrawMenuBar",FALSE,FALSE	ptruser32,"EnableMenuItem","EnableMenuItem",FALSE,FALSE	ptruser32,"EnableWindow","EnableWindow",FALSE,FALSE	ptruser32,"FlashWindow","FlashWindow",FALSE,FALSE	ptruser32,"GetAncestor","GetAncestor",FALSE,FALSE	ptruser32,"GetClientRect","GetClientRect",FALSE,FALSE	ptruser32,"GetComboBoxInfo","GetComboBoxInfo",FALSE,FALSE	ptruser32,"GetCursorPos","GetCursorPos",FALSE,FALSE	ptruser32,"SetCursorPos","SetCursorPos",FALSE,FALSE	ptruser32,"GetCursor","GetCursor",FALSE,FALSE	ptruser32,"SetCursor","SetCursor",FALSE,FALSE	ptruser32,"GetMessage","GetMessageA",FALSE,FALSE	ptruser32,"GetActiveWindow","GetActiveWindow",FALSE,FALSE	ptruser32,"GetParent","GetParent",FALSE,FALSE	ptruser32,"GetWindowRect","GetWindowRect",FALSE,FALSE	ptruser32,"IsIconic","IsIconic",FALSE,FALSE	ptruser32,"HiliteMenuItem","HiliteMenuItem",FALSE,FALSE	ptruser32,"InvalidateRect","InvalidateRect",FALSE,FALSE	ptruser32,"InsertMenu","InsertMenuA",FALSE,FALSE	ptruser32,"InsertMenuItem","InsertMenuItemA",FALSE,FALSE	ptruser32,"IsWindowEnabled","IsWindowEnabled",FALSE,FALSE	ptruser32,"IsWindowVisible","IsWindowVisible",FALSE,FALSE	ptruser32,"KillTimer","KillTimer",FALSE,FALSE	ptruser32,"LoadCursor","LoadCursorA",FALSE,FALSE	ptruser32,"LoadIcon","LoadIconA",FALSE,FALSE	ptruser32,"LoadImage","LoadImageA",FALSE,FALSE	ptruser32,"LoadMenu","LoadMenuA",FALSE,FALSE	ptruser32,"MessageBox","MessageBoxA",FALSE,FALSE	ptruser32,"ModifyMenu","ModifyMenuA",FALSE,FALSE	ptruser32,"PostMessage","PostMessageA",FALSE,FALSE	ptruser32,"MoveWindow","MoveWindow",FALSE,FALSE	ptruser32,"PostQuitMessage","PostQuitMessage",FALSE,FALSE	ptruser32,"RedrawWindow","RedrawWindow",FALSE,FALSE	ptruser32,"RegisterClass","RegisterClassA",FALSE,FALSE	ptruser32,"RegisterWindowMessage","RegisterWindowMessageA",FALSE,FALSE	ptruser32,"ReleaseCapture","ReleaseCapture",FALSE,FALSE	ptruser32,"RemoveMenu","RemoveMenu",FALSE,FALSE	ptruser32,"ScreenToClient","ScreenToClient",FALSE,FALSE	ptruser32,"SendMessage","SendMessageA",FALSE,FALSE	ptruser32,"SetCapture","SetCapture",FALSE,FALSE	ptruser32,"SetClassLong","SetClassLongA",FALSE,FALSE	ptruser32,"SetFocus","SetFocus",FALSE,FALSE	ptruser32,"SetMenu","SetMenu",FALSE,FALSE	ptruser32,"SetMenuItemBitmaps","SetMenuItemBitmaps",FALSE,FALSE	ptruser32,"SetTimer","SetTimer",FALSE,FALSE	ptruser32,"GetWindowLong","GetWindowLongA",FALSE,FALSE	ptruser32,"SetWindowLong","SetWindowLongA",FALSE,FALSE	ptruser32,"SetWindowPos","SetWindowPos",FALSE,FALSE	ptruser32,"ShowWindow","ShowWindow",FALSE,FALSE	ptruser32,"UpdateWindow","UpdateWindow",FALSE,FALSE	ptruser32,"TrackPopupMenuEx","TrackPopupMenuEx",FALSE,FALSE	ptruser32,"TranslateMessage","TranslateMessage",FALSE,FALSE	ptrgdi,"CreateCompatibleDC","CreateCompatibleDC",FALSE,FALSE	ptrgdi,"CreateDIBSection","CreateDIBSection",FALSE,FALSE	ptrgdi,"CreateFontIndirect","CreateFontIndirectA",FALSE,FALSE	ptrgdi,"CreateSolidBrush","CreateSolidBrush",FALSE,FALSE	ptrgdi,"CreateHatchBrush","CreateHatchBrush",FALSE,FALSE	ptrgdi,"CreatePatternBrush","CreatePatternBrush",FALSE,FALSE	ptrgdi,"GetBrushOrgEx","GetBrushOrgEx",FALSE,FALSE	ptrgdi,"SetBrushOrgEx","SetBrushOrgEx",FALSE,FALSE	ptrgdi,"DeleteObject","DeleteObject",FALSE,FALSE	ptrgdi,"GetPixel","GetPixel",FALSE,FALSE	ptrgdi,"SetPixel","SetPixel",FALSE,FALSE	ptrgdi,"CreatePen","CreatePen",FALSE,FALSE	ptrgdi,"LineTo","LineTo",FALSE,FALSE	ptrgdi,"Ellipse","Ellipse",FALSE,FALSE	ptrgdi,"Rectangle","Rectangle",FALSE,FALSE	ptrgdi,"RoundRect","RoundRect",FALSE,FALSE	ptrgdi,"SelectObject","SelectObject",FALSE,FALSE	ptrgdi,"MoveToEx","MoveToEx",FALSE,FALSE	ptrgdi,"AngleArc","AngleArc",FALSE,FALSE	ptrgdi,"Arc","Arc",FALSE,FALSE	ptrgdi,"ArcTo","ArcTo",FALSE,FALSE	ptrgdi,"GetDirection","GetDirection",FALSE,FALSE	ptrgdi,"PolyBezier","PolyBezier",FALSE,FALSE	ptrgdi,"PolyBezierTo","PolyBezierTo",FALSE,FALSE	ptrgdi,"PolyDraw","PolyDraw",FALSE,FALSE	ptrgdi,"Polyline","Polyline",FALSE,FALSE	ptrgdi,"PolylineTo","PolylineTo",FALSE,FALSE	ptrgdi,"PolyPolyline","PolyPolyline",FALSE,FALSE	ptrgdi,"SetArcDirection","SetArcDirection",FALSE,FALSE	ptrgdi,"GetBkColor","GetBkColor",FALSE,FALSE	ptrgdi,"SetBkColor","SetBkColor",FALSE,FALSE	ptrgdi,"SetBkMode","SetBkMode",FALSE,FALSE	ptrgdi,"GetStockObject","GetStockObject",FALSE,FALSE	ptrgdi,"SetTextColor","SetTextColor",FALSE,FALSE	ptrcomctl,"InitCommonControlsEx","InitCommonControlsEx",FALSE,FALSE	ptrcomctl,"ImageListCreate","ImageList_Create",FALSE,FALSE	ptrcomctl,"ImageListAdd","ImageList_Add",FALSE,FALSE	ptrcomctl,"ImageListAddIcon","ImageList_AddIcon",FALSE,FALSE	ptrcomctl,"TrackMouseEvent","_TrackMouseEvent",FALSE,FALSE	ptrcomdlg,"ChooseFont","ChooseFontA",FALSE,FALSE	ptrcomdlg,"ChooseColor","ChooseColorA",FALSE,FALSE	ptrcomdlg,"GetOpenFileName","GetOpenFileNameA",FALSE,FALSE	ptrcomdlg,"GetSaveFileName","GetSaveFileNameA",FALSE,FALSE	ptrcomdlg,"FindText","FindTextA",FALSE,FALSE	ptrcomdlg,"ReplaceText","ReplaceTextA",FALSE,FALSE	ptrshell,"DragAcceptFiles","DragAcceptFiles",FALSE,FALSE	ptrshell,"ShellExecute","ShellExecuteA",FALSE,FALSE	ptrshell,"ShellNotifyIcon","Shell_NotifyIcon",FALSE,FALSE	ptradvapi,"RegCreateKeyEx","RegCreateKeyExA",FALSE,FALSE	ptradvapi,"RegCloseKey","RegCloseKey",FALSE,FALSE	ptrwinmm,"sndPlaySound","sndPlaySoundA",FALSE,FALSE	ptrmsvcrt,"abs","abs",FALSE,FALSE	ptrmsvcrt,"atol","atol",FALSE,FALSE	ptrmsvcrt,"ltoa","_ltoa",FALSE,FALSE	ptrmsvcrt,"printf","printf",FALSE,FALSE	ptrmsvcrt,"puts","puts",FALSE,FALSE	ptrmsvcrt,"sprintf","sprintf",FALSE,FALSE	ptrmsvcrt,"system","system",FALSE,FALSE	ptrcsmdll,"CSMGetDriveHandle","CSMGetDriveHandle",FALSE,FALSE	ptrcsmdll,"CSMDriveStatus","CSMDriveStatus",FALSE,FALSE	ptrcsmdll,"CSMReadBlock","CSMReadBlock",FALSE,FALSE	ptrcsmdll,"CSMReleaseDriveHandle","CSMReleaseDriveHandle",FALSE,FALSE	ptrcsmdll,"CSMWriteBlock","CSMWriteBlock",FALSE,FALSE	ptrrichedit,"CreateTextServices","CreateTextServices",FALSE,FALSE	ptrimagelib,"BitmapFromFile","BitmapFromFile",FALSE,FALSE	ptrimagelib,"BitmapFromMemory","BitmapFromMemory",FALSE,FALSE	ptrimagelib,"BitmapFromPicture","BitmapFromPicture",FALSE,FALSE	ptrimagelib,"BitmapFromResource","BitmapFromResource",FALSE,FALSE	ptrziplib,"zOpenZipFile","zOpenZipFile",FALSE,FALSE	ptrziplib,"zCloseZipFile","zCloseZipFile",FALSE,FALSE	ptrziplib,"zGetTotalFiles","zGetTotalFiles",FALSE,FALSE	ptrziplib,"zGetTotalBytes","zGetTotalBytes",FALSE,FALSE	ptrziplib,"zGetSelectedFiles","zGetSelectedFiles",FALSE,FALSE	ptrziplib,"zGetSelectedBytes","zGetSelectedBytes",FALSE,FALSE	ptrziplib,"zGetLastErrorAsText","zGetLastErrorAsText",FALSE,FALSE	ptrziplib,"zGetSkippedFiles","zGetSkippedFiles",FALSE,FALSE	ptrziplib,"zGetRunTimeInfo","zGetRunTimeInfo",FALSE,FALSE	ptrziplib,"zCancelOperation","zCancelOperation",FALSE,FALSE	ptrziplib,"zExtractOne","zExtractOne",FALSE,FALSE	ptrziplib,"zExtractSelected","zExtractSelected",FALSE,FALSE	ptrziplib,"zExtractAll","zExtractAll",FALSE,FALSE	ptrziplib,"zGetFileName","zGetFileName",FALSE,FALSE	ptrziplib,"zGetFileExt","zGetFileExt",FALSE,FALSE	ptrziplib,"zGetFilePath","zGetFilePath",FALSE,FALSE	ptrziplib,"zGetFileDate","zGetFileDate",FALSE,FALSE	ptrziplib,"zGetFileTime","zGetFileTime",FALSE,FALSE	ptrziplib,"zGetFileSize","zGetFileSize",FALSE,FALSE	ptrziplib,"zGetCompressedFileSize","zGetCompressedFileSize",FALSE,FALSE	ptrziplib,"zFileIsEncrypted","zFileIsEncrypted",FALSE,FALSE	ptrziplib,"zGetLastOperResult","zGetLastOperResult",FALSE,FALSE	ptrziplib,"zFileIsSelected","zFileIsSelected",FALSE,FALSE	ptrziplib,"zSelectFile","zSelectFile",FALSE,FALSE	ptrziplib,"zUnselectAll","zUnselectAll",FALSE,FALSE	ptrziplib,"zSelectByWildcards","zSelectByWildcards",FALSE,FALSE	ptrziplib,"zCreateNewZip","zCreateNewZip",FALSE,FALSE	ptrziplib,"zOrderFile","zOrderFile",FALSE,FALSE	ptrziplib,"zOrderByWildcards","zOrderByWildcards",FALSE,FALSE	ptrziplib,"zCompressFiles","zCompressFiles",FALSE,FALSE	ptrziplib,"zDeleteFiles","zDeleteFiles",FALSE,FALSE	ptrziplib,"zGetOrderedFiles","zGetOrderedFiles",FALSE,FALSE	ptrziplib,"zGetOrderedBytes","zGetOrderedBytes",FALSE,FALSE	ptrziplib,"zGetComment","zGetComment",FALSE,FALSE	ptrziplib,"zIsSpanned","zIsSpanned",FALSE,FALSEEND TABLETABLE FormPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,FALSE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psFormBackColor,LONGVAR,TRUE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,TRUE	"TOOLTIP",pgBad,psBad,LONGVAR,FALSE	"family",pgBad,psFamily,LONGVAR,TRUE	"icon",pgBad,psIcon,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"flashwindow",pgBad,psFlashWindow,BOOLVAR,FALSE	"minimized",pgMinimized,psBad,BOOLVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE FormStyleTable AS StyleData	"base",$10000000,STYLE,FALSE	"default",$10cf0000,STYLE,FALSE	"iconicpopup",$c0000000,STYLE,FALSE	"popup",$80000000,STYLE,FALSE	"child",$40000000,STYLE,FALSE	"minimize",$20000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"disabled",$08000000,STYLE,FALSE	"clipsiblings",$04000000,STYLE,FALSE	"clipchildren",$02000000,STYLE,FALSE	"maximize",$01000000,STYLE,FALSE	"border",$00800000,STYLE,FALSE	"dlgframe",$00400000,STYLE,FALSE	"vscroll",$00200000,STYLE,FALSE	"hscroll",$00100000,STYLE,FALSE	"sysmenu",$00080000,STYLE,TRUE	"thickframe",$00040000,STYLE,TRUE	"minimizebox",$00020000,STYLE,TRUE	"maximizebox",$00010000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"toolwindow",$00000080,EXSTYLE,FALSE	"appwindow",$00040000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE FormEventTable AS EventData	"create",evCreateUsed,evCreateOffs,0	"system",evSysCommandUsed,evSysCommandOffs,0	"resize",evResizeUsed,evResizeOffs,0	"move",evMoveUsed,evMoveOffs,0	"mousemove",evMouseMoveUsed,evMouseMoveOffs,0	"lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0	"lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0	"rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0	"rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0	"paint",evPaintUsed,evPaintOffs,0	"keystruck"evKeyStruckUsed,evKeyStruckOffs,0	"%",0,0,0END TABLETABLE ToolWindowPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,FALSE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psFormBackColor,LONGVAR,TRUE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,TRUE	"TOOLTIP",pgBad,psBad,LONGVAR,FALSE	"family",pgBad,psFamily,LONGVAR,TRUE	"icon",pgBad,psIcon,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"flashwindow",pgBad,psFlashWindow,BOOLVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ToolWindowStyleTable AS StyleData	"base",$00000000,STYLE,FALSE	"default",$10000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ToolWindowEventTable AS EventData	"create",evCreateUsed,evCreateOffs,0	"system",evSysCommandUsed,evSysCommandOffs,0	"resize",evResizeUsed,evResizeOffs,0	"move",evMoveUsed,evMoveOffs,0	"mousemove",evMouseMoveUsed,evMouseMoveOffs,0	"lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0	"lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0	"rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0	"rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0	"%",0,0,0END TABLETABLE ButtonPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"BACKCOLOR",pgBad,psBad,LONGVAR,FALSE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,TRUE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"icon",pgBad,psButtonIcon,LONGVAR,TRUE	"bitmap",pgBad,psButtonBitmap,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"pushed",pgBad,psPushed,BOOLVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ButtonStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000001,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"defpushbutton",$00000001,STYLE,TRUE	"left",$00000100,STYLE,FALSE	"right",$00000200,STYLE,FALSE	"top",$00000400,STYLE,FALSE	"bottom",$00000800,STYLE,FALSE	"icon",$00000040,STYLE,FALSE	"bitmap",$00000080,STYLE,FALSE	"flat",$00008000,STYLE,FALSE	"multiline",$00002000,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ButtonEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0 	"%",0,0,0	"lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0	"lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0	"rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0	"rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0	"%",0,0,0END TABLETABLE StaticIconPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,TRUE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"icon",pgBad,psSTIcon,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE StaticIconStyleTable AS StyleData	"base",$50000103,STYLE,FALSE	"default",$50000303,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"icon",$00000003,STYLE,TRUE	"centerimage",$00000200,STYLE,TRUE	"notify",$00000100,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE StaticIconEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE ComboBoxPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"finditem",pfComboFindItem,pfComboFindItem,LONGVAR,TRUE	"replaceitem",pfComboReplaceItem,pfComboReplaceItem,LONGVAR,TRUE	"replaceitemsorted",pfComboReplaceItemSorted,pfComboReplaceItemSorted,LONGVAR,TRUE	"deleteitem",pfComboDeleteItem,pfComboDeleteItem,LONGVAR,FALSE	"additem",pfComboAddItem,pfComboAddItem,LONGVAR,FALSE	"additemsorted",pfComboAddSorted,pfComboAddSorted,LONGVAR,FALSE	"insertitem",pfComboInsertItem,pfComboInsertItem,LONGVAR,FALSE	"clear",pfComboClear,pfComboClear,LONGVAR,FALSE	"selitem",pgComboBoxSelItem,psComboBoxSelItem,LONGVAR,FALSE	"topitem",pgComboBoxTopItem,psComboBoxTopItem,LONGVAR,FALSE	"seltext",pgComboBoxSelText,psBad,STRINGVAR,FALSE	"itemcount",pgComboBoxItemCount,psBad,LONGVAR,FALSE	"dropped",pgDropped,psDropped,BOOLVAR,FALSE	"font",pgBad,psFont,LONGVAR,TRUE	"hilite",pgBad,psHiliteComboText,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ComboBoxStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50200102,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"vscroll",$00200000,STYLE,TRUE	"simple",$00000001,STYLE,FALSE	"dropdown",$00000002,STYLE,TRUE	"autohscroll",$00000040,STYLE,FALSE	"oemconvert",$00000080,STYLE,FALSE	"sort",$00000100,STYLE,TRUE	"uppercase",$00002000,STYLE,FALSE	"lowercase",$00204000,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,TRUE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ComboBoxEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"change",evChangeUsed,evChangeOffs,5	"select",evSelectUsed,evSelectOffs,9	"scroll",evScrollUsed,evScrollOffs,0	"%",0,0,0END TABLETABLE TextBoxPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"setsel",pfSetSel,pfSetSel,LONGVAR,FALSE	"selectall",pfSelectAll,pfSelectAll,LONGVAR,FALSE	"loadfile",pfRAEditLoadFile,pfRAEditLoadFile,LONGVAR,FALSE	"savefile",pfRAEditSaveFile,pfRAEditSaveFile,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TextBoxStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"center",$00000001,STYLE,FALSE	"right",$00000002,STYLE,FALSE	"multiline",$00000004,STYLE,FALSE	"uppercase",$00000008,STYLE,FALSE	"lowercase",$00000010,STYLE,FALSE	"password",$00000020,STYLE,FALSE	"autovscroll",$00000040,STYLE,FALSE	"autohscroll",$00000080,STYLE,FALSE	"vscroll",$00200000,STYLE,FALSE	"hscroll",$00100000,STYLE,FALSE	"nohidesel",$00000100,STYLE,FALSE	"oemconvert",$00000400,STYLE,FALSE	"readonly",$00000800,STYLE,FALSE	"wantreturn",$00001000,STYLE,FALSE	"number",$00002000,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,TRUE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE TextBoxEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"change",evChangeUsed,evChangeOffs,$300	"%",0,0,0END TABLETABLE FramePropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"TOOLTIP",pgBad,psBad,LONGVAR,FALSE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE FrameStyleTable AS StyleData	"base",$50000007,STYLE,FALSE	"default",$50000007,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"groupbox",$00000007,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE FrameEventTable AS EventData	"%",0,0,0END TABLETABLE ListBoxPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgListBoxText,psBad,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"finditem",pfListBoxFindItem,pfListBoxFindItem,LONGVAR,TRUE	"replaceitem",pfListBoxReplaceItem,pfListBoxReplaceItem,LONGVAR,TRUE	"replaceitemsorted",pfListBoxReplaceItemSorted,pfListBoxReplaceItemSorted,LONGVAR,TRUE	"deleteitem",pfListBoxDeleteItem,pfListBoxDeleteItem,LONGVAR,FALSE	"additem",pfListBoxAddItem,pfListBoxAddItem,LONGVAR,FALSE	"additemsorted",pfListBoxAddSorted,pfListBoxAddSorted,LONGVAR,FALSE	"insertitem",pfListBoxInsertItem,pfListBoxInsertItem,LONGVAR,FALSE	"clear",pfListBoxClear,pfListBoxClear,LONGVAR,FALSE	"selitem",pgListBoxSelItem,psListBoxSelItem,LONGVAR,FALSE	"topitem",pgListBoxTopItem,psListBoxTopItem,LONGVAR,FALSE	"seltext",pgListBoxSelText,psBad,STRINGVAR,FALSE	"itemcount",pgListBoxItemCount,psBad,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ListBoxStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50a00003,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify",$00000001,STYLE,TRUE	"sort",$00000002,STYLE,TRUE	"vscroll",$00200000,STYLE,TRUE	"hscroll",$00100000,STYLE,FALSE	"border",$0080000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,TRUE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ListBoxEventTable AS EventData	"select",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE SliderPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psSliderBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"value",pgSliderValue,psSliderValue,LONGVAR,FALSE	"setrange",pfSliderRange,pfSliderRange,LONGVAR,FALSE	"pagevalue",pgSliderPageValue,psSliderPageValue,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE SliderStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000100,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"autoticks",$00000001,STYLE,TRUE	"both",$00000008,STYLE,FALSE	"enableselrange"$00000020,STYLE,FALSE	"fixedlength",$00000040,STYLE,FALSE	"noticks",$00000010,STYLE,FALSE	"nothumb",$00000080,STYLE,FALSE	"vertical",$00000002,STYLE,FALSE	"left",$00000004,STYLE,FALSE	"tooltips"$00000100,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE SliderEventTable AS EventData	"scroll",evScrollUsed,evScrollOffs,0	"%",0,0,0END TABLETABLE SpinnerPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBad,psBackColor,LONGVAR,TRUE	"forecolor",pgBad,psBad,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"value",pgSpinnerValue,psSpinnerValue,LONGVAR,FALSE	"buddy",pgBad,psSpinnerBuddy,LONGVAR,FALSE	"setrange",pfSetSpinnerRange,pfSetSpinnerRange,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE SpinnerStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$500000aa,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"notify",$00000001,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"wrap",$00000001,STYLE,TRUE	"setbuddyint",$00000002,STYLE,TRUE	"alignright",$00000004,STYLE,TRUE	"alignleft",$00000008,STYLE,TRUE	"autobuddy",$00000010,STYLE,TRUE	"arrowkeys",$00000020,STYLE,TRUE	"horizontal",$00000040,STYLE,TRUE	"notthousands",$00000080,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE SpinnerEventTable AS EventData	"scroll",evScrollUsed,evScrollOffs,0	"%",0,0,0END TABLETABLE ProgressBarPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBad,psProgressBarBackColor,LONGVAR,TRUE	"forecolor",pgBad,psProgressBarForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"value",pgProgressBarValue,psProgressBarValue,LONGVAR,FALSE	"setrange",pfProgressBarRange,pfProgressBarRange,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ProgressBarStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000001,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"smooth",$00000001,STYLE,TRUE	"vertical",$00000004,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ProgressBarEventTable AS EventData	"%",0,0,0END TABLETABLE DrawProgressPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psDPBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgBad,psDPText,STRINGVAR,FALSE	"font",pgBad,psDPFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"value",pgBad,psDPValue,LONGVAR,FALSE	"maxvalue",pgBad,psDPMaxValue,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE DrawProgressStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000004,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify"$00000100,STYLE,FALSE	"center",$00000010,STYLE,FALSE	"red",$00000001,STYLE,FALSE	"green",$00000002,STYLE,FALSE	"text",$00000004,STYLE,FALSE	"percent",$00000008,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE DrawProgressEventTable AS EventData	"%",0,0,0END TABLETABLE ButtonExPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psButtonExBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psButtonExForeColor,LONGVAR,TRUE	"text",pgBad,psText,STRINGVAR,FALSE	"font",pgBad,psFont,LONGVAR,FALSE	"bitmap",pgBad,psButtonExBitmap,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psButtonExStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ButtonExStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ButtonExEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE WebBrowserPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"BACKCOLOR",pgBad,psBad,LONGVAR,FALSE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"TEXT",pgBad,psBad,STRINGVAR,FALSE	"FONT",pgBad,psBad,LONGVAR,FALSE	"BITMAP",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psBad,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"url",pgBad,psWBNavigate,STRINGVAR,FALSE	"goback",pfWBGoBack,pfWBGoBack,LONGVAR,FALSE	"goforward",pfWBGoForward,pfWBGoForward,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE WebBrowserStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$5000000f,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"statusbar",$00000001,STYLE,TRUE	"sizegrip",$00000002,STYLE,TRUE	"caption",$00000004,STYLE,TRUE	"combo",$00000008,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE WebBrowserEventTable AS EventData	"%",0,0,0END TABLETABLE ScrollBarPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"value",pgScrollBarValue,psScrollBarValue,LONGVAR,FALSE	"setrange",pfScrollBarRange,pfScrollBarRange,LONGVAR,FALSE	"pagevalue",pgPageValue,psPageValue,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ScrollBarStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"vertical",$00000001,STYLE,FALSE	"toporleft",$00000002,STYLE,FALSE	"bottomorright",$00000004,STYLE,FALSE	"sizegrip",$00000010,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ScrollBarEventTable AS EventData	"scroll",evScrollUsed,evScrollOffs,0	"%",0,0,0END TABLETABLE DateTimePickPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"init",pgBad,psBad,LONGVAR,FALSE	"value",pgBad,psBad,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE DateTimePickStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE DateTimePickEventTable AS EventData	"%",0,0,0END TABLETABLE AnimatePropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"init",pgBad,psBad,LONGVAR,FALSE	"value",pgProgressBarValue,psProgressBarValue,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE AnimateStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE AnimateEventTable AS EventData	"%",0,0,0END TABLETABLE CalendarPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBad,psMCBackColor,LONGVAR,TRUE	"forecolor",pgBad,psMCTextColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"ICON",pgBad,psIcon,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"getselection",pfGetMonthCalSel,pfGetMonthCalSel,LONGVAR,FALSE	"setselection",pfSetMonthCalSel,pfSetMonthCalSel,LONGVAR,FALSE	"monthbackcolor",pgBad,psMCMonthBackColor,LONGVAR,TRUE	"titlebackcolor",pgBad,psMCTitleBackColor,LONGVAR,TRUE	"titleforecolor",pgBad,psMCTitleForeColor,LONGVAR,TRUE	"trailingtextcolor",pgBad,psMCTrailingTextColor,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE CalendarStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000001,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify",$00000001,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE CalendarEventTable AS EventData	"change",evNotify1Used,0,$fffffd16	"%",0,0,0END TABLETABLE HeaderPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE HeaderStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000001,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify",$00000001,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE HeaderEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE TreeViewPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBad,psTVBackColor,LONGVAR,TRUE	"forecolor",pgBad,psTVForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TreeViewStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$5000003f,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"hasbuttons",$00000001,STYLE,TRUE	"haslines",$00000002,STYLE,TRUE	"linesatroot",$00000004,STYLE,TRUE	"editlabels",$00000008,STYLE,TRUE	"disabledragdrop",$00000010,STYLE,TRUE	"showselalways",$00000020,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE TreeViewEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE TabFolderPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pfSetTabText,pfSetTabText,LONGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"image",pfSetTabImage,pfSetTabImage,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"additem",pfAddTabItem,pfAddTabItem,LONGVAR,FALSE	"insertitem",pfInsertTabItem,pfInsertTabItem,LONGVAR,FALSE	"deleteitem",pfDeleteTabItem,pfDeleteTabItem,LONGVAR,FALSE	"select",pgTabSelect,psTabSelect,LONGVAR,FALSE	"setitemsize",pfSetItemSize,pfSetItemSize,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TabFolderStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000400,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"bottom",$00000002,STYLE,FALSE	"forceiconleft",$00000010,STYLE,FALSE	"forcelabelleft",$00000020,STYLE,FALSE	"vertical",$00000080,STYLE,FALSE	"buttons",$00000100,STYLE,FALSE	"multiline",$00000200,STYLE,FALSE	"fixedwidth",$00000400,STYLE,TRUE	"raggedright",$00000800,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE TabFolderEventTable AS EventData	"change",evNotify1Used,0,$fffffffe	"%",0,0,0END TABLETABLE ToolBarPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ToolBarStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000001,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify",$00000001,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ToolBarEventTable AS EventData	"%",0,0,0END TABLETABLE StatusBarPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgForeColor,psForeColor,LONGVAR,TRUE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"setparts",pfSetParts,pfSetParts,LONGVAR,FALSE	"settext",pfSetSBText,pfSetSBText,LONGVAR,FALSE	"seticon",pfSetSBIcon,pfSetSBIcon,LONGVAR,FALSE	"settooltip",pfSetSBToolTip,pfSetSBToolTip,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE StatusBarStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000810,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"sizegrip",$00000010,STYLE,TRUE	"tooltips",$00000800,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE StatusBarEventTable AS EventData	"%",0,0,0END TABLETABLE CheckBoxPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"checked",pgChecked,psChecked,BOOLVAR,FALSE	"font",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE CheckBoxStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000003,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"autocheckbox"$00000003,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE CheckBoxEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE RadioButtonPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"checked",pgChecked,psChecked,BOOLVAR,FALSE	"font",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RadioButtonStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000009,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"autoradiobutton",$00000009,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE RadioButtonEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE TimerPropTable AS PropData	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE TimerStyleTable AS StyleData	"%",0,0,FALSEEND TABLETABLE TimerEventTable AS EventData	"%",0,0,0END TABLETABLE FamilyPropTable AS PropData	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE FamilyStyleTable AS StyleData	"%",0,0,FALSEEND TABLETABLE FamilyEventTable AS EventData	"%",0,0,0END TABLETABLE RichEditPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psRichEditBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"line",pgLine,psBad,STRINGVAR,FALSE	"font",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RichEditStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50300104,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"multiline",$00000004,STYLE,TRUE	"vscroll",$00200000,STYLE,TRUE	"hscroll",$00100000,STYLE,TRUE	"nohidesel",$00000100,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE RichEditEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE RAEditPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBad,psRAEditBCKCOLOR,LONGVAR,TRUE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"seltext",pgSelText,psBad,STRINGVAR,FALSE	"line",pgLine,psBad,STRINGVAR,FALSE	"loadfile",pfRAEditLoadFile,pfRAEditLoadFile,LONGVAR,FALSE	"savefile",pfRAEditSaveFile,pfRAEditSaveFile,LONGVAR,FALSE	"goto",pfRAEditGoto,pfRAEditGoto,LONGVAR,FALSE	"cursorpos",pgCursorPos,psCursorPos,LONGVAR,FALSE	"selectall",pfSelectAll,pfSelectAll,LONGVAR,FALSE	"setsel",pfSetSel,pfSetSel,LONGVAR,FALSE	"getsel",pfGetSel,pfGetSel,LONGVAR,FALSE	"inserttext",pfInsertText,pfInsertText,LONGVAR,FALSE	"replacesel",pfReplaceSel,pfReplaceSel,LONGVAR,FALSE	"appendtext",pfAppendText,pfAppendText,LONGVAR,FALSE	"replacetext",pfReplaceText,pfReplaceText,LONGVAR,FALSE	"textcolor",pgBad,psRAEditTXTCOLOR,LONGVAR,TRUE	"selbackcolor",pgBad,psRAEditSELBCKCOLOR,LONGVAR,FALSE	"seltextcolor",pgBad,psRAEditSELTXTCOLOR,LONGVAR,FALSE	"commentcolor",pgBad,psRAEditCMNTCOLOR,LONGVAR,FALSE	"stringcolor",pgBad,psRAEditSTRCOLOR,LONGVAR,FALSE	"operatorcolor",pgBad,psRAEditOPRCOLOR,LONGVAR,FALSE	"hilite1color",pgBad,psRAEditHILITE1,LONGVAR,FALSE	"hilite2color",pgBad,psRAEditHILITE2,LONGVAR,FALSE	"hilite3color",pgBad,psRAEditHILITE3,LONGVAR,FALSE	"hiliteline",pgHiLiteLine,psBad,LONGVAR,FALSE	"sethiliteline",pfSetHiLiteLine,pfSetHiLiteLine,LONGVAR,FALSE	"selbarpencolor",pgBad,psRAEditSELBARPEN,LONGVAR,FALSE	"linenumcolor",pgBad,psRAEditLNRCOLOR,LONGVAR,FALSE	"linenumberwidth",pgBad,psRAEditLineNumberWidth,LONGVAR,FALSE	"numbercolor",pgBad,psRAEditNUMCOLOR,LONGVAR,FALSE	"sethilitewords",pfSetHiliteWords,pfSetHiliteWords,LONGVAR,FALSE	"setdividerline",pfSetDividerLine,pfSetDividerLine,LONGVAR,FALSE	"setfont",pfSetRAFont,pfSetRAFont,LONGVAR,FALSE	"find",pfFind,pfFind,LONGVAR,FALSE	"search",pfSearch,pfSearch,LONGVAR,FALSE	"textlength",pgTextLength,psBad,LONGVAR,FALSE	"canundo",pgCanUndo,psBad,BOOLVAR,FALSE	"undo",pfUnDo,pfUnDo,LONGVAR,FALSE	"canredo",pgCanReDo,psBad,BOOLVAR,FALSE	"redo",pfReDo,pfReDo,LONGVAR,FALSE	"canpaste",pgCanPaste,psBad,BOOLVAR,FALSE	"paste",pfPaste,pfPaste,LONGVAR,FALSE	"emptyundobuffer",pfEmptyUndoBuffer,pfEmptyUndoBuffer,LONGVAR,FALSE	"cut",pfCut,pfCut,LONGVAR,FALSE	"copy",pfCopy,pfCopy,LONGVAR,FALSE	"readonly",pgBad,psRAEditReadOnly,BOOLVAR,FALSE	"setchartable",pfSetCharTable,pfSetCharTable,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RAEditStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000044,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,TRUE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE RAEditEventTable AS EventData	"change",evNotify1Used,0,$702	"contextmenu",evContextMenuUsed,evContextMenuOffs,0	"%",0,0,0END TABLETABLE RAGridPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psGridBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psGridForeColor,LONGVAR,TRUE	"text",pgGridText,psGridText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"gridcolor",pgBad,psGridGridColor,LONGVAR,FALSE	"setrowcolor",pfSetGridRowColor,pfSetGridRowColor,LONGVAR,FALSE	"headertext",pgHeaderText,psHeaderText,STRINGVAR,FALSE	"value",pgGridValue,psGridValue,LONGVAR,FALSE	"addrow",pfGridAddRow,pfGridAddRow,LONGVAR,FALSE	"addcol",pfGridAddCol,pfGridAddCol,LONGVAR,FALSE	"deleterow",pfGridDeleteRow,pfGridDeleteRow,LONGVAR,FALSE	"insertrow",pfGridInsertRow,pfGridInsertRow,LONGVAR,FALSE	"moverow",pfGridMoveRow,pfGridMoveRow,LONGVAR,FALSE	"additem",pfGridComboAddItem,pfGridComboAddItem,LONGVAR,FALSE	"headerheight",pgBad,psHeaderHeight,LONGVAR,FALSE	"rowheight",pgBad,psRowHeight,LONGVAR,FALSE	"gridclear",pfGridClear,pfGridClear,LONGVAR,FALSE	"comboclear",pfGridComboClear,pfGridComboClear,LONGVAR,FALSE	"sort",pfGridSort,pfGridSort,LONGVAR,FALSE	"row",pgGridRow,psGridRow,LONGVAR,FALSE	"col",pgGridCol,psGridCol,LONGVAR,FALSE	"rows"pgGridRows,psBad,LONGVAR,FALSE	"cols"pgGridCols,psBad,LONGVAR,FALSE	"scrollcell",pfScrollCell,pfScrollCell,LONGVAR,FALSE	"sel",pgGridSel,psGridSel,LONGVAR,FALSE	"font",pgBad,psFont,LONGVAR,TRUE	"enteredit",pfGridEnterEdit,pfGridEnterEdit,LONGVAR,FALSE	"endedit",pfGridEndEdit,pfGridEndEdit,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RAGridStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$5000000f,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"nosel",$00000001,STYLE,TRUE	"nofocus",$00000002,STYLE,TRUE	"hgridlines",$00000004,STYLE,TRUE	"vgridlines",$00000008,STYLE,TRUE	"gridframe",$00000010,STYLE,FALSE	"nocolsize",$00000020,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,TRUE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE RAGridEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"headerclick",evNotify1Used,0,1	"buttonclick",evNotify2Used,0,2	"checkclick",evNotify3Used,0,3	"imageclick",evNotify4Used,0,4	"beforeselchange",evNotify5Used,0,5	"afterselchange",evNotify6Used,0,6	"beforeedit",evNotify7Used,0,7	"afteredit",evNotify8Used,0,8	"beforeupdate",evNotify9Used,0,9	"afterupdate",evNotify10Used,0,10	"userconvert",evNotify11Used,0,11	"%",0,0,0END TABLETABLE ListViewPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBad,psLVBackColor,LONGVAR,TRUE	"forecolor"pgBad,psLVForeColor,LONGVAR,TRUE	"TEXT",pgBad,psBad,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"addcol",pfLVAddCol,pfLVAddCol,LONGVAR,FALSE	"insertcol",pfLVInsertCol,pfLVInsertCol,LONGVAR,FALSE	"setheadertext",pfLVSetHeaderText,pfLVSetHeaderText,LONGVAR,FALSE	"additem",pfLVAddItem,pfLVAddItem,LONGVAR,FALSE	"insertitem",pfLVInsertItem,pfLVInsertItem,LONGVAR,FALSE	"settext",pfLVSetText,pfLVSetText,LONGVAR,FALSE	"setimage",pfLVSetImage,pfLVSetImage,LONGVAR,FALSE	"clear",pfLVClear,pfLVClear,LONGVAR,FALSE	"deleteitem",pfLVDeleteItem,pfLVDeleteItem,LONGVAR,FALSE	"deletecol",pfLVDeleteCol,pfLVDeleteCol,LONGVAR,FALSE	"setcolwidth",pfLVSetColWidth,pfLVSetColWidth,LONGVAR,FALSE	"xxselitem",pgListBoxSelItem,psListBoxSelItem,LONGVAR,FALSE	"xxtopitem",pgListBoxTopItem,psListBoxTopItem,LONGVAR,FALSE	"xxseltext",pgListBoxSelText,psBad,STRINGVAR,FALSE	"xxfont",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ListViewStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000001,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"report",$00000001,STYLE,TRUE	"smallicon",$00000002,STYLE,TRUE	"list",$00000003,STYLE,FALSE	"singlesel",$00000004,STYLE,TRUE	"showselalways",$00000008,STYLE,TRUE	"sortascending",$00000010,STYLE,TRUE	"sortdescending",$00000020,STYLE,TRUE	"shareimagelists",$00000040,STYLE,TRUE	"nolabelwrap",$00000080,STYLE,TRUE	"autoarrange",$00000100,STYLE,TRUE	"editlabels",$00000200,STYLE,TRUE	"ownerdata",$00001000,STYLE,TRUE	"noscroll",$00002000,STYLE,TRUE	"alignleft",$00000800,STYLE,TRUE	"ownerdrawfixed",$00000400,STYLE,TRUE	"nocolumnheader",$00004000,STYLE,TRUE	"nosortheader",$00008000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,TRUE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ListViewEventTable AS EventData	"select",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE StaticTextPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"bitmap",pgBad,psStaticBitmap,LONGVAR,TRUE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE StaticTextStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000101,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify"$00000100,STYLE,TRUE	"center",$00000001,STYLE,TRUE	"right",$00000002,STYLE,FALSE	"sunken",$00001000,STYLE,FALSE	"etchedframe",$00000012,STYLE,FALSE	"bitmap",$0000000e,STYLE,FALSE	"centerimage",$00000200,STYLE,FALSE	"blackframe",$00000007,STYLE,FALSE	"whiteframe",$00000008,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE StaticTextEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE ImagePropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"IMAGE",pgBad,psBad,LONGVAR,TRUE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"bitmap",pgBad,psStaticBitmap,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"text",pgText,psText,STRINGVAR,TRUE	"font",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE ImageStyleTable AS StyleData 	"base",$5000000e,STYLE,FALSE	"default",$5000130e,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify"$00000100,STYLE,TRUE	"sunken",$00001000,STYLE,TRUE	"bitmap",$0000000e,STYLE,TRUE	"centerimage",$00000200,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE ImageEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE RectanglePropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"text",pgText,psText,STRINGVAR,FALSE	"font",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE RectangleStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"notify"$00000100,STYLE,FALSE	"center",$00000001,STYLE,FALSE	"sunken",$00001000,STYLE,FALSE	"etchedframe",$00000012,STYLE,FALSE	"bitmap",$0000000e,STYLE,FALSE	"centerimage",$00000200,STYLE,FALSE	"blackframe",$00000007,STYLE,FALSE	"whiteframe",$00000008,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE RectangleEventTable AS EventData	"%",0,0,0END TABLETABLE OBCommPropTable AS PropData	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE OBCommStyleTable AS StyleData	"%",0,0,FALSEEND TABLETABLE OBCommEventTable AS EventData	"%",0,0,0END TABLETABLE OBZipPropTable AS PropData	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE OBZipStyleTable AS StyleData	"%",0,0,FALSEEND TABLETABLE OBZipEventTable AS EventData	"%",0,0,0END TABLETABLE IconButtonPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"BACKCOLOR",pgBad,psBad,LONGVAR,FALSE	"FORECOLOR",pgBad,psBad,LONGVAR,FALSE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,TRUE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"icon",pgBad,psButtonIcon,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"font",pgBad,psFont,LONGVAR,TRUE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE IconButtonStyleTable AS StyleData	"base",$50000000,STYLE,FALSE	"default",$50000040,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"icon"$00000040,STYLE,TRUE	"flat",$00008000,STYLE,FALSE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE IconButtonEventTable AS EventData	"command",evCommandUsed,evCommandOffs,0	"%",0,0,0END TABLETABLE SprShtPropTable AS PropData	"NAME",pgBad,psBad,LONGVAR,TRUE	"OWNER",pgBad,psBad,LONGVAR,TRUE	"ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE	"visible",pgVisible,psVisible,BOOLVAR,TRUE	"enabled",pgEnabled,psEnabled,BOOLVAR,TRUE	"left",pgLeft,psLeft,LONGVAR,TRUE	"top",pgTop,psTop,LONGVAR,TRUE	"width",pgWidth,psWidth,LONGVAR,TRUE	"height",pgHeight,psHeight,LONGVAR,TRUE	"backcolor",pgBackColor,psBackColor,LONGVAR,TRUE	"forecolor",pgForeColor,psForeColor,LONGVAR,TRUE	"TEXT",pgText,psText,STRINGVAR,FALSE	"FONT",pgBad,psFont,LONGVAR,FALSE	"IMAGE",pgBad,psBad,LONGVAR,FALSE	"tooltip",pgBad,psToolTip,LONGVAR,TRUE	"family",pgBad,psFamily,LONGVAR,TRUE	"status",pgStatus,psBad,LONGVAR,FALSE	"address",pgAddress,psBad,LONGVAR,FALSE	"created",pgCreated,psBad,BOOLVAR,FALSE	"hdc",pgHDC,psBad,LONGVAR,FALSE	"intercepton",pgBad,psInterceptOn,LONGVAR,FALSE	"interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE	"id",pgID,psBad,LONGVAR,FALSE	"handle",pgHandle,psBad,LONGVAR,FALSE	"style",pgBad,psStyle,LONGVAR,FALSE	"right",pgRight,psRight,LONGVAR,FALSE	"bottom",pgBottom,psBottom,LONGVAR,FALSE	"bringtofront",pfBringToFront,pfBringToFront,LONGVAR,FALSE	"init",pgBad,psBad,LONGVAR,FALSE	"%",MainLoop,MainLoop,0,FALSEEND TABLETABLE SprShtStyleTable AS StyleData	"base",$50000001,STYLE,FALSE	"default",$50000000,STYLE,FALSE	"visible",$10000000,STYLE,TRUE	"child",$40000000,STYLE,TRUE	"topmost",$00000008,EXSTYLE,FALSE	"windowedge",$00000100,EXSTYLE,FALSE	"clientedge",$00000200,EXSTYLE,FALSE	"staticedge",$00020000,EXSTYLE,FALSE	"%",0,0,FALSEEND TABLETABLE SprShtEventTable AS EventData	"scroll",evScrollUsed,evScrollOffs,0	"%",0,0,0END TABLETYPE PropMap	PropMapPropTable AS LABEL	PropMapStyleTable AS LABEL	PropMapEventTable AS LABEL	PropMapCount AS LONG	PropMapType AS STRING*16	PropMapTextFlag AS BOOLEAN	PropMapBCEnab AS BOOLEAN	PropMapFCEnab AS BOOLEAN	PropMapName AS STRING*32END TYPETABLE ToolPropMap AS PropMap	FormPropTable,FormStyleTable,FormEventTable,1,"FORM",TRUE,TRUE,FALSE,"Form"	ToolWindowPropTable,ToolWindowStyleTable,ToolWindowEventTable,0,"TOOLWINDOW",TRUE,TRUE,FALSE,"ToolWindow"	ButtonPropTable,ButtonStyleTable,ButtonEventTable,0,"BUTTON",TRUE,FALSE,FALSE,"Button"	StaticTextPropTable,StaticTextStyleTable,StaticTextEventTable,0,"STATICTEXT",TRUE,TRUE,TRUE,"StaticText"	FramePropTable,FrameStyleTable,FrameEventTable,0,"FRAME",TRUE,TRUE,TRUE,"Frame"	SliderPropTable,SliderStyleTable,SliderEventTable,0,"SLIDER",FALSE,TRUE,TRUE,"Slider"	TextBoxPropTable,TextBoxStyleTable,TextBoxEventTable,0,"TEXTBOX",TRUE,TRUE,TRUE,"TextBox"	ComboBoxPropTable,ComboBoxStyleTable,ComboBoxEventTable,0,"COMBOBOX",TRUE,TRUE,TRUE,"Combo"	ListBoxPropTable,ListBoxStyleTable,ListBoxEventTable,0,"LISTBOX",FALSE,TRUE,TRUE,"ListBox"	RadioButtonPropTable,RadioButtonStyleTable,RadioButtonEventTable,0,"RADIOBUTTON",TRUE,TRUE,TRUE,"Radio"	CheckBoxPropTable,CheckBoxStyleTable,CheckBoxEventTable,0,"CHECKBOX",TRUE,TRUE,TRUE,"Check"	ProgressBarPropTable,ProgressBarStyleTable,ProgressBarEventTable,0,"PROGRESSBAR",FALSE,TRUE,TRUE,"Progress"	CalendarPropTable,CalendarStyleTable,CalendarEventTable,0,"CALENDAR",FALSE,TRUE,TRUE,"Calendar"	TabFolderPropTable,TabFolderStyleTable,TabFolderEventTable,0,"TABFOLDER",FALSE,FALSE,FALSE,"TabFolder"	SpinnerPropTable,SpinnerStyleTable,SpinnerEventTable,0,"SPINNER",FALSE,FALSE,FALSE,"Spinner"	StatusBarPropTable,StatusBarStyleTable,StatusBarEventTable,0,"STATUSBAR",FALSE,FALSE,FALSE,"StatusBar"	HeaderPropTable,HeaderStyleTable,HeaderEventTable,0,"HEADER",FALSE,FALSE,FALSE,"Header"	AnimatePropTable,AnimateStyleTable,AnimateEventTable,0,"ANIMATE",FALSE,FALSE,FALSE,"Animate"	RichEditPropTable,RichEditStyleTable,RichEditEventTable,0,"RICHEDIT",FALSE,FALSE,FALSE,"RichEdit"	RAEditPropTable,RAEditStyleTable,RAEditEventTable,0,"RAEDIT",FALSE,TRUE,FALSE,"RAEdit"	RAGridPropTable,RAGridStyleTable,RAGridEventTable,0,"RAGRID",FALSE,TRUE,TRUE,"RAGrid"	ListViewPropTable,ListViewStyleTable,ListViewEventTable,0,"LISTVIEW",FALSE,FALSE,FALSE,"ListView"	ToolBarPropTable,ToolBarStyleTable,ToolBarEventTable,0,"TOOLBAR",FALSE,FALSE,FALSE,"ToolBar"	TreeViewPropTable,TreeViewStyleTable,TreeViewEventTable,0,"TREEVIEW",FALSE,FALSE,FALSE,"TreeView"	DateTimePickPropTable,DateTimePickStyleTable,DateTimePickEventTable,0,"DATETIMEPICK",FALSE,FALSE,FALSE,"DateTime"	ImagePropTable,ImageStyleTable,ImageEventTable,0,"IMAGE",FALSE,FALSE,FALSE,"Image"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	ButtonExPropTable,ButtonExStyleTable,ButtonExEventTable,0,"ButtonEx",TRUE,TRUE,TRUE,"ButtonEx"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP"	DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable,0,"DRAWPROGRESS",FALSE,FALSE,FALSE,"DP" END TABLETEXTBLOCK RunVarsalign 4; Timer Event Dispatch Vectors!Timer rd !Timers_FltArgSafe0 rf 1_FltArgSafe1 rf 1_FloatRet rf 1_LoopCtr rd 10!hinstance rd 1!dc rd 1_InHandle rd 1_OutHandle rd 1_IOPthNum rd 1_XferAddr rd 1_PUArgs rd 15_ArgList rd 1_ArgNum rd 1_Poker rd 1_DummyArg rd 1!FcnVar1 rd 4!FcnVar2 rd 4!FcnVar3 rd 4!FcnVar4 rd 4!FcnVar5 rd 4!FcnVar6 rd 4!FcnVar7 rd 4_LongRet rd 1_StringRet rd 3_ArgSafe0 rd 1_ArgSafe1 rd 1_ArgSafe2 rd 1_ArgSafe3 rd 1_ArgSafe4 rd 1_ArgSafe5 rd 1_ArgSafe6 rd 1_AccLo rd 1_AccHi rd 1!FileHandle rd 1!FilBufAdr rd 1!FilBufSiz rd 1_SwitchInt rd 1__ByteCounter rd 1_PrtPthNum rd 1_DataPtr rd 1_Decimals rw 1_Digits rw 1_BoolRet rb 1!PassEvent rb 1AltKey rb 1; COMM DCB Structure!DCBlengthOffs equ 0; rd 1!BaudRateOffs equ 4; rd 1!fBitsOffs equ 8; rd 1	!fBinaryBit equ 0	!fParityBit equ 1	!fOutxCtsFlowBit equ 2	!fOutxDsrFlowBit equ 3	!fDtrControlLoBit equ 4	!fDtrControlHiBit equ 5	!fDsrSensitivityBit equ 6	!fTXContinueOnXoffBit equ 7	!fOutXBit equ 8	!fInXBit equ 9	!fErrorCharBit equ 10	!fNullBit equ 11	!fRtsControlLoBit equ 12	!fRtsControlHiBit equ 13	!fAbortOnErrorBit equ 14!wReservedOffs equ 12; rw 1!XonLimOffs equ 14; rw 1!XoffLimOffs equ 16; rw 1!ByteSizeOffs equ 18; rb 1!ParityOffs equ 19;  rb 1!StopBitsOffs equ 20; rb 1!XonCharOffs equ 21; rb 1!XoffCharOffs equ 22; rb 1!ErrorCharOffs equ 23; rb 1!EofCharOffs equ 24; rb 1!EvtCharOffs equ 25; rb 1!wReserved1Offs equ 26; rw 1!HandleOffs equ 28; rd 1!StatusOffs equ 32; rd 1!ArrayOffs equ 36; rd 1!CommReserved1Offs equ 40; rb 1!CommReserved2Offs equ 41; rb 1!CommReserved3Offs equ 42; rb 1!CommReserved4Offs equ 43; rb 1!UserBaudRateOffs equ 44; rd 1!UserParityOffs equ 48; rb 1!UserByteSizeOffs equ 49; rb 1!UserStopBitsOffs equ 50; rb 1!UserRTSOffs equ 51; rb 1!UserDSRCheckOffs equ 52; rb 1!UserParityCheckOffs equ 53; rb 1!UserDTROffs equ 54; rb 1!UserCTSCheckOffs equ 55; rb 1!PortNameOffs equ 56; rb 32!CommStatusOffs equ 88; rd 1!cbInQueOffs equ 92; rd 1!cbOutQueOffs equ 96; rd 1align 4;_FILETIME Structures!dwLowDateTime1 rd 1!dwHighDateTime1 rd 1!dwLowDateTime2 rd 1!dwHighDateTime2 rd 1ENDTEXTTEXTBLOCK GUIInitVars!OBMainWindowClass WNDCLASSmsg MSG!TrapColorChange dd 0!OBMainClass db 'OBMain',0!ToolTipClass db 'Tooltips_class32',0!icc dd $00000008,$00003FFF!!RichEd db 'RichEd20.dll',0!!RAEdit db 'RAEdit.dll',0!!RAGrid db 'RAGrid.dll',0!!Csmdll db 'Csmdll.dll',0!!DrawProgress db 'DrawProgress.dll',0!!ImageLib db 'ImageLib.dll',0!!SprShtLib db 'SprSht.dll',0!!ButtonExLib db 'ButtonEx.dll',0!!WebBrowserLib db 'WBDll.dll',0!!ZipLib db 'bszip.dll',0!title db 'OBMain',0align 4MenuEVPtr dd 0MenuID dd 0FindEVPtr dd 0FindMsgID dd 0FINDMSGSTRING db 'commdlg_FindReplace',0FLAGS dd 0nmhdr_hwndFrom dd 0nmhdr_idFrom dd 0nmhdr_code dd 0cr_cpMin dd 0cr_cpMax dd 0ofn_lStructSize dd 76ofn_hwndOwner dd 0ofn_hInstance dd 0ofn_lpstrFilter dd 0ofn_lpstrCustomFilter dd 0ofn_nMaxCustFilter dd 0ofn_nFilterIndex dd 1ofn_lpstrFile dd 0ofn_nMaxFile dd 0ofn_lpstrFileTitle dd 0ofn_nMaxFileTitle dd 0ofn_lpstrInitialDir dd 0ofn_lpstrTitle dd 0ofn_Flags dd 0ofn_nFileOffset dw 0ofn_nFileExtension dw 0ofn_lpstrDefExt dd 0ofn_lCustData dd 0ofn_lpfnHook dd 0ofn_lpTemplateName dd 0cc_lStructSize dd 36cc_hwndOwner dd 0cc_hInstance dd 0cc_rgbResult dd 0cc_lpCustColors dd _CustColorscc_Flags dd 0cc_lCustData dd 0cc_lpfnHook dd 0cc_lpTemplateName dd 0_CustColors rd 16fr_lStructSize dd 40fr_hwndOwner dd 0fr_hInstance dd 0fr_Flags dd 0fr_lpstrFindWhat dd 0fr_lpstrReplaceWith dd _PrintBuf+12fr_wFindWhatLen dw 0fr_wReplaceWithLen dw 0fr_lCustData dd 0fr_lpfnHook dd 0fr_lpTemplateName dd 0ft_SearchMin rd 1ft_SearchMax rd 1ft_SearchTextPtr rd 1ft_FoundMin rd 1ft_FoundMax rd 1cf_lStructSize dd 58cf_hwndOwner dd 0cf_hDC dd 0cf_lpLogFont dd 0cf_iPointSize dd 0cf_Flags dd 0cf_rgbColors dd 0cf_lCustData dd 0cf_lpfnHook dd 0cf_lpTemplateName dd 0cf_hInstance dd 0cf_lpszStyle dd 0cf_nFontType dw 0cf_nSizeMin dd 0cf_nSizeMax dd 0pr_lStructSize dd 66pr_hwndOwner dd 0pr_hDevMode dd 0pr_hDevNames dd 0pr_hDC dd 0pr_Flags dd 0pr_nFromPage dw 0pr_nToPage dw 0pr_nMinPage dw 0pr_nMaxPage dw 0pr_nCopies dw 0pr_hInstance dd 0pr_lCustData dd 0pr_lpfnPrintHook dd 0pr_lpfnSetupHook dd 0pr_lpPrintTemplateName dd 0pr_lpSetupTemplateName dd 0pr_hPrintTemplate dd 0pr_hSetupTemplate dd 0!RA_BCKCOLOR dd $C0F0F0!RA_TXTCOLOR dd $000000!RA_SELBCKCOLOR dd $800000!RA_SELTXTCOLOR dd $ffffff!RA_CMNTCOLOR dd $008000!RA_STRCOLOR dd $ff0000!RA_OPRCOLOR dd $0000a0!RA_HILITE1 dd $F0C0C0!RA_HILITE2 dd $C0F0C0!RA_HILITE3 dd $C0C0F0!RA_SELBARCOLOR dd $c0c0c0!RA_SELBARPEN dd $808080!RA_LNRCOLOR dd $800000!RA_NUMCOLOR dd $800000!cbSize dd 52!rcItem dd 0,0,0,0!rcButton dd 0,0,0,0!stateButton dd 0!hwndCombo dd 0!hwndItem dd 0!hwndList dd 0ENDTEXTTEXTBLOCK GUIRunVars	; RAGrid Column Structurealign 4gc_colwt rd 1gc_lpszhdrtext rd 1gc_halign rd 1gc_calign rd 1gc_ctype rd 1gc_ctextmax rd 1gc_lpszformat rd 1gc_himl rd 1gc_hdrflag rd 1gc_colxp rd 1gc_edthwnd rd 1; RAGrid rowcol Structurerc_backcolor rd 1rc_textcolor rd 1CursorPosX rd 1CursorPosY rd 1Rect: ;StructureRectLeft rd 1RectTop rd 1RectRight rd 1RectBottom rd 1!ToolTip rd 1	; Paint StructurePaintStruct rd 16	!TargetGUIDesc rd 1!SourceGUIDesc rd 1	; RAGrid GridRow rd 1GridCol rd 1;TC_ITEM structure!TC_ITEMmask rd 1!TC_ITEMState rd 1!TC_ITEMStateMask rd 1!TC_ITEMText rd 1!TC_ITEMTextMax rd 1!TC_ITEMImage rd 1!TC_ITEMlParam rd 1;Treeview Structure!TV_hParent rd 1!TV_hInsertAfter rd 1!TV_mask rd 1!TV_hItem rd 1!TV_state rd 1!TV_stateMask rd 1!TV_pszText rd 1!TV_cchTextMax rd 1!TV_iImage rd 1!TV_iSelectedImage rd 1!TV_cChildren rd 1!TV_lParam rd 1!TV_iIntegral rd 1;Listview Insert Item Structure!LV_Itemmask rd 1 !LV_ItemiItem rd 1 !LV_ItemiSubItem rd 1 !LV_Itemstate rd 1 !LV_ItemstateMask rd 1 !LV_ItempszText rd 1 !LV_ItemcchTextMax rd 1 !LV_ItemiImage rd 1 !LV_ItemlParam rd 1!LV_ItemiIndent rd 1!LV_ItemiGroupId rd 1!LV_ItemcColumns rd 1!LV_ItempuColumns rd 1;ListView Col Structure!LV_Colmask rd 1 !LV_Colfmt rd 1 !LV_Colcx rd 1 !LV_ColpszText rd 1 !LV_ColcchTextMax rd 1 !LV_ColiSubItem rd 1 !LV_ColiImage rd 1!LV_ColiOrder rd 1!LV_ColcxMin rd 1!LV_ColcxDefault rd 1!LV_ColcxIdeal rd 1; RAEdit VarsEditcpMin rd 1EditcpMax rd 1EditSelType rw 1EditLine rd 1EditcpLine rd 1EditlpLine rd 1EditnLines rd 1EditnHidden rd 1EditfChanged rd 1EditnPage rd 1EditnWordGroup rd 1OldFrameProc rd 1!from equ 0; rd 1!to equ 4; rd 1; _TBBUTTON Structure!iBitmap equ 0; rd 1!idCommand equ 4; rd 1!fsState equ 8; rb 1!fsStyle equ 9; rb 1!dwData equ 10; rd 1!iString equ 14; rd 1!CursorFlag rb 1align 4!Brush rd 1!Desc rd 1NMHDR rd 1!dsStatus rd 1ArrayIndex rd 1!dsBackColor rd 1!dsForeColor rd 1!dsControlType rd 1ENDTEXTTEXTBLOCK PreCodeSeg1section '.code' code readable executable; Main Code Sectionalign 4!Start:call _Initinvoke GetModuleHandle, NULLmov dword [!hinstance], eaxinvoke GetCommandLinemov dword [_ArgList],eaxmov dword edi,ProgramNamecall __MovArginvoke GetStdHandle, STD_INPUT_HANDLEmov dword [_InHandle], eaxinvoke GetStdHandle, STD_OUTPUT_HANDLEmov dword [_OutHandle], eaxmov byte [_CRLF+12],13mov byte [_CRLF+13],10mov byte [_CRLF+14],0mov byte [_Prompt+12],63mov byte [_Prompt+13],0mov byte [_NullStr+12],0mov dword [_ErrVec],_ErrExitENDTEXTTEXTBLOCK GUIEquates HandleOffs equ 0 IDOffs equ 4 OwnerOffs equ 8 ArrayOffs equ 12 LeftOffs equ 16 TopOffs equ 20 RightOffs equ 24 BottomOffs equ 28 BackColorOffs equ 32 ForeColorOffs equ 36 TypeOffs equ 40 StatusOffs equ 44 evActivateOffs equ 48 evCommandOffs equ 52 evMouseActivateOffs equ 56 evPaintOffs equ 60 HDCOffs equ 64 evMouseMoveOffs equ 68 evMouseWheelOffs equ 72 evScrollOffs equ 76 evCreateOffs equ 80 evDestroy equ 84 evKeyDownOffs equ 88 evKeyUpOffs equ 92 evDblClickOffs equ 96 cdDblClickOffs equ 100 evClickOffs equ 104 cdClickOffs equ 108 evChangeOffs equ 112 cdChangeOffs equ 116 evSelectOffs equ 120 cdSelectOffs equ 124 evNotify1Offs equ 128 cdNotify1Offs equ 132 evNotify2Offs equ 136 cdNotify2Offs equ 140 evNotify3Offs equ 144 cdNotify3Offs equ 148 evNotify4Offs equ 152 cdNotify4Offs equ 156 evNotify5Offs equ 160 cdNotify5Offs equ 164 evNotify6Offs equ 168 cdNotify6Offs equ 172 evNotify7Offs equ 176 cdNotify7Offs equ 180 evNotify8Offs equ 184 cdNotify8Offs equ 188 evNotify9Offs equ 192 cdNotify9Offs equ 196 evNotify10Offs equ 200 cdNotify10Offs equ 204 evNotify11Offs equ 208 cdNotify11Offs equ 212 evNotify12Offs equ 216 cdNotify12Offs equ 220 evNotify13Offs equ 224 cdNotify13Offs equ 228 evNotify14Offs equ 232 cdNotify14Offs equ 236 evNotify15Offs equ 240 cdNotify15Offs equ 244 evNotify16Offs equ 248 cdNotify16Offs equ 252 evNotify17Offs equ 256 cdNotify17Offs equ 260 evNotify18Offs equ 264 cdNotify18Offs equ 268 evNotify19Offs equ 272 cdNotify19Offs equ 276 evNotify20Offs equ 280 cdNotify20Offs equ 284 evNotify21Offs equ 288 cdNotify21Offs equ 292 evNotify22Offs equ 296 cdNotify22Offs equ 300 evNotify23Offs equ 304 cdNotify23Offs equ 308 evNotify24Offs equ 312 cdNotify24Offs equ 316 evNotify25Offs equ 320 cdNotify25Offs equ 324 evNotify26Offs equ 328 cdNotify26Offs equ 332 evNotify27Offs equ 336 cdNotify27Offs equ 340 evNotify28Offs equ 344 cdNotify28Offs equ 348 evNotify29Offs equ 352 cdNotify29Offs equ 356 evNotify30Offs equ 360 cdNotify30Offs equ 364 evNotify31Offs equ 368 cdNotify31Offs equ 372 evNotify32Offs equ 376 cdNotify32Offs equ 380 evSysCommandOffs equ 384 evResizeOffs equ 388 evMoveOffs equ 392 evLButtonDownOffs equ 396 evLButtonUpOffs equ 400 evRButtonDownOffs equ 404 evRButtonUpOffs equ 408 CursorOffs equ 412 evContextMenuOffs equ 416 evKeyStruckOffs equ 420 evReserved3Offs equ 424 evReserved4Offs equ 428 evReserved5Offs equ 432 evReserved6Offs equ 436 evReserved7Offs equ 440 Reserved1Offs equ 444 Reserved2Offs equ 448 ScrollBarPageOffs equ 452 ScrollBarMinOffs equ 456 ScrollBarMaxOffs equ 460 ScrollBarPosOffs equ 464 GridColorOffs equ 468 FamilyOffs equ 472 OldProcOffs equ 476 WidthOffs equ 480 HeightOffs equ 484 ControlBrushOffs equ 488 InterceptSafeOffs equ 492 InterceptProcOffs equ 496 Style1Offs equ 500 Extra2Offs equ 504 DoNotUseOffs equ 508 TTcbSizeOffs equ 512 TTuFlagsOffs equ 516 TThwndOffs equ 520 TTuIDOffs equ 524 TTRectLeftOffs equ 528 TTRectTopOffs equ 532 TTRectRightOffs equ 536 TTRectBottomOffs equ 540 TThinstOffs equ 544 TTlpszTextOffs equ 548 TTlparamOffs equ 552 TTTextOffs equ 556 NextOffs equ 656 ENDTEXTTEXTBLOCK PreCodeSeg2invoke CreateWindowEx,0,!ToolTipClass,0,TTS_ALWAYSTIP,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,0,0,[!hinstance],0mov dword [!ToolTip],eaxinvoke InitCommonControlsEx,!iccinvoke LoadIcon,0,IDI_APPLICATIONmov [!OBMainWindowClass.hIcon],eaxinvoke LoadCursor,0,IDC_ARROWmov dword [!OBMain+CursorOffs],eaxmov [!OBMainWindowClass.hCursor],eaxmov [!OBMainWindowClass.style],0mov [!OBMainWindowClass.lpfnWndProc],!WindowProcmov [!OBMainWindowClass.cbClsExtra],0mov [!OBMainWindowClass.cbWndExtra],0mov eax,[!hinstance]mov [!OBMainWindowClass.hInstance],eaxmov [!OBMainWindowClass.hbrBackground],COLOR_BTNFACE+1mov [!OBMainWindowClass.lpszMenuName],0mov [!OBMainWindowClass.lpszClassName],!OBMainClassinvoke RegisterClass,!OBMainWindowClassmov dword [!OBMain+StatusOffs],0mov dword [!OBMain+IDOffs],1mov dword [!OBMain+ArrayOffs],0mov dword [!OBMain+LeftOffs],0mov dword [!OBMain+TopOffs],0mov dword [!OBMain+WidthOffs],400mov dword [!OBMain+HeightOffs],300mov dword [!OBMain+ForeColorOffs],$ffffffmov dword [!OBMain+BackColorOffs],$ffffffffmov dword [!OBMain+TypeOffs],!CT_FORMmov dword [!OBMain+ControlBrushOffs],0invoke CreateWindowEx,0,!OBMainClass,!title,WS_VISIBLE+WS_OVERLAPPEDWINDOW,0,0,400,300,NULL,NULL,[!hinstance],0invoke SetWindowLong,[!OBMain],GWL_USERDATA,!OBMain!MsgLoop:invoke GetMessage,msg,NULL,0,0or eax,eaxjz !EndMsgLoopinvoke TranslateMessage,msginvoke DispatchMessage,msgjmp !MsgLoop!EndMsgLoop:invoke ExitProcess,[msg.wParam]proc !WindowProc,!hwnd,wmsg,wparam,lparamenterpush ebx esi edimov ebx,[wmsg]cmp [wmsg],WM_GETMINMAXINFOjne NotwmGetMaxInfomov dword edi,[!hwnd]mov dword [!OBMain+HandleOffs],edimov dword [!OBMain+OwnerOffs],0mov dword [!OBMain+InterceptSafeOffs],!WindowProcjmp !DefWndProcNotwmGetMaxInfo:mov esi,!OBMaincmp ebx,WM_DESTROYje !wmDestroy!WinProcCommon:cmp ebx,WM_SYSCOMMANDje !wmSysCommandcmp ebx,WM_SIZEje !wmSizecmp ebx,WM_MOVEje !wmMovecmp ebx,WM_TIMERje !wmTimercmp ebx,WM_SETCURSORje !wmSetCursorcmp ebx,WM_CREATEje !wmCreatecmp ebx,WM_PAINTje !wmPaintcmp ebx,WM_CONTEXTMENUje !wmContextMenumov eax,[wparam]mov [wparamLow],axshr eax,16mov [wparamHigh],axinvoke GetWindowLong,[lparam],GWL_USERDATAmov [!Desc],eaxcmp ebx,WM_CTLCOLORSTATICje !CtlColorChangecmp ebx,WM_CTLCOLOREDITje !CtlColorChangecmp ebx,WM_CTLCOLORBTNje !CtlColorChangecmp ebx,WM_CTLCOLORSCROLLBARje !CtlColorChangecmp ebx,WM_CTLCOLORLISTBOXje !CtlColorChangecmp ebx,WM_CTLCOLORDLGje !CtlColorChangecmp ebx,WM_CTLCOLORMSGBOXje !CtlColorChangecmp ebx,WM_COMMANDje !wmCommandcmp ebx,WM_NOTIFYje !wmNotifycmp ebx,WM_HSCROLLje !wmScrollcmp ebx,WM_VSCROLLje !wmScrollcmp ebx,WM_CHARje !wmCharcmp ebx,WM_SYSCHARje !wmSysCharcmp ebx,WM_MOUSEMOVEje !wmMouseMovecmp ebx,WM_LBUTTONDOWNje !wmLButtonDowncmp ebx,WM_LBUTTONUPje !wmLButtonUpcmp ebx,WM_RBUTTONDOWNje !wmRButtonDowncmp ebx,WM_RBUTTONUPje !wmRButtonUpmov eax,[wmsg]cmp [FindMsgID],eaxje !FindMsg!DefWndProc:invoke DefWindowProc,[!hwnd],[wmsg],[wparam],[lparam]jmp !Finish!wmSetCursor:cmp [!CursorFlag],0je !DefWndProcmov eax,1jmp !Finish!wmSysCommand:mov [!PassEvent],0mov eax,[esi+evSysCommandOffs]or eax,eaxje !DefWndProcmov edx,[wparam]cmp edx,$f020je !DoSysCmdcmp edx,$f030je !DoSysCmdcmp edx,$f060je !DoSysCmdcmp edx,$f120je !DoSysCmdjmp !DefWndProc!DoSysCmd:mov [STATUS],edxcall dword eaxcmp [!PassEvent],0jne !DefWndProcxor eax,eaxjmp !Finish!wmSize:; need to update RightOffs and BottomOffsmov ecx,[lparam]mov edx,ecxand ecx,$ffffshr edx,16mov [esi+WidthOffs],ecxmov [esi+HeightOffs],edxmov eax,[esi+evResizeOffs]or eax,eaxje !DefWndProcmov edx,[wparam]mov [STATUS],edxcall dword eaxxor eax,eaxjmp !Finish!wmMove:; need to update RightOffs and BottomOffsmov ecx,[lparam]mov edx,ecxand ecx,$ffffshr edx,16mov [esi+LeftOffs],ecxmov [esi+TopOffs],edxmov eax,[esi+evMoveOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!FindMsg:mov edx,[FindEVPtr]or edx,edxje !DefWndProcmov eax,[fr_Flags]mov [FLAGS],eaxcall dword edxje !DefWndProc!wmTimer:mov edx,[wparam]mov ebx,edxshr ebx,16mov [ArrayIndex],ebxand edx,$0000ffffcmp edx,$ffffje !SysTimershl edx,2add edx,!Timermov eax,[edx]cmp eax,0je !Finishcall dword eaxxor eax,eaxjmp !Finish!SysTimer:mov eax,[!Timer]cmp eax,0je !Finishcall dword eaxxor eax,eaxjmp !Finish!wmNotify:mov edi,[lparam]; Address of NMHDRmov [NMHDR],edi; Save NMHDR for event processingmov esi,[edi]; Handleinvoke GetWindowLong,esi,GWL_USERDATAcmp eax,0je !DefWndProcmov esi,eax; Address of Descmov ebx,[edi+8]; Codemov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+TypeOffs]mov [!dsControlType],eaxmov ecx,cdNotify32Offs+4; Points past last Notify Offsadd ecx,esi; Add Offs to baseadd esi,evNotify1Offs; Points to first Notify Offs!NotifyLoop:cmp ebx,[esi+4]jne !NotNotifyCodemov eax,[esi]cmp eax,0jne !ProcNotifyjmp !DefWndProc!NotNotifyCode:add esi,8; Point to next Notifycmp esi,ecx; Past last Notify?jne !NotifyLoop; No, Try nextjmp !DefWndProc; Give up, no Notify match!ProcNotify:mov edi,[NMHDR]add edi,12cmp [!dsControlType],!CT_RAGridjne !RAEditCheckmov ebx,[edi]add ebx,[!ArrayBase]mov [GridCol],ebxmov ebx,[edi+4]add ebx,[!ArrayBase]mov [GridRow],ebxjmp !NotifyDispatch!RAEditCheck:cmp [!dsControlType],!CT_RAEditjne !TabFolderCheckmov ebx,[edi]add ebx,[!ArrayBase]mov [EditcpMin],ebxsub ebx,[edi+14]mov [EditcpLine],ebxmov ebx,[edi+4]add ebx,[!ArrayBase]mov [EditcpMax],ebxmov bx,[edi+8]mov [EditSelType],bxmov ebx,[edi+10]add ebx,[!ArrayBase]mov [EditLine],ebxmov ebx,[edi+18]add ebx,[!ArrayBase]mov [EditlpLine],ebxmov ebx,[edi+22]add ebx,[!ArrayBase]mov [EditnLines],ebxmov ebx,[edi+26]mov [EditnHidden],ebxmov ebx,[edi+30]mov [EditfChanged],ebxmov ebx,[edi+34]add ebx,[!ArrayBase]mov [EditnPage],ebxmov ebx,[edi+38]add ebx,[!ArrayBase]mov [EditnWordGroup],ebxjmp !NotifyDispatch!TabFolderCheck:cmp [!dsControlType],!CT_TABFOLDERje !CommandDispatchcmp [!dsControlType],!CT_CALENDARje !NotifyDispatchjmp !DefWndProc!NotifyDispatch:jmp !CommandDispatch!wmMouseMove:call !GetMousePosmov eax,[esi+evMouseMoveOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmLButtonDown:call !GetMousePosmov eax,[esi+evLButtonDownOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmLButtonUp:call !GetMousePosmov eax,[esi+evLButtonUpOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmRButtonDown:call !GetMousePos mov eax,[esi+evRButtonDownOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmRButtonUp:call !GetMousePos mov eax,[esi+evRButtonUpOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!GetMousePos:mov ebx,[lparam]and ebx,$ffffmov [CursorPosX],ebxmov ebx,[lparam]shr ebx,16mov [CursorPosY],ebxret!wmCreate:mov eax,[esi+evCreateOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmPaint:mov eax,[esi+evPaintOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!CtlColorChange:mov [!PassEvent],0cmp [!TrapColorChange],0je !NotColorChangeTrapmov eax,[!TrapColorChange]call dword eaxcmp [!PassEvent],0jne !NotColorChangeTrapxor eax,eaxjmp !Finish!NotColorChangeTrap:invoke GetWindowLong,[lparam],GWL_USERDATAcmp [!Desc],0je !DefWndProcmov esi,[!Desc]call !GetDescbt [!dsStatus],WinChangeBackColorjc !CtlBackcolorChangebt [!dsStatus],WinChangeForeColorjc !CtlForeColorChangejmp !DefWndProc!CtlBackcolorChange:bt [!dsStatus],WinChangeForeColorjc !CtlBothColorChangecmp [!dsBackColor],$ffffffffjne !NotTransparentinvoke SetBkMode,[wparam],TRANSPARENTinvoke GetStockObject,NULL_BRUSHjmp !Finish!NotTransparent:call !BackColorChangejmp !Finish!BackColorChange:invoke DeleteObject,[!Brush]invoke CreateSolidBrush,[!dsBackColor]mov [!Brush],eaxinvoke SetBkColor,[wparam],[!dsBackColor]mov eax,[!Brush]ret!CtlBothColorChange:call !BothColorChangejmp !Finish!BothColorChange:invoke DeleteObject,[!Brush]invoke CreateSolidBrush,[!dsBackColor]mov [!Brush],eaxinvoke SetBkColor,[wparam],[!dsBackColor]invoke SetTextColor,[wparam],[!dsForeColor]mov eax,[!Brush]ret!CtlForeColorChange:call !ForeColorChangejmp !Finish!ForeColorChange:invoke DeleteObject,[!Brush]invoke GetBkColor,[wparam]cmp [!dsControlType],!CT_TEXTBOXje !ListOrTextOrCombocmp [!dsControlType],!CT_LISTBOXje !ListOrTextOrCombocmp [!dsControlType],!CT_COMBOBOXje !ListOrTextOrComboinvoke GetPixel,[wparam],0,0!ListOrTextOrCombo:mov esi,[!Desc]bts dword [esi+StatusOffs],WinChangeBackColormov [esi+BackColorOffs],eaxinvoke CreateSolidBrush,eaxmov [!Brush],eaxinvoke SetTextColor,[wparam],[!dsForeColor]invoke SetBkMode,[wparam],TRANSPARENTmov eax,[!Brush]ret!wmCommand:mov ax,[wparamLow]cmp ax,999jg !wmMenucmp [!Desc],0je !DefWndProcmov esi,[!Desc]mov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+evCommandOffs]cmp eax,0jne !CommandDispatchxor ebx,ebxmov bx,[wparamHigh]; Clickcmp ebx,[esi+cdClickOffs]jne !evChangemov eax,[esi+evClickOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evChange:cmp ebx,[esi+cdChangeOffs]jne !evSelectmov eax,[esi+evChangeOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evSelect:cmp ebx,[esi+cdSelectOffs]jne !evDblClickmov eax,[esi+evSelectOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evDblClick:cmp ebx,[esi+cdDblClickOffs]jne !DefWndProcmov eax,[esi+evDblClickOffs]cmp eax,0je !DefWndProc!CommandDispatch:call dword eaxxor eax,eaxjmp !Finish!wmMenu:mov edx,[MenuEVPtr]or edx,edxje !DefWndProcand eax,$ffffmov [MenuID],eaxcall dword edxjmp !Finish!wmScroll:cmp [!Desc],0je !DefWndProcmov eax,[wparam]mov [ScrollCode],axshr eax,16mov [ScrollValue],axmov esi,[!Desc]mov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax, dword [esi+TypeOffs]cmp eax,!CT_SCROLLBARjne !NotScrollBarmov ax,[ScrollCode]cmp ax,0je !ScrollLineUpcmp ax,1je !ScrollLineDncmp ax,2je !ScrollPageUpcmp ax,3je !ScrollPageDncmp ax,4je !ScrollThumbPoscmp ax,5jne !NotScrollBarxor eax,eaxmov ax,[ScrollValue]mov [esi+ScrollBarPosOffs],eaxjmp !NotScrollBar!ScrollBarCommon:mov [esi+ScrollBarPosOffs],eaxinvoke SendMessage, dword [esi],SBM_SETPOS,eax,TRUE!NotScrollBar:mov eax,[esi+evScrollOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!ScrollLineUp:mov eax,[esi+ScrollBarPosOffs]dec eaxcmp eax,[esi+ScrollBarMinOffs]jge !ScrollBarCommonmov eax,[esi+ScrollBarMinOffs]jmp !ScrollBarCommon!ScrollLineDn:mov eax,[esi+ScrollBarPosOffs]inc eaxcmp eax,[esi+ScrollBarMaxOffs]jle !ScrollBarCommonmov eax,[esi+ScrollBarMaxOffs]jmp !ScrollBarCommon!ScrollPageUp:mov eax,[esi+ScrollBarPosOffs]sub eax,[esi+ScrollBarPageOffs]cmp eax,[esi+ScrollBarMinOffs]jge !ScrollBarCommonmov eax,[esi+ScrollBarMinOffs]jmp !ScrollBarCommon!ScrollPageDn:mov eax,[esi+ScrollBarPosOffs]add eax,[esi+ScrollBarPageOffs]cmp eax,[esi+ScrollBarMaxOffs]jle !ScrollBarCommonmov eax,[esi+ScrollBarMaxOffs]jmp !ScrollBarCommon!ScrollThumbPos:xor eax,eaxmov ax,[ScrollValue]jmp !ScrollBarCommon!wmChar:mov [AltKey],0jmp !CharCommon!wmSysChar:mov [AltKey],1!CharCommon:mov [!PassEvent],0mov esi,!OBMainmov eax,[esi+evKeyStruckOffs]cmp eax,0je !DefWndProccall dword eaxcmp [!PassEvent],0jne !DefWndProcxor eax,eaxjmp !Finish!wmContextMenu:invoke GetWindowLong,[wparam],GWL_USERDATAor eax,eaxje !DefWndProcmov esi,eaxmov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxcall !GetMousePosmov eax,[esi+evContextMenuOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!GetDesc:mov eax,[esi+StatusOffs]mov [!dsStatus],eaxmov eax,[esi+BackColorOffs]mov [!dsBackColor],eaxmov eax,[esi+ForeColorOffs]mov [!dsForeColor],eaxmov eax,[esi+TypeOffs]mov [!dsControlType],eaxret!wmDestroy:invoke DeleteObject,[!Brush]invoke PostQuitMessage,0xor eax,eax!Finish:pop edi esi ebxreturn ENDTEXTTEXTBLOCK Includes	include 'include\kernel.inc'	include 'include\user.inc'	include 'include\gdi.inc'	include 'include\comctl.inc'	include 'include\comdlg.inc'	include 'include\shell.inc'	include 'include\cproc.inc'	include 'include\riched.inc'	include 'include\raedit.inc'	include 'include\ragrid.inc'	include 'include\OBComm.inc'	include 'include\DrawProgress.inc'	include 'include\macro\import.inc'	include 'include\macro\stdcall.inc'	include 'include\macro\resource.inc'	include 'include\buttonex.inc'	include 'include\wbdll.inc'ENDTEXTTEXTBLOCK SubClassProcproc !SubClassProc,!hwnd,wmsg,wparam,lparamenterpush ebx esi edimov eax,[wparam]mov [wparamLow],axshr eax,16mov [wparamHigh],axinvoke GetWindowLong,[lparam],GWL_USERDATAmov [!Desc],eaxmov ebx,[wmsg]cmp ebx,WM_CTLCOLORSTATICje !CtlColorChangecmp ebx,WM_CTLCOLOREDITje !CtlColorChangecmp ebx,WM_CTLCOLORBTNje !CtlColorChangecmp ebx,WM_CTLCOLORSCROLLBARje !CtlColorChangecmp ebx,WM_CTLCOLORLISTBOXje !CtlColorChangecmp ebx,WM_COMMANDje !wmCommandinvoke GetWindowLong,[!hwnd],GWL_USERDATAor eax,eaxje !DefWndProcadd eax,OldProcOffsmov eax,[eax]invoke CallWindowProc,eax,[!hwnd],[wmsg],[wparam],[lparam]jmp !FinishENDTEXTTEXTBLOCK ReadFileLib__ReadFile:mov [_ArgSafe0],esiinvoke ReadFile,[_IOPthNum],[_IOBuffer],1,XferCount,0mov [STATUS],eaxcmp eax,0je __ReadFile2cmp [XferCount],0je __ReadFile1cmp byte [_IOBuffer+12],13je __ReadFile1cmp byte [_IOBuffer+12],10je __ReadFilecmp [__ByteCounter],0je __ReadFilemov al, byte [_IOBuffer+12]mov esi,[_ArgSafe0]mov [esi],alinc esimov [_ArgSafe0],esidec [__ByteCounter]jmp __ReadFile__ReadFile1:cmp [__ByteCounter],0je __ReadOKmov esi,[_ArgSafe0]mov byte [esi],0jmp __ReadOK__ReadFile2:cmp eax,0jne __ReadOKinvoke GetLastErrormov [err],eaxjmp [_ErrVec]__ReadOK:retENDTEXTTEXTBLOCK WriteFileLib__WriteFile:mov [XferCount],0__WriteStrLen:cmp byte [esi],0je __WriteStrLenDoneinc esiinc [XferCount]dec [__ByteCounter]jne __WriteStrLen__WriteStrLenDone:invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0mov [STATUS],eaxcmp eax,0jne __WriteOKinvoke GetLastErrormov [err],eaxjmp [_ErrVec]__WriteOK:mov edx,[XferCount]mov [_ArgSafe0],edxmov eax,[_CRLF]mov [_XferAddr],eaxmov [XferCount],2invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0mov edx,[_ArgSafe0]add edx,[XferCount]mov [XferCount],edxretENDTEXTTEXTBLOCK WriteOBCommLib__WriteOBComm:xor eax,eax__WriteOBCommStrLen:cmp byte [esi],0je __WriteOBCommStrLenDoneinc esiinc eaxdec edxjne __WriteOBCommStrLen__WriteOBCommStrLenDone:invoke WriteFile, dword [edi],ebx,eax,XferCount,0mov [STATUS],eaxcmp eax,0jne __WriteOBCommOKinvoke GetLastErrormov [err],eaxjmp [_ErrVec]__WriteOBCommOK:retENDTEXTTEXTBLOCK TailStrLib__TailStr:push ebxmov edi,[esi]mov ecx,[esi+4]xor edx,edxdec eaxadd eax,edi__TailStrLen:mov bl,[edi]or bl,blje __TailStr2dec ecxje __TailStr1inc ediinc edxjmp __TailStrLen__TailStr1:inc edi__TailStr2:mov [esi],eaxmov [esi+4],edxpop ebxretENDTEXTTEXTBLOCK PadLib__PadStr:mov ecx,[esi+4]mov esi,[esi]__FindNull:mov al,[esi]or al,alje __PadLoopinc esidec ecxje __PadDonejmp __FindNull__PadLoop:mov byte [esi],$20inc esidec ecxjne __PadLoop__PadDone:retENDTEXTTEXTBLOCK TrimLib__TrimStr:mov ecx,[esi+4]mov esi,[esi]__FindSpace:mov al,[esi]cmp al,$20je __FoundSpacecmp al,0je __TrimDoneinc esidec ecxje __TrimDonejmp __FindSpace__FoundSpace:mov byte [esi],0__TrimDone:retENDTEXTTEXTBLOCK LCaseLib__LCase:mov ecx,[esi+4]mov esi,[esi]__LCaseLoop:mov al,[esi]or al,alje __LCaseDonecmp al,$41jb __NotUppercmp al,$5aja __NotUpperor al,$20__NotUpper:mov [esi],alinc esidec ecxjne __LCaseLoop__LCaseDone:retENDTEXTTEXTBLOCK UCaseLib__UCase:mov ecx,[esi+4]mov esi,[esi]__UCaseLoop:mov al,[esi]or al,alje __UCaseDone cmp al,$61jb __NotLowercmp al, $7aja __NotLowerand al,$df__NotLower:mov [esi],alinc esidec ecxjne __UCaseLoop__UCaseDone:retENDTEXTTEXTBLOCK SetStrConstLib__SetStrConst:mov ecx,[esi+4]mov al,[esi]mov [edi],alor al,alje __SetStrConstDonedec ecxje __SetStrConstDoneinc esiinc edijmp __SetStrConst__SetStrConstDone:retENDTEXTTEXTBLOCK DataLib__ReadBool:mov edi,[_DataPtr]mov al,[edi]cmp al,$30jne __ReadBoolTruexor al,aljmp __ReadBoolDone__ReadBoolTrue:mov al,1__ReadBoolDone:mov [esi],aladd edi,2mov [_DataPtr],ediret__ReadByte:push esicinvoke atol,[_DataPtr]pop esimov [esi],alcall __UpDateDataPtrret__ReadShort:push esicinvoke atol,[_DataPtr]pop esimov [esi],axcall __UpDateDataPtrret__ReadLong:push esicinvoke atol,[_DataPtr]pop esimov [esi],eaxcall __UpDateDataPtrret__ReadFlt:ret__ReadStr:mov edi,[_DataPtr]__ReadStrLoop:mov al,[edi]mov [esi],alinc ediinc esicmp al,0jne __ReadStrLoopmov [_DataPtr],ediret__UpDateDataPtr:mov esi,[_DataPtr]__UpDateDataPtrLoop:mov al,[esi]cmp al,0je __UpDateDataPtrDoneinc esijmp __UpDateDataPtrLoop__UpDateDataPtrDone:inc esimov [_DataPtr],esiretENDTEXTTEXTBLOCK InpDataLib__InpData:invoke ReadConsole,[_InHandle],[_IOBuffer],_BufSize,XferCount,0push eaxcmp [_ArgSafe1],6je __InpDataStringcmp [_ArgSafe1],1je __InpDataBoolcmp [_ArgSafe1],2je __InpDataBytecmp [_ArgSafe1],3je __InpDataShortcmp [_ArgSafe1],5je __InpDataFloatcall __GetNumValmov [esi],eaxjmp __InpDataDone__InpDataString:mov edi,[_ArgSafe0]mov edx,ediadd edx,4mov edx,[edx]mov edi,[edi]mov ecx,[XferCount]mov esi,[_IOBuffer]__InpDataStringLp:mov al,[esi]cmp al,$0djne __NotCRmov byte [edi],0jmp __InpDataDone__NotCR:mov [edi],aldec edxje __InpDataDoneinc esiinc edijne __InpDataStringLpjmp __InpDataDone__InpDataBool:jmp __InpDataDone__InpDataByte:call __GetNumValmov [esi],aljmp __InpDataDone__InpDataShort:call __GetNumValmov [esi],axjmp __InpDataDone__InpDataFloat:__InpDataDone:pop eaxret__GetNumVal:mov esi,[_IOBuffer]cinvoke atol,[_IOBuffer]mov esi,[_ArgSafe0]mov esi,[esi]retENDTEXTTEXTBLOCK BtoALib__BtoA:mov edi,[_ConvBuf1]or al,alje __BoolFalsemov esi,_TrueStrjmp __BldBool__BoolFalse:mov esi,_FalseStr__BldBool:mov al,[esi]mov [edi],alcmp al,0je __BtoADoneinc esiinc edijmp __BldBool__BtoADone:mov [edi],alretENDTEXTTEXTBLOCK MidStrLib__MidStr:dec eaxmov edi,[esi]add edi,eaxmov [esi],edimov [esi+4],edxretENDTEXTTEXTBLOCK MovArgLib__MovArg:mov esi,[_ArgList]mov edx,[edi+4]mov edi,[edi]__MovArg1:mov al,[esi]cmp al,32je __MovArgSpacemov [edi],alor al,alje __MovArgDoneinc esiinc edidec edxje __MovArgDonejmp __MovArg1__MovArgSpace:xor al,almov [edi],alinc esi__MovArgDone:mov [_ArgList],esiretENDTEXTTEXTBLOCK CmpStrLib__CmpStr:mov edx,[edi+4]mov edi,[edi]mov ecx,[esi+4]mov esi,[esi]__CmpStrLoop:mov al,[edi]mov ah,[esi]cmp al,0je __CmpStrDonecmp ah,0je __CmpStrDonecmp al,ahjne __CmpStrDiffinc ediinc esidec edxje __CmpStrDonedec ecxjne __CmpStrLoop__CmpStrDone:cmp al,ah__CmpStrDiff:retENDTEXTTEXTBLOCK MovStrLib__MovStr:push ebxmov edx,[edi+4]mov edi,[edi]__MovStr1:mov ecx,[esi+4]or ecx,ecxje __MovStrDone1mov ebx,[esi]__MovStr2:mov al,[ebx]mov [edi],alinc ediinc ebxdec edxje __MovStrDone2or al,alje __MovStr3dec ecxjne __MovStr2jmp __MovStr4__MovStr3:dec edi__MovStr4:mov ecx,[esi+8]or ecx,ecxje __MovStrDone1mov esi,ecxjmp __MovStr1__MovStrDone1:mov byte [edi],0__MovStrDone2:pop ebxretENDTEXTTEXTBLOCK ShowHideFamilyLib__ShowHideFamily:mov eax,[!ObjectCount]mov [_ArgSafe0],eaxmov edi,!OBMain+FamilyOffsmov [!TargetGUIDesc],edi__ShowHideLoop:mov eax,[edi]cmp eax,[_ArgSafe1]jne __NotFamilyinvoke ShowWindow, dword [edi-FamilyOffs],[_ArgSafe2]__NotFamily:add edi,768mov [!TargetGUIDesc],edidec [_ArgSafe0]jne __ShowHideLoopretENDTEXTTEXTBLOCK EnableDisableFamilyLib__EnableDisableFamily:mov eax,[!ObjectCount]mov [_ArgSafe0],eaxmov edi,!OBMain+FamilyOffsmov [!TargetGUIDesc],edi__EnableDisableLoop:mov eax,[edi]cmp eax,[_ArgSafe1]jne __NotFamily1invoke EnableWindow, dword [edi-FamilyOffs],[_ArgSafe2]__NotFamily1:add edi,768mov [!TargetGUIDesc],edidec [_ArgSafe0]jne __EnableDisableLoopretENDTEXTTEXTBLOCK AtoLLib__AtoL:mov dl,[esi]cmp dl,'$'jne __NotHexcall __NumScan__HexLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'$'je __AtoLDonecmp dl,$39jg __HexLetterand dl,$0fjmp __HexAcc__HexLetter:and dl,$0fadd dl,9__HexAcc:imul edx,ecxadd eax,edximul ecx,16 jmp __HexLoop__NotHex:cmp dl,'%'jne __NotOctalcall __NumScan__OctalLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'%'je __AtoLDoneand dl,$07imul edx,ecxadd eax,edximul ecx,8jmp __OctalLoop__NotOctal:cmp dl,'&'jne __NotBinarycall __NumScan__BinaryLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'&'je __AtoLDoneand dl,$01imul edx,ecxadd eax,edximul ecx,2jmp __OctalLoop__NotBinary:cinvoke atol,esi__AtoLDone:ret__NumScan:inc esimov dl,[esi]cmp dl,0jne __NumScanxor eax,eaxmov ecx,1retENDTEXTTEXTBLOCK StrLenLib__StrLen:xor eax,eax__StrLenGetVec:mov edi,[esi]mov edx,[esi+4]__StrLenLp:mov cl,[edi]cmp cl,0je __StrLenChkLnkinc eaxdec edxje __StrLenChkLnkinc edijmp __StrLenLp__StrLenChkLnk:mov esi,[esi+8]or esi,esijne __StrLenGetVecretENDTEXTTEXTBLOCK RightStrLib__RightStr:mov edi,[esi]mov ecx,[esi+4]__RightStrLen:mov dl,[edi]or dl,dlje __RightStr2dec ecxje __RightStr1inc edijmp __RightStrLen__RightStr1:inc edi__RightStr2:sub edi,eaxmov [esi],edimov [esi+4],eaxretENDTEXTTEXTBLOCK SetRightBottomLib__SetRightBottom:mov edi,[!TargetGUIDesc]mov dword eax,[edi+LeftOffs]add dword eax,[edi+WidthOffs]mov dword [edi+RightOffs],eaxmov dword eax,[edi+TopOffs]add dword eax,[edi+HeightOffs]mov dword [edi+BottomOffs],eaxretENDTEXTTABLE KeyTable AS KeyData	0,"data",DataX	0,"restore",RestoreX	0,"VACANT",MainLoop	0,"close",CloseX	0,"VACANT",MainLoop	0,"type",TypeX	0,"dim",DimX	0,"let",LetX	0,"VACANT",MainLoop	0,"begin",BeginX	0,"for",ForX	0,"return",ReturnX		0,"if",IfX	0,"seek",SeekX	0,"create",CreateX	0,"gosub",GosubX	0,"on",OnX	0,"print",PrintX	0,"input",InputX	0,"read",ReadX	0,"write",WriteX	0,"get",GetX	0,"put",PutX	0,"return",ReturnX	0,"end",EndX	0,"open",OpenX	0,"while",WhileX	0,"next",NextX	0,"VACANT",MainLoop	0,"else",ElseX	0,"delete",DeleteX	0,"deleteobject",DeleteObjectX	0,"buffer",BufferX	0,"repeat",RepeatX	0,"until",UntilX	0,"shell",ShellX	0,"fprint",FPrintX	0,"finput",FInputX	0,"base",BaseX	0,"incr",IncrX	0,"decr",DecrX	0,"bufread",BufReadX	0,"bufwrite",BufWriteX	0,"decimals",DecimalsX	0,"exchange",ExchangeX	0,"beep",BeepX	0,"redim",ReDimX	0,"playwave"PlayWaveX:	0,"digits",DigitsX	0,"macro",MacroX	0,"table",TableX	0,"include",IncludeX	0,"chdir",ChDirX	0,"mkdir",MkDirX	0,"rmdir",RmDirX	0,"menu",MenuX	0,"declare",DeclareX	0,"continue",ContinueX	0,"select",SelectX	0,"selectobject",SelectObjectX	0,"case",CaseX	0,"const",ConstX	0,"program",ProgramX	0,"makelower",MakeLowerX	0,"makeupper",MakeUpperX	0,"find",FindX	0,"endtext",EndTextX	0,"goto",GotoX	0,"getdc",GetDCX	0,"screentoclient",ScreenToClientX	0,"getcursorposition",GetCursorPositionX	0,"getwindowrect",GetWindowRectX	0,"getclientrect",GetClientRectX	0,"getpixel",GetPixelX	0,"getdatetime",GetDateTimeX	0,"getgmtdatetime",GetGMTDateTimeX	0,"getdateformat",GetDateFormatX	0,"gettimeformat",GetTimeFormatX	0,"releasedc",ReleaseDCX	0,"releasecapture",ReleaseCaptureX	0,"invalidaterect",InvalidateRectX	0,"msgbox",MsgBoxX	0,"warningbox",WarningBoxX	0,"infobox",InfoBoxX	0,"questionbox",QuestionBoxX	0,"errorbox",ErrorBoxX	0,"textblock",TextBlockX	0,"destroy",DestroyX	0,"show",ShowX	0,"movewindow",MoveWindowX	0,"moveto",MoveToX	0,"arcto",ArcToX	0,"lineto",LineToX	0,"ellipse",EllipseX	0,"rectangle",RectangleX	0,"roundrect",RoundRectX	0,"drawtext",DrawTextX	0,"settextcolor",SetTextColorX	0,"setbkcolor",SetBkColorX	0,"polyline",PolylineX	0,"setposition",SetPositionX	0,"seteof",SetEOFX"	0,"setvector",SetVecX	0,"setpixel",SetPixelX	0,"setcursor",SetCursorX	0,"setstockcursor",SetStockCursorX	0,"setdefaultcursor",SetDefaultCursorX	0,"settooltipcolors",SetToolTipColorX	0,"setcursorflag",SetCursorFlagX	0,"setcapture",SetCaptureX	0,"setstyle",SetStyleX	0,"setmenuitembitmaps",SetMenuItemBitmapsX	0,"settaskpriority",SetTaskPriorityX	0,"finddialog",FindDialogX	0,"replacedialog",ReplaceDialogX	0,"colordialog",ColorDialogX	0,"fontdialog",FontDialogX	0,"opendialog",OpenDialogX	0,"savedialog",SaveDialogX	0,"printdialog",PrintDialogX	0,"pagedialog",PageDialogX	0,"showpopup",ShowPopupX	0,"deletemenuitem",DeleteMenuItemX	0,"appendmenuitem",AppendmenuItemX	0,"popupmenu",PopupMenuX	0,"checkmenuitem",CheckMenuitemX	0,"enablemenuitem",EnableMenuitemX	0,"hilitemenuitem",HiliteMenuItemX	0,"enum",EnumX	0,"load",LoadX	0,"passevent",PassEventX	0,"trapcolorchangeevent",TrapColorChangeEventX	0,"readcard",ReadCardX	0,"writecard",WriteCardX	0,"useimport",UseImportX	0,"importfunction",ImportFunctionX	0,"exportfunction",ExportFunctionX	0,"sleep",SleepX	0,"exit",ExitX	0,"launch",LaunchX	0,"timeadd",TimeAddX	0,"resume",ResumeX	0,"suspend",SuspendX	0,"call",CallX	0,"enter",EnterX	0,"db",AssemblyX	0,"dw",AssemblyX	0,"dd",AssemblyX	0,"rb",AssemblyX	0,"rw",AssemblyX	0,"rd",AssemblyX	0,"add",AssemblyX	0,"aad",AssemblyX	0,"aam",AssemblyX	0,"aas",AssemblyX	0,"adc",AssemblyX	0,"and",AssemblyX	0,"arpl",AssemblyX	0,"bound",AssemblyX	0,"bsf",AssemblyX	0,"bsr",AssemblyX	0,"bswap",AssemblyX	0,"bt",AssemblyX	0,"btc",AssemblyX	0,"btr",AssemblyX	0,"bts",AssemblyX	0,"cbw",AssemblyX	0,"cdq",AssemblyX	0,"clc",AssemblyX	0,"cld",AssemblyX	0,"cli",AssemblyX	0,"clts",AssemblyX	0,"cmc",AssemblyX	0,"cmp",AssemblyX	0,"cpms",AssemblyX	0,"cmpxchg",AssemblyX	0,"cwd",AssemblyX	0,"cwde",AssemblyX	0,"daa",AssemblyX	0,"das",AssemblyX	0,"dec",AssemblyX	0,"div",AssemblyX	0,"enter",AssemblyX	0,"esc",AssemblyX	0,"hlt",AssemblyX	0,"idiv",AssemblyX	0,"imul",AssemblyX	0,"in",AssemblyX	0,"inc",AssemblyX	0,"ins",AssemblyX	0,"int",AssemblyX	0,"into",AssemblyX	0,"invd",AssemblyX	0,"iret",AssemblyX	0,"iretd",AssemblyX	0,"invlpg",AssemblyX	0,"invoke",AssemblyInvokeX	0,"ja",AssemblyX	0,"jae",AssemblyX	0,"jb",AssemblyX	0,"jbe",AssemblyX	0,"jc",AssemblyX	0,"jcxz",AssemblyX	0,"je",AssemblyX	0,"jecxz",AssemblyX	0,"jg",AssemblyX	0,"jge",AssemblyX	0,"jl",AssemblyX	0,"jle",AssemblyX	0,"jmp",AssemblyX	0,"jna",AssemblyX	0,"jnae,",AssemblyX	0,"jnb",AssemblyX	0,"jnbe",AssemblyX	0,"jnc",AssemblyX	0,"jne",AssemblyX	0,"jng",AssemblyX	0,"jnge",AssemblyX	0,"jnl",AssemblyX	0,"jnle",AssemblyX	0,"jno",AssemblyX	0,"jnp",AssemblyX	0,"jns",AssemblyX	0,"jnz",AssemblyX	0,"jo",AssemblyX	0,"jp",AssemblyX	0,"jpe",AssemblyX	0,"jpo",AssemblyX	0,"js",AssemblyX	0,"jz",AssemblyX	0,"lahf",AssemblyX	0,"lar",AssemblyX	0,"lds",AssemblyX	0,"lea",AssemblyX	0,"leave",AssemblyX	0,"les",AssemblyX	0,"lfs",AssemblyX	0,"lgdt",AssemblyX	0,"lidt",AssemblyX	0,"lgs",AssemblyX	0,"lldt",AssemblyX	0,"lmsw",AssemblyX	0,"lock",AssemblyX	0,"lods",AssemblyX	0,"loop",AssemblyX	0,"loope",AssemblyX	0,"loopne",AssemblyX	0,"loopnz",AssemblyX	0,"loopz",AssemblyX	0,"mov",AssemblyX	0,"movs",AssemblyX	0,"movsx",AssemblyX	0,"movzx",AssemblyX	0,"mul",AssemblyX	0,"neg",AssemblyX	0,"nop",AssemblyX	0,"not",AssemblyX	0,"or",AssemblyX	0,"out",AssemblyX	0,"outs",AssemblyX	0,"pop",AssemblyX	0,"popa",AssemblyX	0,"popad",AssemblyX	0,"popf",AssemblyX	0,"popfd",AssemblyX	0,"push",AssemblyX	0,"pusha",AssemblyX	0,"pushad",AssemblyX	0,"pushf",AssemblyX	0,"pushfd",AssemblyX	0,"rcl",AssemblyX	0,"rcr",AssemblyX	0,"rep",AssemblyX	0,"repe",AssemblyX	0,"repne",AssemblyX	0,"repnz",AssemblyX	0,"repz",AssemblyX	0,"ret",AssemblyX	0,"retf",AssemblyX	0,"rol",AssemblyX	0,"ror",AssemblyX	0,"sahf",AssemblyX	0,"sal",AssemblyX	0,"shl",AssemblyX	0,"sar",AssemblyX	0,"sbb",AssemblyX	0,"scas",AssemblyX	0,"setae",AssemblyX	0,"setnb",AssemblyX	0,"setnae",AssemblyX	0,"setbe",AssemblyX	0,"setna",AssemblyX	0,"sete",AssemblyX	0,"setz",AssemblyX	0,"setne",AssemblyX	0,"setnz",AssemblyX	0,"setl",AssemblyX	0,"setnge",AssemblyX	0,"setge",AssemblyX	0,"setnl",AssemblyX	0,"setle",AssemblyX	0,"setng",AssemblyX	0,"setg",AssemblyX	0,"setnle",AssemblyX	0,"sets",AssemblyX	0,"setns",AssemblyX	0,"setc",AssemblyX	0,"setnc",AssemblyX	0,"seto",AssemblyX	0,"setno",AssemblyX	0,"setp",AssemblyX	0,"setpe",AssemblyX	0,"setnp",AssemblyX	0,"setpo",AssemblyX	0,"sgdt",AssemblyX	0,"sidt",AssemblyX	0,"shl",AssemblyX	0,"shr",AssemblyX	0,"shld",AssemblyX	0,"shrd",AssemblyX	0,"shld",AssemblyX	0,"smsw",AssemblyX	0,"stc",AssemblyX	0,"std",AssemblyX	0,"sti",AssemblyX	0,"stos",AssemblyX	0,"str",AssemblyX	0,"sub",AssemblyX	0,"test",AssemblyX	0,"verr",AssemblyX	0,"verw",AssemblyX	0,"wait",AssemblyX	0,"fwait",AssemblyX	0,"wbinvd",AssemblyX	0,"xchg",AssemblyX	0,"xlat",AssemblyX	0,"xlatb",AssemblyX	0,"xor",AssemblyXEND TABLETABLE ObjTable AS ObjData	0,STDCTL,"form","Havis","0",FormPropTable,FormStyleTable,FormEventTable	0,STDCTL,"button","BUTTON","0",ButtonPropTable,ButtonStyleTable,ButtonEventTable	0,STDCTL,"staticicon","STATIC","0",StaticIconPropTable,StaticIconStyleTable,StaticIconEventTable	0,STDCTL,"combobox","COMBOBOX","0",ComboBoxPropTable,ComboBoxStyleTable,ComboBoxEventTable	0,STDCTL,"textbox","EDIT","WS_EX_CLIENTEDGE",TextBoxPropTable,TextBoxStyleTable,TextBoxEventTable	0,STDCTL,"frame","BUTTON","0",FramePropTable,FrameStyleTable,FrameEventTable	0,STDCTL,"listbox","LISTBOX","0",ListBoxPropTable,ListBoxStyleTable,ListBoxEventTable	0,COMCTL,"slider","msctls_trackbar32","0",SliderPropTable,SliderStyleTable,SliderEventTable	0,COMCTL,"spinner","msctls_updown32","0",SpinnerPropTable,SpinnerStyleTable,SpinnerEventTable	0,COMCTL,"progressbar","msctls_progress32","0",ProgressBarPropTable,ProgressBarStyleTable,ProgressBarEventTable	0,COMCTL,"calendar","SysMonthCal32","0",CalendarPropTable,CalendarStyleTable,CalendarEventTable	0,COMCTL,"header","SysHeader32","0",HeaderPropTable,HeaderStyleTable,HeaderEventTable	0,COMCTL,"treeview","SysTreeView32","0",TreeViewPropTable,TreeViewStyleTable,TreeViewEventTable	0,COMCTL,"tabfolder","SysTabControl32","0",TabFolderPropTable,TabFolderStyleTable,TabFolderEventTable	0,COMCTL,"animate","SysAnimate32","0",AnimatePropTable,AnimateStyleTable,AnimateEventTable	0,COMCTL,"toolbar","ToolbarWindow32","0",ToolBarPropTable,ToolBarStyleTable,ToolBarEventTable	0,COMCTL,"statusbar","msctls_statusbar32","0",StatusBarPropTable,StatusBarStyleTable,StatusBarEventTable	0,STDCTL,"checkbox","BUTTON","0",CheckBoxPropTable,CheckBoxStyleTable,CheckBoxEventTable	0,STDCTL,"radiobutton","BUTTON","0",RadioButtonPropTable,RadioButtonStyleTable,CheckBoxEventTable	0,TIMCTL,"timer","TIMER","0",TimerPropTable,TimerStyleTable,TimerEventTable	0,COMCTL,"richedit","RICHEDIT20A","WS_EX_CLIENTEDGE",RichEditPropTable,RichEditStyleTable,RichEditEventTable	0,COMCTL,"raedit","RAEdit","WS_EX_CLIENTEDGE",RAEditPropTable,RAEditStyleTable,RAEditEventTable	0,COMCTL,"ragrid","RAGrid","WS_EX_CLIENTEDGE",RAGridPropTable,RAGridStyleTable,RAGridEventTable	0,STDCTL,"toolwindow","Havis","0",ToolWindowPropTable,ToolWindowStyleTable,ToolWindowEventTable	0,COMCTL,"listview","SysListView32","0",ListViewPropTable,ListViewStyleTable,ListViewEventTable	0,STDCTL,"statictext","STATIC","0",StaticTextPropTable,StaticTextStyleTable,StaticTextEventTable	0,STDCTL,"iconbutton","BUTTON","0",IconButtonPropTable,IconButtonStyleTable,IconButtonEventTable	0,STDCTL,"rectangle","STATIC","0",RectanglePropTable,RectangleStyleTable,RectangleEventTable	0,STDCTL,"obcomm","OBCOMM","0",OBCommPropTable,OBCommStyleTable,OBCommEventTable	0,COMCTL,"drawprogress","DRAWPROGRESS","0",DrawProgressPropTable,DrawProgressStyleTable,DrawProgressEventTable	0,COMCTL,"scrollbar","SCROLLBAR","0",ScrollBarPropTable,ScrollBarStyleTable,ScrollBarEventTable	0,COMCTL,"datetimepick","SysDateTimePick32","0",DateTimePickPropTable,DateTimePickStyleTable,DateTimePickEventTable	0,STDCTL,"image","STATIC","0",ImagePropTable,ImageStyleTable,ImageEventTable	0,STDCTL,"sprsht","SPREAD_SHEET","0",SprShtPropTable,SprShtStyleTable,SprShtEventTable	0,STDCTL,"buttonex","ButtonEx","0",ButtonExPropTable,ButtonExStyleTable,ButtonExEventTable	0,STDCTL,"family","FAMILY","0",FamilyPropTable,FamilyStyleTable,FamilyEventTable	0,STDCTL,"webbrowser","WEB_BROWSER","0",WebBrowserPropTable,WebBrowserStyleTable,WebBrowserEventTable	0,STDCTL,"obzip","OBZIP","0",OBZipPropTable,OBZipStyleTable,OBZipEventTableEND	TABLEErrorTbl: DATA "Undefined symbol"; ErrUDSymDATA "Invalid symbol name"; ErrIVSNamDATA "Type mismatch or wrong type"; ErrTypMisDATA "Invalid Expression"; ErrIVExpDATA "Syntax Error"; ErrSyntaxDATA "Symbol already defined"; ErrDupSymDATA "Symbol table full"; ErrSymFulDATA "Undefined Function"; ErrUDFcnDATA "Invalid data type"; ErrIVTypeDATA "Invalid data type modifier"; ErrIVModDATA "Macro argument error"; ErrMacArgDATA "Invalid directive"; ErrIVDirDATA "Macro already defined"; ErrDupMacDATA "Undefined Error"; ErrEndStrDATA "Nested macro"; ErrMacNstDATA "Macro buffer full"; ErrMacBufDATA "Invalid macro"; ErrIVMacDATA "END MACRO without MACRO";  ErrEndmDATA "Unbalanced control structure"; ErrUBConDATA "Nested too deep"; ErrNDeepDATA "Illegal Declaration inside Fcn or Sub"; ErrDecFcnDATA "Invalid parameter"; ErrIVParmDATA "Parameter Statement out of Place"; ErrErrParmDATA "Expression too complex"; ErrCpxExpDATA "Invalid function";  ErrIVFuncDATA "No more temps available"; ErrTmpUseDATA "Unbalanced parens"; ErrParenDATA "Function error"; ErrFcnDATA "Invalid target"; ErrIVTargetDATA "Fcn/Sub/Proc/Event/Task nested"; ErrFSNestDATA "Undefined Error"; ErrTblArrDATA "END FCN statement not in fcn"; ErrEndFcnDATA "Array subscript error"; ErrArrSubDATA "END PROC statement not in proc"; ErrEndProcDATA "END TABLE not in TABLE"; ErrEndTblDATA "Undefined Error"; ErrTblArgsDATA "Wrong number of args in proc or fcn"; ErrFcnArgsDATA "TYPE, DIM, or TABLE statement inside proc or fcn"; ErrTypeFcnDATA "Duplicate event"; ErrDupEventDATA "Invalid property, event, or style"; ErrIVPropDATA "END EVENT statement not in event"; ErrEndEventDATA "Operand value is out of range for data type specified"; ErrOpRangeDATA "Text arrays not allowed"; ErrTextArrayDATA "Text already defined"; ErrTextDefinedDATA "Text not defined"; ErrTextNotDefinedDATA "END TASK statement not in task"; ErrEndTaskDATA "END SUB statement not in sub"; ErrEndSubDATA "EXIT EVENT statement not in event"; ErrExitEventDATA "EXIT PROC statement not in proc"; ErrExitProcDATA "EXIT TASK statement not in task"; ErrExitTaskDATA "EXIT SUB statement not in sub"; ErrExitSubDATA "EXIT SEG statement not in seg"; ErrExitSegDATA "END SEG statement not in seg"; ErrEndSegDATA "SEG inside seg"; ErrSegInSegDATA "Illegal operation for device"; ErrDeviceRunStringTbl: DATA "_IOBuffer",_BufSizeDATA "_PrintBuf",_BufSizeDATA "_NullStr",1DATA "_CRLF",2DATA "_Prompt",1DATA "_ConvBuf",32DATA "_ConvBuf1",32DATA "ProgramName",28DATA "_SwitchStr",_BufSizeDATA "%",0PreDefTbl: DATA "{",OPER,0,0,0,0DATA "}",OPER,0,0,0,0DATA "[",OPER,0,0,0,0DATA "]",OPER,0,0,0,0DATA "(",OPER,0,0,0,0DATA ")",OPER,0,0,0,0DATA "=",OPER,0,0,0,0DATA "<",OPER,0,0,0,0DATA ">",OPER,0,0,0,0DATA "<=",OPER,0,0,0,0DATA ">=",OPER,0,0,0,0DATA "<>",OPER,0,0,0,0DATA ".",OPER,0,0,0,0DATA ",",OPER,0,0,0,0DATA "+",OPER,0,0,0,0DATA "-",OPER,0,0,0,0DATA "*",OPER,0,0,0,0DATA "/",OPER,0,0,0,0DATA "~",OPER,4,0,0,0DATA "_NullStr",STRINGVAR,VectorBit,0,0,0DATA "0x0",LONGVAR,ConstBit,0,0,4DATA "<",OPER,0,0,0,0DATA ">",OPER,0,0,0,0DATA "(",OPER,0,0,0,0DATA ")",OPER,0,0,0,0DATA "*",OPER,0,0,0,0DATA "",OPER,0,0,0,0DATA "true",BOOLVAR,4,1,0,1DATA "false",BOOLVAR,4,0,0,1DATA "eof",FCN,0,1,0,0DATA "len",FCN,0,2,0,0DATA "str$",FCN,0,3,0,0DATA "val",FCN,0,4,0,0DATA "land",FCN,0,5,0,0DATA "mid$",FCN,0,6,0,0DATA "lor",FCN,0,7,0,0DATA "left$",FCN,0,8,0,0DATA "mod",FCN,0,9,0,0DATA "chr$",FCN,0,10,0,0DATA "right$",FCN,0,11,0,0DATA "asc",FCN,0,12,0,0DATA "not",FCN,0,13,0,0DATA "bufadr",FCN,0,14,0,0DATA "bufsiz",FCN,0,15,0,0DATA "tab",FCN,0,16,0,0DATA "timediff",FCN,0,17,0,0DATA "addr",FCN,0,18,0,0DATA "lxor",FCN,0,19,0,0DATA "lnot",FCN,0,20,0,0DATA "index",FCN,0,21,0,0DATA "size",FCN,0,22,0,0DATA "ival",FCN,0,23,0,0DATA "fval",FCN,0,24,0,0DATA "trim$",FCN,0,25,0,0DATA "lof",FCN,0,26,0,0DATA "pof",FCN,0,27,0,0DATA "sqr",FCN,0,28,0,0DATA "int",FCN,0,29,0,0DATA "abs",FCN,0,30,0,0DATA "sin",FCN,0,31,0,0DATA "cos",FCN,0,32,0,0DATA "tan",FCN,0,33,0,0DATA "asn",FCN,0,34,0,0DATA "acs",FCN,0,35,0,0DATA "atn",FCN,0,36,0,0DATA "log",FCN,0,37,0,0DATA "log10",FCN,0,38,0,0DATA "pad$",FCN,0,39,0,0DATA "!Vacant",FCN,0,40,0,0DATA "!Vacant",FCN,0,41,0,0DATA "!Vacant",FCN,0,42,0,0DATA "!Vacant",FCN,0,43,0,0DATA "!Vacant",FCN,0,44,0,0DATA "!Vacant",FCN,0,45,0,0DATA "!Vacant",FCN,0,46,0,0DATA "!Vacant",FCN,0,47,0,0DATA "chkword",FCN,0,48,0,0DATA "hex$",FCN,0,49,0,0DATA "bittst",FCN,0,50,0,0DATA "shl",FCN,0,51,0,0DATA "shr",FCN,0,52,0,0DATA "rol",FCN,0,53,0,0DATA "ror",FCN,0,54,0,0DATA "bitchg",FCN,0,55,0,0DATA "bitclr",FCN,0,56,0,0DATA "bitset",FCN,0,57,0,0DATA "substr",FCN,0,56,0,0DATA "zstr$",FCN,0,59,0,0DATA "zhex$",FCN,0,60,0,0DATA "using",FCN,0,61,0,0DATA "err",LONGVAR,0,0,0,4DATA "_BufSize",0,0,0,0,0DATA "POS",LONGVAR,0,0,0,4DATA "_DummyArg",LONGVAR,0,0,0,4DATA "OBMain",100,0,0,0,0DATA "_IOBuffer",STRINGVAR,VectorBit,_BufSize,_BufSize,_BufSizeDATA "_PrintBuf",STRINGVAR,VectorBit,_BufSize,_BufSize,_BufSizeDATA "NMHDR",LONGVAR,0,0,0,4DATA "_Digits",WORDVAR,0,0,0,2DATA "_Decimals",WORDVAR,0,0,0,2DATA "STATUS",LONGVAR,0,0,0,4DATA "_ArgSafe0",LONGVAR,0,0,0,4DATA "_ArgSafe1",LONGVAR,0,0,0,4DATA "_IOPthNum",LONGVAR,0,0,0,4DATA "wparamHigh",WORDVAR,0,0,0,2DATA "wparamLow",WORDVAR,0,0,0,2DATA "_IOBufPtr",LONGVAR,0,0,0,4DATA "MenuID",LONGVAR,0,0,0,4DATA "Menu",LONGVAR,0,0,0,4DATA "_DataPtr",LONGVAR,0,0,0,4DATA "ProgramName",STRINGVAR,VectorBit,28,28,28DATA "pad",FCN,0,39,0,0DATA "_ConvBuf",STRINGVAR,VectorBit,32,32,32DATA "FLAGS",LONGVAR,0,0,0,4DATA "_ConvBuf1",STRINGVAR,VectorBit,32,32,32DATA "PaintStruct",LONGVAR,0,0,0,4DATA "_Tmp1",LONGVAR,TempBit,0,0,4DATA "_Tmp2",LONGVAR,TempBit,0,0,4DATA "_Tmp3",LONGVAR,TempBit,0,0,4DATA "_Tmp4",LONGVAR,TempBit,0,0,4DATA "_Tmp5",LONGVAR,TempBit,0,0,4DATA "_Tmp6",LONGVAR,TempBit,0,0,4DATA "_Tmp7",LONGVAR,TempBit,0,0,4DATA "_Tmp8",LONGVAR,TempBit,0,0,4DATA "_Tmp9",LONGVAR,TempBit,0,0,4DATA "_Tmp10",LONGVAR,TempBit,0,0,4DATA "_Tmp11",LONGVAR,TempBit,0,0,4DATA "_Tmp12",LONGVAR,TempBit,0,0,4DATA "_Tmp13",LONGVAR,TempBit,0,0,4DATA "_Tmp14",LONGVAR,TempBit,0,0,4DATA "_Tmp15",LONGVAR,TempBit,0,0,4DATA "_TmpVec1",VOIDX,TmpVec,0,0,12DATA "_TmpVec2",VOIDX,TmpVec,0,0,12DATA "_TmpVec3",VOIDX,TmpVec,0,0,12DATA "_TmpVec4",VOIDX,TmpVec,0,0,12DATA "_TmpVec5",VOIDX,TmpVec,0,0,12DATA "_TmpVec6",VOIDX,TmpVec,0,0,12DATA "_TmpVec7",VOIDX,TmpVec,0,0,12DATA "_TmpVec8",VOIDX,TmpVec,0,0,12DATA "_TmpVec9",VOIDX,TmpVec,0,0,12DATA "_TmpVec10",VOIDX,TmpVec,0,0,12DATA "_TmpVec11",VOIDX,TmpVec,0,0,12DATA "_TmpVec12",VOIDX,TmpVec,0,0,12DATA "_TmpVec13",VOIDX,TmpVec,0,0,12DATA "_TmpVec14",VOIDX,TmpVec,0,0,12DATA "_TmpVec15",VOIDX,TmpVec,0,0,12DATA "&",9,0,0,0,0DATA "|",9,0,0,0,0DATA "0BUGBUG",FLOATVAR,ConstBit,0,0,8DATA "NextArg",6,TmpVec,0,0,0DATA "XferCount",4,0,0,0,0DATA "_FTmp1",FLOATVAR,0,0,0,8DATA "_FTmp2",FLOATVAR,0,0,0,8DATA "_FTmp3",FLOATVAR,0,0,0,8DATA "_FTmp4",FLOATVAR,0,0,0,8DATA "_FTmp5",FLOATVAR,0,0,0,8DATA "_FTmp6",FLOATVAR,0,0,0,8DATA "_FTmp7",FLOATVAR,0,0,0,8DATA "_FTmp8",FLOATVAR,0,0,0,8DATA "_FTmp9",FLOATVAR,0,0,0,8DATA "_FTmp10",FLOATVAR,0,0,0,8DATA "_FTmp11",FLOATVAR,0,0,0,8DATA "_FTmp12",FLOATVAR,0,0,0,8DATA "_FTmp13",FLOATVAR,0,0,0,8DATA "_FTmp14",FLOATVAR,0,0,0,8DATA "_FTmp15",FLOATVAR,0,0,0,8DATA "TRUE",BOOLVAR,ConstBit,1,0,1DATA "True",BOOLVAR,ConstBit,1,0,1DATA "FALSE",BOOLVAR,ConstBit,0,0,1DATA "False",BOOLVAR,ConstBit,0,0,1DATA "sal",FCN,0,62,0,0DATA "sar",FCN,0,63,0,0DATA "rcl",FCN,0,64,0,0DATA "rcr",FCN,0,65,0,0DATA "tablesize",FCN,0,66,0,0DATA "filtyp",FCN,0,67,0,0DATA "curdir",FCN,0,68,0,0DATA "bin$",FCN,0,69,0,0DATA "oct$",FCN,0,70,0,0DATA "!Vacant",FCN,0,71,0,0DATA "rnd",FCN,0,72,0,0DATA "gettickcount",FCN,0,73,0,0DATA "!Vacant",FCN,0,74,0,0DATA "!Vacant",FCN,0,75,0,0DATA "!Vacant",FCN,0,76,0,0DATA "!Vacant",FCN,0,77,0,0DATA "lcase$",FCN,0,78,0,0DATA "ucase$",FCN,0,79,0,0DATA "tail$",FCN,0,80,0,0DATA "!Vacant",FCN,0,81,0,0DATA "!Vacant",FCN,0,82,0,0DATA "ArrayIndex",LONGVAR,0,0,0,4DATA "_BoolRet",BOOLVAR,0,0,0,1DATA "_LongRet",LONGVAR,0,0,0,4DATA "_StringRet",STRINGVAR,VectorBit,0,0,0DATA "_FloatRet",FLOATVAR,0,0,0,8DATA "str",FCN,0,3,0,0DATA "mid",FCN,0,6,0,0DATA "left",FCN,0,8,0,0DATA "chr",FCN,0,10,0,0DATA "right",FCN,0,11,0,0DATA "trim",FCN,0,25,0,0DATA "hex",FCN,0,49,0,0DATA "zstr",FCN,0,59,0,0DATA "zhex",FCN,0,60,0,0DATA "bin",FCN,0,69,0,0DATA "oct",FCN,0,70,0,0DATA "lcase",FCN,0,78,0,0DATA "ucase",FCN,0,79,0,0DATA "tail",FCN,0,80,0,0DATA "LOGFONT",TYPE,0,14,0,60DATA "lfHeight",LONGVAR,0,0,0,4DATA "lfWidth",LONGVAR,0,0,4,4DATA "lfEscapement",LONGVAR,0,0,8,4DATA "lfOrientation",LONGVAR,0,0,12,4DATA "lfWeight",LONGVAR,0,0,16,4DATA "lfItalic",BYTEVAR,0,0,20,1DATA "lfUnderline",BYTEVAR,0,21,0,1DATA "lfStrikeOut",BYTEVAR,0,22,0,1DATA "lfCharSet",BYTEVAR,0,0,23,1DATA "lfOutPrecision",BYTEVAR,0,0,24,1DATA "lfClipPrecision",BYTEVAR,0,0,25,1DATA "lfQuality",BYTEVAR,0,0,26,1DATA "lfPitchAndFamily",BYTEVAR,0,0,27,1DATA "lfFaceName",STRINGVAR,0,32,28,32DATA "GridRow",LONGVAR,0,0,0,4DATA "GridCol",LONGVAR,0,0,0,4DATA "EditcpMin",LONGVAR,0,0,0,4DATA "EditcpMax",LONGVAR,0,0,0,4DATA "EditSelType",WORDVAR,0,0,0,4DATA "EditLine",LONGVAR,0,0,0,4DATA "EditcpLine",LONGVAR,0,0,0,4DATA "EditlpLine",LONGVAR,0,0,0,4DATA "EditnLines",LONGVAR,0,0,0,4DATA "EditnHidden",LONGVAR,0,0,0,4DATA "EditfChanged",LONGVAR,0,0,0,4DATA "EditnPage",LONGVAR,0,0,0,4DATA "EditnWordGroup",LONGVAR,0,0,0,4DATA "ft_SearchMin",LONGVAR,0,0,0,4DATA "ft_SearchMax",LONGVAR,0,0,0,4DATA "ft_SearchTextPtr",LONGVAR,0,0,0,4DATA "fr_lpstrFindWhat",LONGVAR,0,0,0,4DATA "ft_FoundMin",LONGVAR,0,0,0,4DATA "ft_FoundMax",LONGVAR,0,0,0,4DATA "cr_cpMin",LONGVAR,0,0,0,4DATA "cr_cpMax",LONGVAR,0,0,0,4DATA "SC_CLOSE",LONGVAR,ConstBit,61536,0,4DATA "SC_MINIMIZE",LONGVAR,ConstBit,61472,0,4DATA "SC_MAXIMIZE",LONGVAR,ConstBit,61488,0,4DATA "SC_RESTORE",LONGVAR,ConstBit,61728,0,4DATA "wmsg",LONGVAR,0,0,0,4DATA "wparam",LONGVAR,0,0,0,4DATA "lparam",LONGVAR,0,0,0,4DATA "ncode",LONGVAR,0,0,0,4DATA "WM_MOUSEMOVE",LONGVAR,ConstBit,512,0,4DATA "WM_LBUTTONDOWN",LONGVAR,ConstBit,513,0,4DATA "WM_LBUTTONUP",LONGVAR,ConstBit,514,0,4DATA "WM_RBUTTONDOWN",LONGVAR,ConstBit,516,0,4DATA "WM_RBUTTONUP",LONGVAR,ConstBit,517,0,4DATA "MK_LBUTTON",LONGVAR,ConstBit,1,0,4DATA "MK_RBUTTON",LONGVAR,ConstBit,2,0,4DATA "MK_SHIFT",LONGVAR,ConstBit,4,0,4DATA "MK_CONTROL",LONGVAR,ConstBit,8,0,4DATA "MK_MBUTTON",LONGVAR,ConstBit,16,0,4DATA "CursorPosX",LONGVAR,0,0,0,4DATA "CursorPosY",LONGVAR,0,0,0,4DATA "RectLeft",LONGVAR,0,0,0,4DATA "RectTop",LONGVAR,0,0,0,4DATA "RectRight",LONGVAR,0,0,0,4DATA "RectBottom",LONGVAR,0,0,0,4DATA "IDOK",LONGVAR,ConstBit,1,0,4DATA "IDCANCEL",LONGVAR,ConstBit,2,0,4DATA "IDABORT",LONGVAR,ConstBit,3,0,4DATA "IDRETRY",LONGVAR,ConstBit,4,0,4DATA "IDIGNORE",LONGVAR,ConstBit,5,0,4DATA "IDYES",LONGVAR,ConstBit,6,0,4DATA "IDNO",LONGVAR,ConstBit,7,0,4DATA "IDCLOSE",LONGVAR,ConstBit,8,0,4DATA "IDHELP",LONGVAR,ConstBit,9,0,4DATA "ZTOP",LONGVAR,ConstBit,0,0,4DATA "ZBOTTOM",LONGVAR,ConstBit,1,0,4DATA "ZTOPMOST",LONGVAR,ConstBit,4294967295,0,4DATA "ZNOTOPMOST",LONGVAR,ConstBit,4294967294,0,4DATA "NOPARITY",LONGVAR,ConstBit,0,0,4DATA "ODDPARITY",LONGVAR,ConstBit,1,0,4DATA "EVENPARITY",LONGVAR,ConstBit,2,0,4DATA "MARKPARITY",LONGVAR,ConstBit,3,0,4DATA "SPACEPARITY",LONGVAR,ConstBit,4,0,4DATA "ONESTOPBIT",LONGVAR,ConstBit,0,0,4DATA "ONE5STOPBITS",LONGVAR,ConstBit,1,0,4DATA "TWOSTOPBITS",LONGVAR,ConstBit,2,0,4DATA "CommError",LONGVAR,0,0,0,4DATA "AltKey",BOOLVAR,0,0,0,1DATA "DATETIME",TYPE,0,8,0,16DATA "wYear",WORDVAR,0,0,0,2DATA "wMonth",WORDVAR,0,0,2,2DATA "wDayOfWeek",WORDVAR,0,0,4,2DATA "wDay",WORDVAR,0,0,6,2DATA "wHour",WORDVAR,0,0,8,2DATA "wMinute",WORDVAR,0,0,10,2DATA "wSecond",WORDVAR,0,0,12,2DATA "wMilliseconds",WORDVAR,0,0,14,2DATA "erl",LONGVAR,0,0,0,4DATA "ScrollValue",WORDVAR,0,0,0,2DATA "ScrollCode",WORDVAR,0,0,0,2DATA "%"; *************************************** Compiler Code Starts Here ******************************; StartBEGIN SUB Compile	IF Changed=TRUE THEN		WARNINGBOX "File Not Saved","Save?",MB_YESNO		IF STATUS=IDYES THEN			IF FileName="Untitled" THEN				CALL SUB SaveAs			ELSE				CALL SUB SaveEdit				IF LCASE(Extension)=".obp" THEN				CALL SUB WriteTools				END IF				;// ENABLEMENUITEMMainMenu,mnuSave,FALSE				Button(3).ENABLED=FALSE			END IF		ELSE			SETDEFAULTCURSOR			EXIT SUB		END IF	END IF	SETSTOCKCURSOR Wait	Edit.EMPTYUNDOBUFFER	Changed=FALSE	;// ENABLEMENUITEMMainMenu,mnuSave,FALSE	Button(3).ENABLED=FALSE	StatusBar.SETTEXT 5,"Not Changed"	StartTime=GETTICKCOUNT()	SELECT CASE LCASE(Extension)		CASE ".obc"; Console pgm			GUIFlag=FALSE			DLLFlag=FALSE			ProjectFlag=FALSE		CASE ".obw"; Windows pgm			GUIFlag=TRUE			DLLFlag=FALSE			ProjectFlag=FALSE		CASE ".obp"; Windows pgm project			GUIFlag=TRUE			DLLFlag=FALSE			ProjectFlag=TRUE		CASE ".obd"; DLL (GUI)			GUIFlag=TRUE			DLLFlag=TRUE			ProjectFlag=FALSE		CASE ".obl"; Library (DLL console)			GUIFlag=FALSE			DLLFlag=TRUE			ProjectFlag=FALSE		CASE ".obo"; GUI Object DLL (custom control)			GUIFlag=TRUE			DLLFlag=TRUE			ProjectFlag=FALSE		CASE ELSE			TempStr="No Recognized Extension"			SETDEFAULTCURSOR			WARNINGBOX "Error",TempStr,MB_OK			RETURN	END SELECT	ON ERROR GOTO NoInpFile	InpFilPtr=1	OPEN FileName FOR INPUT AS InpFile(InpFilPtr)	ON ERROR	OPEN "_DeclareFile" FOR SCRATCH AS DeclareFile	OPEN "_PreCodeFile" FOR SCRATCH AS PreCodeFile	OPEN "_CodeFile" FOR SCRATCH AS CodeFile	OPEN "_DataFile" FOR SCRATCH AS DataFile	OPEN "_DimFile" FOR SCRATCH AS DimFile	OPEN "_DescFile" FOR SCRATCH AS DescFile	OPEN "_InitFile" FOR SCRATCH AS InitFile	OPEN "_FunctionFile" FOR SCRATCH AS FunctionFile	OPEN "_LibFile" FOR SCRATCH AS LibFile	OPEN "_ProcFile" FOR SCRATCH AS ProcFile	OPEN "_ExportFile" FOR SCRATCH AS ExportFile	OPEN "_ResourceFile" FOR SCRATCH AS ResourceFile	UseReadFile=FALSE	UseWriteFile=FALSE	UseWriteOBComm=FALSE	UseSetStrConst=FALSE	UseTrmStr=FALSE	UseData=FALSE	UseMovStr=FALSE	UseCmpStr=FALSE	UseStrLen=FALSE	UseSubStr=FALSE	UseMidStr=FALSE	UseRightStr=FALSE	UseClrConv=FALSE	UseAtoD=FALSE	UseAtoL=FALSE	UseNumScan=FALSE	UseZLtoH=FALSE	UseZLtoA=FALSE	UseLtoA=FALSE	UseDtoA=FALSE	UseLtoH=FALSE	UsePrintStr=FALSE	UsePrintTab=FALSE	UseInpData=FALSE	UseBtoA=FALSE	UseLCase=FALSE	UseUCase=FALSE	UseTailStr=FALSE	UseSetRightBottom=FALSE	UseShowHideFamily=FALSE	UseEnableDisableFamily=FALSE	UsePad=FALSE	UseTrim=FALSE	RichEdLibUsed=FALSE	RAEditLibUsed=FALSE	RAGridLibUsed=FALSE	CsmdllLibUsed=FALSE	DrawProgressLibUsed=FALSE	ImageLibUsed=FALSE	SprShtLibUsed=FALSE	ButtonExLibUsed=FALSE	WebBrowserLibUsed=FALSE	ZipLibUsed=FALSE	GFNdx=1	DataLabel=FALSE	ExclamationOK=FALSE	GenFlag(GFNdx)=$ff	DeferFlag=FALSE	EnumVal=0	EnumStep=1	FindReplaceFlag=0	XBufSize=_BufSize	SelectFlag=FALSE	CaseFlag=FALSE	CaseElseFlag=FALSE	SegFlag=FALSE	SubFlag=FALSE	TaskFlag=FALSE	ProcFlag=FALSE	FcnFlag=FALSE	EventFlag=FALSE	ProcFcnFlag=FALSE	CodeBlockFlag=FALSE	DataFlag=FALSE	LastSym=UserSym-1	StartFlag=FALSE	LopCtrNum=-1	ArrayBase=1;  default to base 1	SubClassFlag=FALSE	PrintPathFlag=0	ResourceFlag=FALSE	ExportFlag=FALSE	DtaRegNum=0	TmpMax=0	TmpVecMax=0	FTmpMax=0	ChrTmpMax=0	StrTmpMax=0	ErrCnt=0	LastStmt=""	ConStkPtr=0	LopVarNdx=0	StringNum=0	TimerNum=0	FamilyNum=0	SegNum=0	LabelNum=0	OELabelNum=0	SCLabelNum=0	GUILabelNum=0	BitmapNum=0	TableNum=0	ObjectID=100	MenuIDNum=999	ProcNum=0	InterceptProcNum=0	LoopNum=0	MacExFlag=0	RAEditFlag=FALSE	OBZipFlag=FALSE	BasicLineCtr=0	AsmLineCtr=0	ErrNo=0	PoolCtr=0	VarBytRem=0	ErrOpCode="jmp"	CALL SUB MainLoopInit	FOR LopVarNdx=1 to 100		LoopVars(LopVarNdx)="%"	NEXT LopVarNdx	FOR MacDefNdx=1 TO MacBufSiz		MacBuf(MacDefNdx)=0	NEXT MacDefNdx	MacDefNdx=1	RESTORE PreDefTbl	SymNdx=0	BEGIN LOOP		INCR SymNdx		READ TempStr		EXIT IF TempStr="%"		SymTemp.SymName=TempStr		READ SymTemp.DataType		READ SymTemp.DataMod		READ SymTemp.Detail		READ SymTemp.DataAddr		READ SymTemp.DataSize		SymTable(SymNdx)=SymTemp		SymTableKey(SymNdx)=CHKWORD(TempStr)	END LOOP		LastKey=TABLESIZE(KeyTable)	FOR KeyNdx=1 TO LastKey		KeyTable(KeyNdx).KeyCheckWord=CHKWORD(KeyTable(KeyNdx).KeyName)	NEXT KeyNdx	LastImportLib=TABLESIZE(ImportLibTable)	FOR I=1 TO LastImportLib		ImportLibTable(I).ImportLibUse=FALSE		ImportLibTable(I).ImportLibLastUsed=FALSE	NEXT I	LastImportFcn=TABLESIZE(ImportFcnTable)	FOR I=1 TO LastImportFcn		ImportFcnTable(I).ImportFcnUse=FALSE		ImportFcnTable(I).ImportFcnLastUsed=FALSE	NEXT I	NewLine=$0d	OutBuf=";Compiler Declaration Section";;; Temp fix for init problem	;CALL SUB OutDeclare	OutBuf=";Compiler Declaration Section"	CALL SUB OutDeclare	OutBuf=""	CALL SUB OutDeclare	OutBuf="format PE "	IF GUIFlag=FALSE THEN		OutBuf=OutBuf+"console"	ELSE		OutBuf=OutBuf+"GUI 4.0"	END IF	IF DLLFlag=TRUE THEN		OutBuf=OutBuf+" DLL"	END IF	CALL SUB OutDeclare	OutBuf="section '.data' data readable writeable"	CALL SUB OutInitData	OutBuf=""	CALL SUB OutInitData	OutBuf="align 4"	CALL SUB OutInitData	OutBuf=""	CALL SUB OutInitData	OutBuf="err dd 0"	CALL SUB OutInitData	OutBuf="!ArrayBase dd 1"	CALL SUB OutInitData	OutBuf="_ErrVec dd 0"	CALL SUB OutInitData	OutBuf="STATUS dd 0"	CALL SUB OutInitData	OutBuf="erl dd 0"	CALL SUB OutInitData	OutBuf="POS dd 0"	CALL SUB OutInitData	OutBuf="Ticks dd 0"	CALL SUB OutInitData	OutBuf="XferCount dd 0"	CALL SUB OutInitData	OutBuf="CommError dd 0"	CALL SUB OutInitData	OutBuf="wparamHigh dw 0"	CALL SUB OutInitData	OutBuf="wparamLow dw 0"	CALL SUB OutInitData	OutBuf="ScrollValue dw 0"	CALL SUB OutInitData	OutBuf="ScrollCode dw 0"	CALL SUB OutInitData	OutBuf="_TrueStr db "+CHR(OBQUOTE)+"TRUE"+CHR(OBQUOTE)+",0"	CALL SUB OutInitData	OutBuf="_FalseStr db "+CHR(OBQUOTE)+"FALSE"+CHR(OBQUOTE)+",0"	CALL SUB OutInitData	IF GUIFlag=TRUE THEN		LastObj=TABLESIZE(ObjTable)		FOR ObjNdx=1 TO LastObj			ObjTable(ObjNdx).ObjCheckWord=CHKWORD(ObjTable(ObjNdx).ObjName)			OutBuf="!ControlType"+STR(ObjNdx)+" db '"+ObjTable(ObjNdx).ObjTypeName+"',0"			CALL SUB OutInitData		NEXT ObjNdx	END IF	OutBuf=""	CALL SUB OutDeclare	OutBuf="entry !Start"	CALL SUB OutDeclare	OutBuf=""	CALL SUB OutDeclare	OutBuf="macro align value { rb (value-1) - (rva $ + value-1) mod value }"	CALL SUB OutDeclare	OutBuf=""	CALL SUB OutDeclare	OutBuf="_BufSize="+STR(_BufSize)	CALL SUB OutDeclare	RESTORE RunVars	CALL SUB OutUninitText	RESTORE PreCodeSeg1	CALL SUB OutPreCodeText	ImportFcnTable(ptrGetStdHandle).ImportFcnUse=TRUE	ImportFcnTable(ptrGetCommandLine).ImportFcnUse=TRUE	ImportFcnTable(ptrGetModuleHandle).ImportFcnUse=TRUE	IF GUIFlag=TRUE THEN		RESTORE GUIRunVars		CALL SUB OutUninitText		RESTORE GUIInitVars		CALL SUB OutInitText			OutBuf="!OBMain rd 192""		CALL SUB OutDesc			ObjectCtr=1			GenConst CT,FORM,100		GenConst CT,BUTTON,101		GenConst CT,STATICICON,102		GenConst CT,COMBOBOX,103		GenConst CT,TEXTBOX,104		GenConst CT,FRAME,105		GenConst CT,LISTBOX,106		GenConst CT,SLIDER,107		GenConst CT,SPINNER,108		GenConst CT,PROGRESSBAR,109		GenConst CT,CALENDAR,110		GenConst CT,HEADER,111		GenConst CT,TREEVIEW,112		GenConst CT,TABFOLDER,113		GenConst CT,ANIMATE,114		GenConst CT,TOOLBAR,115		GenConst CT,STATUSBAR,116		GenConst CT,CHECKBOX,117		GenConst CT,RADIOBUTTON,118		GenConst CT,TIMER,119		GenConst CT,RICHEDIT,120		GenConst CT,RAEdit,121		GenConst CT,RAGrid,122		GenConst CT,TOOLWINDOW,123		GenConst CT,LISTVIEW,124		GenConst CT,STATICTEXT,125		GenConst CT,ICONBUTTON,126		GenConst CT,RECTANGLE,127		GenConst CT,OBCOMM,128		GenConst CT,DRAWPROGRESS,129		GenConst CT,SCROLLBAR,130		GenConst CT,DATETIMEPICK,131		GenConst CT,IMAGE,132		GenConst CT,SPRSHT,133		GenConst CT,ButtonEx,134		GenConst CT,FAMILY,135		GenConst CT,WEB_BROWSER,136		GenConst CT,OBZIP,137			GenEquate WinCreated,0		GenEquate WinEnabled,1		GenEquate WinVisible,2		GenEquate WinChangeBackColor,3		GenEquate WinChangeForeColor,4		GenEquate WinArray,5		GenEquate WinSubClassed,6		GenEquate WinLoaded,7		GenEquate WinPlaced,8		GenEquate WinTipExists,9			IF DLLFlag=FALSE THEN				RESTORE PreCodeSeg2			CALL SUB OutPreCodeText			CALL SUB MakeLine			CALL SUB OutFcnCodeData		END IF			ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		ImportFcnTable(ptrRegisterClass).ImportFcnUse=TRUE		ImportFcnTable(ptrLoadCursor).ImportFcnUse=TRUE		ImportFcnTable(ptrLoadIcon).ImportFcnUse=TRUE		ImportFcnTable(ptrLoadLibrary).ImportFcnUse=TRUE		ImportFcnTable(ptrInitCommonControlsEx).ImportFcnUse=TRUE		ImportFcnTable(ptrGetMessage).ImportFcnUse=TRUE		ImportFcnTable(ptrTranslateMessage).ImportFcnUse=TRUE		ImportFcnTable(ptrDispatchMessage).ImportFcnUse=TRUE		ImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUE		ImportFcnTable(ptrSetBkColor).ImportFcnUse=TRUE		ImportFcnTable(ptrSetTextColor).ImportFcnUse=TRUE		ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE		ImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUE		ImportFcnTable(ptrDefWindowProc).ImportFcnUse=TRUE		ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE		ImportFcnTable(ptrGetBkColor).ImportFcnUse=TRUE		ImportFcnTable(ptrGetPixel).ImportFcnUse=TRUE		ImportFcnTable(ptrSetBkMode).ImportFcnUse=TRUE		ImportFcnTable(ptrGetStockObject).ImportFcnUse=TRUE		ImportFcnTable(ptrGetModuleHandle).ImportFcnUse=TRUE		ImportFcnTable(ptrPostQuitMessage).ImportFcnUse=TRUE		ImportFcnTable(ptrSetTimer).ImportFcnUse=TRUE		ImportFcnTable(ptrShellExecute).ImportFcnUse=TRUE		ImportFcnTable(ptrMessageBox).ImportFcnUse=TRUE		ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUE		RESTORE GUIEquates		OutBuf=""		CALL SUB OutDeclare		OutBuf="; GUI Equates"		CALL SUB OutDeclare		OutBuf=""		CALL SUB OutDeclare		BEGIN LOOP			READ OutBuf			EXIT IF OutBuf="ENDTEXT"			CALL SUB OutDeclare			INCR AsmLineCtr		END LOOP	END IF	OutBuf="_ErrExitMsg db 'Error exit',0"	CALL SUB OutInitData	RESTORE RunStringTbl	BEGIN LOOP		READ VarName		EXIT IF VarName="%"		READ ArraySize		TempInt=ArraySize/4		IF Mod(ArraySize,4)<>0 THEN			TempInt=TempInt+1		END IF		OutBuf="align 4"		CALL SUB OutInitData		OutBuf=VarName+" dd "+VarName+"+12"		CALL SUB OutInitData		OutBuf=" dd "+STR(ArraySize)		CALL SUB OutInitData		OutBuf=" dd 0"		CALL SUB OutInitData		OutBuf=" rb "+STR(ArraySize)		CALL SUB OutInitData	END LOOP	OutBuf=""	CALL SUB OutInitCode	OutBuf="; Init Section"	CALL SUB OutInitCode	OutBuf="_Init:"	CALL SUB OutInitCode	IF GUIFlag=TRUE THEN		OutBuf="mov [!CursorFlag],0"		CALL SUB OutInitCode	END IF	OutBuf=""	CALL OutFunction	OutBuf="; Function Code Section"	CALL OutFunction	OutBuf=""	CALL OutFunction	ENTER SEG MainLoopEND SUB CompileBEGIN SEG MainLoop	IF ErrNo<>0 THEN		SETDEFAULTCURSOR		IF ErrNo=ErrMacArg THEN			TempStr="MACRO argument error in line "+STR(BasicLineCtr)			CALL SUB ShowError			RETURN		END IF		IF ErrNo=$ff THEN			CALL SUB ShowError			RETURN		END IF			RESTORE ErrorTbl		FOR Ctr1=1 to ErrNo			READ TempStr		NEXT Ctr1		TempStr=TempStr+" in line "+STR(BasicLineCtr)		CALL SUB ShowError		RETURN	END IF	IF DimFlag=0 THEN		BEGIN LOOP			EXIT IF SymTable(LastSym).DataType<>STRINGVAR OR LAND(SymTable(LastSym).DataMod,ConstBit)<>ConstBit			DECR LastSym		END LOOP	END IF	CALL SUB MainLoopInit	IF MacExFlag=0 THEN		CALL SUB ReadSource		IF TempInt=0 THEN Finish	ELSE		SrcLine=""		SrcNdx=0		MacExLp: AsciiByte=MacBuf(MacExNdx)		INCR MacExNdx		IF AsciiByte=0 THEN;  end of MACRO			MacExFlag=0			EXIT SEG		END IF		IF AsciiByte<>NewLine THEN			IF LAND($80,AsciiByte)=$80 THEN				AsciiByte=LAND($7f,AsciiByte)				IF AsciiByte=0 THEN					SrcLine=SrcLine+STR(SymTable(MacTblPtr).Detail)					GOTO MacExLp				END IF				IF AsciiByte>MaxArgNum THEN					ErrNo=ErrMacArg					EXIT SEG				END IF				MacArgPtr=AsciiByte				SrcLine=SrcLine+MacArgBuf(MacArgPtr)				GOTO MacExLp			END IF			SrcLine=SrcLine+CHR(AsciiByte)			GOTO MacExLp		END IF	END IF	SrcNdx=0	IF GenFlag(GFNdx)=0 THEN		IF LEFT(SrcLine,1)<>"$" THEN MainLoop		INCR SrcNdx		CALL SUB NexToken		IF TokenBuf<>"if" AND TokenBuf<>"else" AND TokenBuf<>"endif" THEN MainLoop		IF TokenBuf="if" THEN IFDx		IF TokenBuf="else" THEN ELSEDx		GOTO ENDIFDx	END IF		IF LEN(SrcLine)=0 THEN MainLoop	TempByte=LEFT(SrcLine,1)	IF TempByte=";" THEN		CALL SUB Remark		CALL SUB OutFcnCodeData		EXIT SEG	END IF	IF TempByte="$" THEN		; Process Directive		CALL SUB Remark		CALL SUB OutFcnCodeData		INCR SrcNdx		CALL SUB NexToken		IF TokenBuf="if" THEN IFDx		IF TokenBuf="else" THEN ELSEDx		IF TokenBuf="endif" THEN ENDIFDx		IF TokenBuf="exok" THEN			ExclamationOK=TRUE			EXIT SEG		END IF		IF TokenBuf="loadlibrary" THEN LoadLibraryX		ErrNo=ErrSyntax		EXIT SEG	END IF 	CALL SUB NexToken	SrcNdx=0	IF NextByte=":" THEN		IF DataFlag=TRUE THEN			DataFlag=FALSE		END IF		CALL SUB ProcLabel		ErrMain		CALL SUB NexToken; Eat the ':'		CALL SUB NexToken		IF TokenBuf="data" THEN			SymTable(SymNdx).DataMod=DataBit			GOTO DataX;  DATA statement processing		END IF		CALL SUB UnDoToken		SymbolSaf=SymbolSaf+":"	END IF	CALL SUB NexToken	IF TokenSaf="STATUS" THEN		EqualMain		CALL SUB NexToken		StatFlag=$ff	END IF	IF LEN(TokenBuf)>0 THEN		LastStmt=TokenBuf	END IF	IF TokenLen=0 THEN		CALL SUB OutLabel		EXIT SEG	END IF	CALL SUB KeyLook	IF KeyNdx=0 THEN		; maybe a macro		SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=TRUE AND SymTable(SymNdx).DataType=MACROVAR THEN			CALL SUB Remark			CALL SUB OutFcnCodeData			MacTblPtr=SymNdx			MacExNdx=SymTable(SymNdx).DataAddr			SymTable(SymNdx).Detail=SymTable(SymNdx).Detail+1; inc macro occurrance			NeedComma=FALSE			MaxArgNum=0			MacExFlag=$ff			CALL SUB OutLabel			IF MID(SrcLine,SrcNdx+1,1)=" " THEN				INCR SrcNdx			END IF			MacExLoop:			CALL SUB MacToken			IF TokenLen=0 THEN				EXIT SEG			END IF			IF NeedComma=FALSE AND TokenSaf="," THEN				INCR MaxArgNum				MacArgBuf(MaxArgNum)=""				GOTO MacExLoop			END IF			IF NeedComma=TRUE AND TokenSaf<>"," THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			IF NeedComma=TRUE AND TokenSaf="," THEN				NeedComma=FALSE				GOTO MacExLoop			END IF			INCR MaxArgNum			MacArgBuf(MaxArgNum)=TokenSaf			NeedComma=TRUE			GOTO MacExLoop		END IF		IF SymFound=TRUE AND SymTable(SymNdx).DataType>99 THEN			KeyNdx=999; Pseudo code for GUI Target			ObjectType=SymTable(SymNdx).DataType			ObjectName=SymTable(SymNdx).SymName			ObjectDetail=SymTable(SymNdx).Detail			ObjectArray=SymTable(SymNdx).ArrayDim1		ELSE			KeyNdx=8; Assume LET		END IF		CALL SUB UnDoToken	END IF	IF KeyNdx<>1 THEN		DataFlag=FALSE	END IF	CALL SUB Remark	SELECT CASE KeyNdx		CASE 1; DATA			CALL SUB OutInitData			GOTO DataX		CASE 6; TYPE			CALL SUB OutUninitData			GOTO TypeX		CASE 7; DIM			GOTO DimX		CASE 10; BEGIN			GOTO BeginX		CASE 999			ErrGUI			CALL SUB NexToken			ObjectName=TokenSaf			StartFlag=TRUE			CALL SUB OutFcnCodeData; put out OmniBasic source as comment			GUITargetSymNdx=SymNdx			GUITargetFlag=$ff			CALL SUB ProcessObject			ErrMain			GOTO GUITarget		CASE ELSE			StartFlag=TRUE			CALL SUB OutFcnCodeData; put out OmniBasic source as comment			OutBuf=""			CALL SUB OutLabel			GOTO [KeyTable(KeyNdx).KeyLabel]	END SELECTEND SEG MainLoopBEGIN SUB ProcLabel	IF ProcFcnFlag=TRUE THEN		TempStr="Label in Function or Proc"		ErrNo=$ff		EXIT SUB	END IF	StartFlag=TRUE	CALL SUB TokenSym	ErrMain	LabelFlag=$ff	TDataType=SymTable(SymNdx).DataType	TDetail=SymTable(SymNdx).Detail	TDataSize=SymTable(SymNdx).DataSize	TempStr=SymbolSaf	SymbolSaf=TempStr	IF SymFound=TRUE THEN; Label Found		IF TDataType<>LABELVAR THEN			ErrNo=ErrDupSym			EXIT SUB		END IF		IF TDetail=LabelUnresolved THEN			SymTable(SymNdx).Detail=LabelResolved		ELSE			ErrNo=ErrDupSym			EXIT SUB		END IF	ELSE		CALL SUB ClrDatTyp		TDataType=LABELVAR		SymTemp.DataType=LABELVAR		CALL SUB ClrSym		SymTemp.DataMod=0		SymTemp.Detail=LabelResolved		CALL SUB SymInsert		ErrRet	END IFEND SUBBEGIN SUB ProcCmd	IF Op1Class<>STRClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf="mov dword edi,"+Op1Name	CALL SUB OutFcnCodeData	OutBuf="call __MovArg"	CALL SUB OutFcnCodeDataEND SUBBEGIN SEG ConstX	SetMask=0	CALL SUB ConstX1END SEG MainLoopConstX1:; Changed into a subroutine because is called by; inline code OR CmdLine, so cannot "jump" to MainLoop as before.UMFlag=0CALL SUB TokenSymErrRetIF SymFound=FALSE THEN	SymTemp.DataType=COMPVAR	CALL SUB ClrSym	CALL SUB SymInsert	ErrRetELSE	IF SymTable(SymNdx).DataType<>COMPVAR AND SymTable(SymNdx).DataType<> MACROVAR THEN		ErrNo=ErrTypMis		RETURN	END IF	IF LAND(SymTable(SymNdx).DataMod,SetMask)<>0 THEN		RETURN	END IFEND IFSymNdxSaf=SymNdxEqualRetCALL SUB NexTokenIF TokenBuf="-" THEN	UMFlag=$ff	CALL SUB NexTokenEND IFSELECT CASE TokenType	CASE TTypInt		CALL SUB ChkInt		ErrRet		GOTO SetOp1	CASE TTypHex		CALL SUB ChkHex		ErrRet		GOTO SetOp1	CASE TTypSym		CALL SUB ChkSym		ErrRet		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO SetOp1	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTSetOp1:IF UMFlag=$ff THEN	TempStr="-"ELSE	TempStr=""END IFTempStr=TempStr+TokenSafIF MID(TempStr,1,2)="--" THEN	TempStr=MID(TempStr,2,LEN(TempStr)-2)END IFCVTemp=VAL(TempStr)CALL SUB NexTokenIF TokenLen=0 THEN SetFinishIF TokenBuf="<" THEN	CALL SUB NexToken	IF TokenBuf<>"<" THEN		ErrNo=ErrIVExp		RETURN	END IF	TokenType=TTypMathEND IFIF TokenBuf=">>" THEN	TokenType=TTypMathEND IFIF TokenType<>TTypMath THEN	ErrNo=ErrIVExp	RETURNEND IFCVOp=TokenBufCALL SUB NexTokenSELECT CASE TokenType	CASE TTypInt		CALL SUB ChkInt	CASE TTypHex		CALL SUB ChkHex	CASE TTypSym		CALL SUB ChkSym		TokenSaf=STR(SymTable(SymNdx).Detail)	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTErrRetSymNdx=SymNdxSafSymTable(SymNdx).Detail=CVTempIF CVOp="+" THEN	CVTemp=SymTable(SymNdx).Detail+VAL(TokenSaf)END IFSELECT CASE CVOp	CASE "-"		CVTemp=SymTable(SymNdx).Detail-VAL(TokenSaf)	CASE "*"		CVTemp=SymTable(SymNdx).Detail*VAL(TokenSaf)	CASE "/"		CVTemp=SymTable(SymNdx).Detail/VAL(TokenSaf)	CASE "&"		CVTemp=LAND(SymTable(SymNdx).Detail,VAL(TokenSaf))	CASE "|"		CVTemp=LOR(SymTable(SymNdx).Detail,VAL(TokenSaf))END SELECTIF CVOp="<" OR CVOp=">>" THEN	CVTemp=SymTable(SymNdx).Detail	TempInt=VAL(TokenSaf);;if (CVOp[0] == '>') CVTemp=CVTemp>>TempInt;;;else CVTemp=CVTemp<<TempInt;END IFSetFinish:SymNdx=SymNdxSafSymTable(SymNdx).Detail=CVTempSymTable(SymNdx).DataMod=SetMaskOutBuf=SymTable(SymNdx).SymName+" equ "+STR(CVTemp)CALL SUB OutFcnCodeDataRETURNBEGIN SEG MacroX	CALL SUB NexToken	IF TokenType<>TTypSym THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=TRUE THEN		ErrNo=ErrDupSym;  symbol already defined		EXIT SEG	END IF	SymTemp.DataType=MACROVAR	CALL SUB ClrSym	SymTemp.DataAddr=MacDefNdx;  address of macro in macro buffer	CALL SUB SymInsert	ErrMain	MacLp:	CALL SUB ReadSource	IF TempInt=0 THEN		TempStr="EOF in MACRO"		ErrNo=$ff		EXIT SEG	END IF	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "macro"			ErrNo=ErrMacNst;  nested macro			GOTO MainLoop		CASE "endmacro"			MacBuf(MacDefNdx)=0			CALL SUB MacDefInc			EXIT SEG		CASE "end"			CALL SUB NexToken			IF TokenBuf="macro" THEN				MacBuf(MacDefNdx)=0				CALL SUB MacDefInc				EXIT SEG			END IF	END SELECT		SrcNdx=0	lbl7027:	INCR SrcNdx	IF SrcNdx>LEN(SrcLine) THEN		MacBuf(MacDefNdx)=NewLine		CALL SUB MacDefInc		ErrMain		GOTO MacLp	END IF	IF MID(SrcLine,SrcNdx,1)="~" THEN		INCR SrcNdx		TempByte=MID(SrcLine,SrcNdx,1)		AsciiByte=ASC(TempByte)		IF TempByte>="0" AND TempByte<="9" THEN			AsciiByte=LAND($0f,AsciiByte)			AsciiByte=LOR($80,AsciiByte)			MacBuf(MacDefNdx)=AsciiByte			CALL SUB MacDefInc			ErrMain			GOTO lbl7027		END IF		AsciiByte=LAND(AsciiByte,$4f); make upper case		TempByte=CHR(AsciiByte)		IF TempByte>="A" AND TempByte<="F" THEN			AsciiByte=LAND($0f,AsciiByte)			AsciiByte=LOR($80,AsciiByte)			AsciiByte=AsciiByte+9			MacBuf(MacDefNdx)=AsciiByte			CALL SUB MacDefInc			ErrMain			GOTO lbl7027		END IF		ErrNo=ErrIVMac		EXIT SEG	END IF	TempByte=MID(SrcLine,SrcNdx,1)	AsciiByte=ASC(TempByte)	MacBuf(MacDefNdx)=AsciiByte	CALL SUB MacDefInc	ErrMain	GOTO lbl7027END SEG MainLoopBEGIN SEG ENDMDx	ErrNo=ErrEndmEND SEG MainLoopBEGIN SEG IFDx	CondValid=GenFlag(GFNdx)	INCR GFNdx	IF GFNdx>20 THEN		TempStr="Conditional stack overflow"		ErrNo=$ff		EXIT SEG	END IF	UMFlag=0	CALL SUB TokenSym	ErrMain	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).DataType<>COMPVAR THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	CondOp1=SymTable(SymNdx).Detail	EqualMain	CALL SUB NexToken	IF TokenBuf="-" THEN		UMFlag=$ff		CALL SUB NexToken	END IF	SELECT CASE TokenType		CASE TTypInt			CALL SUB ChkInt			ErrMain		CASE TTypHex			CALL SUB ChkHex			ErrMain		CASE TTypSym			CALL SUB TokenSym1			ErrMain			TokenSaf=STR(SymTable(SymNdx).Detail)		CASE ELSE			ErrNo=ErrIVExp			EXIT SEG	END SELECT	IF UMFlag=$ff THEN		TempStr="-"	ELSE		TempStr=""	END IF	TempStr=TempStr+TokenSaf	IF MID(TempStr,1,2)="--" THEN		TempStr=MID(TempStr,2,LEN(TempStr)-2)	END IF	CondOp2=VAL(TempStr)	IF CondOp1=CondOp2 AND CondValid=$ff THEN		GenFlag(GFNdx)=$ff	ELSE		GenFlag(GFNdx)=0	END IFEND SEG MainLoopBEGIN SEG ELSEDx	IF GFNdx<2 THEN		TempStr="Conditional stack error)"		ErrNo=$ff		EXIT SEG	END IF	IF GenFlag(GFNdx-1)=$ff THEN		GenFlag(GFNdx)=LNOT(GenFlag(GFNdx))	END IFEND SEG MainLoopBEGIN SEG ENDIFDx	DECR GFNdx	IF GFNdx=0 THEN		TempStr="Conditional stack error)"		ErrNo=$ff		EXIT SEG	END IF	CondValid=GenFlag(GFNdx)END SEG MainLoopBEGIN SEG LoadLibraryX	CALL SUB GetStringOp	OutBuf="invoke LoadLibrary,["+TSymName+"]"	CALL SUB OutInitCodeEND SEG MainLoopBEGIN SEG DataX	UseData=TRUE	IF DataFlag=FALSE THEN		DataFlag=TRUE		IF LabelFlag=0 OR SymTable(SymNdx).DataMod<>DataBit THEN			TempStr="DATA block with no label in line "';BasicLineCtr			ErrNo=$ff			EXIT SEG		END IF		LastStmt="data"; needed for first 'DATA' in block		CALL SUB Remark		CALL SUB OutInitData		OutBuf=SymbolSaf+":"		CALL SUB OutInitData	END IF	NeedComma=FALSE	DATALoop:	CALL SUB NexToken	IF TokenLen=0 THEN		EXIT SEG	END IF	IF NeedComma=FALSE AND TokenBuf="," THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	IF NeedComma=TRUE AND TokenBuf="," THEN		NeedComma=FALSE		GOTO DATALoop	END IF	IF TokenType=TTypQuote THEN		TempStr=MID(TokenSaf,2,LEN(TokenSaf)-2)		GOTO NextData	END IF	SELECT CASE TokenType		CASE TTypHex			CALL SUB ChkHex			ErrMain			TempStr=TokenSaf		CASE TTypInt			CALL SUB ChkInt			ErrMain			TempStr=TokenSaf		CASE TTypFloat			CALL SUB ChkFlt			ErrMain			TempStr=TokenSaf		CASE TTypSym			IF TokenBuf="true" OR TokenBuf="false" THEN				IF TokenBuf="true" THEN					TempStr="1"				ELSE					TempStr="0"				END IF				GOTO NextData			END IF			CALL SUB TokenSym1			ErrMain			TDataType=SymTable(SymNdx).DataType			IF TDataType<>COMPVAR THEN				ErrNo=ErrTypMis				EXIT SEG			END IF			Konstant=SymTable(SymNdx).Detail			TempStr=STR(Konstant)		CASE ELSE			ErrNo=ErrSyntax			EXIT SEG	END SELECT	NextData:	IF TempStr="" THEN		TempStr=CHR($80)	END IF	OutBuf="db "+CHR(OBQUOTE)+TempStr+CHR(OBQUOTE)+",0"	CALL SUB OutInitData	NeedComma=TRUE	GOTO DATALoopEND SEG MainLoopBEGIN SEG RestoreX	CALL SUB ChkLabel	ErrMain	IF SymTable(SymNdx).DataType<>LABELVAR OR SymTable(SymNdx).DataMod<>DataBit THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	OutBuf="mov dword [_DataPtr],"+SymbolSaf	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ReturnX	IF FcnFlag=TRUE THEN		CALL SUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		CALL SUB UnDoToken		CALL SUB Expr		ErrMain		SELECT CASE TFcnDataType			CASE BOOLVAR				IF TDataType<>BOOLVAR THEN					ErrNo=ErrTypMis					EXIT SEG				END IF				OutBuf="mov byte al,["+TSymName+"]"			CASE LONGVAR				IF TDataType<>LONGVAR THEN					ErrNo=ErrTypMis					EXIT SEG				END IF				IF TSymName<>"~" THEN					IF LAND(TDataMod,ConstBit)=ConstBit THEN						OutBuf="mov eax,"+TSymName					ELSE						OutBuf="mov eax,["+TSymName+"]"					END IF					CALL OutFunction				END IF				OutBuf="mov [_LongRet],eax"						CASE STRINGVAR				IF TDataType<>STRINGVAR THEN					ErrNo=ErrTypMis					EXIT SEG				END IF				OutBuf="mov edi,["+TSymName+"]"				CALL OutFunction				OutBuf="mov [_StringRet],edi"				CALL OutFunction				OutBuf="mov edi,["+TSymName+"+4]"				CALL OutFunction				OutBuf="mov [_StringRet+4],edi"				CALL OutFunction				OutBuf="mov edi,["+TSymName+"+8]"				CALL OutFunction				OutBuf="mov [_StringRet+8],edi"			CASE FLOATVAR				IF TDataType<>FLOATVAR THEN					ErrNo=ErrTypMis					EXIT SEG				END IF		END SELECT		CALL OutFunction	END IF	OutBuf="ret"	CALL SUB OutFcnCodeDataEND SEG MainLoop BEGIN SEG ExitX	CALL SUB NexToken	IF TokenLen<>0 THEN		SELECT CASE TokenBuf			CASE "event"				GOTO ExitEvent			CASE "proc"				GOTO ExitProc			CASE "task"				GOTO ExitTask			CASE "sub"				GOTO ExitSub			CASE "seg"				GOTO ExitSeg			CASE "if"				GOTO ExitIf			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG		END SELECT	ELSE		IF ConStkPtr<1 THEN			ErrNo=ErrUBCon			EXIT SEG		END IF		OutBuf="jmp _Lbl"+STR(ConStk(ConStkPtr).TermLabel)		CALL SUB OutFcnCodeData	END IFEND SEG MainLoopBEGIN SEG ExitEvent	IF EventFlag=FALSE THEN		ErrNo=ErrExitEvent		EXIT SEG	END IF	OutBuf="ret"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ExitProc	IF ProcFlag=FALSE THEN		ErrNo=ErrExitProc		EXIT SEG	END IF	OutBuf="ret"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ExitTask	IF TaskFlag=FALSE THEN		ErrNo=ErrExitTask		EXIT SEG	END IF	OutBuf="pop esp"	CALL SUB OutFcnCodeData	OutBuf="return"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ExitSub	IF SubFlag=FALSE THEN		ErrNo=ErrExitSub		EXIT SEG	END IF	OutBuf="ret"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EndSubX	IF SubFlag=FALSE THEN		ErrNo=ErrEndSub		EXIT SEG	END IF	OutBuf="ret"	CALL SUB OutFcnCodeData	CALL SUB MakeLine	CALL SUB OutFcnCodeData	SubFlag=FALSE	CodeBlockFlag=FALSEEND SEG MainLoopBEGIN SEG BeginSubX	CALL SUB FcnFlagChk	ErrMain	SubFlag=TRUE	CodeBlockFlag=TRUE	CALL SUB ProcLabel	ErrMain	SymbolSaf=SymbolSaf+":"	CALL SUB OutLabelEND SEG MainLoopBEGIN SEG SeekX	DiskIO=$ff	CALL SUB GetFileHandle	ErrMain	IF TSubType=DEVICE THEN		ErrNo=ErrDevice		EXIT SEG	END IF	CALL SUB Expr	ErrMain	IF OpClass<>INTClass AND OpClass<>FLTClass THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	CALL SUB LoadNumericValue	ImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUE	OutBuf="invoke SetFilePointer,[_IOPthNum],eax,0,FILE_BEGIN"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrEND SEG MainLoopBEGIN SEG TypeX	IF ProcFcnFlag=TRUE THEN		ErrNo=ErrTypeFcn		EXIT SEG	END IF	CALL SUB ClrDatTyp	CALL SUB TokenSym	ErrMain	IF SymFound=TRUE THEN		ErrNo=ErrDupSym		EXIT SEG	END IF	TypeFlag=$ff	TypePtr=SymNdx	TypeVars=0	TypeBytes=0	SymTemp.DataType=TYPE	CALL SUB ClrSym	CALL SUB SymInsert	ErrMain	TypeLp:	CALL SUB ReadSource	IF TempInt=0 THEN		ErrNo=$ff		EXIT SEG	END IF	TypeLp2:	CALL SUB NexToken	IF TokenBuf="end" THEN		CALL SUB NexToken		IF TokenBuf="type" THEN TypeEnd		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB UnDoToken			IF LEFT(SrcLine,1)="*" THEN TypeLp	CALL SUB DimVar	IF DimOK=0 THEN MainLoop	INCR TypeVars	SymTemp.DataAddr=TypeBytes	CALL SUB SymInsert	ErrMain 	TypeBytes=TypeBytes+SymTemp.DataSize	IF MultiFlag=$ff THEN		;CALL SUB AddMulti	END IF	GOTO TypeLp	TypeEnd:	SymTable(TypePtr).DataSize=TypeBytes	SymTable(TypePtr).Detail=TypeVarsEND SEG MainLoopBEGIN SEG DimX	IF ProcFcnFlag=TRUE THEN		ErrNo=ErrTypeFcn		EXIT SEG	END IF	CALL SUB DimVar	IF DimOK=0 THEN MainLoop	CALL SUB SymInsert	ErrMain	IF TDataType<>TEXT AND TDataType<>TIMER AND TDataType<>FAMILY THEN		CALL SUB DecVar	ELSE		CALL SUB OutFcnCodeData	END IF	IF MultiFlag=$ff THEN		;CALL SUB AddMulti	END IFEND SEG MainLoopBEGIN SEG LetX	Target=$ff	CALL SUB GetExp	ErrMain	IF TextFlag<>0 THEN		IF LAND(SymTemp.DataMod,TextDefinedBit)<>0 THEN			ErrNo=ErrTextDefined			EXIT SEG		END IF		SymTable(SymNdx).DataMod=TextDefinedBit		EqualMain		TempInt=SrcNdx+1		BEGIN LOOP			CALL SUB NexToken			IF TokenLen=0 OR TokenSaf="," THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			CALL SUB NexToken			EXIT IF TokenLen=0			IF TokenSaf<>"," THEN				ErrNo=ErrSyntax				EXIT SEG			END IF		END LOOP		OutBuf=SymTemp.SymName+" db "+TAIL(SrcLine,TempInt)		CALL SUB OutInitData		EXIT SEG	END IF	CALL SUB ProcExp	ErrMain	CALL SUB ClassOp	ErrMain	IF DMConst<>0 THEN		ErrNo=ErrIVTarget		EXIT SEG	END IF	Op1Name=TSymName	Op1Mod=TDataMod	Op1Detail=TDetail	Op1DataSize=TDataSize	Op1Type=TDataType	Op1Class=OpClass	SELECT CASE Op1Type		CASE 1			OpSizeStr=" byte "		CASE 2			OpSizeStr=" byte "		CASE 3			OpSizeStr=" word "		CASE 4			OpSizeStr=" dword "		CASE ELSE			OpSizeStr=" "	END SELECT	IF Op1Name="NextArg" THEN		ErrNo=ErrIVTarget		EXIT SEG	END IF	IF LAND(TempBit,Op1Mod)<>0 AND LAND(VectorBit,Op1Mod)=0 THEN		ErrNo=ErrIVTarget		EXIT SEG	END IF 	CALL SUB NexToken	IF TokenBuf<>"=" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	IF Op1Mod=VectorBit AND Op1Type=STRINGVAR AND NextByte=CHR($22) THEN		CALL SUB NexToken		IF RIGHT(TokenSaf,1)<>CHR(OBQUOTE) THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		IF LEN(TokenBuf)=2 THEN			OutBuf="mov ["+Op1Name+"+12],0"			CALL SUB OutFcnCodeData			EXIT SEG		ELSE			IF NextByte<>"+" AND Op1Detail>LEN(TokenSaf) THEN				ediUsed=TRUE				OutBuf="mov edi,["+Op1Name+"]"				CALL SUB OutFcnCodeData				CALL SUB MakeStrConst				OutBuf="mov esi,_StrConst"+STR(PoolCtr)				CALL SUB OutFcnCodeData				UseSetStrConst=TRUE				OutBuf="call __SetStrConst"				CALL SUB OutFcnCodeData				EXIT SEG			END IF		END IF		CALL SUB UnDoToken	END IF	IF Op1Type=LABELPTR THEN		CALL SUB NexToken		SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=FALSE THEN			;print "make label here",SrcLine			ELSE 			IF  SymTable(SymNdx).DataType<>LABELVAR AND SymTable(SymNdx).DataType<>LABELPTR THEN				ErrNo=ErrTypMis				EXIT SEG			END IF			END IF		IF LAND(VectorBit,Op1Mod)=0 THEN			OutBuf="mov dword ["+Op1Name+"],"+SymTemp.SymName		ELSE			OutBuf="mov dword esi,["+Op1Name+"]"			CALL SUB OutFcnCodeData			OutBuf="mov dword [esi], dword "+SymTemp.SymName		END IF		CALL SUB OutFcnCodeData		GOTO MainLoop	END IF	CALL SUB GetExp	ErrMain	Target=0	CALL SUB ProcOp2	CALL SUB NexToken	IF TokenLen<>0 THEN; check for junk on end		ErrNo=ErrSyntax		EXIT SEG	END IF	IF Op2Name="NextArg" THEN		CALL SUB ProcCmd		EXIT SEG	END IF	IF Op1Class<>Op2Class THEN;  int=float for example		EXIT IF Op1Class=INTClass AND Op2Class=FLTClass		EXIT IF Op1Class=FLTClass AND Op2Class=INTClass		ErrNo=ErrTypMis		EXIT SEG	END IF	IF Op1Class=INTClass OR Op1Class=FLTClass OR Op1Class=BOOLClass THEN		IF TSymName<>"~" THEN			TDataType=Op1Type			CALL SUB GetDataType			;OutBuf="; GetdataType LET "+DataTypeName			;CALL SUB OutFcnCodeData			IF Op1Mod=0 AND Op2Mod=ConstBit THEN				Op2Name=STR(Op2Detail)				IF Op1Type=BOOLVAR OR Op1Type=BYTEVAR THEN					IF Op2Detail>255 THEN						ErrNo=ErrOpRange						EXIT SEG					END IF				END IF				IF Op1Type=WORDVAR THEN					IF Op2Detail>65535 THEN						ErrNo=ErrOpRange						EXIT SEG					END IF				END IF				IF Op1Type=LONGVAR THEN					IF Op2Detail>$7fffffff THEN						ErrNo=ErrOpRange						EXIT SEG					END IF				END IF				OutBuf="mov"+OpSizeStr+"["+Op1Name+"],"+Op2Name				CALL SUB OutFcnCodeData				EXIT SEG			END IF			IF Op1Mod=0 AND Op2Mod=0 THEN				IF Op1Type>Op2Type AND Op2Type<>BOOLVAR THEN					OutBuf="xor eax,eax"					CALL SUB OutFcnCodeData				END IF 				IF Op2Type=BOOLVAR OR Op2Type=BYTEVAR THEN					OutBuf="mov al, byte ["+Op2Name+"]"								CALL SUB OutFcnCodeData					CALL SUB StoreInt					EXIT SEG				END IF				IF Op2Type=WORDVAR THEN					OutBuf="mov ax, word ["+Op2Name+"]"								CALL SUB OutFcnCodeData					CALL SUB StoreInt					EXIT SEG				END IF				IF Op2Type=LONGVAR THEN					OutBuf="mov eax, dword ["+Op2Name+"]"								CALL SUB OutFcnCodeData					CALL SUB StoreInt					EXIT SEG				END IF			END IF			D0Loaded=0			CALL SUB LoadReg			ErrMain		END IF		CALL SUB StoreD0		EXIT SEG	END IF	IF Op1Class=STRClass THEN		ediUsed=TRUE		OutBuf="mov edi,"+Op1Name		CALL SUB OutFcnCodeData		OutBuf="mov esi,"+Op2Name		CALL SUB OutFcnCodeData		UseMovStr=TRUE		OutBuf="call __MovStr"		CALL SUB OutFcnCodeData		EXIT SEG	END IF	IF Op1Class=CPXClass OR Op1Class=ARRClass THEN		ediUsed=TRUE		IF LAND(Op1Mod,VectorBit)=0 THEN			OutBuf="mov edi,"+Op1Name		ELSE			OutBuf="mov edi,["+Op1Name+"]"		END IF		CALL SUB OutFcnCodeData		IF LAND(Op2Mod,VectorBit)=0 THEN			OutBuf="mov esi,"+Op2Name		ELSE			OutBuf="mov esi,["+Op2Name+"]; Get src addr"		END IF		CALL SUB OutFcnCodeData		IF Op1Class=ARRClass THEN			TempInt=Op1DataSize		ELSE			TempInt=SymTable(Op1Detail).DataSize		END IF		OutBuf="mov ecx,"+STR(TempInt)			CALL SUB OutFcnCodeData		INCR LabelNum		OutBuf="_Lbl"+STR(LabelNum)+":"		CALL SUB OutFcnCodeData		OutBuf="mov al,byte [esi]"		CALL SUB OutFcnCodeData		OutBuf="mov byte [edi],al"		CALL SUB OutFcnCodeData		OutBuf="inc esi"		CALL SUB OutFcnCodeData		OutBuf="inc edi"		CALL SUB OutFcnCodeData		OutBuf="dec ecx"		CALL SUB OutFcnCodeData		OutBuf="jne "+"_Lbl"+STR(LabelNum)		CALL SUB OutFcnCodeData		EXIT SEG	END IF	SELECT CASE Op1Class		CASE BOOLClass			D0Loaded=0			CALL SUB LoadReg			ErrMain			CALL SUB StoreD0			EXIT SEG		CASE FRMClass			ErrNo=ErrIVType			GOTO MainLoop		CASE ELSE 			TempStr="Internal Error"			CALL SUB ShowError			EXIT SEG	END SELECTEND SEG MainLoopBEGIN SUB ProcOp2	IF GUIObjFlag<>0 THEN;//		CALL SUB UnDoToken;//		GUITargetFlag=0;//		CALL SUB ValidateObject;//		ErrRet;//		CALL SUB GUISource		Op2Name=GUITempName		Op2Type=GUIDataType		SELECT CASE Op2Type			CASE BOOLVAR				Op2Class=BOOLClass			CASE LONGVAR				Op2Class=INTClass			CASE STRINGVAR				Op2Class=STRClass		END SELECT		OpClass=Op2Class		TSymName=Op2Name		TDataType=Op2Type		Op2Mod=0		TDataMod=0		Op2Detail=0		TDetail=0		SymTemp.SymName="~"	ELSE		CALL SUB ProcExp		ErrRet		CALL SUB ClassOp		Op2Name=TSymName		Op2Class=OpClass		Op2Type=TDataType		Op2Mod=TDataMod		Op2Detail=TDetail	END IFEND SUBBEGIN SUB StoreInt	IF Op1Type=BOOLVAR OR Op1Type=BYTEVAR THEN		OutBuf="mov ["+Op1Name+"],al"	END IF	IF Op1Type=WORDVAR THEN		OutBuf="mov ["+Op1Name+"],ax"	END IF	IF Op1Type=LONGVAR THEN		OutBuf="mov ["+Op1Name+"],eax"	END IF	CALL SUB OutFcnCodeDataEND SUBBEGIN SEG ForX	CALL SUB TokenSym	ErrMain	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).DataType<>LONGVAR THEN		ErrNo=ErrIVType		EXIT SEG	END IF	IF LAND(SymTable(SymNdx).DataMod,ConstBit)=ConstBit THEN		ErrNo=ErrIVTarget		EXIT SEG	END IF	CALL SUB IncConStk	ErrMain	ConStk(ConStkPtr).LoopName=SymTemp.SymName	SymTemp=SymTable(SymNdx)	CALL GetLopVec	ErrMain	ConStk(ConStkPtr).LoopVec=LopVarNdx	ConStk(ConStkPtr).ConType=5	ConStk(ConStkPtr).ConLine=BasicLineCtr	EqualMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],eax"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenBuf<>"to" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_LopVec"+STR(LopVarNdx)+"],eax"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen=0 THEN		ConStk(ConStkPtr).NoStep=$ff	ELSE		IF TokenBuf<>"step" THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		ConStk(ConStkPtr).NoStep=0		CALL SUB GetIntOp		ErrMain		OutBuf="mov [_LopVec"+Str(LopVarNdx)+"+4],eax"		CALL SUB OutFcnCodeData	END IF	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	ConStk(ConStkPtr).LoopLabel=LabelNum	INCR LabelNum	ConStk(ConStkPtr).ContLabel=LabelNum	INCR LabelNum	ConStk(ConStkPtr).TermLabel=LabelNum	; compare loopvar to "to" value	OutBuf="mov eax,["+ConStk(ConStkPtr).LoopName+"]"	CALL SUB OutFcnCodeData	IF ConStk(ConStkPtr).NoStep=$ff THEN		OutBuf="cmp eax,[_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"]"		CALL SUB OutFcnCodeData		OutBuf="jg "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)		CALL SUB OutFcnCodeData	ELSE		OutBuf="mov ebx,[_LopVec"+Str(LopVarNdx)+"+4]"		CALL SUB OutFcnCodeData		OutBuf="or ebx,ebx"		CALL SUB OutFcnCodeData		OutBuf="js "+"_Lbl"+STR(LabelNum+1)		CALL SUB OutFcnCodeData				OutBuf="cmp eax,[_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"]"		CALL SUB OutFcnCodeData		OutBuf="jg "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)		CALL SUB OutFcnCodeData		OutBuf="jmp "+"_Lbl"+STR(LabelNum+2)		CALL SUB OutFcnCodeData			INCR LabelNum		OutBuf="_Lbl"+STR(LabelNum)+":"		CALL SUB OutFcnCodeData		OutBuf="cmp eax,[_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"]"		CALL SUB OutFcnCodeData		OutBuf="jl "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)		CALL SUB OutFcnCodeData			INCR LabelNum		OutBuf="_Lbl"+STR(LabelNum)+":"		CALL SUB OutFcnCodeData	END IFEND SEG MainLoopBEGIN SEG IfX	CALL SUB CmpOps 	ErrMain	INCR LabelNum	IF TokenBuf<>"then" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB NexToken	IF TokenLen>0 THEN		CALL SUB UnDoToken		CALL SUB ChkLabel		ErrMain		IF SymTable(SymNdx).DataType<>LABELVAR THEN			ErrNo=ErrTypMis			EXIT SEG		END IF		IF SimpleCmp=0 THEN			OutBuf="jne "+SymTemp.SymName		ELSE			OutBuf=SimpleOp+SymTemp.SymName		END IF		CALL SUB OutFcnCodeData		EXIT SEG	END IF	CALL SUB IncConStk	ErrMain	ConStk(ConStkPtr).TermLabel=LabelNum	ConStk(ConStkPtr).ConType=0	ConStk(ConStkPtr).ConLine=BasicLineCtr	ConStk(ConStkPtr).ContLabel=-1	IF SimpleCmp=0 THEN		OutBuf="je "+"_Lbl"+STR(LabelNum)	ELSE		OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)	END IF	CALL SUB OutFcnCodeData END SEG MainLoopBEGIN SEG GotoX	ToSub="jmp "	CALL SUB GotoGosubEND SEG MainLoopBEGIN SEG GosubX	ToSub="call "	CALL SUB GotoGosubEND SEG MainLoopBEGIN SUB GotoGosub	IF ProcFcnFlag=TRUE THEN		TempStr="GOTO, GOSUB, or CALL SUB in Function or Proc"		ErrNo=$ff		EXIT SUB	END IF	CALL SUB NexToken	IF TokenBuf="[" THEN		CALL SUB RightBracket		ErrRet		CALL SUB Expr		IF TDataType<>LABELPTR THEN			ErrNo=ErrTypMis			EXIT SUB		END IF		IF DMVector<>0 THEN			OutBuf="mov esi,["+TSymName+"]"			CALL SUB OutFcnCodeData			OutBuf=ToSub+"dword [esi]"				ELSE			OutBuf=ToSub+"["+TSymName+"]"		END IF		CALL SUB OutFcnCodeData		IF EndSegFlag=TRUE THEN			CALL SUB MakeLine			CALL SUB OutFcnCodeData		END IF		EXIT SUB	END IF	CALL SUB UnDoToken	CALL SUB ChkLabel	ErrRet	IF SymTable(SymNdx).DataType<>LABELVAR THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf=ToSub+SymbolSaf	CALL SUB OutFcnCodeData	IF EndSegFlag=TRUE THEN		CALL SUB MakeLine		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SEG OnX	JmpArgs=0	CALL SUB NexToken	IF TokenBuf="error" THEN ON_ERROR	CALL SUB UnDoToken	INCR LabelNum	INCR TableNum	OutBuf="align 4"	CALL SUB OutInitData	OutBuf="_Table"+STR(TableNum)+":"	CALL SUB OutInitData	CALL SUB GetIntOp; get test integer	ErrMain	CALL SUB NexToken	IF TokenBuf="goto" OR TokenBuf="gosub" THEN		IF TokenBuf="goto" THEN			ToSubFlag=0		ELSE			ToSubFlag=$ff		END IF	ELSE		ErrNo=ErrSyntax		EXIT SEG	END IF	NeedComma=TRUE	BEGIN LOOP		NeedComma=NOT(NeedComma)		CALL SUB NexToken		EXIT IF TokenLen=0		CONTINUE IF TokenBuf="," AND NeedComma=TRUE		IF TokenBuf="," AND NeedComma=FALSE THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		IF TokenBuf<>"," AND NeedComma=TRUE THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		CALL SUB UnDoToken		CALL SUB ChkLabel		ErrMain		TempInt=SymTable(SymNdx).Detail		TDataType=SymTable(SymNdx).DataType		IF TDataType<>LABELVAR THEN			ErrNo=ErrTypMis			EXIT SEG		END IF		OutBuf="dd "+SymTable(SymNdx).SymName		CALL SUB OutInitData		INCR JmpArgs	END LOOP	IF JmpArgs<1 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	Ctr1=0	OutBuf="cmp eax,1"	CALL SUB OutFcnCodeData	OutBuf="jl "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="cmp eax,"+STR(JmpArgs)	CALL SUB OutFcnCodeData	OutBuf="jg "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="dec eax"	CALL SUB OutFcnCodeData	OutBuf="shl eax,2"	CALL SUB OutFcnCodeData	OutBuf="add eax,_Table"+STR(TableNum)	CALL SUB OutFcnCodeData	OutBuf="mov eax,[eax]"	CALL SUB OutFcnCodeData	IF ToSubFlag=0 THEN		OutBuf="jmp dword eax"	ELSE		OutBuf="call dword eax"	END IF	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ON_ERROR	CALL SUB NexToken	IF TokenLen=0 THEN; Turn off ON ERROR		OutBuf="mov [_ErrVec],_ErrExit"		CALL SUB OutFcnCodeData		EXIT SEG	END IF	IF TokenBuf="goto" THEN		ErrOpCode="jmp"	ELSE		IF TokenBuf="gosub" THEN			ErrOpCode="call"		ELSE			ErrNo=ErrSyntax			EXIT SEG		END IF	END IF	CALL SUB ChkLabel	ErrMain	IF SymTable(SymNdx).DataType<>LABELVAR THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	OutBuf="mov [_ErrVec],"+SymTemp.SymName	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG PrintX	UseStrLen=TRUE	CALL SUB DevChk	PrintFlag=$ff	IF DevFlag=$ff THEN		PrintPathFlag=$ff		CALL SUB GetFileHandle		ErrMain		PrintPathFlag=0	END IF	CALL SUB NexToken	PrintLp:	CALL SUB NexToken	IF TokenLen=0 THEN PrintEx	CALL SUB UnDoToken	CALL SUB Expr	ErrMain	IF TDataType=VOIDX THEN PrtArgSep	IF TabFlag=$ff THEN		TabFlag=0		GOTO PrtArgSep	END IF	IF TDataType<>STRINGVAR OR DMAddr<>0 THEN		CALL SUB MakString		ErrMain	END IF	CALL SUB ClassOp	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	ediUsed=TRUE	OutBuf="mov edi,_PrintBuf"	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	OutBuf="mov esi,_PrintBuf"	CALL SUB OutFcnCodeData	OutBuf="call __StrLen"	CALL SUB OutFcnCodeData	OutBuf="mov edx,eax"	CALL SUB OutFcnCodeData	OutBuf="add edx,[POS]"	CALL SUB OutFcnCodeData	OutBuf="mov [POS],edx"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE	OutBuf="invoke WriteConsole,[_OutHandle],[_PrintBuf],eax,XferCount,NULL"	CALL SUB OutFcnCodeData	CALL SUB CallErrZ	PrtArgSep:	CALL SUB NexToken	IF FileIO<>0 THEN		CALL SUB OutCRLF		IF TokenBuf="," OR TokenBuf=";" THEN			IF NextByte<>"" THEN PrintLp		END IF		GOTO PrintEx	END IF	IF TokenBuf="," THEN		OutBuf="xor eax,eax"		CALL SUB OutFcnCodeData		OutBuf="";call __PrintTab		CALL SUB OutFcnCodeData		CALL SUB CallErr		IF NextByte="" THEN PrintEx		GOTO PrintLp	END IF	IF TokenBuf=";" THEN		IF NextByte="" THEN PrintEx		GOTO PrintLp	END IF	PrintEx:	IF TokenBuf<>"," AND TokenBuf<>";" THEN		ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE		OutBuf="invoke WriteConsole,[_OutHandle],[_CRLF],2,XferCount,NULL"		CALL SUB OutFcnCodeData		OutBuf="mov [POS],0"		CALL SUB OutFcnCodeData	END IFEND SEG MainLoopBEGIN SEG InputX	CALL SUB DevChk	IF DevFlag=$ff THEN		CALL SUB GetFileHandle		ErrMain	END IF	IF FileIO=0 THEN		CALL SUB NexToken		CALL SUB UnDoToken		IF TokenType=TTypQuote THEN			CALL SUB Expr			ErrMain			ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE			OutBuf="invoke WriteConsole,[_OutHandle],["+TSymName+"],["+TSymName+"+4],XferCount,NULL"			CALL SUB OutFcnCodeData			CommaMain		ELSE			ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE			OutBuf="invoke WriteConsole,[_OutHandle],[_Prompt],1,XferCount,NULL"			CALL SUB OutFcnCodeData		END IF		CALL SUB CallErrZ	END IF	Target=$ff	BEGIN LOOP		CALL SUB Expr		ErrMain		IF DMVector=0 THEN			CALL Vectorize			ErrMain			CALL SUB ClassOp		END IF		IF DMVector<>0 AND DMTemp=0 THEN			CALL SetTmpVec			ErrMain		END IF		OutBuf="mov esi,"+TSymName		CALL SUB OutFcnCodeData		OutBuf="mov [_ArgSafe0],esi"		CALL SUB OutFcnCodeData		OutBuf="mov [_ArgSafe1],"+STR(TDataType)		CALL SUB OutFcnCodeData		UseInpData=TRUE		OutBuf="call __InpData"		CALL SUB OutFcnCodeData		CALL SUB CallErrZ		CALL SUB NexToken		EXIT IF TokenBuf<>","	END LOOP	IF FileIO=0 AND NewLine=$0d THEN		CALL SUB OutCRLF	END IFEND SEG MainLoopBEGIN SEG ReadX	NeedComma=FALSE	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType=FILE OR SymTable(SymNdx).SubType=DEVICE THEN		ENTER SEG FileRead	END IF	SymTemp=SymTable(SymNdx)	CALL SUB UnDoToken	Target=$ff	ReadFlag=$ff	BEGIN LOOP		IF NeedComma=TRUE THEN			CALL SUB NexToken			IF TokenLen=0 THEN MainLoop			IF TokenBuf<>"," THEN				ErrNo=ErrSyntax				EXIT SEG			ELSE				NeedComma=FALSE			END IF		END IF		CALL SUB GetExp		ErrMain		IF TokenLen=0 THEN			EXIT SEG		END IF		CALL SUB ProcExp		ErrMain		CALL SUB ClassOp		CALL SUB GetBase		IF TDataType=COMPVAR OR TDataType>6 THEN			ErrNo=ErrTypMis			EXIT SEG		END IF		IF DMAddr<>0 THEN			TDataType=LONGVAR		END IF		SELECT CASE TDataType			CASE BOOLVAR				OutBuf="call __ReadBool"			CASE BYTEVAR				OutBuf="call __ReadByte";			CASE WORDVAR				OutBuf="call __ReadShort"			CASE LONGVAR				OutBuf="call __ReadLong"			CASE FLOATVAR				OutBuf="call __ReadFlt"			CASE STRINGVAR				OutBuf="mov eax,"+STR(TDetail)				CALL SUB OutFcnCodeData				OutBuf="call __ReadStr"		END SELECT		CALL SUB OutFcnCodeData		NeedComma=TRUE	END LOOPEND SEG MainLoopBEGIN SEG FileRead	UseReadFile=TRUE	CALL SUB UnDoToken	CALL SUB ReadWrite	ErrMain	OutBuf="call __ReadFile"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG BeginResourceX	IF ResourceFlag=TRUE THEN		TempStr="Already have resource section"		ErrNo=$ff		EXIT SEG	END IF	ResourceFlag=TRUE	OutBuf=""	CALL SUB OutResource	OutBuf="section '.rsrc' resource data readable"	CALL SUB OutResource	OutBuf=""	CALL SUB OutResource	BEGIN LOOP		CALL SUB ReadSource		IF TempInt=0 THEN			TempStr="EOF in RESOURCE"			ErrNo=$ff			EXIT SEG		END IF		CALL SUB NexToken		IF TokenBuf="end" THEN			CALL SUB NexToken			IF TokenBuf="resource" THEN				OutBuf=""				CALL SUB OutResource				OutBuf="; End of Resource Section"				CALL SUB OutResource				CALL SUB MakeLine				CALL SUB OutResource				EXIT SEG			ELSE				CALL SUB UnDoToken			END IF		END IF		OutBuf=SrcLine		CALL SUB OutResource	END LOOPEND SEG MainLoopBEGIN SEG EndResourceX	TempStr="END RESOURCE while not in resource"	ErrNo=$ffEND SEG MainLoopBEGIN SEG BeginExportX	IF ExportFlag=TRUE THEN		TempStr="Already have export section"		ErrNo=$ff		EXIT SEG	END IF	ExportFlag=TRUE	OutBuf=""	CALL SUB OutExport	OutBuf="section '.edata' export data readable"	CALL SUB OutExport	OutBuf=""	CALL SUB OutExport	BEGIN LOOP		CALL SUB ReadSource		IF TempInt=0 THEN			TempStr="EOF in EXPORT"			ErrNo=$ff			EXIT SEG		END IF		CALL SUB NexToken		IF TokenBuf="end" THEN			CALL SUB NexToken			IF TokenBuf="export" THEN				OutBuf=""				CALL SUB OutExport				OutBuf="; End of Export Section"				CALL SUB OutExport				CALL SUB MakeLine				CALL SUB OutExport				EXIT SEG			ELSE				CALL SUB UnDoToken			END IF		END IF		OutBuf=SrcLine		CALL SUB OutExport	END LOOPEND SEG MainLoopBEGIN SEG EndExport	TempStr="END EXPORT while not in export"	ErrNo=$ffEND SEG MainLoopBEGIN SEG WriteX	UseWriteFile=TRUE	CALL SUB ReadWrite	ErrMain	OutBuf="call __WriteFile"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetX	CALL SUB GetPut	ErrMain	CALL SUB OutReadEND SEG MainLoopBEGIN SEG PutX	CALL SUB GetPut	ErrMain	CALL SUB OutWriteEND SEG MainLoopBEGIN SEG EndX	CALL SUB NexToken	IF TokenLen<>0 THEN		LastStmt=LastStmt+TokenBuf; prevents bug involving false 'end'		SELECT CASE TokenBuf			CASE "if"				GOTO EndIfX			CASE "loop"				GOTO EndLoopX			CASE "while"				GOTO EndWhileX			CASE "select"				GOTO EndSelectX			CASE "fcn"				GOTO EndFcnX			CASE "proc"				GOTO EndProcX			CASE "task"				GOTO EndTaskX			CASE "sub"				GOTO EndSubX			CASE "seg"				GOTO EndSegX			CASE "table"				GOTO EndTableX			CASE "text"				GOTO EndTextX			CASE "type"				GOTO EndTypeX			CASE "event"				GOTO EndEventX			CASE "menu"				GOTO EndMenuX			CASE "enum"				GOTO EndEnumX			CASE "enum"				GOTO EndResourceX			CASE "paint"				GOTO EndPaintX			CASE "macro"				GOTO EndMacroX			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG		END SELECT	END IF	IF GUIFlag=FALSE THEN		OutBuf="xor eax,eax"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE		OutBuf="invoke ExitProcess, eax"		CALL SUB OutFcnCodeData	ELSE		ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE		OutBuf="invoke DeleteObject,[!Brush]"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrPostMessage).ImportFcnUse=TRUE		OutBuf="invoke PostMessage,[!OBMain],WM_CLOSE,0,0"		CALL SUB OutFcnCodeData	END IFEND SEG MainLoopBEGIN SEG OpenX	Target=0	CALL SUB GetFileName	ErrMain	CALL SUB NexToken	IF TokenBuf<>"for" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "input"			FcnName="GENERIC_READ"			OpenMode=0		CASE "output"			FcnName="GENERIC_WRITE"			OpenMode=1		CASE "scratch"			FcnName="GENERIC_WRITE"			OpenMode=2		CASE "append"			FcnName="GENERIC_WRITE"			OpenMode=3		CASE "update"			FcnName="GENERIC_READ+GENERIC_WRITE"			OpenMode=4		CASE ELSE			ErrNo=ErrSyntax			EXIT SEG	END SELECT		CALL SUB NexToken	IF TokenBuf<>"as" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB GetExp	ErrMain	IF SymTable(SymNdx).DataType<>LONGVAR THEN		ErrNo=ErrIVType		EXIT SEG	END IF	CALL SUB ProcExp	ErrMain	CALL SUB ClassOp	IF TSubType=FILE THEN		IF OpenMode=0 THEN			ArgStr="OPEN_EXISTING"		ELSE			ArgStr="OPEN_ALWAYS"		END IF	ELSE		IF TSubType=DEVICE THEN			ArgStr="OPEN_EXISTING"			IF OpenMode=2 OR OpenMode=3 THEN				ErrNo=ErrDevice				EXIT SEG			END IF		ELSE			ErrNo=ErrIVType			EXIT SEG		END IF	END IF	IF DMConst<>0 THEN		ErrNo=ErrIVExp		EXIT SEG	END IF	IF DMVector=0 THEN		PathIsVector=0		PathVar=TSymName	ELSE		PathIsVector=$ff		PathVar=TSymName	END IF	ImportFcnTable(ptrCreateFile).ImportFcnUse=TRUE	OutBuf="invoke CreateFile,[_IOBuffer],"+FcnName+",FILE_SHARE_READ+FILE_SHARE_WRITE,0,"+ArgStr+",FILE_ATTRIBUTE_NORMAL,0"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	IF PathIsVector=0 THEN		OutBuf="mov ["+PathVar+"],eax"	ELSE		OutBuf="mov edi,["+PathVar+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],eax"	END IF	CALL SUB OutFcnCodeData	CALL SUB CallErr	IF OpenMode=2 THEN		ImportFcnTable(ptrSetEndOfFile).ImportFcnUse=TRUE		OutBuf="invoke SetEndOfFile,eax"		CALL SUB OutFcnCodeData	ELSE		IF OpenMode=3 THEN			ImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUE			OutBuf="invoke SetFilePointer,eax,0,0,FILE_END"			CALL SUB OutFcnCodeData		END IF	END IFEND SEG MainLoopBEGIN SEG CloseX	DiskIO=$ff	BEGIN LOOP		CALL SUB GetFileHandle		ErrMain		ImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUE		OutBuf="invoke CloseHandle,[_IOPthNum]"		CALL SUB OutFcnCodeData		CALL SUB SetStatus		CALL SUB CallErrZ		CALL SUB NexToken		IF TokenLen=0 THEN			EXIT SEG		END IF		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF	END LOOPEND SEG MainLoopBEGIN SEG WhileX	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	CALL SUB CmpOps	ErrMain	IF TokenBuf<>"do" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB IncConStk	ErrMain	ConStk(ConStkPtr).LoopLabel=LabelNum	ConStk(ConStkPtr).ContLabel=LabelNum; For consistancy with CONTINUE statement	INCR LabelNum	ConStk(ConStkPtr).TermLabel=LabelNum	ConStk(ConStkPtr).ConType=1	ConStk(ConStkPtr).ConLine=BasicLineCtr	IF SimpleCmp=0 THEN		OutBuf="je "+"_Lbl"+STR(LabelNum)	ELSE		OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EndWhileX	TempInt=1	CALL SUB ConStkChk	ErrMain	OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	DECR ConStkPtrEND SEG MainLoopBEGIN SEG NextX	IF ConStkPtr=0 THEN		ErrNo=ErrUBCon		EXIT SEG	END IF	CALL SUB NexToken	IF TokenLen=0 THEN		TokenSaf=ConStk(ConStkPtr).LoopName	END IF	IF TokenSaf<>ConStk(ConStkPtr).LoopName THEN		ErrNo=ErrUBCon		EXIT SEG	END IF	TempInt=5	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"	CALL SUB OutFcnCodeData	CALL SUB ConStkChk	ErrMain	; add "step" to loop var	IF ConStk(ConStkPtr).NoStep=$ff THEN		OutBuf="mov eax,["+ConStk(ConStkPtr).LoopName+"]"		CALL SUB OutFcnCodeData		OutBuf="add eax,1"		CALL SUB OutFcnCodeData		OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],eax"		CALL SUB OutFcnCodeData	ELSE		OutBuf="mov eax,["+ConStk(ConStkPtr).LoopName+"]"		CALL SUB OutFcnCodeData		OutBuf="add eax,[_LopVec"+Str(LopVarNdx)+"+4]"		CALL SUB OutFcnCodeData		OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],eax"		CALL SUB OutFcnCodeData	END IF	; branch back to loop beginning	OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	CALL SUB OutFcnCodeData	; generate done label	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	DECR ConStkPtrEND SEG MainLoopBEGIN SEG ElseX	CALL SUB NexToken;  make sure nothing follows	IF TokenLen<>0 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	TempInt=0	CALL SUB ConStkChk	ErrMain	INCR LabelNum	OutBuf="jmp "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	ConStk(ConStkPtr).TermLabel=LabelNumEND SEG MainLoopBEGIN SEG EndIfX	TempInt=0	CALL SUB ConStkChk	ErrMain	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	DECR ConStkPtrEND SEG MainLoopBEGIN SEG DeleteObjectX	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	TSubType=SymTable(SymNdx).SubType	IF TSubType<>SOLIDBRUSH AND TSubType<>HATCHBRUSH AND TSubType<>PATTERNBRUSH AND TSubType<>PEN AND TSubType<>FONT THEN		ErrNo=ErrIVType		EXIT SEG	END IF	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	OutBuf="invoke DeleteObject,["+TokenSaf+"]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG DeleteX	CALL SUB GetFileName	ErrMain	ImportFcnTable(ptrDeleteFile).ImportFcnUse=TRUE	OutBuf="invoke DeleteFile,[_IOBuffer]"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZEND SEG MainLoopBEGIN SEG BufferX	CALL SUB TokenSym	ErrMain	BufName=SymTemp.SymName	IF SymFound=FALSE THEN		CALL SUB MakeBuffer		CALL SUB ClrSym		SymTemp.DataMod=0		SymTemp.DataType=BUFFER		SymTemp.DataSize=8		CALL SUB SymInsert		ErrMain	END IF	TDataType=SymTable(SymNdx).DataType	IF TDataType<>BUFFER THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	EqualMain	CALL SUB Expr	ErrMain	IF TSymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg		ErrMain	END IF	IF DMConst<>0 AND TSymName="0" THEN		CALL SUB ReleaseBuffer	ELSE		CALL SUB GetBuffer	END IFEND SEG MainLoopBEGIN SEG BeginX	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "fcn"			CALL OutFunction			GOTO BeginFcnX		CASE "proc"			CALL OutFunction			GOTO BeginProcX		CASE "loop"			CALL SUB OutFcnCodeData			GOTO BeginLoopX		CASE "task"			CALL SUB OutFcnCodeData			GOTO BeginTaskX		CASE "sub"			CALL SUB OutFcnCodeData			GOTO BeginSubX		CASE "seg"			CALL SUB OutFcnCodeData			GOTO BeginSegX		CASE "menu"			CALL SUB OutFcnCodeData			GOTO BeginMenuX		CASE "resource"			CALL SUB OutResource			GOTO BeginResourceX		CASE "export"			CALL SUB OutExport			GOTO BeginExportX		CASE "paint"			CALL SUB OutFcnCodeData			GOTO BeginPaintX		CASE ELSE			ErrNo=ErrSyntax	END SELECTEND SEG MainLoopBEGIN SEG BeginLoopX	CALL SUB IncConStk	ErrMain	CALL SUB NexToken	IF TokenLen=0 THEN		ConStk(ConStkPtr).ConType=3	ELSE		INCR LopCtrNum		IF LopCtrNum>9 THEN			ErrNo=ErrTmpUse			GOTO MainLoop		END IF		IF TokenBuf<>"count" THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		EqualMain		CALL SUB GetIntOp		ErrMain		OutBuf="mov [_LoopCtr+"+STR(LopCtrNum*4)+"],"+LdRegName		CALL SUB OutFcnCodeData		ConStk(ConStkPtr).ConType=4	END IF	ConStk(ConStkPtr).ConLine=BasicLineCtr	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	ConStk(ConStkPtr).LoopLabel=LabelNum	ConStk(ConStkPtr).ContLabel=LabelNum; For consistancy with CONTINUE statement	INCR LabelNum	ConStk(ConStkPtr).TermLabel=LabelNumEND SEG MainLoopBEGIN SEG EndLoopX	TempInt=3	CALL SUB ConStkChk	IF ErrNo<>0 THEN		ErrNo=0		TempInt=4		CALL SUB ConStkChk		ErrMain	END IF	IF TempInt=3 THEN		OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	ELSE		OutBuf="dec [_LoopCtr"+"+"+STR(LopCtrNum*4)+"];"		CALL SUB OutFcnCodeData		OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)		DECR LopCtrNum	END IF	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	DECR ConStkPtrEND SEG MainLoopBEGIN SEG RepeatX	CALL SUB IncConStk	ErrMain	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	ConStk(ConStkPtr).LoopLabel=LabelNum	ConStk(ConStkPtr).ConLine=BasicLineCtr	ConStk(ConStkPtr).ConType=2	INCR LabelNum	ConStk(ConStkPtr).ContLabel=LabelNum	INCR LabelNum	ConStk(ConStkPtr).TermLabel=LabelNumEND SEG MainLoopBEGIN SEG UntilX	TempInt=2	CALL SUB ConStkChk	ErrMain	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"	CALL SUB OutFcnCodeData	CALL SUB CmpOps	ErrMain	IF TokenLen<>0 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	IF SimpleCmp=0 THEN		OutBuf="je "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	ELSE		OutBuf=SimpleStructOp+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	END IF	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	DECR ConStkPtrEND SEG MainLoopBEGIN SEG ExitIf	IF ConStkPtr<1 THEN		ErrNo=ErrUBCon		ErrMain	END IF	CALL SUB CmpOps	ErrMain	IF ConStkPtr<1 THEN		ErrNo=ErrUBCon		EXIT SEG	END IF	IF SimpleCmp=0 THEN		OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	ELSE		OutBuf=SimpleOp+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ShellX	CALL SUB Expr	IF TDataType<>STRINGVAR THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	ediUsed=TRUE	OutBuf="mov edi,_IOBuffer"	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+TSymName+"; Get src"	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrsystem).ImportFcnUse=TRUE	OutBuf="cinvoke system,[_IOBuffer]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG FPrintX	FileIO=$ffEND SEG PrintXBEGIN SEG FInputX	FileIO=$ffEND SEG  InputXBEGIN SEG BaseX	CALL SUB NexToken	IF TokenBuf<>"0" AND TokenBuf<>"1" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	IF TokenBuf="0" THEN		ArrayBase=0		OutBuf="mov [!ArrayBase],0"	ELSE		ArrayBase=1		OutBuf="mov [!ArrayBase],1"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG DecrXDecInc="dec"END SEG IncrDecrBEGIN SEG IncrX	DecInc="inc"END SEG IncrDecrBEGIN SEG IncrDecr	Target=$ff	CALL SUB Expr	ErrMain	FcnOp1Nam=TSymName	IF DMConst<>0 THEN		ErrNo=ErrIVExp		EXIT SEG	END IF	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	IF DMAddr=0 THEN		IF LAND(VectorBit,TDataMod)=VectorBit THEN			OutBuf="mov esi,["+SymTemp.SymName+"]"			CALL SUB OutFcnCodeData			OutBuf=DecInc+DataTypeName+"[esi]; INC/DEC operand"		ELSE			OutBuf=DecInc+" ["+SymTemp.SymName+"]"		END IF	ELSE		CALL SUB GetVarSiz		IF LAND(VectorBit,TDataMod)=VectorBit THEN			OutBuf="mov esi,["+SymTemp.SymName+"]"			CALL SUB OutFcnCodeData			OutBuf="add [esi],"+STR(VarSize)		ELSE			OutBuf="add ["+SymTemp.SymName+"],"+STR(VarSize)		END IF	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG BufReadX	CALL SUB BufRW	ErrMain	CALL SUB OutReadEND SEG MainLoopBEGIN SEG BufWriteX	CALL SUB BufRW	ErrMain	CALL SUB OutWriteEND SEG MainLoopBEGIN SEG DigitsX	DigDec=$ffEND SEG Decimals1BEGIN SEG DecimalsX	DigDec=0END SEG Decimals1	BEGIN SEG Decimals1	CALL SUB GetIntOp	ErrMain	IF DigDec=0 THEN		OutBuf="mov [_Decimals],eax"	ELSE		OutBuf="mov [_Digits],eax"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ExchangeX	Target=$ff	CALL SUB Expr	ErrMain	IF DMConst<>0 THEN		ErrNo=ErrIVExp		EXIT SEG	END IF	Op1Name=TSymName	Op1Class=OpClass	Op1Type=TDataType	Op1Mod=TDataMod	Op1Detail=TDetail	Op1DataSize=TDataSize	IF Op1Name="NextArg" THEN		ErrNo=ErrIVTarget		EXIT SEG 	END IF	CommaMain	CALL SUB Expr	ErrMain	IF DMConst<>0 THEN		ErrNo=ErrIVExp		EXIT SEG 	END IF	Op2Name=TSymName	Op2Class=OpClass	Op2Type=TDataType	Op2Mod=TDataMod	Op2Detail=TDetail	Op2DataSize=TDataSize	IF Op2Name="NextArg" THEN		ErrNo=ErrIVTarget		EXIT SEG 	END IF	IF Op1Type<>Op2Type THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	IF Op1Class<>CPXClass AND Op1DataSize<>Op2DataSize THEN		IF Op1Type<>STRINGVAR THEN			ErrNo=ErrTypMis			EXIT SEG 		ELSE			IF Op1Detail<>Op2Detail THEN				ErrNo=ErrTypMis				EXIT SEG 			END IF		END IF	END IF	IF Op1Class=CPXClass AND SymTable(Op1Detail).DataSize<>SymTable(Op2Detail).DataSize THEN		ErrNo=ErrTypMis		EXIT SEG 	END IF	IF Op1Class=FLTClass OR Op1Class=INTClass OR Op1Class=BOOLClass THEN		Promote=$ff		SymTemp.SymName=Op1Name		CALL SUB LoadReg		ErrMain		SymTemp.SymName=Op2Name		CALL SUB LoadReg		ErrMain		TempStr=Op1Name		Op1Name=Op2Name		Op2Name=TempStr		CALL SUB StoreD0		ErrMain		OutBuf="mov eax,edx"		CALL SUB OutFcnCodeData		Op1Name=Op2Name		CALL SUB StoreD0		EXIT SEG	END IF	IF Op1Class=CPXClass OR Op1Class=ARRClass OR Op1Type=STRINGVAR THEN		IF LAND(Op1Mod,VectorBit)=0 THEN			OutBuf="mov esi,"+Op1Name		ELSE			OutBuf="mov esi,["+Op1Name+"]"			CALL SUB OutFcnCodeData			OutBuf="mov esi,[esi]"		END IF		CALL SUB OutFcnCodeData		IF LAND(Op1Mod,VectorBit)=0 THEN			OutBuf="mov esi,"+Op2Name		ELSE			OutBuf="mov esi,["+Op2Name+"]"			CALL SUB OutFcnCodeData			OutBuf="mov esi,[esi]"		END IF		CALL SUB OutFcnCodeData		IF Op1Class=ARRClass THEN			TempInt=Op1DataSize		ELSE			IF Op1Type=STRINGVAR THEN				TempInt=Op1Detail			ELSE				TempInt=SymTable(Op1Detail).DataSize			END IF		END IF		INCR LabelNum				OutBuf="mov edx,"+STR(TempInt)			CALL SUB OutFcnCodeData		OutBuf="_Lbl"+STR(LabelNum)+":"		CALL SUB OutFcnCodeData		OutBuf="mov al,[esi]"		CALL SUB OutFcnCodeData		OutBuf="mov ah,[edi]"		CALL SUB OutFcnCodeData		OutBuf="mov [esi],ah"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],al"		CALL SUB OutFcnCodeData		OutBuf="inc esi"		CALL SUB OutFcnCodeData		OutBuf="inc edi"		CALL SUB OutFcnCodeData			OutBuf="dec edx"		CALL SUB OutFcnCodeData		OutBuf="jne "+"_Lbl"+STR(LabelNum)		CALL SUB OutFcnCodeData		EXIT SEG		END IF	ErrNo=ErrIVTypeEND SEG MainLoopBEGIN SEG BeepX	GOSUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	GOSUB GetIntOp	ErrMain	ImportFcnTable(ptrBeep).ImportFcnUse=TRUE	OutBuf="invoke Beep,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ReDimX	IgnoreRightParen=$ff	CALL SUB TokenSym	ErrMain	BufName=SymTemp.SymName	BufDataSize=SymTable(SymNdx).DataAddr	IF LAND(SymTable(SymNdx).DataMod,ReDimBit)<>ReDimBit THEN		ErrNo=ErrTypMis	END IF	CALL SUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	TempInt=0	Ctr1=0	FOR I=SrcNdx TO EndNdx		IF MID(SrcLine,I,1)="," THEN			INCR Ctr1		END IF	NEXT I	IF Ctr1>2 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB Expr	ErrMain	IF TSymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg		EXIT SEG	END IF	OutBuf="imul eax,"+STR(BufDataSize)	CALL SUB OutFcnCodeData	IF DMConst<>0 AND TSymName="0" THEN		CALL SUB ReleaseBuffer	ELSE		CALL SUB GetBuffer	END IFEND SEG MainLoopBEGIN SEG PlayWaveX	CALL SUB Expr	ErrMain	IF OpClass<>STRClass THEN		ErrNo=ErrIVType		EXIT SEG	END IF	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	OutBuf="mov eax,[esi]"	CALL SUB OutFcnCodeData	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [_ArgSafe1],0"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen>0 THEN		CALL SUB Expr		IF OpClass<>INTClass THEN			ErrNo=ErrIVType			EXIT SEG		END IF		IF TSymName<>"~" THEN			D0Loaded=0			CALL SUB LoadReg			ErrMain		END IF		OutBuf="mov _ArgSafe1,eax"		CALL SUB OutFcnCodeData	END IF	ImportFcnTable(ptrsndPlaySound).ImportFcnUse=TRUE	OutBuf="invoke sndPlaySound,[_ArgSafe0],[_ArgSafe1]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EndMacroX	ErrNo=ErrEndmEND SEG MainLoopBEGIN SEG TableX	IF ProcFcnFlag=TRUE THEN		ErrNo=ErrTypeFcn		EXIT SEG	END IF	ArraySize=0	CALL SUB ClrDatTyp	CALL SUB TokenSym	SymNdxSaf=SymNdx	ErrMain	IF SymFound=TRUE THEN		ErrNo=ErrDupSym		EXIT SEG	END IF	CALL SUB NexToken	IF TokenBuf<>"as" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	OutBuf=""	CALL SUB OutInitData	OutBuf="align 4"	CALL SUB OutInitData	OutBuf=SymTemp.SymName+":"	CALL SUB OutInitData	CALL SUB ClrSym	CALL SUB NexToken	SELECT CASE TokenBuf		SymTemp.SubType=NONE		CASE "boolean"			SymTemp.DataType=BOOLVAR			SymTemp.DataAddr=1		CASE "byte"			SymTemp.DataType=BYTEVAR			SymTemp.DataAddr=1		CASE "integer"			SymTemp.DataType=WORDVAR			SymTemp.DataAddr=2		CASE "long"			SymTemp.DataType=LONGVAR			SymTemp.DataAddr=4		CASE "quad"			SymTemp.DataType=QUADVAR			SymTemp.DataAddr=8		CASE "float"			SymTemp.DataType=FLOATVAR			SymTemp.DataAddr=8		CASE "label"			SymTemp.DataType=LABELPTR			SymTemp.DataAddr=4		CASE "string"			SymTemp.DataType=STRINGVAR			IF NextByte<>"*" THEN				TempInt=255; Default string size			ELSE				CALL SUB NexToken; Eat '*'				CALL SUB NexToken				TempStr=TokenSaf				CALL SUB StrSiz				ErrMain			END IF			SymTemp.Detail=TempInt			SymTemp.DataAddr=TempInt			StringLength=TempInt		CASE "file"			SymTemp.DataType=LONGVAR			SymTemp.DataAddr=4			SymTemp.SubType=FILE		CASE "task"			SymTemp.DataType=LONGVAR			SymTemp.DataAddr=4			SymTemp.SubType=TASK		CASE "device"			SymTemp.DataType=LONGVAR			SymTemp.DataAddr=4			SymTemp.SubType=DEVICE		CASE ELSE			TableName=SymTemp.SymName			SymTemp.SymName=TokenSaf			CALL SUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO MainLoop			END IF			IF SymTable(SymNdx).DataType<>TYPE THEN				ErrNo=ErrTypMis				GOTO MainLoop			END IF			TypeNdx=SymNdx			TypeVars=SymTable(SymNdx).Detail			SymTemp.DataType=COMPLEX			SymTemp.Detail=TypeNdx			SymTemp.DataAddr=SymTable(SymNdx).DataSize			SymTemp.SymName=TableName	END SELECT	SymTemp.DataMod=ArrayBit	SymNdx=SymNdxSaf	TDataAddr=SymTemp.DataAddr	CALL SUB SymInsert	ErrMain	TblDataType=SymTemp.DataType	TDataType=TblDataType; Useful only if NOT COMPLEX data type	RepeatFlag=0	TblLoop:	BEGIN LOOP		INCR ArraySize		IF RepeatFlag<>0 THEN			DECR RepeatCnt			IF RepeatCnt=0 THEN				RepeatFlag=0				GOTO TblLoop			END IF			SrcNdx=0			CALL SUB NexToken		ELSE			CALL SUB ReadSource			CALL SUB NexToken			IF TokenBuf="repeat" THEN				RepeatFlag=$ff				CALL SUB NexToken				IF TokenBuf="until" THEN					CALL SUB NexToken					RepeatCnt=VAL(TokenSaf)					RepeatCnt=RepeatCnt-ArraySize+1				ELSE					RepeatCnt=VAL(TokenSaf)+1				END IF				SrcLine=SrcLineSaf				GOTO TblLoop			ELSE				SrcLineSaf=SrcLine			END IF		END IF		IF TempInt=0 THEN			TempStr="EOF in TABLE"			ErrNo=$ff			EXIT SEG		END IF		CONTINUE IF LEN(SrcLine)=0			IF TokenBuf="end" THEN			CALL SUB  NexToken			IF TokenBuf<>"table" THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			SymTable(SymNdxSaf).DataSize=(ArraySize-1)*TDataAddr			OutBuf="; End of table"			CALL SUB OutInitData			CALL SUB MakeLine			CALL SUB OutInitData			OutBuf=""			CALL SUB OutInitData			EXIT SEG		END IF		IF TblDataType=COMPLEX THEN			CALL SUB UnDoToken			FOR I=1 TO TypeVars				CALL SUB NexToken				IF TokenBuf="," THEN					CALL SUB NexToken					IF TokenBuf="," THEN						ErrNo=ErrSyntax						EXIT SEG					END IF				END IF				TDataType=SymTable(TypeNdx+I).DataType				IF TDataType=STRINGVAR THEN					StringLength=SymTable(TypeNdx+I).Detail				END IF				CALL SUB MakeTableEntry				ErrMain				NEXT I		ELSE			CALL SUB MakeTableEntry			ErrMain		END IF	END LOOPEND SEG MainLoopBEGIN SUB MakeTableEntry	SELECT CASE TDataType		CASE BOOLVAR			IF TokenBuf="true" THEN				OutBuf="db 1"			ELSE				IF TokenBuf="false" THEN					OutBuf="db 0"				ELSE					ErrNo=ErrTypMis					EXIT SUB				END IF			END IF			CASE BYTEVAR			CALL SUB ChkConst			ErrRet			IF IVAL(TokenSaf)>255 THEN				ErrNo=ErrOpRange				EXIT SUB			END IF			CALL SUB TblInt			ErrRet			OutBuf="db "+TempStr		CASE WORDVAR			CALL SUB ChkConst			ErrRet			IF IVAL(TokenSaf)>65535 THEN				ErrNo=ErrOpRange				EXIT SUB			END IF			CALL SUB TblInt			ErrRet			OutBuf="dw "+TempStr		CASE LABELPTR			CALL SUB UnDoToken			CALL SUB ChkLabel			ErrRet			OutBuf="dd "+TempStr		CASE LONGVAR			CALL SUB ChkConst			ErrRet			IF IVAL(TokenSaf)>$7fffffff THEN				ErrNo=ErrOpRange				RETURN			END IF			CALL SUB TblInt			ErrRet			OutBuf="dd "+TokenSaf;TempStr		CASE FLOATVAR			;		CASE STRINGVAR			IF TokenType<>TTypQuote THEN				ErrNo=ErrTypMis				EXIT SUB				END IF			IF LEN(TokenSaf)-1>StringLength THEN				TempStr="Oversize string in table"				ErrNo=$ff			EXIT SUB			END IF			IF LEN(TokenSaf)>2 THEN				OutBuf="db "+TokenSaf+",0"			ELSE				OutBuf="db 0"			END IF			FOR Ctr1=1 TO StringLength-LEN(TokenSaf)+1				OutBuf=OutBuf+",0"			NEXT Ctr1	END SELECT	CALL SUB OutInitDataEND SUBBEGIN SUB ChkConst	IF TokenType=TTypInt THEN		EXIT SUB	END IF	IF TokenType=TTypHex THEN		EXIT SUB	END IF	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	TokenSaf=STR(SymTable(SymNdx).Detail)	TokenBuf=TokenSaf	TokenType=TTypIntEND SUBBEGIN SUB TblInt	IF TokenType=TTypInt THEN		CALL SUB ValidInt		IF IntOK=FALSE THEN			ErrNo=ErrIVExp			EXIT SUB		END IF	END IF	IF TokenType=TTypHex THEN		CALL SUB ValidHex		IF HexOK=FALSE THEN			ErrNo=ErrIVExp			EXIT SUB		END IF	END IF	TempStr=TokenSafEND SUBBEGIN SEG EndTableX	TempStr="END TABLE while not in table"	ErrNo=$ffEND SEG MainLoopBEGIN SEG IncludeX	UseFilNam=""	BEGIN LOOP		CALL SUB NexToken		EXIT IF TokenLen=0		UseFilNam=UseFilNam+TokenSaf	END LOOP	ON ERROR GOTO NoUseFile	INCR InpFilPtr	IF InpFilPtr>20 THEN		TempStr="Include Stack OverFlow"		ErrNo=$ff		EXIT SEG	END IF	OPEN UseFilNam FOR INPUT AS InpFile(InpFilPtr)	ON ERROREND SEG MainLoopBEGIN SEG NoUseFile	TempStr="Cannot Open Include File: "	CALL SUB ShowErrorEND SEG MainLoopBEGIN SEG SetEOFX	DiskIO=$ff	CALL SUB GetFileHandle	ErrMain	IF TSubType=DEVICE THEN		ErrNo=ErrDevice		EXIT SEG	END IF	ImportFcnTable(ptrSetEndOfFile).ImportFcnUse=TRUE	OutBuf="invoke SetEndOfFile,[_IOPthNum]"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZEND SEG MainLoopBEGIN SEG SetVecX	CALL SUB TokenSym	ErrMain	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	VectorName=SymTemp.SymName	VDataMod=SymTable(SymNdx).DataMod	VDataAddr=SymTable(SymNdx).DataAddr	IF SymTable(SymNdx).DataType=STRINGVAR THEN		VDetail=SymTable(SymNdx).Detail	ELSE		VDetail=0	END IF	IF LAND(VDataMod,VectorBit)=0 THEN; Not a vector		ErrNo=ErrTypMis		EXIT SEG	END IF	EqualMain	CALL SUB NexToken	IF TokenBuf="[" THEN		CALL SUB RightBracket		ErrMain		CALL SUB Expr		MID(SrcLine,SrcLineMod,1)="]"		ErrMain		IF TDataType<>LABELPTR THEN			ErrNo=ErrTypMis			EXIT SEG		END IF		OutBuf="mov eax,[esi]"		CALL SUB OutFcnCodeData		SymTemp.SymName=VectorName		CALL SUB SymSrch		SymNdx=SymTable(SymNdx).Detail		TempInt=SymTable(SymNdx).DataSize		OutBuf="sub eax,"+STR(TempInt)		CALL SUB OutFcnCodeData		OutBuf="mov ["+VectorName+"],eax"		CALL SUB OutFcnCodeData		GOTO MainLoop	ELSE		CALL SUB UnDoToken		CALL SUB GetIntOp		ErrMain		IF LAND(VDataMod,ArrayBit)=ArrayBit THEN			TempInt=ArrayBase*VDataAddr			OutBuf="sub eax,"+STR(TempInt)			CALL SUB OutFcnCodeData		END IF		OutBuf="mov ["+VectorName+"],eax"		CALL SUB OutFcnCodeData		IF VDetail<>0 THEN;  must be STRING.. do rest of vector			CALL SUB NexToken			IF TokenLen=0 THEN				OutBuf="mov ["+VectorName+"+4],"+STR(VDetail)			ELSE				IF TokenBuf<>"," THEN					ErrNo=ErrSyntax					GOTO MainLoop				END IF				CALL SUB GetIntOp				ErrMain				OutBuf="mov ["+VectorName+"+4],eax"			END IF			CALL SUB OutFcnCodeData			OutBuf="mov ["+VectorName+"+8],0"			CALL SUB OutFcnCodeData		END IF	END IFEND SEG MainLoopBEGIN SEG SetPositionX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CALL SUB SetPos	ErrMain	CALL SUB SetPosFromTableEND SEG MainLoopBEGIN SEG SetPixelX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	ImportFcnTable(ptrSetPixel).ImportFcnUse=TRUE	OutBuf="invoke SetPixel, dword [edi+HDCOffs],[_ArgSafe0],[_ArgSafe1],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetCursorX	ErrGUI	CALL SUB GetIntOp	ErrMain	IF TSubType<>CURSOR THEN		ErrNo=ErrIVType		EXIT SEG	END IFEND SEG SetCursorCommonBEGIN SEG SetStockCursorX	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "appstarting"			TempStr="IDC_APPSTARTING"		CASE "arrow"			TempStr="IDC_ARROW"		CASE "cross"			TempStr="IDC_CROSS"		CASE "hand"			TempStr="IDC_HAND"		CASE "help"			TempStr="IDC_HELP"		CASE "ibeam"			TempStr="IDC_IBEAM"		CASE "no"			TempStr="IDC_NO"		CASE "size"			TempStr="IDC_SIZEALL"		CASE "sizeall"			TempStr="IDC_SIZEALL"		CASE "sizenesw"			TempStr="IDC_SIZENESW"		CASE "sizens"			TempStr="IDC_SIZENS"		CASE "sizenwse"			TempStr="IDC_SIZENWSE"		CASE "sizewe"			TempStr="IDC_SIZEWE"		CASE "uparrow"			TempStr="IDC_UPARROW"		CASE "wait"			TempStr="IDC_WAIT"		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop		END SELECT	OutBuf="invoke LoadCursor,0,"+TempStr	CALL SUB OutFcnCodeDataEND SEG SetCursorCommonBEGIN SEG SetCursorCommon	OutBuf="mov [!CursorFlag],1"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetCursor).ImportFcnUse=TRUE	OutBuf="invoke SetCursor,eax"	CALL SUB OutFcnCodeData	CALL SUB SetStatusEND SEG MainLoopBEGIN SEG SetDefaultCursorX	OutBuf="mov [!CursorFlag],0"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!OBMain+CursorOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetCursor).ImportFcnUse=TRUE	OutBuf="invoke SetCursor,eax"	CALL SUB OutFcnCodeData	CALL SUB SetStatusEND SEG MainLoopBEGIN SEG SetToolTipColorX	ErrGUI	ErrMain	CALL SUB GetIntOp	ErrMain	OutBuf="invoke SendMessage, dword [!ToolTip],WM_USER+19,eax,0"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="invoke SendMessage, dword [!ToolTip],WM_USER+20,eax,0"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetCursorFlagX	ErrGUI	CALL SUB NexToken	IF TokenBuf="true" THEN		OutBuf="mov [!CursorFlag],1"	ELSE		IF TokenBuf="false" THEN			OutBuf="mov [!CursorFlag],0"		ELSE			ErrNo=ErrSyntax		END IF	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetCaptureX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrSetCapture).ImportFcnUse=TRUE	OutBuf="invoke SetCapture, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetStyleX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB NexToken	TempStr=TokenSaf	CommaMain	CALL SUB NexToken	CALL SUB ediUsedCheck	ImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke GetWindowLong, dword ["+HandleName+"],GWL_STYLE"	CALL SUB OutFcnCodeData	SELECT CASE TokenBuf		CASE "true"			OutBuf="or eax,"+TempStr		CASE "false"			OutBuf="not eax"			CALL SUB OutFcnCodeData			OutBuf="or eax,"+TempStr			CALL SUB OutFcnCodeData			OutBuf="not eax"		CASE ELSE			ErrNo=ErrIVType			EXIT SEG	END SELECT	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_STYLE,eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetMenuItemBitmapsX	CALL SUB NexToken	ObjectName=TokenSaf	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	SymTemp=SymTable(SymNdx)	IF SymTemp.SubType<>MENU THEN		ErrNo=ErrIVType		EXIT SEG	END IF	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	IF TSubType<>BITMAP THEN		ErrNo=ErrIVType		EXIT SEG	END IF	CommaMain	CALL SUB GetIntOp	ErrMain	IF TSubType<>BITMAP THEN		ErrNo=ErrIVType		EXIT SEG	END IF	ImportFcnTable(ptrSetMenuItemBitmaps).ImportFcnUse=TRUE	OutBuf="invoke SetMenuItemBitmaps,["+ObjectName+"],[_ArgSafe0],MF_BYCOMMAND,[_ArgSafe1],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetTaskPriorityX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType<>TASK THEN		ErrNo=ErrIVType		EXIT SEG	END IF	TSubType=SymTable(SymNdx).SubType	FcnName="!"+TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrSetThreadPriority).ImportFcnUse=TRUE	OutBuf="invoke SetThreadPriority,["+FcnName+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ChDirX	CALL SUB GetFileName	ErrMain	ImportFcnTable(ptrSetCurrentDirectory).ImportFcnUse=TRUE	OutBuf="invoke SetCurrentDirectory,[_IOBuffer]"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZ END SEG MainLoopBEGIN SEG MkDirX	CALL SUB GetFileName	ErrMain	ImportFcnTable(ptrCreateDirectory).ImportFcnUse=TRUE	OutBuf="invoke CreateDirectory,[_IOBuffer],0"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZEND SEG MainLoopBEGIN SEG RmDirX	CALL SUB GetFileName	ErrMain	ImportFcnTable(ptrRemoveDirectory).ImportFcnUse=TRUE	OutBuf="invoke RemoveDirectory,[_IOBuffer]"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZEND SEG MainLoopBEGIN SEG EndFcnX	IF FcnFlag=FALSE THEN		ErrNo=ErrEndFcn		EXIT SEG	END IF	; Put default return data here	SELECT CASE TFcnDataType		CASE BOOLVAR			OutBuf="mov [_BoolRet],0"		CASE LONGVAR			OutBuf="mov [_LongRet],0"		CASE STRINGVAR			ediUsed=TRUE			OutBuf="mov edi,_NullStr"			CALL OutFunction			OutBuf="mov [_StringRet],edi"			CALL OutFunction			OutBuf="mov [_StringRet+4],0"			CALL OutFunction			OutBuf="mov [_StringRet+8],0"		CASE FLOATVAR	END SELECT	CALL OutFunction	OutBuf="ret"	CALL OutFunction	CALL SUB MakeLine	CALL OutFunction	FcnFlag=FALSE	ProcFcnFlag=FALSE	CodeBlockFlag=FALSEEND SEG MainLoopBEGIN SUB MakeLine	OutBuf=";________________________________________________________________________________________________________________________________"END SUBBEGIN SEG EndProcX	IF ProcFlag=FALSE THEN		ErrNo=ErrEndProc		EXIT SEG	END IF	OutBuf="ret"	CALL OutFunction	CALL SUB MakeLine	CALL OutFunction	ProcFlag=FALSE	ProcFcnFlag=FALSE	CodeBlockFlag=FALSEEND SEG MainLoopBEGIN SEG DeclareX	CALL SUB NexToken	SymTemp.DataMod=UsrFcnBit	IF TokenBuf="proc" THEN		ProcFcn=0		SymTemp.DataType=PROC	ELSE		IF TokenBuf="fcn" THEN			ProcFcn=$ff			SymTemp.DataType=FCN		ELSE			ErrNo=ErrSyntax			EXIT SEG		END IF	END IF	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=TRUE THEN		ErrNo=ErrDupSym		EXIT SEG	END IF	Ctr3=0	CALL SUB NexToken	IF TokenSaf<>"(" THEN		IF ProcFcn=0 THEN			GOTO ProcFcnDone		ELSE			ErrNo=ErrSyntax			EXIT SEG		END IF	END IF	NeedComma=FALSE	DeclareLoop:	CALL SUB NexToken	IF TokenBuf=")" THEN		IF ProcFcn=0 THEN			GOTO ProcFcnDone		ELSE			CALL SUB NexToken			IF TokenBuf<>"as" THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			CALL SUB NexToken			IF TokenLen=0 THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			SELECT CASE TokenBuf				CASE "boolean"					SymTemp.FcnDataType=BOOLVAR				CASE "integer"					SymTemp.FcnDataType=LONGVAR				CASE "string"					SymTemp.FcnDataType=STRINGVAR				CASE "float"					SymTemp.FcnDataType=FLOATVAR				CASE ELSE					ErrNo=ErrSyntax					EXIT SEG			END SELECT			GOTO ProcFcnDone		END IF	ELSE		IF NeedComma=TRUE THEN			IF TokenSaf<>"," THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			NeedComma=FALSE			GOTO DeclareLoop		ELSE			IF TokenSaf="," THEN				ErrNo=ErrSyntax				EXIT SEG			END IF		END IF		INCR Ctr3		IF Ctr3>7 THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		SELECT CASE TokenBuf			CASE "boolean"				TempInt=BOOLVAR			CASE "integer"				TempInt=LONGVAR			CASE "string"				TempInt=STRINGVAR			CASE "float"				TempInt=FLOATVAR			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG		END SELECT		SELECT CASE Ctr3			CASE 1				SymTemp.DataAddr=TempInt			CASE 2				SymTemp.DataSize=TempInt			CASE 3				SymTemp.ArrayDim1=TempInt			CASE 4				SymTemp.ArrayDim2=TempInt			CASE 5				SymTemp.ArrayDim3=TempInt			CASE 6				SymTemp.ArrayDims=TempInt			CASE 7				SymTemp.Misc=TempInt		END SELECT		NeedComma=TRUE		GOTO DeclareLoop	END IF	ProcFcnDone:	IF ProcFcn=$ff THEN		IF Ctr3=0 THEN			ErrNo=ErrSyntax			EXIT SEG		END IF	END IF	SymTemp.FcnArgs=Ctr3	SymTemp.Detail=LabelUnresolved	CALL SUB SymInsertEND SEG MainLoopBEGIN SEG BeginFcnX	CALL SUB FcnFlagChk	ErrMain	FcnFlag=TRUE	ProcFcnFlag=TRUE	CodeBlockFlag=TRUE	CALL SUB ProcFcnPrep	CALL SUB PopArgs	ErrMainEND SEG MainLoopBEGIN SEG BeginProcX	CALL SUB FcnFlagChk	ErrMain	ProcFlag=TRUE	ProcFcnFlag=TRUE	CodeBlockFlag=TRUE	CALL SUB ProcFcnPrep	IF SymTemp.FcnArgs<>0 THEN		CALL SUB PopArgs		ErrMain	END IFEND SEG MainLoopBEGIN SUB FcnFlagChk	IF CodeBlockFlag=TRUE THEN		ErrNo=ErrFSNest		EXIT SUB	END IFEND SUBBEGIN SEG ContinueX	IF ConStk(ConStkPtr).ContLabel=-1 THEN		TempStr="CONTINUE inside IF block"		ErrNo=$ff		EXIT SEG	END IF	IF ConStkPtr<1 THEN		ErrNo=ErrUBCon		EXIT SEG	END IF	CALL SUB NexToken	IF TokenLen=0 THEN		OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).ContLabel)		CALL SUB OutFcnCodeData		EXIT SEG	END IF	IF TokenBuf<>"if" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	IF ConStkPtr<1 THEN		ErrNo=ErrUBCon		EXIT SEG	END IF	TempInt=ConStk(ConStkPtr).ConType	IF TempInt<0 OR TempInt>5 THEN; Everything except Select Case		ErrNo=ErrUBCon		EXIT SEG	END IF	CALL SUB CmpOps	ErrMain	IF SimpleCmp=0 THEN		OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).ContLabel)	ELSE		OutBuf=SimpleOp+"_Lbl"+STR(ConStk(ConStkPtr).ContLabel)	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SelectObjectX			ErrGUI			GUITargetFlag=$ff			CALL SUB ValidateObject			ErrMain			CommaMain			CALL SUB NexToken			GUITempName=TokenSaf			SymTemp.SymName=TokenSaf			CALL SUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				EXIT SEG			END IF			TSubType=SymTable(SymNdx).SubType			IF TSubType<>SOLIDBRUSH AND TSubType<>HATCHBRUSH AND TSubType<>PATTERNBRUSH AND TSubType<>PEN AND TSubType<>FONT THEN				ErrNo=ErrIVType				EXIT SEG			END IF			CALL SUB ediUsedCheck			OutBuf="mov ebx,[edi+HDCOffs]"			CALL SUB OutFcnCodeData			ImportFcnTable(ptrSelectObject).ImportFcnUse=TRUE			OutBuf="invoke SelectObject,ebx,[ dword "+GUITempName+"]"			CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SelectX	CALL SUB NexToken	IF TokenBuf="case" THEN		IF SelectFlag=TRUE THEN			ErrNo=ErrUBCon			EXIT SEG		END IF		SelectFlag=TRUE			CALL SUB Expr		ErrMain		IF OpClass<>STRClass AND OpClass<>INTClass THEN			ErrNo=ErrIVType			EXIT SEG		END IF		IF OpClass=INTClass AND TSymName<>"~" THEN			D0Loaded=0			CALL SUB LoadReg			ErrMain		END IF		SwitchClass=OpClass		IF OpClass=INTClass THEN			OutBuf="mov [_SwitchInt],eax"		ELSE			ediUsed=TRUE			OutBuf="mov edi,["+TSymName+"]"			CALL SUB OutFcnCodeData			OutBuf="mov [_SwitchStr],edi"			CALL SUB OutFcnCodeData			OutBuf="mov edi,["+TSymName+"+4]"			CALL SUB OutFcnCodeData			OutBuf="mov [_SwitchStr+4],edi"			CALL SUB OutFcnCodeData			OutBuf="mov edi,["+TSymName+"+8]"			CALL SUB OutFcnCodeData			OutBuf="mov [_SwitchStr+8],edi"		END IF		CALL SUB OutFcnCodeData		CALL SUB IncConStk		ErrMain		ConStk(ConStkPtr).ConLine=BasicLineCtr		ConStk(ConStkPtr).ConType=7		INCR LabelNum		ConStk(ConStkPtr).TermLabel=LabelNum	ELSE		ErrNo=ErrSyntax	END IFEND SEG MainLoopBEGIN SEG EndSelectX	IF SelectFlag=FALSE THEN		ErrNo=ErrUBCon		GOTO MainLoop	END IF	IF CaseFlag=TRUE THEN		CALL SUB EndCasex		CaseFlag=FALSE	END IF	SelectFlag=FALSE	CaseElseFlag=FALSE	TempInt=7	CALL SUB ConStkChk	ErrMain	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"	CALL SUB OutFcnCodeData	DECR ConStkPtrEND SEG MainLoop BEGIN SEG CaseX	IF SelectFlag=FALSE OR CaseElseFlag=TRUE THEN		ErrNo=ErrUBCon		EXIT SEG	END IF	IF CaseFlag=TRUE THEN		CALL SUB EndCasex	END IF	CaseFlag=TRUE	INCR LabelNum	ConStk(ConStkPtr).ConLine=BasicLineCtr	ConStk(ConStkPtr).ConType=7	ConStk(ConStkPtr).ContLabel=LabelNum	CALL SUB NexToken	IF TokenBuf="else" THEN		CaseElseFlag=TRUE	ELSE		CALL SUB UnDoToken		CALL SUB Expr		ErrMain		IF OpClass<>STRClass AND OpClass<>INTClass THEN			ErrNo=ErrIVType			EXIT SEG		END IF		IF OpClass=INTClass AND TSymName<>"~" THEN			D0Loaded=0			CALL SUB LoadReg			ErrMain		END IF		IF OpClass<>SwitchClass THEN			ErrNo=ErrTypMis			EXIT SEG		END IF		CaseToFlag=FALSE		CALL SUB NexToken		IF TokenLen<>0 THEN			IF TokenBuf="to" THEN				CaseToFlag=TRUE			ELSE				ErrNo=ErrSyntax				EXIT SEG			END IF		END IF		IF CaseToFlag=FALSE THEN			SymType="jne "			CALL SUB GenCase		ELSE			SymType="jg "			CALL SUB GenCase			; Get second arg here			D0Loaded=0			CALL SUB Expr			ErrMain			IF OpClass<>STRClass AND OpClass<>INTClass THEN				ErrNo=ErrIVType				GOTO MainLoop			END IF			IF OpClass=INTClass AND TSymName<>"~" THEN				D0Loaded=0				CALL SUB LoadReg				ErrMain			END IF			IF OpClass<>SwitchClass THEN				ErrNo=ErrTypMis				GOTO MainLoop			END IF			SymType="jl "			CALL SUB GenCase 			END IF	END IF	END SEG MainLoopBEGIN SEG EndCase	IF SelectFlag=FALSE OR CaseFlag=FALSE THEN		ErrNo=ErrUBCon		EXIT Seg	END IF	CaseFlag=FALSE	CALL SUB EndCasexEND SEG MainLoopBEGIN SEG ProgramX	StartFlag=TRUEEND SEG MainLoopBEGIN SEG MakeLowerX	CALL SUB GetStringOp	ErrMain	OutBuf="mov esi,"GetStringOp	CALL SUB OutFcnCodeData	UseLCase=TRUE	OutBuf="call __LCase"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG MakeUpperX	CALL SUB GetStringOp	ErrMain	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	UseUCase=TRUE	OutBuf="call __UCase"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG TextBlockX	UseData=TRUE	CALL SUB TokenSym	ErrMain	IF SymFound=TRUE THEN		ErrNo=ErrDupSym		GOTO MainLoop	END IF	CALL SUB ClrDatTyp	TDataType=LABELVAR	SymTemp.DataType=LABELVAR	CALL SUB ClrSym	SymTemp.DataMod=DataBit	SymTemp.Detail=LabelResolved	CALL SUB SymInsert	ErrMain	OutBuf=SymTemp.SymName+":"	CALL SUB OutInitData	TextLoop:	CALL SUB ReadSource	IF TempInt=0 THEN		TempStr="EOF in Text"		ErrNo=$ff		EXIT SEG	END IF	OutBuf=" db "+CHR(OBQUOTE)+SrcLine+CHR(OBQUOTE)+",0"	CALL SUB OutInitData	CALL SUB NexToken	IF TokenBuf="end" THEN		CALL SUB NexToken		IF TokenBuf="text" THEN			EXIT SEG		ELSE			GOTO TextLoop		END IF	END IF	IF TokenBuf<>"endtext" THEN TextLoopEND SEG MainLoopBEGIN SEG EndTextX	TempStr="EndText while not in TEXT"	ErrNo=$ffEND SEG MainLoopBEGIN SEG EndTypeX	TempStr="END TYPE while not in TYPE or Empty TYPE Declaration"	ErrNo=$ffEND SEG MainLoopBEGIN SEG MoveWindowX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CALL SUB SetPos	ErrMain	UseSetRightBottom=TRUE	OutBuf="call __SetRightBottom"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrMoveWindow).ImportFcnUse=TRUE	OutBuf="invoke MoveWindow, dword ["+HandleName+"], dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs],TRUE"	CALL SUB OutFcnCodeData	CALL SUB SetPosFromTableEND SEG MainLoopBEGIN SEG GetDCX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrGetDC).ImportFcnUse=TRUE	OutBuf="invoke GetDC, dword ["+HandleName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="mov [edi+HDCOffs],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetCursorPositionX	ErrGUI	ImportFcnTable(ptrGetCursorPos).ImportFcnUse=TRUE	OutBuf="invoke GetCursorPos,CursorPosX"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ScreenToClientX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrScreenToClient).ImportFcnUse=TRUE	OutBuf="invoke ScreenToClient, dword ["+HandleName+"],CursorPosX"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetWindowRectX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrGetWindowRect).ImportFcnUse=TRUE	OutBuf="invoke GetWindowRect, dword ["+HandleName+"],RectLeft"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetClientRectX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrGetClientRect).ImportFcnUse=TRUE	OutBuf="invoke GetClientRect, dword ["+HandleName+"],RectLeft"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetPixelX	ErrGUI	GUITargetFlag=$ff;???	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	ImportFcnTable(ptrGetPixel).ImportFcnUse=TRUE	OutBuf="invoke GetPixel, dword [edi+HDCOffs],[_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CALL SUB SetStatusEND SEG MainLoopBEGIN SEG ReleaseDCX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrReleaseDC).ImportFcnUse=TRUE	OutBuf="invoke ReleaseDC, dword ["+HandleName+"], dword [edi+HDCOffs]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ReleaseCaptureX	ErrGUI	ImportFcnTable(ptrReleaseCapture).ImportFcnUse=TRUE	OutBuf="invoke ReleaseCapture"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG BeginPaintX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrBeginPaint).ImportFcnUse=TRUE	OutBuf="invoke BeginPaint, dword ["+HandleName+"],PaintStruct"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EndPaintX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrEndPaint).ImportFcnUse=TRUE	OutBuf="invoke EndPaint, dword ["+HandleName+"],PaintStruct"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG InvalidateRectX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CreateX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	TSubType=SymTable(SymNdx).SubType	SELECT CASE TSubType		CASE FONT			CALL SUB UnDoToken			GOTO CreateFontX		CASE BITMAP			CALL SUB UnDoToken			GOTO CreateImageX		CASE ICON			CALL SUB UnDoToken			GOTO CreateIconX		CASE CURSOR			CALL SUB UnDoToken			GOTO CreateCursorX		CASE IMAGELIST			GOTO CreateImageListX		CASE TASK			GOTO CreateTaskX		CASE SOLIDBRUSH			GOTO CreateSolidBrushX		CASE HATCHBRUSH			GOTO CreateHatchBrushX		CASE PATTERNBRUSH			GOTO CreatePatternBrushX		CASE PEN			GOTO CreatePenX	END SELECT	CALL SUB UnDoToken	GUITargetFlag=$ff	CreateObjectFlag=TRUE	InFlag=False	ChildFlag=FALSE	CALL SUB ValidateObject	ErrMain	CALL SUB SetPos	ErrMain	ObjectTypeSafe=ObjectType-99	ObjectNameSafe=ObjectName	TempExStyleStr=ObjTable(ObjectTypeSafe).ObjExStyle	SETVECTOR StyleArray=[ObjTable(ObjectTypeSafe).ObjStyleTable]	TempStr="default"	CALL SUB FindStyle	ErrMain	StyleCode=StyleArray(I).StyleValue	IF NextByte="," THEN; Style Arg		StyleCode=0		CALL SUB NexToken; Eat the comma		BEGIN LOOP			EXIT IF NextByte=" " OR NextByte=","			CALL SUB NexToken			EXIT IF TokenLen=0			IF TokenBuf<>"+" THEN				TempStr=TokenBuf				CALL SUB FindStyle				ErrMain				StyleCode=StyleCode+StyleArray(I).StyleValue			END IF		END LOOP	END IF	TempStyleStr="$"+HEX(StyleCode)	ObjectParent="!OBMain"	INCR ObjectID	OutBuf="mov [_ArgSafe3],0"	CALL SUB OutFcnCodeData	BEGIN LOOP		CALL SUB NexToken		EXIT IF TokenLen=0		SELECT CASE TokenBuf			CASE "child"				IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				ChildFlag=TRUE			CASE "in"				IF ObjectTypeSafe=ptrFORM OR ObjectTypeSafe=ptrTOOLWINDOW THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB NexToken				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=TRUE AND SymTable(SymNdx).SubType=FAMILY THEN					OutBuf="mov [_ArgSafe3],"+STR(SymTable(SymNdx).Detail)					CALL SUB OutFcnCodeData				ELSE					CALL SUB UnDoToken					CALL SUB ValidateParentObject					ErrMain					InFlag=TRUE				END IF			CASE "topmost"				IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN								ErrNo=ErrSyntax					EXIT SEG			END IF			FormExStyle=FormExStyle+"+WS_EX_TOPMOST"			CASE "appwindow"				IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN								ErrNo=ErrSyntax					EXIT SEG				END IF				FormExStyle=FormExStyle+"+WS_EX_APPWINDOW"			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG		END SELECT	END LOOP	INCR LabelNum	TempStr="!ControlType"+STR(ObjectTypeSafe)	IF ObjectTypeSafe=ptrFORM OR ObjectTypeSafe=ptrTOOLWINDOW THEN; FORM		OutBuf="!"+ObjectName+"WindowClass WNDCLASS"		CALL SUB OutInitData		OutBuf="!"+ObjectName+"Class db '"+ObjectName+"',0"		CALL SUB OutInitData		ImportFcnTable(ptrLoadIcon).ImportFcnUse=TRUE		OutBuf="invoke LoadIcon,0,IDI_APPLICATION"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.hIcon],eax"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrLoadCursor).ImportFcnUse=TRUE		OutBuf="invoke LoadCursor,0,IDC_ARROW"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+CursorOffs],eax"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.hCursor],eax"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.style],0"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.lpfnWndProc],!"+ObjectName+"Proc"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.cbClsExtra],0"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.cbWndExtra],0"		CALL SUB OutFcnCodeData		OutBuf="mov eax,[!hinstance]"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.hbrBackground],COLOR_BTNFACE+1"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.lpszMenuName],0"			CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"WindowClass.lpszClassName],!"+ObjectName+"Class"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrRegisterClass).ImportFcnUse=TRUE		OutBuf="invoke RegisterClass,!"+ObjectName+"WindowClass"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+HandleOffs],0"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+IDOffs],1"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+ArrayOffs],0"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+ForeColorOffs],$ffffff"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+BackColorOffs],$ffffffff"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+TypeOffs],!CT_FORM"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+ControlBrushOffs],0"		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+InterceptSafeOffs],!"+ObjectName+"Proc"		CALL SUB OutFcnCodeData		IF ChildFlag=TRUE THEN			ObjectParent="[!OBMain]"		ELSE			ObjectParent="NULL"		END IF		UseSetRightBottom=TRUE		OutBuf="call __SetRightBottom"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE		OutBuf="invoke CreateWindowEx,"+FormExStyle+",!"+ObjectName+"Class,!title,WS_VISIBLE+WS_OVERLAPPEDWINDOW,dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs], dword "+ObjectParent+",NULL,[!hinstance],0"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		OutBuf="invoke SetWindowLong,[!"+ObjectName+"+HandleOffs],GWL_USERDATA,!"+ObjectName		CALL SUB OutFcnCodeData		OutBuf="mov dword [!"+ObjectName+"+StatusOffs],$07"		CALL SUB OutFcnCodeData		OutBuf="mov eax,[_ArgSafe3]"		CALL SUB OutFcnCodeData		OutBuf="mov [!"+ObjectName+"+FamilyOffs],eax"		CALL SUB OutFcnCodeData		OutBuf="proc !"+ObjectName+"Proc"+",!hwnd,wmsg,wparam,lparam"		CALL OutProc		OutBuf="enter"		CALL OutProc		OutBuf="push ebx esi edi"		CALL OutProc		OutBuf="mov [!PassEvent],0"		CALL OutProc		OutBuf="mov ebx,[wmsg]"		CALL OutProc		OutBuf="cmp ebx,WM_GETMINMAXINFO"		CALL OutProc		OutBuf="jne "+ObjectName+"NotwmGetMaxInfo"		CALL OutProc		OutBuf="mov dword edi,[!hwnd]"		CALL OutProc		OutBuf="mov dword [!"+ObjectName+"+HandleOffs],edi"		CALL OutProc		OutBuf="mov dword [!"+ObjectName+"+OwnerOffs],0"		CALL OutProc		OutBuf="jmp !DefWndProc"		CALL OutProc		OutBuf=ObjectName+"NotwmGetMaxInfo:"		CALL OutProc		OutBuf="mov esi,!"+ObjectName		CALL OutProc		OutBuf="cmp ebx,WM_DESTROY"		CALL OutProc		OutBuf="jne !WinProcCommon"		CALL OutProc		ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE		OutBuf="invoke DeleteObject,dword [esi+ControlBrushOffs]"		CALL OutProc		OutBuf="jmp !DefWndProc"		CALL OutProc		EXIT SEG	END IF	UseSetRightBottom=TRUE	OutBuf="call __SetRightBottom"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE	OutBuf="invoke CreateWindowEx,"+TempExStyleStr+","+TempStr+",NULL,"+TempStyleStr+", dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs], dword ["+ObjectParent+"],"+STR(ObjectID)+",[!hinstance],0"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+HandleOffs],eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong, dword eax,GWL_USERDATA,edi"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+TTcbSizeOffs],44"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[_ArgSafe3]"	CALL SUB OutFcnCodeData	OutBuf="mov [edi+FamilyOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+TTuFlagsOffs],TTF_IDISHWND+TTF_SUBCLASS"	CALL SUB OutFcnCodeData	OutBuf="mov dword eax,[edi+HandleOffs]"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+TTuIDOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,edi"	CALL SUB OutFcnCodeData	OutBuf="add eax,TTTextOffs"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+TTlpszTextOffs],eax"	CALL SUB OutFcnCodeData	IF ObjectTypeSafe=ptrRICHEDIT THEN		RichEdLibUsed=TRUE	END IF	IF ObjectTypeSafe=ptrRAEdit THEN		RAEditLibUsed=TRUE	END IF	IF ObjectTypeSafe=ptrRAGrid THEN		RAGridLibUsed=TRUE	END IF	IF ObjectTypeSafe=ptrDRAWPROGRESS THEN		DrawProgressLibUsed=TRUE	END IF	IF ObjectTypeSafe=ptrButtonEx THEN		ButtonExLibUsed=TRUE	END IF	IF ObjectTypeSafe=ptrWEB_BROWSER THEN		WebBrowserLibUsed=TRUE	END IF	IF ObjectTypeSafe=ptrCOMBOBOX THEN		ImportFcnTable(ptrGetComboBoxInfo).ImportFcnUse=TRUE			OutBuf="invoke GetComboBoxInfo, dword ["+HandleName+"],!cbSize"		CALL SUB OutFcnCodeData		OutBuf="mov eax,[!hwndCombo]"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"		CALL SUB OutFcnCodeData		OutBuf="mov eax,[!hwndItem]"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"		CALL SUB OutFcnCodeData		OutBuf="mov eax,[!hwndList]"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"		CALL SUB OutFcnCodeData	END IF		ObjectName=ObjectNameSafe	ObjectNameSafe="!"+ObjectName	IF InFlag=TRUE THEN		IF LAND(SymTable(SymNdx).DataMod,SubClassedBit)=0 THEN			INCR ProcNum			TDataMod=SymTable(SymNdx).DataMod			TDataMod=LOR(TDataMod,SubClassedBit)			SymTable(SymNdx).DataMod=TDataMod			INCR SCLabelNum			OutBuf="bts dword ["+ObjectParentName+"+StatusOffs],WinSubClassed"			CALL SUB OutFcnCodeData			OutBuf="jc _SCLbl"+STR(SCLabelNum)			CALL SUB OutFcnCodeData			ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE			OutBuf="invoke SetWindowLong, dword ["+ObjectParent+"],GWL_WNDPROC,!SubClassProc"			CALL SUB OutFcnCodeData			OutBuf="mov ["+ObjectParentName+"+OldProcOffs],eax"			CALL SUB OutFcnCodeData			OutBuf="_SCLbl"+STR(SCLabelNum)+":"			CALL SUB OutFcnCodeData				IF SubClassFlag=FALSE THEN				RESTORE SubClassProc				CALL SUB OutLibCodeText				SubClassFlag=TRUE			END IF			ImportFcnTable(ptrCallWindowProc).ImportFcnUse=TRUE				END IF	END IF	OutBuf="mov dword [edi+TypeOffs],"+STR(ObjectTypeSafe+99)	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+IDOffs],"+STR(ObjectID)	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+ObjectParent+"]"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+OwnerOffs],eax"	CALL SUB OutFcnCodeData	IF GUIArrayFlag=0 THEN		OutBuf="mov dword [edi+ArrayOffs],0"		CALL SUB OutFcnCodeData		OutBuf="mov dword [edi+StatusOffs],$07"	ELSE		OutBuf="mov eax,[ArrayIndex]"		CALL SUB OutFcnCodeData		OutBuf="mov dword [edi+ArrayOffs],eax"		CALL SUB OutFcnCodeData		OutBuf="mov dword [edi+StatusOffs],$27"	END IF	CALL SUB OutFcnCodeData	IF ObjectTypeSafe=ptrCOMBOBOX OR ObjectTypeSafe=ptrTEXTBOX OR ObjectTypeSafe=ptrLISTBOX OR ObjectTypeSafe=ptrRAGrid THEN		OutBuf="mov dword [edi+BackColorOffs],$ffffff"		CALL SUB OutFcnCodeData	ELSE		IF ObjectTypeSafe=ptrRAEdit THEN			OutBuf="mov dword [edi+BackColorOffs],$c0f0f0"			CALL SUB OutFcnCodeData		ELSE		OutBuf="mov dword [edi+BackColorOffs],$ffffffff"			CALL SUB OutFcnCodeData		END IF	END IF	OutBuf="mov dword [edi+ForeColorOffs],$ffffff"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+ControlBrushOffs],0"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke GetWindowLong,dword [edi+HandleOffs],GWL_WNDPROC"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+InterceptSafeOffs],eax"	CALL SUB OutFcnCodeData	IF ObjectTypeSafe=ptrSCROLLBAR THEN		OutBuf="invoke SendMessage, dword [edi+HandleOffs],SBM_SETRANGE,0,100"		CALL SUB OutFcnCodeData		OutBuf="mov  dword [edi+ScrollBarPageOffs],20"		CALL SUB OutFcnCodeData		OutBuf="mov  dword [edi+ScrollBarMinOffs],0"		CALL SUB OutFcnCodeData		OutBuf="mov  dword [edi+ScrollBarMaxOffs],100"		CALL SUB OutFcnCodeData		OutBuf="mov  dword [edi+ScrollBarPosOffs],0"		CALL SUB OutFcnCodeData	END IFEND SEG MainLoopBEGIN SEG MsgBoxX	GUITempName=""END SEG MsgBox2BEGIN SEG WarningBoxX	GUITempName="+MB_ICONWARNING"END SEG MsgBox2BEGIN SEG InfoBoxX	GUITempName="+MB_ICONINFORMATION"END SEG MsgBox2BEGIN SEG QuestionBoxX	GUITempName="+MB_ICONQUESTION"END SEG MsgBox2BEGIN SEG ErrorBoxX	GUITempName="+MB_ICONERROR"END SEG MsgBox2BEGIN SEG MsgBox2	ErrGUI	CALL SUB GetStringOp	ErrMain	VSymName=TSymName	CommaMain	CALL SUB GetStringOp	ErrMain	CommaMain	CALL SUB NexToken	SELECT CASE TokenSaf		CASE "MB_OK"		CASE "MB_OKCANCEL"		CASE "MB_ABORTRETRYIGNORE" 		CASE "MB_YESNOCANCEL"		CASE "MB_YESNO"		CASE ELSE			ErrNo=ErrSyntax			EXIT SEG	END SELECT	ImportFcnTable(ptrMessageBox).ImportFcnUse=TRUE	OutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+GUITempName	CALL SUB OutFcnCodeData	CALL SUB SetStatusEND SEG MainLoopBEGIN SEG FindX	ErrGUI	CALL SUB NexToken	IF TokenBuf="." THEN		CALL SUB NexToken		IF TokenBuf<>"notify" THEN			ErrNo=ErrSyntax			GOTO MainLoop		END IF		TempStr="Find_notify"		SymTemp.SymName=TempStr		CALL SUB MakeEvent		ErrMain		OutBuf="mov [FindEVPtr],"+TempStr		CALL SUB OutInitCode		EXIT SEG	ELSE		ErrNo=ErrSyntax		EXIT SEG	END IFEND SEG MainLoopBEGIN SEG DestroyX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	INCR LabelNum	OutBuf="btr dword [edi+StatusOffs],WinCreated"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrDestroyWindow).ImportFcnUse=TRUE	OutBuf="invoke DestroyWindow, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ShowX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	; finish thisEND SEG MainLoopBEGIN SEG EndEventX	IF EventFlag=FALSE THEN		ErrNo=ErrEndEvent		EXIT SEG	END IF	OutBuf="ret"	CALL SUB OutFcnCodeData	CALL SUB MakeLine	CALL SUB OutFcnCodeData	EventFlag=FALSE	CodeBlockFlag=FALSEEND SEG MainLoopBEGIN SEG ReplaceDialogX	ErrGUI	FindReplace=$ffEND SEG FindReplaceDialogBEGIN SEG FindDialogX	ErrGUI	FindReplace=0END SEG FindReplaceDialogBEGIN SEG FindReplaceDialog	ErrGUI	CALL SUB GetStringOp	ErrMain	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [fr_lpstrFindWhat],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="mov [fr_wFindWhatLen],ax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!hinstance]"	CALL SUB OutFcnCodeData	OutBuf="mov [fr_hInstance],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!OBMain]"	CALL SUB OutFcnCodeData	OutBuf="mov [fr_hwndOwner],eax"	CALL SUB OutFcnCodeData	IF FindReplace=0 THEN		OutBuf="mov [fr_Flags],FR_DOWN"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrFindText).ImportFcnUse=TRUE		OutBuf="invoke FindText,fr_lStructSize"		CALL SUB OutFcnCodeData	ELSE		CommaMain		CALL SUB GetStringOp		ErrMain		OutBuf="mov eax,["+TSymName+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [fr_lpstrReplaceWith],eax"		CALL SUB OutFcnCodeData		OutBuf="mov eax,["+TSymName+"+4]"		CALL SUB OutFcnCodeData		OutBuf="mov [fr_wReplaceWithLen],ax"		CALL SUB OutFcnCodeData		OutBuf="mov [fr_Flags],FR_DOWN"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrReplaceText).ImportFcnUse=TRUE		OutBuf="invoke ReplaceText,fr_lStructSize"		CALL SUB OutFcnCodeData	END IF	CALL SUB SetStatus	IF FindReplaceFlag=0 THEN; How about the REPLACE case?		FindReplaceFlag=$ff		ImportFcnTable(ptrRegisterWindowMessage).ImportFcnUse=TRUE		OutBuf="invoke RegisterWindowMessage,FINDMSGSTRING"		CALL SUB OutFcnCodeData		OutBuf="mov [FindMsgID],eax"		CALL SUB OutFcnCodeData		END IFEND SEG MainLoopBEGIN SEG ColorDialogX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).DataType<>LONGVAR THEN		ErrNo=ErrIVType		EXIT SEG	END IF	ImportFcnTable(ptrChooseColor).ImportFcnUse=TRUE		OutBuf="invoke ChooseColor,cc_lStructSize"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="or eax,eax"	CALL SUB OutFcnCodeData	OutBuf="jne _Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="mov [cc_rgbResult],$ffffffff"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[cc_rgbResult]"	CALL SUB OutFcnCodeData	OutBuf="mov ["+TokenSaf+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG FontDialogX	ErrGUI	CALL SUB GetStringOp	ErrMain	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [cf_lpszStyle],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [cf_Flags],CF_SCREENFONTS"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!OBMain]"	CALL SUB OutFcnCodeData	OutBuf="mov [cf_hwndOwner],eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrChooseFont).ImportFcnUse=TRUE	OutBuf="invoke ChooseFont,cf_lStructSize"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SaveDialogX	ErrGUI	OpenSave=$ffEND SEG OpenSaveDialogBEGIN SEG OpenDialogX	ErrGUI	OpenSave=0END SEG OpenSaveDialogBEGIN SEG OpenSaveDialog	ErrGUI	CALL SUB GetStringOp	ErrMain	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [ofn_lpstrFile],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="mov [ofn_nMaxFile],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetTextOp	ErrMain	OutBuf="mov eax,"+TSymName	CALL SUB OutFcnCodeData	OutBuf="mov [ofn_lpstrFilter],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetStringOp	ErrMain		OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [ofn_lpstrInitialDir],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!hinstance]"	CALL SUB OutFcnCodeData	OutBuf="mov [ofn_hInstance],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!OBMain]"	CALL SUB OutFcnCodeData	OutBuf="mov [ofn_hwndOwner],eax"	CALL SUB OutFcnCodeData	IF OpenSave=0 THEN		OutBuf="mov [ofn_Flags],OFN_FILEMUSTEXIST+OFN_PATHMUSTEXIST+OFN_HIDEREADONLY"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrGetOpenFileName).ImportFcnUse=TRUE		OutBuf="invoke GetOpenFileName,ofn_lStructSize"		CALL SUB OutFcnCodeData	ELSE		OutBuf="mov [ofn_Flags],OFN_OVERWRITEPROMPT"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrGetSaveFileName).ImportFcnUse=TRUE		OutBuf="invoke GetSaveFileName,ofn_lStructSize"		CALL SUB OutFcnCodeData	END IF	CALL SUB SetStatusEND SEG MainLoopBEGIN SEG PrintDialogX	ErrGUIEND SEG MainLoopBEGIN SEG PageDialogX	ErrGUIEND SEG MainLoopBEGIN SEG ShowPopupX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType<>MENU THEN		ErrNo=ErrIVType		EXIT SEG	END IF	MenuTitleName=TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrTrackPopupMenuEx).ImportFcnUse=TRUE	OutBuf="invoke TrackPopupMenuEx,["+MenuTitleName+"],TPM_LEFTALIGN+TPM_TOPALIGN,[_ArgSafe0],eax,[!OBMain],0"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG DeleteMenuItemX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType<>MENU THEN		ErrNo=ErrIVType		EXIT SEG	END IF	MenuTitleName=TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrDeleteMenu).ImportFcnUse=TRUE	OutBuf="invoke  DeleteMenu, dword ["+MenuTitleName+"],eax,MF_BYCOMMAND"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG AppendmenuItemX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType<>MENU THEN		ErrNo=ErrIVType		EXIT SEG	END IF	MenuTitleName=TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	CommaMain	CALL SUB GetStringOp	ErrMain	MenuItemName=TSymName	ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE	OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,eax,["+MenuItemName+"]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG PopupMenuX	ErrGUI	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType<>MENU THEN		ErrNo=ErrIVType		EXIT SEG	END IF	MenuTitleName=TokenSaf	ImportFcnTable(ptrCreatePopupMenu).ImportFcnUse=TRUE	OutBuf="invoke CreatePopupMenu"	CALL SUB OutFcnCodeData	OutBuf="mov ["+TokenSaf+"],eax"	CALL SUB OutFcnCodeData	BEGIN LOOP		CALL SUB MainLoopInit		CALL SUB ReadSource		IF TempInt=0 THEN			TempStr="EOF in MENU"			ErrNo=$ff			EXIT SEG		END IF		CONTINUE IF LEN(SrcLine)=0		CONTINUE IF LCASE(LEFT(SrcLine,1))=";"		CALL SUB Remark		CALL SUB OutFcnCodeData		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "menuitem"				CALL SUB NexToken				CALL SUB SymChk				IF SymbolValid=FALSE THEN					ErrNo=ErrIVSNam					EXIT SEG				END IF								SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					INCR MenuIDNum					CALL SUB ClrSym					SymTemp.DataType=LONGVAR					SymTemp.DataSize=4					SymTemp.DataMod=ConstBit					SymTemp.Detail=MenuIDNum					CALL SUB SymInsert					ErrMain					OutBuf=TokenSaf+" equ "+STR(MenuIDNum)					CALL SUB OutDeclare				ELSE					ErrNo=ErrDupSym					EXIT SEG				END IF				CommaMain				CALL SUB GetStringOp				ErrMain				MenuItemName=TSymName				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,"+STR(MenuIDNum)+",["+MenuItemName+"]"				CALL SUB OutFcnCodeData			CASE "reserveitems"				CALL SUB NexToken				CALL SUB SymChk				IF SymbolValid=FALSE THEN					ErrNo=ErrIVSNam					EXIT SEG				END IF								SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					INCR MenuIDNum					CALL SUB ClrSym					SymTemp.DataType=LONGVAR					SymTemp.DataSize=4					SymTemp.DataMod=ConstBit					SymTemp.Detail=MenuIDNum					CALL SUB SymInsert					ErrMain					OutBuf=TokenSaf+" equ "+STR(MenuIDNum)					CALL SUB OutDeclare				ELSE					ErrNo=ErrDupSym					EXIT SEG				END IF				CommaMain				CALL SUB NexToken				ErrMain				MenuIDNum=MenuIDNum+VAL(TokenBuf)-1			CASE "submenu"				IF LEN(MenuTitleName)=0 THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB NexToken				HandleName="edi+HandleOffs"				OutBuf="mov edi,"+TokenSaf				CALL SUB OutFcnCodeData							SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					ErrNo=ErrUDSym					EXIT SEG				END IF				IF SymTable(SymNdx).SubType<>MENU THEN					ErrNo=ErrIVType					EXIT SEG				END IF				CommaMain				CALL SUB GetStringOp				ErrMain				MenuItemName=TSymName				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_POPUP, dword ["+HandleName+"],["+MenuItemName+"]"				CALL SUB OutFcnCodeData			CASE "menuseparator"				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke AppendMenu,["+MenuTitleName+"],MF_SEPARATOR,0,0"				CALL SUB OutFcnCodeData			CASE "end"				CALL SUB NexToken				IF TokenBuf<>"menu" THEN					ErrNo=ErrSyntax				END IF				EXIT SEG			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG							END SELECT	END LOOPEND SEG MainLoopBEGIN SEG MenuX	ErrGUI	CALL SUB NexToken	IF TokenBuf="." THEN		CALL SUB NexToken		IF TokenBuf<>"command" THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		TempStr="Menu_command"		SymTemp.SymName=TempStr		CALL SUB MakeEvent		ErrMain		OutBuf="mov [MenuEVPtr],"+TempStr		CALL SUB OutInitCode	ELSE		ErrNo=ErrSyntax	END IFEND SEG MainLoopBEGIN SEG BeginMenuX	ErrGUI	MenuBarName=""	MenuTitleName=""	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	SymTemp=SymTable(SymNdx)	IF SymTemp.DataType<>FORM AND SymTemp.DataType<>TOOLWINDOW THEN		ErrNo=ErrIVType		EXIT SEG	END IF	MenuWindowName="!"+SymTemp.SymName	BEGIN LOOP		CALL SUB MainLoopInit		CALL SUB ReadSource		IF TempInt=0 THEN			TempStr="EOF in MENU"			ErrNo=$ff			EXIT SEG		END IF		CONTINUE IF LEN(SrcLine)=0		CONTINUE IF LCASE(LEFT(SrcLine,1))=";"		CALL SUB Remark		CALL SUB OutFcnCodeData		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "menubar"				CALL SUB NexToken				MenuBarName=TokenSaf				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=TRUE THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB ClrDatTyp				CALL SUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.SubType=MENU				SymTemp.DataMod=0				SymTemp.Detail=0				CALL SUB SymInsert				ErrMain				OutBuf=MenuBarName+" rd 1"				CALL SUB OutUninitData				ImportFcnTable(ptrCreateMenu).ImportFcnUse=TRUE				OutBuf="invoke CreateMenu"				CALL SUB OutFcnCodeData				OutBuf="mov ["+MenuBarName+"],eax"				CALL SUB OutFcnCodeData			CASE "menutitle"				IF LEN(MenuBarName)=0 THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB NexToken				MenuTitleName=TokenSaf				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=TRUE THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB ClrDatTyp				CALL SUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.SubType=MENU				SymTemp.DataMod=0				SymTemp.Detail=0				CALL SUB SymInsert				ErrMain				OutBuf=MenuTitleName+" rd 1"				CALL SUB OutUninitData				ImportFcnTable(ptrCreatePopupMenu).ImportFcnUse=TRUE				OutBuf="invoke CreatePopupMenu"				CALL SUB OutFcnCodeData				OutBuf="mov ["+MenuTitleName+"],eax"				CALL SUB OutFcnCodeData				CommaMain				CALL SUB GetStringOp				ErrMain				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke AppendMenu,["+MenuBarName+"],MF_POPUP,["+MenuTitleName+"],["+TSymName+"]"				CALL SUB OutFcnCodeData			CASE "menuitem"				IF LEN(MenuTitleName)=0 THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB NexToken				CALL SUB SymChk				IF SymbolValid=FALSE THEN					ErrNo=ErrIVSNam					EXIT SEG				END IF								SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					INCR MenuIDNum					CALL SUB ClrSym					SymTemp.DataType=LONGVAR					SymTemp.DataSize=4					SymTemp.DataMod=ConstBit					SymTemp.Detail=MenuIDNum					CALL SUB SymInsert					ErrMain					OutBuf=TokenSaf+" equ "+STR(MenuIDNum)					CALL SUB OutDeclare				ELSE					ErrNo=ErrDupSym					EXIT SEG				END IF				CommaMain				CALL SUB GetStringOp				ErrMain				MenuItemName=TSymName				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,"+STR(MenuIDNum)+",["+MenuItemName+"]"				CALL SUB OutFcnCodeData								CASE "submenu"				IF LEN(MenuTitleName)=0 THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				CALL SUB NexToken				HandleName="edi+HandleOffs"				OutBuf="mov edi,"+TokenSaf				CALL SUB OutFcnCodeData							SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					ErrNo=ErrUDSym					EXIT SEG				END IF				IF SymTable(SymNdx).SubType<>MENU THEN					ErrNo=ErrIVType					EXIT SEG				END IF				CommaMain				CALL SUB GetStringOp				ErrMain				MenuItemName=TSymName				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_POPUP, dword ["+HandleName+"],["+MenuItemName+"]"				CALL SUB OutFcnCodeData			CASE "menuseparator"				ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE				OutBuf="invoke AppendMenu,["+MenuTitleName+"],MF_SEPARATOR,0,0"				CALL SUB OutFcnCodeData			CASE "end"				CALL SUB NexToken				IF TokenBuf<>"menu" THEN					ErrNo=ErrSyntax					EXIT SEG				END IF				ImportFcnTable(ptrSetMenu).ImportFcnUse=TRUE				OutBuf="invoke SetMenu,["+MenuWindowName+"],["+MenuBarName+"]"				CALL SUB OutFcnCodeData				EXIT SEG			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG								END SELECT	END LOOPEND SEG  MainLoopBEGIN SEG EndMenuX	TempStr="EndMenu while not in menu"	ErrNo=$ffEND SEG MainLoopBEGIN SEG CheckMenuitemX	MenuOp=1END SEG MenuCommonBEGIN SEG EnableMenuitemX	MenuOp=2END SEG MenuCommonBEGIN SEG HiliteMenuItemX	MenuOp=3END SEG MenuCommonBEGIN SEG MenuCommon	ErrGUI	CALL SUB NexToken	ObjectName=TokenSaf	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	SymTemp=SymTable(SymNdx)	IF SymTemp.SubType<>MENU THEN		ErrNo=ErrIVType		EXIT SEG	END IF	CommaMain	CALL SUB GetIntOp	ErrMain	CommaMain	CALL SUB NexToken	SELECT CASE MenuOp		CASE 1			IF TokenBuf="true" THEN				TempStr="MF_CHECKED+MF_BYCOMMAND"			ELSE				TempStr="MF_UNCHECKED+MF_BYCOMMAND"			END IF			ImportFcnTable(ptrCheckMenuItem).ImportFcnUse=TRUE			OutBuf="invoke CheckMenuItem,["+ObjectName+"],eax,"+TempStr		CASE 2			IF TokenBuf="true" THEN				TempStr="MF_ENABLED+MF_BYCOMMAND"			ELSE				TempStr="MF_GRAYED+MF_BYCOMMAND"			END IF			ImportFcnTable(ptrEnableMenuItem).ImportFcnUse=TRUE			OutBuf="invoke EnableMenuItem,["+ObjectName+"],eax,"+TempStr		CASE 3			IF TokenBuf="true" THEN				TempStr="MF_HILITE+MF_BYCOMMAND"			ELSE				TempStr="MF_UNHILITE+MF_BYCOMMAND"			END IF			ImportFcnTable(ptrHiliteMenuItem).ImportFcnUse=TRUE			OutBuf="invoke HiliteMenuItem,[!OBMain],["+ObjectName+"],eax,"+TempStr	END SELECT	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EnumX	CALL SUB NexToken	EnumStep=1	IF TokenLen<>0 THEN		EnumVal=VAL(TokenSaf)		CALL SUB NexToken		IF TokenLen<>0 THEN			IF TokenBuf<>"step" THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			CALL SUB NexToken			IF TokenLen=0 THEN				ErrNo=ErrSyntax				EXIT SEG			END IF			EnumStep=VAL(TokenSaf)		END IF		END IF	BEGIN LOOP		CALL SUB ReadSource		IF TempInt=0 THEN			TempStr="EOF in Enum"			ErrNo=$ff			EXIT SEG		END IF		CONTINUE IF LEN(SrcLine)=0		CALL SUB NexToken		IF TokenBuf="end" THEN			CALL SUB NexToken			IF TokenBuf<>"enum" THEN				ErrNo=ErrSyntax			END IF			EXIT SEG		END IF		CALL SUB SymChk		IF SymbolValid=FALSE THEN			ErrNo=ErrIVSNam			EXIT SEG		END IF						SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=FALSE THEN			CALL SUB ClrSym			SymTemp.DataType=COMPVAR			SymTemp.DataSize=4			SymTemp.Detail=EnumVal			SymTemp.DataMod=0			CALL SUB SymInsert			ErrMain			OutBuf=TokenSaf+" equ "+STR(EnumVal)			CALL SUB OutDeclare		ELSE			ErrNo=ErrDupSym			EXIT SEG		END IF		EnumVal=EnumVal+EnumStep	END LOOPEND SEG MainLoopBEGIN SEG EndEnumX	TempStr="EndEnum while not in enum"	ErrNo=$ffEND SEG MainLoopBEGIN SEG CreateFontX	CALL SUB Expr	Op1Name=TSymName	Op1Mod=TDataMod	CommaMain	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF LAND(SymTable(SymNdx).DataMod,LogFontBit)=0 THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	ImportFcnTable(ptrCreateFontIndirect).ImportFcnUse=TRUE	OutBuf="invoke CreateFontIndirect,"+TokenSaf	CALL SUB OutFcnCodeData	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov ["+Op1Name+"],eax"	ELSE		OutBuf="mov edi,["+Op1Name+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],eax"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CreateCursorX	IconCursorFlag=FALSEEND SEG  CreateIconCursorBEGIN SEG CreateIconX	IconCursorFlag=TRUEEND SEG CreateIconCursorBEGIN SEG CreateIconCursor	ErrGUI	CALL SUB Expr	Op1Name=TSymName	Op1Mod=TDataMod	CommaMain	PathVar=""	BEGIN LOOP		CALL SUB NexToken		EXIT IF TokenLen=0		EXIT IF TokenBuf="," THEN		PathVar=PathVar+TokenBuf	END LOOP	IF TokenBuf="," THEN		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "small"				IconSize=$10			CASE "medium"				IconSize=$20			CASE "large"				IconSize=$48			CASE ELSE				ErrNo=ErrSyntax				EXIT SEG		END SELECT	ELSE		IconSize=0	END IF	IF IconCursorFlag=TRUE THEN		IF RIGHT(PathVar,4)<>".ico" THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		Opt="1"	ELSE		IF RIGHT(PathVar,4)<>".cur" THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		Opt="0"	END IF	ON ERROR GOTO BadIconFile	OPEN PathVar FOR INPUT AS BitMapFile	ON ERROR	OutBuf="!"+Op1Name+":"	CALL SUB OutInitData	OutBuf=""	GET BitMapFile,IconDir	IF IconDir.idReserved<>0 THEN BadIconFile	IF IconCursorFlag=FALSE AND IconDir.idType<>2 THEN BadIconFile	IF IconCursorFlag=TRUE AND IconDir.idType<>1 THEN BadIconFile	IconDirEntries=IconDir.idCount	IF IconDirEntries<1 THEN BadIconFile	BEGIN LOOP		EXIT IF IconDirEntries=0		GET BitMapFile,IconEntry		EXIT IF IconEntry.bWidth=IconSize OR IconSize=0		DECR IconDirEntries	END LOOP	TempInt=IconEntry.dwBytesInRes	I=0	SEEK BitMapFile,IconEntry.dwImageOffset	BEGIN LOOP		FOR J=1 TO 32			INCR I			IF I>TempInt THEN				IF OutBuf<>"" THEN					CALL SUB OutInitData				END IF				GOTO CreateIcon1			END IF			GET BitMapFile,AsciiByte			TempName=HEX(AsciiByte)			IF LEN(TempName)=1 THEN				TempStr="$0"+TempName			ELSE				TempStr="$"+TempName			END IF			IF J=1 THEN				OutBuf=OutBuf+" db "+TempStr			ELSE				OutBuf=OutBuf+","+TempStr			END IF							NEXT J		CALL SUB OutInitData		OutBuf=""	END LOOP	CreateIcon1:	CLOSE BitMapFile	ImportFcnTable(ptrCreateIconFromResourceEx).ImportFcnUse=TRUE	OutBuf="invoke CreateIconFromResourceEx,!"+Op1Name+","+STR(TempInt)+","+Opt+",$30000,"+STR(IconEntry.bWidth)+","+STR(IconEntry.bHeight)+",0"	CALL SUB OutFcnCodeData	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov ["+Op1Name+"],eax"	ELSE		OutBuf="mov edi,["+Op1Name+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],eax"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG BadIconFile	TempStr="Icon/Cursor file improper"	ErrNo=$ffEND SEG MainLoopBEGIN SEG CreateImageListX	ImportFcnTable(ptrImageListCreate).ImportFcnUse=TRUE	FcnName=TokenSaf	CommaMain	CALL SUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).SubType=BITMAP THEN		TempBool=TRUE		ImportFcnTable(ptrImageListAdd).ImportFcnUse=TRUE	ELSE		TempBool=FALSE		ImportFcnTable(ptrImageListAddIcon).ImportFcnUse=TRUE	END IF	CALL SUB UnDoToken	NumArgs=0	BEGIN LOOP		CALL SUB NexToken		CONTINUE IF TokenBuf=","		EXIT IF TokenLen=0		SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			EXIT SEG		END IF		IF TempBool=TRUE AND SymTable(SymNdx).SubType<>BITMAP THEN			ErrNo=ErrIVType			EXIT SEG		END IF		IF TempBool=FALSE AND SymTable(SymNdx).SubType<>ICON THEN			ErrNo=ErrIVType			EXIT SEG		END IF		INCR NumArgs		Handles(NumArgs)=TokenSaf	END LOOP	IF NumArgs=0 THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	OutBuf="invoke ImageListCreate,16,16,ILC_COLOR,"+STR(NumArgs)+","+STR(NumArgs)	CALL SUB OutFcnCodeData	OutBuf="mov ["+FcnName+"],eax"	CALL SUB OutFcnCodeData	FOR I=1 TO NumArgs		TempStr=Handles(I)		IF TempBool=TRUE THEN			OutBuf="invoke ImageListAdd,["+FcnName+"],["+TempStr+"],0"		ELSE			OutBuf="invoke ImageListAddIcon,["+FcnName+"],["+TempStr+"]"		END IF		CALL SUB OutFcnCodeData	NEXT IEND SEG MainLoopBEGIN SEG LoadX	ErrGUI	CALL SUB Expr	Op1Name=TSymName	Op1Mod=TDataMod	SELECT CASE TSubType		CASE BITMAP			GOTO LoadImageX		CASE ICON			FcnName="IMAGE_ICON"			GOTO LoadIconX		CASE CURSOR			FcnName="IMAGE_CURSOR"			GOTO LoadIconX		CASE ELSE			ErrNo=ErrSyntax	END SELECTEND SEG MainLoopBEGIN SEG LoadImageX	CommaMain	CALL SUB GetStringOp	ErrMain	ImageLibUsed=TRUE	ImportFcnTable(ptrBitmapFromFile).ImportFcnUse=TRUE	OutBuf="invoke BitmapFromFile,["+TSymName+"]"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov ["+Op1Name+"],eax"	ELSE		OutBuf="mov edi,["+Op1Name+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],eax"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG LoadIconX	CommaMain	CALL SUB GetStringOp	ErrMain	ImportFcnTable(ptrLoadImage).ImportFcnUse=TRUE	OutBuf="invoke LoadImage,0,["+TSymName+"],"+FcnName+",0,0,$10"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov ["+Op1Name+"],eax"	ELSE		OutBuf="mov edi,["+Op1Name+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],eax"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SuspendX	CALL SUB Expr	IF TSubType<>TASK THEN		ErrNo=ErrIVType		EXIT SEG	END IF	ImportFcnTable(ptrSuspendThread).ImportFcnUse=TRUE	OutBuf="invoke SuspendThread,[!"+TSymName+"]"	CALL SUB OutFcnCodeData	CALL SUB SetStatusEND SEG  MainLoopBEGIN SEG ResumeX	CALL SUB Expr	IF TSubType<>TASK THEN		ErrNo=ErrIVType		EXIT SEG	END IF	ImportFcnTable(ptrResumeThread).ImportFcnUse=TRUE	OutBuf="invoke ResumeThread,[!"+TSymName+"]"	CALL SUB OutFcnCodeData	CALL SUB SetStatusEND SEG MainLoopBEGIN SEG CreateImageX	ErrGUI	CALL SUB Expr	Op1Name=TSymName	Op1Mod=TDataMod	CommaMain	PathVar=""	BEGIN LOOP		CALL SUB NexToken		EXIT IF TokenLen=0		PathVar=PathVar+TokenBuf	END LOOP	IF RIGHT(PathVar,4)<>".bmp" AND RIGHT(PathVar,4)<>".jpg" AND RIGHT(PathVar,4)<>".gif" THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	ON ERROR GOTO BadImageFile	OPEN PathVar FOR INPUT AS ImageFile	ON ERROR	OutBuf="!"+Op1Name+":"	CALL SUB OutInitData	OutBuf=""	TempInt=LOF(ImageFile)	I=0	BEGIN LOOP		FOR J=1 TO 32			INCR I			IF I>TempInt THEN				IF OutBuf<>"" THEN					CALL SUB OutInitData				END IF				GOTO CreateImage1			END IF			GET ImageFile,AsciiByte			TempName=HEX(AsciiByte)			IF LEN(TempName)=1 THEN				TempStr="$0"+TempName			ELSE				TempStr="$"+TempName			END IF			IF J=1 THEN				OutBuf=OutBuf+" db "+TempStr			ELSE				OutBuf=OutBuf+","+TempStr			END IF							NEXT J		CALL SUB OutInitData		OutBuf=""	END LOOP	CreateImage1:	CLOSE ImageFile	ImageLibUsed=TRUE	ImportFcnTable(ptrBitmapFromMemory).ImportFcnUse=TRUE	OutBuf="invoke BitmapFromMemory,!"+TSymName+","+STR(TempInt)	CALL SUB OutFcnCodeData	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov ["+Op1Name+"],eax"	ELSE		OutBuf="mov edi,["+Op1Name+"]"		CALL SUB OutFcnCodeData		OutBuf="mov [edi],eax"	END IF	CALL SUB OutFcnCodeDataEND SEG MainLoop	BEGIN SEG BadImageFile	TempStr="ImageFile File does not exist"	ErrNo=$ffEND SEG MainLoopBEGIN SEG PassEventX	ErrGUI	OutBuf="mov [!PassEvent],1"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG TrapColorChangeEventX	CALL SUB ChkLabel	ErrMain	IF SymTable(SymNdx).DataType<>LABELVAR THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	OutBuf="mov [!TrapColorChange],"+SymbolSaf	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ReadCardX	CsmdllLibUsed=TRUE	; READCARD Buffer,NumBytes	ImportFcnTable(ptrCSMGetDriveHandle).ImportFcnUse=TRUE	OutBuf="invoke CSMGetDriveHandle, [DriverName], DriverHandle, 1"	CALL SUB OutFcnCodeData	; Get and test status, set STATUS to -1 if bad	ImportFcnTable(ptrCSMReadBlock).ImportFcnUse=TRUE	OutBuf="invoke CSMReadBlock,[DriverHandle],0,2,0,CardBuf,262144"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	ImportFcnTable(ptrCSMReleaseDriveHandle).ImportFcnUse=TRUE	OutBuf="invoke CSMReleaseDriveHandle,[DriverHandle]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG WriteCardX	CsmdllLibUsed=TRUE	; WRITECARD Buffer,NumBytes	ImportFcnTable(ptrCSMGetDriveHandle).ImportFcnUse=TRUE	OutBuf="invoke CSMGetDriveHandle, [DriverName], DriverHandle, 1"	CALL SUB OutFcnCodeData	; Get and test status, set STATUS to -1 if bad	ImportFcnTable(ptrCSMWriteBlock).ImportFcnUse=TRUE	OutBuf="invoke CSMWriteBlock,[DriverHandle],0,2,96,0,CardBuf,0,262144"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	ImportFcnTable(ptrCSMReleaseDriveHandle).ImportFcnUse=TRUE	OutBuf="invoke CSMReleaseDriveHandle,[DriverHandle]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG UseImportX	CALL SUB NexToken	FOR I=1 TO LastImportFcn		IF ImportFcnTable(I).ImportFcnAlias=TokenSaf THEN			ImportFcnTable(I).ImportFcnUse=TRUE			EXIT SEG		END IF	NEXT I	ErrNo=ErrUDSymEND SEG MainLoopBEGIN SEG ImportFunctionXEND SEG MainLoopBEGIN SEG ExportFunctionXEND SEG MainLoopBEGIN SEG CreateTaskX	ErrGUI	ImportFcnTable(ptrCreateThread).ImportFcnUse=TRUE	OutBuf="invoke CreateThread,0,0,"+TokenSaf+",0,0,STATUS"	CALL SUB OutFcnCodeData	OutBuf="mov [!"+TokenSaf+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CreateSolidBrushX	ErrGUI	GUITempName=TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUE	OutBuf="invoke CreateSolidBrush,eax"	CALL SUB OutFcnCodeData	OutBuf="mov ["+GUITempName+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CreateHatchBrushX	ErrGUI	GUITempName=TokenSaf	CommaMain	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "bdiagonal"			FcnName="HS_BDIAGONAL"		CASE "cross"			FcnName="HS_CROSS"		CASE "diagcross"			FcnName="HS_DIAGCROSS"		CASE "fdiagonal"			FcnName="HS_FDIAGONAL"		CASE "horizontal"			FcnName="HS_HORIZONTAL"		CASE "vertical"			FcnName="HS_VERTICAL"		CASE ELSE			ErrNo=ErrSyntax			EXIT SEG	END SELECT	CommaMain	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrCreateHatchBrush).ImportFcnUse=TRUE	OutBuf="invoke CreateHatchBrush,"+FcnName+",eax"	CALL SUB OutFcnCodeData	OutBuf="mov ["+GUITempName+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CreatePatternBrushX	ErrGUI	GUITempName=TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	IF TSubType<>BITMAP THEN		ErrNo=ErrIVType		EXIT SEG	END IF	ImportFcnTable(ptrCreatePatternBrush).ImportFcnUse=TRUE	OutBuf="invoke CreatePatternBrush,eax"	CALL SUB OutFcnCodeData	OutBuf="mov ["+GUITempName+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CreatePenX	ErrGUI	GUITempName=TokenSaf	CommaMain	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "solid"			FcnName="PS_SOLID"		CASE "dash"			FcnName="PS_DASH"		CASE "dot"			FcnName="PS_DOT"		CASE "dashdot"			FcnName="PS_DASHDOT "		CASE "dashdotdot"			FcnName="PS_DASHDOTDOT"		CASE "null"			FcnName="PS_NULL"		CASE "insideframe"			FcnName="PS_INSIDEFRAME"		CASE ELSE			ErrNo=ErrSyntax			EXIT SEG	END SELECT	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrCreatePen).ImportFcnUse=TRUE	OutBuf="invoke CreatePen,"+FcnName+",[_ArgSafe0],eax"	CALL SUB OutFcnCodeData	OutBuf="mov ["+GUITempName+"],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG MoveToX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrMoveToEx).ImportFcnUse=TRUE	OutBuf="invoke MoveToEx,ebx,[_ArgSafe0],eax,0"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG ArcToX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe2],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe3],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe4],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe5],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe6],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrArcTo).ImportFcnUse=TRUE	OutBuf="invoke ArcTo,ebx,[_ArgSafe0],[_ArgSafe1],[_ArgSafe2],[_ArgSafe3],[_ArgSafe4],[_ArgSafe5],[_ArgSafe6],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG LineToX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrLineTo).ImportFcnUse=TRUE	OutBuf="invoke LineTo,ebx,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EllipseX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe2],eax"	CALL SUB OutFcnCodeData		CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrEllipse).ImportFcnUse=TRUE	OutBuf="invoke Ellipse,ebx,[_ArgSafe0],[_ArgSafe1],[_ArgSafe2],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetTextColorX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetTextColor).ImportFcnUse=TRUE	OutBuf="invoke SetTextColor,ebx,eax""	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SetBkColorX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetBkColor).ImportFcnUse=TRUE	OutBuf="invoke SetBkColor,ebx,eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG DrawTextX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [RectLeft],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [RectTop],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [RectRight],eax"	CALL SUB OutFcnCodeData		CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [RectBottom],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GUIStringPrep	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrDrawTextEx).ImportFcnUse=TRUE	OutBuf="invoke DrawTextEx,ebx,[_IOBuffer],-1,RectLeft,0,0"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG RectangleX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe2],eax"	CALL SUB OutFcnCodeData		CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrRectangle).ImportFcnUse=TRUE	OutBuf="invoke Rectangle,ebx,[_ArgSafe0],[_ArgSafe1],[_ArgSafe2],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG RoundRectX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe2],eax"	CALL SUB OutFcnCodeData		CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe3],eax"	CALL SUB OutFcnCodeData		CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov [_ArgSafe4],eax"	CALL SUB OutFcnCodeData		CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrRoundRect).ImportFcnUse=TRUE	OutBuf="invoke RoundRect,ebx,[_ArgSafe0],[_ArgSafe1],[_ArgSafe2],[_ArgSafe3],[_ArgSafe4],eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG PolylineX	ErrGUI	GUITargetFlag=$ff	CALL SUB ValidateObject	ErrMain	CommaMain	GOSUB NexToken	FcnName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	CommaMain	CALL SUB GetIntOp	ErrMain	CALL SUB ediUsedCheck	OutBuf="mov ebx,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrPolyline).ImportFcnUse=TRUE	OutBuf="invoke Polyline,ebx,"+FcnName+",eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG SleepX	ErrGUI	CALL SUB GetIntOp	ErrMain	ImportFcnTable(ptrSleep).ImportFcnUse=TRUE	OutBuf="invoke Sleep,eax"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG BeginTaskX	ErrGUI	CALL SUB FcnFlagChk	ErrMain	TaskFlag=TRUE	CodeBlockFlag=TRUE	CALL SUB NexToken	OutBuf=TokenSaf+":"	CALL SUB OutFcnCodeData	OutBuf="pop eax"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	OutBuf="push esp"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EndTaskX	ErrGUI	IF TaskFlag=FALSE THEN		ErrNo=ErrEndTask		EXIT SEG	END IF	OutBuf="pop esp"	CALL SUB OutFcnCodeData	OutBuf="ret"	CALL SUB OutFcnCodeData	CALL SUB MakeLine	CALL SUB OutFcnCodeData	TaskFlag=FALSE	CodeBlockFlag=FALSEEND SEG MainLoopBEGIN SEG LaunchX	CALL SUB Expr	IF TDataType<>STRINGVAR THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	ediUsed=TRUE	OutBuf="mov edi,_IOBuffer"	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+TSymName+"; Get src"	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen=0 THEN		OutBuf="mov [_PrintBuf+12],0"		CALL SUB OutFcnCodeData	ELSE		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		CALL SUB Expr		IF TDataType<>STRINGVAR THEN			ErrNo=ErrTypMis			EXIT SEG		END IF	END IF	OutBuf="mov edi,_PrintBuf"	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+TSymName+"; Get src"	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrShellExecute).ImportFcnUse=TRUE	OutBuf="invoke ShellExecute,[!OBMain],NULL,[_IOBuffer],[_PrintBuf],0,SW_SHOWNORMAL"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetDateTimeX	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	ImportFcnTable(ptrGetLocalTime).ImportFcnUse=TRUE	OutBuf="invoke GetLocalTime,"+TokenSaf	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetGMTDateTimeX	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	ImportFcnTable(ptrGetSystemTime).ImportFcnUse=TRUE	OutBuf="invoke GetSystemTime,"+TokenSaf	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG GetDateFormatX	FcnName="GetDateFormat"END SEG GetDateTimeFormatBEGIN SEG GetTimeFormatX	FcnName="GetTimeFormat"END SEG GetDateTimeFormatBEGIN SEG GetDateTimeFormat	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	ObjectName=TokenSaf	CommaMain	CALL SUB GetStringOp	ErrMain	CommaMain	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTable(SymNdx).DataType<>STRINGVAR THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	OutBuf="mov [_ArgSafe0],"+STR(SymTable(SymNdx).Detail)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrGetDateFormat).ImportFcnUse=TRUE	ImportFcnTable(ptrGetTimeFormat).ImportFcnUse=TRUE	OutBuf="invoke "+FcnName+",0,0,"+ObjectName+",["+TSymName+"],["+SymTable(SymNdx).SymName+"],[_ArgSafe0]"	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG TimeAddX	; TIMEADD DateTime1,Seconds	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	;IF TDataType<>DATETIME THEN	;	ErrNo=ErrTypMis	;	GOTO MainLoop	;END IF	FcnOp1Nam=TokenSaf	CommaMain	CALL SUB GetIntOp	ErrMain	OutBuf="mov edx,10000000"	CALL SUB OutFcnCodeData	OutBuf="imul edx"	CALL SUB OutFcnCodeData	OutBuf="mov [!dwLowDateTime2],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!dwHighDateTime2],edx"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSystemTimeToFileTime).ImportFcnUse=TRUE	OutBuf="invoke SystemTimeToFileTime, dword "+FcnOp1Nam+",!dwLowDateTime1"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!dwLowDateTime1]"	CALL SUB OutFcnCodeData	OutBuf="mov edx,[!dwHighDateTime1]"	CALL SUB OutFcnCodeData	OutBuf="add eax,[!dwLowDateTime2]"	CALL SUB OutFcnCodeData	OutBuf="adc edx,[!dwHighDateTime2]"	CALL SUB OutFcnCodeData	OutBuf="mov [!dwLowDateTime1],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!dwHighDateTime1],edx"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrFileTimeToSystemTime).ImportFcnUse=TRUE	OutBuf="invoke FileTimeToSystemTime,!dwLowDateTime1, dword "+FcnOp1Nam+""	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG CallX	CALL SUB NexToken	IF TokenBuf="sub" THEN		GOTO GosubX	ELSE		IF TokenBuf="proc" THEN			GOTO CallProc		ELSE			GOTO AssemblyX		END IF	END IFEND SEG MainLoopBEGIN SEG CallProc	CALL SUB NexToken	SymTemp.SymName=TokenSaf	ProcName=TokenSaf	CALL SUB SymSrch	SymTemp=SymTable(SymNdx)	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SEG	END IF	IF SymTemp.DataType<>PROC THEN		ErrNo=ErrTypMis		EXIT SEG	END IF	FcnDataMod=SymTable(SymNdx).DataMod	FcnSymNdx=SymNdx	IF SymTemp.FcnArgs<>0 THEN		CALL SUB PushArgs		ErrMain	END IF	TempInt=FcnDataMod	TempInt=LOR(TempInt,CalledBit)	SymTable(FcnSymNdx).DataMod=TempInt	OutBuf="call "+ProcName	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG BeginSegX	IF SegFlag=TRUE THEN		ErrNo=ErrSegInSeg		EXIT SEG	END IF	SegFlag=TRUE	INCR SegNum	CALL SUB ProcLabel	ErrMain	SymbolSaf=SymbolSaf+":"	CALL SUB OutLabelEND SEG MainLoopBEGIN SEG EndSegX	IF SegFlag=FALSE THEN		ErrNo=ErrEndSeg		EXIT SEG	END IF	SegFlag=FALSE	OutBuf="_Seg"+STR(SegNum)+":"	CALL SUB OutFcnCodeData	EndSegFlag=TRUEEND SEG GotoXBEGIN SEG ExitSeg	IF SegFlag=FALSE THEN		ErrNo=ErrExitSeg		EXIT SEG	END IF	OutBuf="jmp "+"_Seg"+STR(SegNum)	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG EnterX	CALL SUB NexToken	IF TokenBuf<>"seg" THEN		ErrNo=ErrSyntax		EXIT SEG	END IFEND SEG GotoXBEGIN SEG AssemblyX	StartFlag=TRUE	OutBuf=SrcLine	CALL SUB OutFcnCodeDataEND SEG MainLoopBEGIN SEG AssemblyInvokeX	CALL SUB NexToken	FOR I=1 TO LastImportFcn		IF ImportFcnTable(I).ImportFcnAlias=TokenSaf THEN			ImportFcnTable(I).ImportFcnUse=TRUE			GOTO AssemblyX		END IF			NEXT I	TempStr="Cannot import function"	ErrNo=$ffEND SEG MainLoopBEGIN SEG Finish	IF InpFilPtr>1 THEN		CLOSE InpFile(InpFilPtr)		DECR InpFilPtr		EXIT SEG	END IF	CALL SUB ChkUse	CLOSE InpFile(InpFilPtr)	IF LastStmt="data" THEN		DataFlag=FALSE	END IF	INCR TimerNum	OutBuf="!Timers equ "+STR(TimerNum)	CALL SUB OutDeclare	IF LastStmt<>"end" AND GUIFlag=FALSE THEN		OutBuf=""		CALL SUB OutFcnCodeData		OutBuf="; Automatic END statement"		CALL SUB OutFcnCodeData		OutBuf="xor eax,eax"		CALL SUB OutFcnCodeData		ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE		OutBuf="invoke ExitProcess, eax"		CALL SUB OutFcnCodeData	END IF	OutBuf="_ErrExit:"	CALL SUB OutFcnCodeData	IF GUIFlag=FALSE THEN		ImportFcnTable(ptrputs).ImportFcnUse=TRUE		OutBuf="cinvoke puts,_ErrExitMsg"		CALL SUB OutFcnCodeData	ELSE		OutBuf="invoke MessageBox,[!OBMain],_ErrExitMsg,0,MB_OK"		CALL SUB OutFcnCodeData	END IF		OutBuf="mov eax,[err]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE	OutBuf="invoke ExitProcess, eax"	CALL SUB OutFcnCodeData	OutBuf="; End of Declaration Section"	CALL SUB OutDeclare	CALL SUB MakeLine	CALL SUB OutDeclare	CLOSE DeclareFile	OutBuf="!ObjectCount dd "+STR(ObjectCtr)	CALL SUB OutInitData	OutBuf="; End of Initialized Data Section"	CALL SUB OutInitData	CALL SUB MakeLine	CALL SUB OutInitData	OutBuf=""	CALL SUB OutInitData	OutBuf="; Start of Uninitialized Data Section"	CALL SUB OutInitData	OutBuf=""	CALL SUB OutInitData	CLOSE DataFile	OutBuf="; End of Uninitialized Data Section"	CALL SUB OutUninitData	CALL SUB MakeLine	CALL SUB OutUninitData	OutBuf=""	CALL SUB OutUninitData	OutBuf="; Start of Control Descriptor Section"	CALL SUB OutUninitData	CLOSE DimFile	CLOSE DescFile	CLOSE PreCodeFile	OutBuf="; End of Code Section"	CALL OutCode	CALL SUB MakeLine	CALL OutCode	CLOSE CodeFile	IF ExclamationOK=TRUE THEN		RichEdLibUsed=TRUE		RAEditLibUsed=TRUE		RAGridLibUsed=TRUE		CsmdllLibUsed=TRUE		DrawProgressLibUsed=TRUE		ImageLibUsed=TRUE		SprShtLibUsed=TRUE		ButtonExLibUsed=TRUE		WebBrowserLibUsed=TRUE		ZipLibUsed=TRUE	END IF	IF RichEdLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!RichEd"		CALL SUB OutInitCode	END IF	IF RAEditLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!RAEdit"		CALL SUB OutInitCode	END IF	IF RAGridLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!RAGrid"		CALL SUB OutInitCode	END IF	IF CsmdllLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!Csmdll"		CALL SUB OutInitCode	END IF	IF DrawProgressLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!DrawProgress"		CALL SUB OutInitCode	END IF	IF ImageLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!ImageLib"		CALL SUB OutInitCode	END IF	IF SprShtLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!SprShtLib"		CALL SUB OutInitCode	END IF	IF ButtonExLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!ButtonExLib"		CALL SUB OutInitCode	END IF	IF WebBrowserLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!WebBrowserLib"		CALL SUB OutInitCode	END IF	IF ZipLibUsed=TRUE THEN		OutBuf="invoke LoadLibrary,!!ZipLib"		CALL SUB OutInitCode	END IF	OutBuf="ret"	CALL SUB OutInitCode	OutBuf="; End of Init Section"	CALL SUB OutInitCode	CALL SUB MakeLine	CALL SUB OutInitCode	CLOSE InitFile	OutBuf="; End of Function Section"	CALL OutFunction	CALL SUB MakeLine	CALL OutFunction	CLOSE FunctionFile	CLOSE LibFile	CLOSE ProcFile	CLOSE ExportFile	CLOSE ResourceFile	AsmFileName=BareFileName+".asm"	OPEN AsmFileName FOR SCRATCH AS OutFile	OPEN "_DeclareFile" FOR INPUT AS DeclareFile	FilBufSiz=LOF(DeclareFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD DeclareFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE DeclareFile	DELETE "_DeclareFile"	RESTORE Includes	OutBuf=""	WRITE OutFile,OutBuf	OutBuf="; Import Section"	WRITE OutFile,OutBuf	OutBuf=""	WRITE OutFile,OutBuf	BEGIN LOOP		READ OutBuf		EXIT IF OutBuf="ENDTEXT"		WRITE OutFile,OutBuf		INCR AsmLineCtr	END LOOP	OutBuf=""	WRITE OutFile,OutBuf	OutBuf="section '.idata' import data readable writeable"	WRITE OutFile,OutBuf	OutBuf=""	WRITE OutFile,OutBuf	FOR I=1 TO LastImportLib; Find last fcn for each Lib		TempInt=0		FOR J=1 TO LastImportFcn			IF ImportFcnTable(J).ImportFcnUse=TRUE AND ImportFcnTable(J).ImportLibUseNdx=I THEN				TempInt=J			END IF				NEXT J		IF TempInt<>0 THEN			ImportFcnTable(TempInt).ImportFcnLastUsed=TRUE		END IF	NEXT I	FOR I=1 TO LastImportFcn; Mark each Lib used as used		IF ImportFcnTable(I).ImportFcnUse=TRUE THEN			TempInt=ImportFcnTable(I).ImportLibUseNdx			ImportLibTable(TempInt).ImportLibUse=TRUE		END IF	NEXT I	TempInt=0; Find last Lib used	FOR I=1 TO LastImportLib		IF ImportLibTable(I).ImportLibUse=TRUE THEN			TempInt=I		END IF			NEXT I	ImportLibTable(TempInt).ImportLibLastUsed=TRUE	OutBuf="library "; Output the Lib Section	FOR I=1 TO LastImportLib		IF ImportLibTable(I).ImportLibUse=TRUE THEN			OutBuf=OutBuf+ImportLibTable(I).ImportLibAlias+","+CHR(OBQUOTE)+ImportLibTable(I).ImportLibName+CHR(OBQUOTE)			IF ImportLibTable(I).ImportLibLastUsed=FALSE THEN				OutBuf=OutBuf+CHR$($2c)+CHR$($5c)			END IF			WRITE OutFile,OutBuf			OutBuf="        "		END IF	NEXT I	OutBuf=""	WRITE OutFile,OutBuf	FOR I=1 TO LastImportLib; Output the Fcn lists		TempStr="import"		IF ImportLibTable(I).ImportLibUse=TRUE THEN			OutBuf=ImportLibTable(I).ImportLibAlias+":"			WRITE OutFile,OutBuf			FOR J=1 TO LastImportFcn				OutBuf=CHR$($09)+TempStr+CHR$($09)				IF ImportFcnTable(J).ImportLibUseNdx=I AND ImportFcnTable(J).ImportFcnUse=TRUE THEN					OutBuf=OutBuf+ImportFcnTable(J).ImportFcnAlias+CHR$($2c)+CHR(OBQUOTE)+ImportFcnTable(J).ImportFcnName+CHR(OBQUOTE)					IF ImportFcnTable(J).ImportFcnLastUsed=FALSE THEN						OutBuf=OutBuf+CHR$($2c)+CHR$($5c)					END IF					WRITE OutFile,OutBuf					TempStr=""				END IF			NEXT J		END IF	NEXT I	OutBuf=""	WRITE OutFile,OutBuf	OutBuf="; End of Import Section"	WRITE OutFile,OutBuf	CALL SUB MakeLine	WRITE OutFile,OutBuf	OutBuf=""	WRITE OutFile,OutBuf	OPEN "_DataFile" FOR INPUT AS DataFile	FilBufSiz=LOF(DataFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD DataFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE DataFile	DELETE "_DataFile"	OPEN "_DimFile" FOR INPUT AS DimFile	FilBufSiz=LOF(DimFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD DimFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE DimFile	DELETE "_DimFile"	OPEN "_DescFile" FOR INPUT AS DescFile	FilBufSiz=LOF(DescFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD DescFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE DescFile	DELETE "_DescFile"	OPEN "_PreCodeFile" FOR INPUT AS PreCodeFile	FilBufSiz=LOF(PreCodeFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD PreCodeFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	CLOSE PreCodeFile	DELETE "_PreCodeFile"	OPEN "_CodeFile" FOR INPUT AS CodeFile	FilBufSiz=LOF(CodeFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD CodeFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE CodeFile	DELETE "_CodeFile"	OPEN "_InitFile" FOR INPUT AS InitFile	FilBufSiz=LOF(InitFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD InitFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE InitFile	DELETE "_InitFile"	OPEN "_FunctionFile" FOR INPUT AS FunctionFile	FilBufSiz=LOF(FunctionFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD FunctionFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE FunctionFile	DELETE "_FunctionFile"	OPEN "_LibFile" FOR INPUT AS LibFile	FilBufSiz=LOF(LibFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD LibFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE LibFile	DELETE "_LibFile"	OPEN "_ProcFile" FOR INPUT AS ProcFile	FilBufSiz=LOF(ProcFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD ProcFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE ProcFile	DELETE "_ProcFile"	OPEN "_ExportFile" FOR INPUT AS ExportFile	FilBufSiz=LOF(ExportFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD ExportFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE ExportFile	DELETE "_ExportFile"	OPEN "_ResourceFile" FOR INPUT AS ResourceFile	FilBufSiz=LOF(ResourceFile)	BUFFER FileBuf=FilBufSiz	FilBufAdr=BUFADR(FileBuf)	BUFREAD ResourceFile,FilBufAdr,FilBufSiz	BUFWRITE OutFile,FilBufAdr,FilBufSiz	BUFFER FileBuf=0	CLOSE ResourceFile	DELETE "_ResourceFile"	CLOSE OutFile	FOR Ctr1=1 TO LastSym		TDataType=SymTable(Ctr1).DataType		IF TDataType=LABELVAR OR TDataType=FCN OR TDataType=PROC THEN			TDetail=SymTable(Ctr1).Detail			TDataMod=SymTable(Ctr1).DataMod			IF TDetail=LabelUnresolved THEN				IF TDataType=LABELVAR THEN					INCR ErrCnt					TempStr="Label unresolved: "+SymTable(Ctr1).SymName					SETDEFAULTCURSOR					WARNINGBOX "Error",TempStr,MB_OK					RETURN				ELSE					IF TDataType=FCN OR TDataType=PROC THEN						IF LAND(TDataMod,UsrFcnBit)=UsrFcnBit THEN							IF LAND(TDataMod,CalledBit)=CalledBit THEN								INCR ErrCnt								TempStr="Fcn or proc unresolved: "+SymTable(Ctr1).SymName								SETDEFAULTCURSOR								WARNINGBOX "Error",TempStr,MB_OK								RETURN							END IF						END IF					END IF				END IF									END IF		END IF	NEXT Ctr1	IF ConStkPtr<>0 THEN		TempStr="Unbalanced control structure in line "+STR(ConStk(ConStkPtr).ConLine)		SETDEFAULTCURSOR		WARNINGBOX "Error",TempStr,MB_OK		RETURN		DECR ConStkPtr; ???		INCR ErrCnt	END IF	IF GFNdx<>1 THEN		TempStr="Unbalanced conditional stack"		SETDEFAULTCURSOR		WARNINGBOX "Error",TempStr,MB_OK		RETURN		INCR ErrCnt	END IF	IF CodeBlockFlag=TRUE THEN		TempStr="Proc, fcn, event, task, or sub not complete"		SETDEFAULTCURSOR		WARNINGBOX "Error",TempStr,MB_OK		RETURN		INCR ErrCnt	END IF	IF ErrCnt<>0 THEN		TempStr=STR(ErrCnt)+" error(s)"		SETDEFAULTCURSOR		WARNINGBOX "Error",TempStr,MB_OK		RETURN	ELSE		; Do assembly here		IF AsmOutFlag=FALSE AND NoGen=FALSE THEN			CALL SUB Assemble		END IF	END IF	IF AsmOutFlag=FALSE OR NoGen=TRUE THEN		DELETE BareFileName+".asm"	END IF	IF AsmOutFlag=TRUE OR NoGen=TRUE THEN		CALL SUB FormatCompileTime		MSGBOX "Success",TempName,MB_OK		CALL SUB ShowMode		IF AsmOutFlag=TRUE THEN			ENABLEMENUITEM EditPopUp,emnuReturnToSource,TRUE			FileName=BareFileName+".asm"			Edit.LOADFILE FileName			SaveFileName=FileName			BareFileName=LEFT(FileName,LEN(FileName)-4)			Extension=LCASE(RIGHT(FileName,4))			OBMain.TEXT=ProgramName+"     ["+FileName+"]"			Timer1.TIME=50			StatusBar.SETTEXT 5,"Edit Objects"			Changed=FALSE			Edit.SETFOCUS		END IF		END IF	RETURN	NoInpFile:	TempStr="Cannot open file: "+FileName	SETDEFAULTCURSOR	WARNINGBOX "Error",TempStr,MB_OK	RETURNEND SEG MainLoop	;***** Subroutine Section ******BEGIN SUB DimVar	CALL SUB PrepVar	ErrRet	IF SymFound=TRUE THEN		ErrNo=ErrDupSym		EXIT SUB	END IF	TokenBuf=LCASE(RootSymbol)	CALL SUB KeyLook	IF KeyNdx<>0 THEN		TempStr="Symbol is Keyword"		ErrNo=$ff		EXIT SUB	END IF	IF SubCtr<>0 THEN		DMArray=$ff		ArraySize=SubValue(1)*SubValue(2)*SubValue(3)		SymTemp.ArrayDim1=SubValue(1)		SymTemp.ArrayDim2=SubValue(2)		SymTemp.ArrayDim3=SubValue(3)		SymTemp.ArrayDims=SubCtr		IF SubCtr>1 THEN			MultiFlag=$ff			TDataMod=LOR(TDataMod,MultiBit)		END IF		IF ArraySize=0 THEN			DMReDim=$ff			TDataMod=LOR(TDataMod,ReDimBit)		END IF	END IF	CALL SUB NexToken	IF TokenBuf<>"as" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	CALL SUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	SymTemp.SubType=NONE	SELECT CASE TokenBuf		CASE "boolean"			TDataType=BOOLVAR			SymType=" rb "			TDataSize=1			TDataAddr=1		CASE "byte"			TDataType=BYTEVAR			SymType=" rb "			TDataSize=1			TDataAddr=1		CASE "integer"			TDataType=WORDVAR			SymType=" rw "			TDataSize=2			TDataAddr=2		CASE "long"			TDataType=LONGVAR			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "quad"			TDataType=LONGVAR			SymType=" rq "			TDataSize=8			TDataAddr=8		CASE "label"			TDataType=LABELPTR			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "float"			TDataType=FLOATVAR			SymType=" rf "			TDataSize=8			TDataAddr=8		CASE "string"			TDataType=STRINGVAR			SymType=" rb "			CALL SUB NexToken			IF TokenBuf<>"*" THEN				TempInt=255; Default string size				CALL SUB UnDoToken			ELSE				CALL SUB NexToken				TempStr=TokenSaf				CALL SUB StrSiz				ErrRet			END IF			SymTemp.Detail=TempInt			IF TypeFlag=0 AND DMArray=0 THEN				VectorFlag=$ff				TDataMod=LOR(TDataMod,VectorBit)			END IF			TDataSize=TempInt			TDataAddr=TempInt		CASE "text"			IF DMArray<>0 THEN				ErrNo=ErrTextArray				RETURN			END IF			TDataType=TEXT			TDataSize=0			TDataAddr=0		CASE "file"			TDataType=LONGVAR			SymTemp.SubType=FILE			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "device"			TDataType=LONGVAR			SymTemp.SubType=DEVICE			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "task"			TDataType=LONGVAR			SymTemp.SubType=TASK			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "font"			TDataType=LONGVAR			SymTemp.SubType=FONT			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "icon"			TDataType=LONGVAR			SymTemp.SubType=ICON			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "cursor"			TDataType=LONGVAR			SymTemp.SubType=CURSOR			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "bitmap"			TDataType=LONGVAR			SymTemp.SubType=BITMAP			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "handle"			TDataType=LONGVAR			SymTemp.SubType=HANDLE			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "imagelist"			TDataType=LONGVAR			SymTemp.SubType=IMAGELIST			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "solidbrush"			TDataType=LONGVAR			SymTemp.SubType=SOLIDBRUSH			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "hatchbrush"			TDataType=LONGVAR			SymTemp.SubType=HATCHBRUSH			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "patternbrush"			TDataType=LONGVAR			SymTemp.SubType=PATTERNBRUSH			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "pen"			TDataType=LONGVAR			SymTemp.SubType=PEN			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "menu"			TDataType=LONGVAR			SymTemp.SubType=MENU			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE "timer"			TDataType=TIMER			INCR TimerNum			SymTemp.Detail=TimerNum			IF 	DMArray<>0 THEN				TimerNum=TimerNum+ArraySize-1			END IF			TDataSize=0			TDataAddr=0		CASE "family"			TDataType=FAMILY			SymTemp.SubType=FAMILY			INCR FamilyNum			SymTemp.Detail=FamilyNum			IF 	DMArray<>0 THEN				TempStr="Arrays of Familys not allowed"				ErrNo=$ff				GOTO MainLoop			END IF			TDataSize=0			TDataAddr=0		CASE "obcomm"			TDataType=OBCOMM			SymType=" rb "			TDataSize=100			TDataAddr=100		CASE "obzip"			IF 	DMArray<>0 THEN				TempStr="Arrays of OBZip not allowed"				ErrNo=$ff				DimOK=0				EXIT SUB			END IF			IF OBZipFlag=FALSE THEN				OBZipFlag=TRUE			ELSE				TempStr="Only one OBZip per program"				ErrNo=$ff				DimOK=0				EXIT SUB			END IF			TDataType=OBZIP			SymType=" rd "			TDataSize=4			TDataAddr=4		CASE ELSE					IF TokenBuf="raedit" THEN				IF RAEditFlag=FALSE THEN					RAEditFlag=TRUE				ELSE					TempStr="Only one RAEdit per program"					ErrNo=$ff					DimOK=0					EXIT SUB				END IF			END IF			CALL SUB ObjLook			IF ObjNdx<>0 THEN				ObjectCtr=ObjectCtr+SubValue(1)				TDataType=ObjNdx+99				SymType=" rd "				TDataSize=192				TDataAddr=192				IF SubCtr>1 THEN					TempStr="One Dim arrays only for controls"					ErrNo=$ff					EXIT SUB				END IF				IF TDataType=FORM OR TDataType=FRAME  OR TDataType=TABFOLDER OR TDataType=TOOLBAR OR TDataType=STATUSBAR OR TDataType=TOOLWINDOW OR TDataType=RAEdit THEN					IF SubCtr>0 THEN;Array not allowed						TempStr="Arrays not allowed for this control type"						ErrNo=$ff						EXIT SUB					END IF				END IF			ELSE				IF TokenBuf="logfont" THEN					TDataMod=LogFontBit				END IF				IF TokenBuf="datetime" THEN					TDataMod=DateTimeBit				END IF				TSymName=SymTemp.SymName				TypePtr=SymNdx				SubCtrSaf=SubCtr				SubValSaf=SubValue				CALL SUB TokenSym1				ErrRet				IF SymFound=FALSE OR SymTable(SymNdx).DataType<>TYPE THEN					ErrNo=ErrIVType					EXIT SUB				END IF				TDataSize=SymTable(SymNdx).DataSize				TDataAddr=SymTable(SymNdx).DataSize				SymType=" rb "				SymTemp.Detail=SymNdx				SymNdx=TypePtr				SymTemp.SymName=TSymName				SubCtr=SubCtrSaf				SubValue=SubValSaf				TDataType=COMPLEX			END IF	END SELECT	CALL SUB NexToken	SELECT CASE TokenBuf		CASE ""			CASE ";"			CASE "="			IF TDataType<1 OR TDataType>6 OR SymTemp.SubType<>NONE THEN				ErrNo=ErrSyntax				EXIT SUB			END IF			TDataMod=LOR(TDataMod,InitDataBit)		CASE "pointer"			IF TypeFlag<>0 OR DMArray<>0 THEN				ErrNo=ErrIVParm				EXIT SUB			END IF			DMAddr=$ff			VectorFlag=0			SymType=" rd "			TDataSize=4			TDataAddr=4			TDataMod=LOR(TDataMod,PointerBit)		CASE "alias"			IF TypeFlag<>0 THEN				ErrNo=ErrIVParm				EXIT SUB			END IF			IF TDataType=STRINGVAR THEN				ErrNo=ErrSyntax				EXIT SUB			END IF			AliasFlag=$ff			CALL SUB NexToken			IF TokenLen=0 THEN				ErrNo=ErrSyntax				EXIT SUB			END IF			SymNdxSaf=SymNdx			HandleName=SymTemp.SymName			SymTemp.SymName=TokenSaf			CALL SUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				EXIT SUB			END IF			AliasDataType=SymTable(SymNdx).DataType			TempInt=SymTable(SymNdx).DataMod			IF LAND(TempInt,ArrayBit)=ArrayBit THEN				AliasDataType=BYTEVAR; (Anything but string)			END IF			SymNdx=SymNdxSaf			SymTemp.SymName=HandleName			GUITempName=TokenSaf		CASE "vector"			IF TypeFlag<>0 OR DMAddr<>0 THEN				ErrNo=ErrIVParm				EXIT SUB			END IF			VectorFlag=$ff			TDataMod=LOR(TDataMod,VectorBit)		CASE ELSE			ErrNo=ErrIVMod			EXIT SUB	END SELECT	SymTemp.DataType=TDataType	IF DMArray<>0 THEN		TDataMod=LOR(ArrayBit,TDataMod)	END IF	DimOK=$ff	SymTemp.DataMod=TDataMod	SymTemp.DataSize=ArraySize*TDataSize	SymTemp.DataAddr=TDataAddr	IF TDataType=STRINGVAR OR TDataType=COMPLEX OR TDataType>99 THEN		ArraySize=SymTemp.DataSize	END IFEND SUBBEGIN SUB DecVar	TSymName=SymTemp.SymName	IF AliasFlag<>0 THEN		CALL SUB OutUninitData; Basic line as comment		IF AliasDataType=STRINGVAR THEN			OutBuf=TSymName+" equ "+GUITempName+"+12"		ELSE			OutBuf=TSymName+" equ "+GUITempName		END IF		CALL SUB OutUninitData		EXIT SUB	END IF	Comment=OutBuf	IF DMAddr<>0 THEN		CALL SUB OutUninitData; Basic line as comment		OutBuf=TSymName+" rd 1"		CALL SUB OutUninitData		EXIT SUB	END IF	IF DMReDim<>0 THEN		CALL SUB OutInitData; Basic line as comment		BufName=TSymName		CALL SUB MakeBuffer		EXIT SUB	END IF	IF VectorFlag=$ff THEN		IF TDataType=STRINGVAR AND DMArray=0 THEN			CALL SUB OutInitData; Basic line as comment			OutBuf="align 4"			CALL SUB OutInitData			OutBuf=TSymName+" dd "+TempStr+"+12"			CALL SUB OutInitData			OutBuf=" dd "+STR(TDataSize)			CALL SUB OutInitData			OutBuf=" dd 0"			CALL SUB OutInitData			OutBuf=" rb "+STR(ArraySize)			CALL SUB OutInitData		ELSE			CALL SUB OutUninitData; Basic line as comment			OutBuf="align 4"			CALL SUB OutUninitData			OutBuf=TSymName+" rd 3"			CALL SUB OutUninitData		END IF		EXIT SUB	END IF	IF TDataType=STRINGVAR THEN; String array case		CALL SUB OutUninitData; Basic line as comment		OutBuf=TSymName+" rb "+STR(ArraySize)		CALL SUB OutUninitData		EXIT SUB	END IF	IF DMArray<>0 OR TDataType=COMPLEX THEN		IF TDataType<100 THEN			CALL SUB OutUninitData			OutBuf="align 4"			CALL SUB OutUninitData				OutBuf=TSymName+SymType+STR(ArraySize)			CALL SUB OutUninitData		ELSE			IF TDataType=OBCOMM THEN				CALL SUB OutUninitData				OutBuf=TSymName+SymType+STR(ArraySize)				CALL SUB OutUninitData			ELSE				CALL SUB OutDesc				OutBuf="!"+TSymName+SymType+STR(ArraySize)				CALL SUB OutDesc			END IF				END IF		EXIT SUB	ELSE		IF TDataSize=2 THEN			OutBuf="align 2"			CALL SUB OutUninitData		ELSE			IF TDataSize>=4 AND TDataType<100 THEN				OutBuf="align 4"				CALL SUB OutUninitData			END IF		END IF		IF TDataType<100 THEN			OutBuf=Comment			CALL SUB OutUninitData			IF SymTemp.SubType=TASK THEN				OutBuf="!"+TSymName+SymType+"1"			ELSE				OutBuf=TSymName+SymType+"1"			END IF			CALL SUB OutUninitData		ELSE			OutBuf=Comment			IF TDataType=OBCOMM THEN				CALL SUB OutUninitData				OutBuf=TSymName+SymType+"100"				CALL SUB OutUninitData			ELSE				CALL SUB OutDesc				OutBuf="!"+TSymName+SymType+"192"				CALL SUB OutDesc			END IF				END IF	END IFEND SUBBEGIN SUB PrepVar	TDataMod=LAND(MemberBit,TypeFlag)	SymTemp.Detail=0	CALL SUB ClrDatTyp	VectorFlag=0	MultiFlag=0	DimOK=0	DimFlag=$ff	TDataType=COMPVAR	TDataSize=1	ArraySize=1	CALL SUB ClrSym	CALL SUB TokenSym	DataSymNdx=SymNdxEND SUBBEGIN SUB VarBlank	OutBuf=""	CALL SUB OutUninitDataEND SUBBEGIN SUB OutLabel	IF LabelFlag=$ff THEN		OutBuf=SymbolSaf		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB GetExp	FloatFlag=0	TypePtr=0	ExpEnd=0	ExpNdx=1	ExpLen=0	ParenCnt=0	FcnCtr=0	AECtr=0	ExpTable(ExpNdx)=1	LastEntry=SymTable(ExpTable(ExpNdx))	GetExp1:	IF ExpEnd=$ff THEN ExpExit	IF NextByte="," AND FcnCtr=0 AND AECtr=0 THEN ExpExit	IF IgnoreRightParen<>0 AND SrcNdx+1=EndNdx THEN ExpExit	IF IgnoreRightParen<>0 AND NextByte=")" AND ParenCnt<1 THEN ExpExit	CALL SUB NexToken	IF TokenLen=0 THEN ExpExit	IF TokenBuf="," THEN		CALL SUB AddRtGrp2		IncExpNdx		ExpTable(ExpNdx)=2		IncExpNdx		ExpTable(ExpNdx)=1		LastEntry=SymTable(ExpTable(ExpNdx))		GOTO GetExp1	END IF	;***********************	; Start of Pointer Stuff Here	IF TokenBuf="[" THEN		IncExpNdx		CALL SUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		END IF		SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO ExpExit		END IF		SymTemp=SymTable(SymNdx)		IF LAND(SymTemp.DataMod,PointerBit)<>PointerBit THEN			ErrNo=ErrTypMis			GOTO ExpExit		END IF		IF SymTemp.DataType=FLOATVAR THEN			INCR FloatFlag		END IF		IF SymTemp.DataType=COMPLEX THEN			ExpTable(ExpNdx)=24;  cpx begin			IncExpNdx		END IF		ExpTable(ExpNdx)=26;  "["		IncExpNdx		ExpTable(ExpNdx)=SymNdx		LastEntry=SymTemp		CALL SUB NexToken		IF TokenBuf<>"]" OR TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO ExpExit		END IF		IncExpNdx		ExpTable(ExpNdx)=27;  put "]" in table		IF SymTemp.DataType<>COMPLEX THEN GetExp1		IncExpNdx		IF NextByte="." THEN			CALL SUB NexToken;  eat "."			ExpTable(ExpNdx)=13;  "."			CALL SUB NexToken			IF TokenLen=0 THEN				ErrNo=ErrSyntax				GOTO ExpExit			END IF			SymTemp.SymName=TokenSaf			CALL SUB SymSrch			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO ExpExit			END IF			SymTemp=SymTable(SymNdx)			IF LAND(MemberBit,SymTemp.DataMod)<>MemberBit THEN				ErrNo=ErrTypMis				GOTO ExpExit			END IF			IF SymTemp.DataType=FLOATVAR THEN				INCR FloatFlag			END IF			IncExpNdx			ExpTable(ExpNdx)=SymNdx			IncExpNdx		END IF		ExpTable(ExpNdx)=25;  cpx end		GOTO GetExp1	END IF	; End of Pointer Stuff Here	;***********************	IF TokenType=TTypMath THEN		IncExpNdx		SELECT CASE TokenBuf			CASE "+"				CALL SUB Unary				ExpTable(ExpNdx)=15			CASE"-"				CALL SUB Unary				ExpTable(ExpNdx)=16			CASE "*"				ExpTable(ExpNdx)=17			CASE "/"				ExpTable(ExpNdx)=18			CASE "&"				ExpTable(ExpNdx)=147			CASE "|"				ExpTable(ExpNdx)=148			CASE "^"				ExpTable(ExpNdx)=149		END SELECT		LastEntry=SymTable(ExpTable(ExpNdx))		GOTO GetExp1	END IF	IF TokenBuf="(" THEN		IncExpNdx		IF LAND(ArrayBit,LastEntry.DataMod)<>0 AND SymTemp.DataType<$10 THEN			ExpTable(ExpNdx)=3			INCR ParenCnt			ParenStk(ParenCnt)=3			INCR AECtr			IncExpNdx			ExpTable(ExpNdx)=1			GOTO GetExp3		END IF		IF LAND(ArrayBit,LastEntry.DataMod)<>0 AND SymTemp.DataType=LABELPTR THEN			ExpTable(ExpNdx)=3			INCR ParenCnt			ParenStk(ParenCnt)=3			INCR AECtr			IncExpNdx			ExpTable(ExpNdx)=1			GOTO GetExp3		END IF		IF LastEntry.DataType=FCN THEN			ExpTable(ExpNdx)=5			INCR ParenCnt			ParenStk(ParenCnt)=5			INCR FcnCtr			IncExpNdx			ExpTable(ExpNdx)=1			GOTO GetExp3		END IF		IF LastEntry.DataType<>9 AND ExpNdx<>1 THEN			ErrNo=ErrIVExp			GOTO ExpExit		END IF		LevelCnt=1		CALL SUB PreScan1		CALL SUB AddLftGrp		ExpTable(ExpNdx)=1		INCR ParenCnt		ParenStk(ParenCnt)=1		GetExp3:		LastEntry=SymTable(ExpTable(ExpNdx))		GOTO GetExp1	END IF	IF TokenBuf=")" THEN		CALL SUB AddRtGrp2		IncExpNdx		IF ParenCnt=0 THEN			ErrNo=ErrParen			GOTO ExpExit		END IF		IF ParenStk(ParenCnt)=3 OR ParenStk(ParenCnt)=5 THEN			ExpTable(ExpNdx)=2			IncExpNdx		END IF		ExpTable(ExpNdx)=ParenStk(ParenCnt)+1		IF ExpTable(ExpNdx)=4 THEN			DECR AECtr		END IF		IF ExpTable(ExpNdx)=6 THEN			DECR FcnCtr		END IF		DECR ParenCnt		LastEntry=SymTable(ExpTable(ExpNdx))		CALL SUB AddRtGrp1		GOTO GetExp1	END IF	IF TokenBuf="." THEN		IncExpNdx		ExpTable(ExpNdx)=13		LastEntry=SymTable(ExpTable(ExpNdx))		GOTO GetExp1	END IF	SELECT CASE TokenType		CASE TTypSym			IncExpNdx			SymTemp.SymName=TokenBuf			CALL SUB SymSearch			IF SymFound=TRUE THEN				SymTemp=SymTable(SymNdx)				IF SymTemp.DataType=FCN THEN; Function found					FcnSymNdx=SymNdx					IF MID(SrcLine,SrcNdx+1,2)="()" THEN						ExpTable(ExpNdx)=SymNdx						IncExpNdx						INCR SrcNdx						ExpTable(ExpNdx)=5						IncExpNdx						INCR SrcNdx						ExpTable(ExpNdx)=6						NextByte=MID(SrcLine,SrcNdx+1,1)						GOTO GetExp1					END IF					CALL SUB PreScan					CALL SUB AddLftGrp					LastEntry=SymTemp					ExpTable(ExpNdx)=SymNdx					GOTO GetExp1				END IF			END IF			SymTemp.SymName=TokenSaf			CALL SUB SymSrch			IF ErrNo<>0 THEN ExpExit			IF SymFound=FALSE THEN				ErrNo=ErrUDSym				GOTO ExpExit			END IF			SymTemp=SymTable(SymNdx)			IF SymTemp.DataType>=100 THEN;//				GUIObjFlag=$ff;//				RETURN;//			END IF;//			IF SymTemp.DataType=TEXT THEN;//				TextFlag=$ff;//				RETURN;//			END IF;//			IF LAND(SymTemp.DataMod,PointerBit)=0 AND SymTemp.DataType<$10 THEN;  special test for pointer				DataTemp=SymTemp.DataType				IF SymTemp.DataType=FLOATVAR THEN					INCR FloatFlag				END IF			ELSE				DataTemp=LONGVAR			END IF			IF DataTemp>=BOOLVAR AND DataTemp<=STRINGVAR OR DataTemp=COMPLEX OR DataTemp=BUFFER THEN				ExpTable(ExpNdx)=SymNdx				IF LAND(MemberBit,SymTemp.DataMod)<>0 AND LastEntry.SymName<>"." AND SymTemp.DataType<$10 THEN					ErrNo=ErrIVExp					GOTO ExpExit				END IF				IF TypePtr<>0 AND LastEntry.SymName="." THEN					IF SymNdx-TypePtr>SymTable(TypePtr).Detail OR TypePtr>SymNdx THEN						ErrNo=ErrUDSym						GOTO ExpExit					ELSE						TypePtr=0					END IF				END IF				IF DataTemp=COMPLEX THEN					TempStr=NextByte					CALL SUB PreScan					CALL SUB AddLftGrp					NextByte=TempStr					INCR ParenCnt					ParenStk(ParenCnt)=24					ExpTable(ExpNdx)=24					IncExpNdx					TypePtr=SymTemp.Detail				END IF				IF DataTemp<>COMPLEX AND LAND(ArrayBit,SymTemp.DataMod)=ArrayBit AND SymTemp.DataType<$10 THEN					TempStr=NextByte					CALL SUB PreScan					CALL SUB AddLftGrp					NextByte=TempStr				END IF				IF DataTemp<>COMPLEX THEN					CALL SUB AddLftGrp				END IF				ExpTable(ExpNdx)=SymNdx				LastEntry=SymTemp				CALL SUB AddRtGrp1				GOTO GetExp1			END IF			IF DataTemp=COMPVAR OR DataTemp=MACROVAR THEN				Konstant=SymTable(SymNdx).Detail				SymTemp.SymName=STR(Konstant)				CALL SUB ProcKonst				IF ErrNo<>0 THEN ExpExit				CALL SUB AddRtGrp1				GOTO GetExp1			END IF			GOTO ExpExit		CASE TTypFloat			INCR FloatFlag			IncExpNdx			CALL SUB AddLftGrp			CALL SUB ValidFlt			IF FloatOK=FALSE THEN				ErrNo=ErrIVExp				GOTO ExpExit			END IF			SymTemp.SymName=TokenBuf			CALL SUB SymSrch			IF SymFound=FALSE THEN				CALL SUB ClrSym				SymTemp.DataType=FLOATVAR				SymTemp.DataSize=8				SymTemp.DataMod=ConstBit				CALL SUB SymInsert				ErrRet			END IF			SymTemp=SymTable(SymNdx)			LastEntry=SymTemp			ExpTable(ExpNdx)=SymNdx			CALL SUB AddRtGrp1		CASE TTypInt			IncExpNdx			CALL SUB AddLftGrp			CALL SUB ValidInt			IF IntOK=FALSE THEN				ErrNo=ErrIVExp				GOTO ExpExit			END IF			Konstant=VAL(TokenBuf)			SymTemp.SymName=Str(Konstant)			CALL SUB ProcKonst			IF ErrNo<>0 THEN ExpExit			CALL SUB AddRtGrp1		CASE TTypHex			IncExpNdx			CALL SUB AddLftGrp			CALL SUB ValidHex			IF HexOK=FALSE THEN				ErrNo=ErrIVExp				GOTO ExpExit			END IF			SymTemp.SymName=TokenBuf			CALL SUB ProcKonst			IF ErrNo<>0 THEN ExpExit			CALL SUB AddRtGrp1		CASE TTypQuote			IncExpNdx			IF LEN(TokenSaf)=2 THEN;  null string				LastEntry=SymTable(20)				ExpTable(ExpNdx)=20;  20 is table entry for null string				GOTO GetExp1			END IF			CALL SUB MakeStrConst			TempStr="_StrConst"+STR(PoolCtr)			SymTemp.SymName=TempStr			;Skip SymSrch, just point to next vacancy in symbol table			SymNdx=LastSym+1			IF SymNdx>SymTabSiz THEN				SymFull=$ff			END IF			SymTemp.DataType=STRINGVAR			SymTemp.DataMod=ConstBit			CALL SUB ClrSym			SymTemp.Detail=LEN(TokenSaf)-1			SymTemp.DataSize=SymTemp.Detail			CALL SUB SymInsert			IF ErrNo<>0 THEN				GOTO ExpExit			END IF			LastEntry=SymTemp			ExpTable(ExpNdx)=SymNdx		CASE ELSE			ErrNo=ErrIVExp			EXIT SUB	END SELECT	GOTO GetExp1	ExpExit:	IF ExpLen=ExpTabSiz THEN		ErrNo=ErrCpxExp	END IF	IF ExpLen=1 THEN	ErrNo=ErrIVExp	END IF	IF ErrNo=0 THEN; Check this block of code		IF ParenCnt<>0 THEN			IF ParenStk(ParenCnt)=24 THEN				IncExpNdx				ExpTable(ExpNdx)=25				DECR ParenCnt			END IF		END IF		IF ParenCnt<>0 THEN			IF ParenStk(ParenCnt)=22 THEN				IncExpNdx				ExpTable(ExpNdx)=23				ParenCnt=0			END IF		END IF		IF ParenCnt<>0 THEN			ErrNo=ErrParen		ELSE			IncExpNdx			ExpTable(ExpNdx)=2		END IF	END IFEND SUBBEGIN SUB PreScan	LevelCnt=0	CALL SUB PreScan1END SUBBEGIN SUB PreScan1	SrcNdxSaf=SrcNdx	ExpEndSaf=ExpEnd	BEGIN LOOP		CALL SUB NexToken		IF TokenLen=0 THEN			NextByte="%"			SrcNdx=SrcNdxSaf			ExpEnd=ExpEndSaf			EXIT SUB		END IF		IF TokenType=TTypMath AND LevelCnt=0 THEN			NextByte=TokenBuf			SrcNdx=SrcNdxSaf			ExpEnd=ExpEndSaf			EXIT SUB		END IF		IF TokenBuf="(" THEN			INCR LevelCnt		END IF		IF TokenBuf=")" THEN			DECR LevelCnt		END IF	END LOOPEND SUBBEGIN SUB Unary	LastExpression=ExpTable(ExpNdx-1)	IF LastExpression=1 OR LastExpression=3 OR LastExpression=5 OR LastExpression=22 OR LastExpression=24 THEN		ExpTable(ExpNdx)=21; *********		IncExpNdx	END IFEND SUBBEGIN SUB AddLftGrp	IF NextByte="*" OR NextByte="/" OR NextByte="&" THEN		IF LAND(MemberBit,SymTemp.DataMod)<>MemberBit THEN			IF ParenCnt<>0 THEN				IF ParenStk(ParenCnt)=22 THEN					EXIT SUB				END IF			END IF			INCR ParenCnt			ParenStk(ParenCnt)=22			ExpTable(ExpNdx)=22			IncExpNdx		END IF	END IFEND SUBBEGIN SUB AddRtGrp1	IF ParenCnt=0 THEN		EXIT SUB	END IF	IF NextByte="+" OR NextByte="-" OR NextByte="*" OR NextByte="/"  OR NextByte="&" OR NextByte="|" OR NextByte="^" THEN		IF ParenStk(ParenCnt)=24 THEN			IncExpNdx			DECR ParenCnt			ExpTable(ExpNdx)=25		END IF		IF ParenCnt=0 THEN			RETURN		END IF		IF NextByte="+" OR NextByte="-"  OR NextByte="|" THEN; ???? should "&", "^" be here also?			IF ParenStk(ParenCnt)=22 THEN				IncExpNdx				DECR ParenCnt				ExpTable(ExpNdx)=23				LastEntry=SymTable(ExpTable(ExpNdx))				EXIT SUB			ELSE				EXIT SUB			END IF		END IF	END IFEND SUBBEGIN SUB AddRtGrp2	IF ParenStk(ParenCnt)=24 THEN		IncExpNdx		DECR ParenCnt		ExpTable(ExpNdx)=25	END IF	IF ParenStk(ParenCnt)=22 THEN		IncExpNdx		DECR ParenCnt		ExpTable(ExpNdx)=23	END IFEND SUBBEGIN SUB ProcKonst	CALL SUB SymSrch	IF SymFound=FALSE THEN		CALL SUB ClrSym		SymTemp.DataType=LONGVAR		SymTemp.DataSize=4		SymTemp.DataMod=ConstBit		SymTemp.Detail=IVAL(SymTemp.SymName)		CALL SUB SymInsert		ErrRet	END IF	SymTemp=SymTable(SymNdx)	LastEntry=SymTemp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB ProcExp	IF ExpFlag=TRUE THEN		FOR Ctr1=1 to ExpLen			;PRINT SymTable(ExpTable(Ctr1)).SymName;		NEXT Ctr1		TempStr=""		;CALL SUB OutPrint	END IF	BEGIN LOOP		LastGroup=$00		TempInt=ExpNdx		CALL SUB ParenScan		ExpNdx=TempInt		IF ParenCnt=0 THEN			EXIT SUB		END IF		CALL SUB SolveTerm		ErrRet		CALL SUB SquishExp	END LOOPEND SUBBEGIN SUB ParenScan	ParenCnt=0	ExpNdx=0	PType=0	ExpLeft=0	ExpRight=0	IF ExpNdx>ExpLen THEN;???		EXIT SUB	END IF	BEGIN LOOP		INCR ExpNdx		PType=ExpTable(ExpNdx)		IF PType=1 OR PType=PTArrOpn OR PType=PTFcnOpn OR PType=22 OR PType=PTCpxOpn OR PType=26 THEN			ExpLeft=ExpNdx			INCR ParenCnt		END IF		IF PType=2 OR PType=PTArrCls OR PType=PTFcnCls OR PType=23 OR PType=PTFCpxCls OR PType=27 THEN			ExpRight=ExpNdx			EXIT SUB		END IF	END LOOPEND SUBBEGIN SUB SquishExp	BEGIN LOOP		IF ExpRight+1>ExpLen THEN			ExpLen=ExpLeft-1			EXIT SUB		END IF		ExpTable(ExpLeft)=ExpTable(ExpRight+1)		INCR ExpLeft		INCR ExpRight	END LOOPEND SUBBEGIN SUB SolveTerm	D0Loaded=0	IF ExpLeft=1 AND ExpRight=ExpLen THEN		LastGroup=$ff	END IF	IF ExpLeft=2 AND ExpRight=ExpLen-1 AND ExpTable(1)=1 THEN		LastGroup=$ff	END IF	;*******************************	; Pointer Stuff Begins Here	IF PType=27 THEN		ExpNdx=ExpLeft+1		CALL SUB ClassOp		CALL SUB GetTmpVec		ErrRet		SymTable(SymNdx).DataMod=LAND(SymTable(SymNdx).DataMod,$fd);  kill addr bit		ExpTable(ExpNdx)=SymNdx		OutBuf="mov esi,["+TSymName+"]"		CALL SUB OutFcnCodeData		IF SymTemp.DataType=COMPLEX THEN			OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+3)).DataAddr)			CALL SUB OutFcnCodeData		END IF		OutBuf="mov ["+SymTemp.SymName+"],esi"		CALL SUB OutFcnCodeData		IF TDataType=STRINGVAR THEN			OutBuf="mov ["+SymTemp.SymName+"+4],"+STR(TDetail)			CALL SUB OutFcnCodeData			OutBuf="mov ["+SymTemp.SymName+"+8],0"			CALL SUB OutFcnCodeData		END IF		GOTO GrpCpxEnd	END IF	; Pointer Stuff Ends Here	;*******************************	IF PType=PTArrCls THEN		ExpNdx=ExpLeft-1		CALL SUB ClassOp		ArrayDataType=TDataType		ArrayDetail=TDetail		CALL SUB GetTmpVec		ErrRet		CALL SUB GetBase		ExpTable(ExpNdx)=SymNdx		TempStr=SymTemp.SymName		CALL SUB GetOpSize		CALL SUB BldOffset		ErrRet		OutBuf="mov ["+TempStr+"],esi"		CALL SUB OutFcnCodeData		IF ArrayDataType=STRINGVAR THEN			OutBuf="mov ["+TempStr+"+4],"+STR(ArrayDetail)			CALL SUB OutFcnCodeData			OutBuf="mov ["+TempStr+"+8],0"			CALL SUB OutFcnCodeData		END IF		GOTO ArrFcnEnd	END IF	IF PType=PTFcnCls THEN; Function		HasFcn=$ff		ExpNdx=ExpLeft-1		SymTemp=SymTable(ExpTable(ExpNdx))		FcnName=SymTemp.SymName		ExpNdx=ExpNdx+2		IF LAND(SymTemp.DataMod,UsrFcnBit)=UsrFcnBit THEN			SymTable(FcnSymNdx).DataMod=LOR(SymTable(FcnSymNdx).DataMod,CalledBit)			TFcnDataType=SymTemp.FcnDataType			CALL SUB GetFcnTypes			FOR Ctr3=1 TO TFcnArgs				CALL SUB ClassOp				CALL SUB ArgPush				ErrRet				INCR ExpNdx			NEXT Ctr3			OutBuf="call "+FcnName			CALL SUB OutFcnCodeData			SELECT CASE TFcnDataType				CASE BOOLVAR					ExpTable(ExpNdx)=193				CASE LONGVAR					ExpTable(ExpNdx)=194				CASE STRINGVAR					ExpTable(ExpNdx)=195				CASE FLOATVAR					ExpTable(ExpNdx)=196			END SELECT							ELSE			FcnCode=SymTemp.Detail			ON FcnCode GOSUB F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13,F14,F15,F16,F17,F18,F19,F20,F21,F22,F23,F24,F25,F26,F27,F28,F29,F30,F31,F32,F33,F34,F35,F36,F37,F38,F39,F40,F41,F42,F43,F44,F45,F46,F47,F48,F49,F50,F51,F52,F53,F54,F55,F56,F57,F58,F59,F60,F61,F62,F63,F64,F65,F66,F67,F68,F69,F70,F71,F72,F73,F74,F75,F76,F77,F78,F79,F80,F81,F82		END IF		ErrRet		GOTO ArrFcnEnd	END IF	IF PType=PTFCpxCls THEN		IF ExpRight-ExpLeft=2 THEN			ExpNdx=ExpLeft+1			CALL SUB ClassOp			IF DMVector=0 THEN				CALL Vectorize				ErrRet			END IF			IF DMVector<>0 AND DMTemp=0 THEN				CALL SetTmpVec				ErrRet			END IF			GOTO GrpCpxEnd		END IF		ExpNdx=ExpLeft+3		CALL SUB ClassOp		IF TDataType=STRINGVAR AND DMVector=0 THEN			;CALL SUB VecString		END IF		IF DMVector<>0 AND DMTemp=0 THEN			CALL SetTmpVec			ErrRet		END IF		ExpNdx=ExpNdx-2		CALL SUB ClassOp		IF DMVector=0 THEN			CALL Vectorize			ErrRet		END IF		IF DMVector<>0 AND DMTemp=0 THEN			CALL SetTmpVec			ErrRet		END IF		ExpNdx=ExpNdx+2		CALL SUB ClassOp		ExpNdx=ExpNdx-2		SymNdx=ExpTable(ExpNdx)		SymTable(SymNdx).DataType=TDataType		SymTable(SymNdx).DataSize=TDataSize		SymTable(SymNdx).Detail=TDetail		IF DMVector<>0 THEN			OutBuf="mov eax,["+SymTable(SymNdx).SymName+"]"			CALL SUB OutFcnCodeData			OutBuf="add eax,["+TSymName+"]"			CALL SUB OutFcnCodeData			OutBuf="mov ["+SymTable(SymNdx).SymName+"],eax"			CALL SUB OutFcnCodeData		END IF		IF OpClass=STRClass AND ReadFlag=0 THEN			OutBuf="mov ["+SymTable(SymNdx).SymName+"+4],"+STR(SymTemp.Detail)			CALL SUB OutFcnCodeData			OutBuf="mov ["+SymTable(SymNdx).SymName+"+8],0"			CALL SUB OutFcnCodeData			END IF		GOTO GrpCpxEnd	END IF	; Get here if PType=2	ExpNdx=ExpLeft+1	CALL SUB ClassOp	MakeLong	IF ExpRight-ExpLeft=2 AND DMArray<>0 THEN		IF CompFlag<>0 THEN			ErrNo=ErrIVExp		END IF		GOTO GrpCpxEnd	END IF	IF LastGroup=$ff AND ExpRight-ExpLeft<>2 AND Target=$ff THEN		ErrNo=ErrIVTarget		RETURN	END IF	IF ExpRight-ExpLeft=2 THEN		IF TDataType=STRINGVAR AND DMVector=0 AND DMAddr=0 THEN			CALL SUB VecString		END IF		IF TDataType=STRINGVAR AND DMVector<>0 AND DMTemp=0 AND DiskIO=$ff  AND BufRWFlg=0 THEN			CALL SUB GetBase		END IF		GOTO GrpCpxEnd	END IF	ScanStr:	CALL SUB ClassOp	MakeLong	IF TDataType=STRINGVAR AND DMVector=0 AND DMAddr=0 THEN		CALL SUB VecString	END IF	IF DMVector<>0 AND DMTemp=0 THEN		CALL SetTmpVec		ErrRet	END IF	INCR ExpNdx	IF ExpNdx<ExpRight THEN ScanStr	ExpNdx=ExpLeft+1	CALL SUB ClassOp	MakeLong	IF TDataType=STRINGVAR THEN		DataOp=0		Ctr1=0		BEGIN LOOP			IF DataOp=0 THEN				CALL SUB ClassOp				IF TDataType<>STRINGVAR THEN					ErrNo=ErrIVExp					EXIT SUB				END IF				INCR Ctr1				IF Ctr1>1 THEN					OutBuf="mov esi,"+TSymName					CALL SUB OutFcnCodeData					TSymName=SymTable(ExpTable(ExpNdx-2)).SymName					OutBuf="mov ["+TSymName+"+8],esi; concatenation"					CALL SUB OutFcnCodeData				END IF				DataOp=$ff			ELSE				MathOp=ExpTable(ExpNdx)				IF MathOp<15 THEN					ErrNo=ErrIVExp					EXIT SUB				END IF				DataOp=0			END IF			INCR ExpNdx			EXIT IF ExpNdx>=ExpRight		END LOOP				IF DataOp=0 THEN			ErrNo=ErrIVExp			EXIT SUB		END IF		ExpNdx=ExpLeft+1		GOTO GrpCpxEnd	END IF	IF TDataType<2 OR TDataType>5 THEN		ErrNo=ErrIVExp		EXIT SUB	ELSE		DataOp=0		Ctr1=0		BEGIN LOOP			IF DataOp=0 THEN				DataOp=$ff				CALL SUB LoadReg				ErrRet				INCR Ctr1				IF Ctr1>1 THEN					IF MathOp=15 THEN						CALL SUB DoAdd					ELSE						IF MathOp=16 THEN							CALL SUB DoSub						ELSE							IF MathOp=17 THEN								CALL SUB DoMul							ELSE								IF MathOp=18 THEN									CALL SUB DoDiv								ELSE									IF MathOp=147 THEN										CALL SUB DoAnd									ELSE										IF MathOp=148 THEN											CALL SUB DoOr										ELSE											CALL SUB DoXor										END IF									END IF								END IF							END IF						END IF					END IF				END IF			ELSE				MathOp=ExpTable(ExpNdx)				DataOp=0			END IF			INCR ExpNdx			EXIT IF ExpNdx>=ExpRight		END LOOP		IF DataOp=0 THEN			ErrNo=ErrIVExp		END IF		ExpNdx=ExpLeft+1		IF LastGroup=$ff AND CompFlag=0 THEN			ExpTable(ExpNdx)=19			IF TDataType=FLOATVAR THEN				SymTable(19).DataType=FLOATVAR			ELSE				SymTable(19).DataType=LONGVAR			END IF			GOTO GrpCpxEnd		END IF		IF FloatFlag=0 THEN			CALL SUB GetTmp			ErrRet		ELSE			CALL SUB GetFltTmp			ErrRet		END IF    	   	OutBuf="mov ["+SymTemp.SymName+"],"+Reg0Name		CALL SUB OutFcnCodeData		D1Cleared=0		ExpTable(ExpNdx)=SymNdx		GOTO GrpCpxEnd	END IF	ArrFcnEnd:	DECR ExpLeft	GrpCpxEnd:	ExpTable(ExpLeft)=ExpTable(ExpNdx)	ExpNdx=ExpLeft	INCR ExpLeftEND SUBBEGIN SUB GetBase	GetBaseFlag=TRUE	TArrayDim2Safe=TArrayDim2	IF DMMember<>0 THEN		IF DMArray=0 THEN			OutBuf="mov esi,"+STR(TDataAddr)		ELSE			CALL SUB GetOpSize			OutBuf="mov esi,0-("+STR(ArrayBase)+"*"+STR(TempInt)+"*"+STR(TArrayDim2)+")"		END IF		CALL SUB OutFcnCodeData		EXIT SUB	END IF	IF DMVector<>0 THEN		OutBuf="mov esi,["+TSymName+"]"		CALL SUB OutFcnCodeData		IF TDataType=COMPLEX THEN			CpxArrayOffset=ArrayBase*TDataAddr			OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)			CALL SUB OutFcnCodeData		END IF		EXIT SUB	END IF	IF DMArray<>0 THEN		OutBuf="mov esi,"+TSymName+"-("+STR(ArrayBase)+"*"+STR(TDataAddr)+"*"+STR(TArrayDim2)+")"		IF TDataType=COMPLEX THEN			CpxArrayOffset=ArrayBase*TDataAddr			IF ExpTable(ExpNdx+1)<>3 THEN; Whole Array				OutBuf="mov esi,"+TSymName			ELSE				OutBuf=OutBuf+"+"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)			END IF		END IF		CALL SUB OutFcnCodeData		EXIT SUB	END IF	IF TDataType=COMPLEX THEN		OutBuf="mov esi,"+TSymName+"+"+STR(SymTable(ExpTable(ExpNdx+2)).DataAddr)		CALL SUB OutFcnCodeData		EXIT SUB	END IF	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB BldOffset	SymTable(SymNdx).DataSize=TempInt	SymTable(SymNdx).DataMod=LAND(ArrayMsk,SymTable(SymNdx).DataMod)	CALL SUB ClassOp	ExpNdx=ExpNdx+2	NumArgs=ExpRight-ExpLeft-1	IF NumArgs<>SubCtr THEN		ErrNo=ErrArrSub		EXIT SUB	END IF	CALL SUB SubLoad	IF TempInt<>1 THEN		OutBuf="imul eax,"+STR(TempInt); first sub*datasize		CALL SUB OutFcnCodeData	END IF	IF NumArgs=1 THEN;  1 DIM array		OutBuf="add esi,eax"		CALL SUB OutFcnCodeData		ExpNdx=ExpNdx-2		EXIT SUB	END IF	IF NumArgs=2 THEN;  2 DIM array		OutBuf="mov edx,eax"; save first sub*datasize		CALL SUB OutFcnCodeData		OutBuf="imul edx,"+STR(TArrayDim2Safe)		CALL SUB OutFcnCodeData		INCR ExpNdx		CALL SUB SubLoad		ErrRet		DecArrayNdx		OutBuf="imul eax,"+STR(TempInt)		CALL SUB OutFcnCodeData		OutBuf="add eax,edx"		CALL SUB OutFcnCodeData		OutBuf="add esi,eax"		CALL SUB OutFcnCodeData		ExpNdx=ExpNdx-3	ELSE		ErrNo=ErrArrSub	END IFEND SUBBEGIN SUB VecString	IF BufRWFlg=$ff THEN;  for the case of BUFRW fn,ADDR(a$),size		EXIT SUB	END IF	CALL SUB GetTmpVec	ErrRet	CALL SUB GetBase	ExpTable(ExpNdx)=SymNdx	TempStr=SymTemp.SymName	TempInt=TDetail	IF PType=PTArrCls THEN		CALL SUB BldOffset	END IF	OutBuf="mov ["+TempStr+"],esi"	CALL SUB OutFcnCodeData	IF ReadFlag=0 THEN		OutBuf="mov ["+TempStr+"+4],"+STR(TempInt)		CALL SUB OutFcnCodeData		OutBuf="mov ["+TempStr+"+8],0"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB ClassOp	SymTemp=SymTable(ExpTable(ExpNdx))	CALL SUB ClassOp1END SUBBEGIN SUB ClassOp1	CALL SUB ClrDatTyp	TSymName=SymTemp.SymName	TDataType=SymTemp.DataType	TSubType=SymTemp.SubType	TDataMod=SymTemp.DataMod	TDetail=SymTemp.Detail	TDataAddr=SymTemp.DataAddr	TDataSize=SymTemp.DataSize	TArrayDim2=SymTemp.ArrayDim2	CALL SUB GetDataType 	;OutBuf="; GetdataType ClassOp "+DataTypeName	;CALL SUB OutFcnCodeData	DMTemp=LAND(TempBit,TDataMod)	DMVector=LAND(VectorBit,TDataMod)	DMMember=LAND(MemberBit,TDataMod)	DMMulti=LAND(MultiBit,TDataMod)	DMConst=LAND(ConstBit,TDataMod)	DMAddr=LAND(PointerBit,TDataMod)	IF LAND(ArrayBit,TDataMod)=ArrayBit THEN		DMArray=$ff		OpClass=ARRClass		IF DMMulti<>0 THEN			;MultiNdx=TMultiPtr			SubCtr=SymTemp.ArrayDims;;			;SubValue(1)=SymTable(MultiNdx).Detail			;SubValue(2)=SymTable(MultiNdx).DataAddr			;SubValue(3)=SymTable(MultiNdx).DataSize		ELSE			SubCtr=1		END IF		EXIT SUB	END IF	IF TDataType>=2 AND TDataType<=4 OR LAND(TDataMod,PointerBit)=PointerBit THEN		OpClass=INTClass		EXIT SUB	END IF	IF TDataType=FCN AND LAND(TDataSize,$00000004)=4 THEN		OpClass=INTClass	END IF	SELECT CASE TDataType		CASE BOOLVAR			OpClass=BOOLClass		CASE STRINGVAR			OpClass=STRClass		CASE FLOATVAR			OpClass=FLTClass		CASE COMPLEX			OpClass=CPXClass		CASE LABELPTR			OpClass=LBLClass		CASE ELSE			OpClass=0	END SELECTEND SUBBEGIN SUB Expr	CALL SUB GetExp	ErrRet	CALL SUB ProcExp	ErrRet	CALL SUB ClassOpEND SUBBEGIN SUB TokenSym	CALL SUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	CALL SUB TokenSym1END SUBBEGIN SUB TokenSym1	CALL SUB GetRootSymbol	CALL SUB ChkValidSymbol	IF SymbolValid=FALSE THEN		ErrNo=ErrIVSNam		EXIT SUB	END IF	SymTemp.SymName=SymbolSaf	CALL SUB SymSrchEND SUBBEGIN SUB ClrSym	SymTemp.SubType=0	SymTemp.Detail=0	SymTemp.DataAddr=0	SymTemp.DataSize=0	SymTemp.ArrayDim1=0	SymTemp.ArrayDim2=1	SymTemp.ArrayDim3=1	SymTemp.GUIEvents=0	SymTemp.GUINotifyEvents=0	SymTemp.ArrayDims=0	SymTemp.Misc=0	SymTemp.FcnDataType=0	SymTemp.FcnArgs=0END SUBBEGIN SUB CallErr	IF StatFlag=$ff THEN		EXIT SUB	END IF	INCR OELabelNum	OutBuf="cmp eax,-1"	CALL SUB OutFcnCodeData	OutBuf="jg _OELbl"+STR(OELabelNum)	CALL SUB OutFcnCodeData	CALL SUB CallErrCommonEND SUBBEGIN SUB CallErrZ	IF StatFlag=$ff THEN		RETURN	END IF	INCR OELabelNum	OutBuf="cmp eax,0"	CALL SUB OutFcnCodeData	OutBuf="jne _OELbl"+STR(OELabelNum)	CALL SUB OutFcnCodeData	CALL SUB CallErrCommonEND SUBBEGIN SUB CallErrCommon	ImportFcnTable(ptrGetLastError).ImportFcnUse=TRUE	OutBuf="invoke GetLastError"	CALL SUB OutFcnCodeData	OutBuf="mov [err],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [erl],"+STR(BasicLineCtr)	CALL SUB OutFcnCodeData	OutBuf=ErrOpCode+" [_ErrVec]"	CALL SUB OutFcnCodeData	OutBuf="_OELbl"+STR(OELabelNum)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetOpSize	SELECT CASE TDataType		CASE BOOLVAR			TempInt=1		CASE BYTEVAR			TempInt=1		CASE WORDVAR			TempInt=2		CASE LONGVAR			TempInt=4		CASE LABELPTR			TempInt=4		CASE FLOATVAR			TempInt=8		CASE COMPLEX			TempInt=SymTable(SymTable(SymNdx).Detail).DataSize		CASE STRINGVAR			TempInt=(SymTable(SymNdx).Detail)	END SELECT	IF LAND(TDataMod,PointerBit)=PointerBit THEN		TempInt=4	END IFEND SUBBEGIN SUB DevChk	CALL SUB NexToken	IF TokenBuf="#" THEN		DevFlag=$ff	ELSE		CALL SUB UnDoToken	END IFEND SUBBEGIN SUB GetFileHandle	CALL SUB GetExp	ErrRet	IF SymTable(SymNdx).DataType>99 THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	CALL SUB ProcExp	ErrRet	CALL SUB GetFileHandle2	IF KeyNdx<>3 AND KeyNdx<>4 THEN; Not SETEOF, CLOSE		CALL SUB NexToken		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax		END IF	END IFEND SUBBEGIN SUB GetFileHandle2	CALL SUB ClassOp	IF TSubType<>FILE AND TSubType<>DEVICE THEN		ErrNo=ErrIVType		EXIT SUB	END IF	IF Target=0 THEN		IF TSymName<>"~" THEN			D0Loaded=0			CALL SUB LoadReg			ErrRet		END IF		OutBuf="mov [_IOPthNum],eax"		CALL SUB OutFcnCodeData	ELSE		IF DMConst<>0 THEN			ErrNo=ErrIVExp			EXIT SUB		END IF		IF DMVector=0 THEN			PathIsVector=0			PathVar=TSymName		ELSE			PathIsVector=$ff			PathVar=TSymName		END IF	END IFEND SUBBEGIN SUB GetFileName	CALL SUB Expr	ErrRet	IF TDataType<>STRINGVAR THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	ediUsed=TRUE	OutBuf="mov edi,_IOBuffer"	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB BufRW	BufRWFlg=$ff	DiskIO=$ff	CALL SUB GetFileHandle	ErrRet	CALL SUB GetIntOp; Get Address	ErrRet	OutBuf="mov [_XferAddr],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp; Get # of bytes	ErrRet	OutBuf="mov [XferCount],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetPut	DiskIO=$ff	CALL SUB GetFileHandle	ErrRet	CALL SUB Expr	ErrRet	IF GetBaseFlag=FALSE THEN		OutBuf="mov esi,"+TSymName		CALL SUB OutFcnCodeData	END IF	IF DMConst<>0 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf="mov [_XferAddr],esi"	CALL SUB OutFcnCodeData	OutBuf="mov [XferCount],"+STR(SymTemp.DataSize)	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen=0 THEN		EXIT SUB	END IF	IF TokenBuf<>"," THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	CALL SUB GetIntOp	ErrMain	DecArrayNdx	OutBuf="mov edx,[XferCount]"	CALL SUB OutFcnCodeData	OutBuf="imul eax,edx"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUE	OutBuf="invoke SetFilePointer,[_IOPthNum],eax,0,FILE_BEGIN"	CALL SUB OutFcnCodeData	CALL SUB CallErrEND SUBBEGIN SUB ReadWrite	DiskIO=$ff	ImportFcnTable(ptrGetLastError).ImportFcnUse=TRUE	CALL SUB GetFileHandle	ErrRet	CALL SUB Expr	ErrRet	IF TDataType<>STRINGVAR THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf="mov [_XferAddr],esi"	CALL SUB OutFcnCodeData	OutBuf="mov [__ByteCounter],"+STR(SymTemp.Detail)	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetRegPrm	SymTemp=SymTable(ExpTable(ExpNdx))	CALL SUB GetRP1END SUBBEGIN SUB GetRP1	TDataType=SymTemp.DataType	TDataMod=SymTemp.DataMod	IF LAND(SymTemp.DataMod,PointerBit)<>PointerBit THEN		IF TDataType<1 OR TDataType>5 THEN			ErrNo=ErrIVExp			EXIT SUB		END IF	END IF	CALL SUB GetDataType	;OutBuf="; GetdataType GetRp1 "+DataTypeName	;CALL SUB OutFcnCodeData	IF FloatFlag=0 THEN		Reg0Name="eax"		Reg1Name="edx"	ELSE		Reg0Name="eaxf"		Reg1Name="edxf"	END IF	IF D0Loaded=0 THEN		LdRegName=Reg0Name	ELSE		LdRegName=Reg1Name	END IFEND SUBBEGIN SUB LoadReg	IF Promote=$ff OR Demote=$ff THEN		CALL SUB SymSrch		SymTemp=SymTable(SymNdx)		CALL SUB GetRP1	ELSE		CALL SUB GetRegPrm	END IF	ErrRet	TDataType=SymTemp.DataType	IF LAND(ConstBit,SymTemp.DataMod)=ConstBit THEN		TConst=$ff		TConstVal=SymTemp.Detail	ELSE		TConst=0	END IF	IF D0Loaded=0 THEN		D0Const=TConst		D0ConstVal=TConstVal		SELECT CASE TDataType			CASE BOOLVAR				LdRegName="al"			CASE BYTEVAR				LdRegName="al"			CASE WORDVAR				LdRegName="ax"			CASE LONGVAR				LdRegName="eax"		END SELECT		ELSE		D1Const=TConst		D0ConstVal=TConstVal		SELECT CASE TDataType			CASE BOOLVAR				LdRegName="dl"			CASE BYTEVAR				LdRegName="dl"			CASE WORDVAR				LdRegName="dx"			CASE LONGVAR				LdRegName="edx"		END SELECT	END IF	IF TConst<>0 THEN		OutBuf="mov "+LdRegName+","+STR(TConstVal)	ELSE		IF LAND(VectorBit,SymTemp.DataMod)=0 THEN			CALL SUB ClrDataRegs			OutBuf="mov "+LdRegName+","+DataTypeName+"["+SymTemp.SymName+"]"		ELSE			ediUsed=TRUE			OutBuf="mov edi,["+SymTemp.SymName+"]"			CALL SUB OutFcnCodeData			CALL SUB ClrDataRegs			OutBuf="mov "+LdRegName+","+DataTypeName+"[edi]"		END IF	END IF	D0Loaded=$ff	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB StoreD0	SymTemp.SymName=Op1Name	CALL SUB SymSrch	TSymName=SymTable(SymNdx).SymName	TDataType=SymTable(SymNdx).DataType	TDataMod=SymTable(SymNdx).DataMod	DMConst=0	SELECT CASE TDataType		CASE BOOLVAR			Reg0Name="al"			OpSizeStr=" byte "		CASE BYTEVAR			Reg0Name="al"			OpSizeStr=" byte "		CASE WORDVAR			Reg0Name="ax"			OpSizeStr=" word "		CASE LONGVAR			Reg0Name="eax"			OpSizeStr=" dword "		CASE FLOATVAR			Reg0Name="floatreg"			OpSizeStr=" qword "	END SELECT	IF LAND(TDataMod,PointerBit)<>0 THEN			Reg0Name="eax"			OpSizeStr=" dword "	END IF	IF LAND(TDataMod,VectorBit)=0 THEN		OutBuf="mov"+OpSizeStr+"["+TSymName+"],"+Reg0Name	ELSE		IF LAND(TDataMod,PointerBit)<>0 THEN			Reg0Name="eax"			OutBuf="mov esi,"+SymTemp.SymName			CALL SUB OutFcnCodeData		ELSE			OutBuf="mov esi,["+SymTemp.SymName+"]"			CALL SUB OutFcnCodeData		END IF		OutBuf="mov"+OpSizeStr+"[esi],"+Reg0Name	END IF	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetIntTmp	OpClass=INTClass	CALL SUB GetTmpEND SUBBEGIN SUB GetTmp	IF TmpUse=NumTemps THEN		ErrNo=ErrTmpUse		EXIT SUB	END IF	INCR TmpUse	IF TmpUse>TmpMax THEN		TmpMax=TmpUse		CALL SUB VarBlank		Comment="Temporary Variable"		CALL SUB BldComment		CALL SUB OutUninitData		OutBuf="_Tmp"+STR(TmpUse)+" rd 1"		CALL SUB OutUninitData	END IF	SymTemp.SymName="_Tmp"+STR(TmpUse)	CALL SUB SymSrch	IF OpClass=INTClass THEN		SymTable(SymNdx).DataType=LONGVAR	ELSE		SymTable(SymNdx).DataType=TDataType	END IF	SymTable(SymNdx).DataSize=TDataSizeEND SUBBEGIN SUB GetFltTmp	IF FTmpUse=NumTemps THEN		ErrNo=ErrTmpUse		EXIT SUB	END IF	INCR FTmpUse	IF FTmpUse>FTmpMax THEN		FTmpMax=FTmpUse		CALL SUB VarBlank		Comment="Temporary Floating Point Variable"		CALL SUB BldComment		CALL SUB OutUninitData		OutBuf=";static double _FTmp"+STR(FTmpUse)+";"		CALL SUB OutUninitData		CALL SUB VarBlank	END IF	SymTemp.SymName="_FTmp"+STR(FTmpUse)	CALL SUB SymSrchEND SUBBEGIN SUB GetStrVec	INCR StrTmpUse	IF StrTmpUse>StrTmpMax THEN		StrTmpMax=StrTmpUse		CALL SUB VarBlank		Comment="Temporary String Variable"		CALL SUB BldComment		CALL SUB OutUninitData		OutBuf="_StrTmp"+STR(StrTmpUse)+" rb 32"		CALL SUB OutUninitData	END IF	CALL SUB ReqTmpVec	ErrRet	SymTable(SymNdx).DataMod=TmpVec	SymTable(SymNdx).DataType=STRINGVAR	SymTable(SymNdx).Detail=32	TempInt=32	SymTable(SymNdx).DataAddr=0	SymTable(SymNdx).DataSize=32	OutBuf="mov esi,_StrTmp"+STR(StrTmpUse)	CALL SUB OutFcnCodeData	CALL SUB SetStrVecEND SUBBEGIN SUB GetChrVec	INCR ChrTmpUse	IF ChrTmpUse>ChrTmpMax THEN		ChrTmpMax=ChrTmpUse		CALL SUB VarBlank		Comment="Temporary Character Variable"		CALL SUB BldComment		CALL SUB OutUninitData		OutBuf="_ChrTmp"+STR(ChrTmpUse)+" rb 1"		CALL SUB OutUninitData		CALL SUB VarBlank	END IF	CALL SUB ReqTmpVec	ErrRet	SymTable(SymNdx).DataMod=TmpVec	SymTable(SymNdx).DataType=STRINGVAR	SymTable(SymNdx).Detail=1	TempInt=1	SymTable(SymNdx).DataAddr=0	SymTable(SymNdx).DataSize=1	OutBuf="mov esi,_ChrTmp"+STR(ChrTmpUse)	CALL SUB OutFcnCodeData	CALL SUB SetStrVecEND SUBBEGIN SUB SetStrVec	OutBuf="mov ["+SymTemp.SymName+"],esi"	CALL SUB OutFcnCodeData	OutBuf="mov ["+SymTemp.SymName+"+4],"+STR(TempInt)	CALL SUB OutFcnCodeData	OutBuf="mov ["+SymTemp.SymName+"+8],0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB ReqTmpVec	IF TmpVecUse=NumTemps THEN		ErrNo=ErrTmpUse		EXIT SUB	END IF	INCR TmpVecUse	IF TmpVecUse>TmpVecMax THEN		TmpVecMax=TmpVecUse		CALL SUB MakTmpVec	END IF	SymTemp.SymName="_TmpVec"+STR(TmpVecUse)	CALL SUB SymSrch	SymNdxSaf=SymNdxEND SUBBEGIN SUB GetTmpVec	CALL SUB ReqTmpVec	ErrRet	SymTable(SymNdx).DataMod=TmpVec	SymTable(SymNdx).DataMod=LOR(TDataMod,SymTable(SymNdx).DataMod)	SymTable(SymNdx).DataType=TDataType	SymTable(SymNdx).SubType=TSubType	SymTable(SymNdx).Detail=TDetail	SymTable(SymNdx).DataAddr=TDataAddr	SymTable(SymNdx).DataSize=TDataSizeEND SUBBEGIN SUB MakTmpVec	CALL SUB VarBlank	Comment="Temporary Vector"	CALL SUB BldComment	CALL SUB OutUninitData	OutBuf="_TmpVec"+STR(TmpVecUse)+" rd 3"	CALL SUB OutUninitDataEND SUBBEGIN SUB SetTmpVec	CALL SUB GetTmpVec	ErrRet	ExpTable(ExpNdx)=SymNdx	ediUsed=TRUE	OutBuf="mov esi,["+TSymName+"]"	CALL SUB OutFcnCodeData	IF SymTemp.DataType=COMPLEX THEN		OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+2)).DataAddr)		CALL SUB OutFcnCodeData	END IF	OutBuf="mov ["+SymTable(SymNdx).SymName+"],esi"	CALL SUB OutFcnCodeData	IF TDataType<>STRINGVAR THEN		EXIT SUB	END IF	OutBuf="mov esi,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="mov ["+SymTable(SymNdx).SymName+"+4],esi"	CALL SUB OutFcnCodeData	OutBuf="mov esi,["+TSymName+"+8]"	CALL SUB OutFcnCodeData	OutBuf="mov ["+SymTable(SymNdx).SymName+"+8],esi"	CALL SUB OutFcnCodeData	CALL SUB ClassOpEND SUBBEGIN SUB Vectorize	CALL SUB GetTmpVec	ErrRet	CALL SUB GetBase	ExpTable(ExpNdx)=SymNdx	OutBuf="mov ["+SymTemp.SymName+"],esi"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetLopVec	LopVarNdx=0	BEGIN LOOP		INCR LopVarNdx		IF LopVarNdx=101 THEN			ErrNo=ErrTmpUse			EXIT SUB		END IF		IF LoopVars(LopVarNdx)=ConStk(ConStkPtr).LoopName THEN			EXIT SUB		END IF		EXIT IF LoopVars(LopVarNdx)="%"	END LOOP	LoopVars(LopVarNdx)=ConStk(ConStkPtr).LoopName	CALL SUB VarBlank	Comment="For Loop Vector"	CALL SUB BldComment	CALL SUB OutUninitData	OutBuf="_LopVec"+STR(LopVarNdx)+" rd 2"	CALL SUB OutUninitData	GetLV2:END SUBBEGIN SUB DoAnd	IF TDataType=FLOATVAR THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf="and eax,edx"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB DoOr	IF TDataType=FLOATVAR THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf="or eax,edx"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB DoAdd	OutBuf="add "+Reg0Name+","+Reg1Name	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB DoXor	OutBuf="xor "+Reg0Name+","+Reg1Name	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB DoSub	OutBuf="sub "+Reg0Name+","+Reg1Name	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB DoMul	OutBuf="imul "+Reg1Name	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB DoDiv	; The following is ONLY for integer divide	; Check for edx=0 here and trap divide-by-zero	OutBuf="cmp edx,0"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jne _Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="mov [err],$db00db00"	CALL SUB OutFcnCodeData	OutBuf="jmp [_ErrVec]"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="mov ecx,edx"	CALL SUB OutFcnCodeData	OutBuf="xor edx,edx"	CALL SUB OutFcnCodeData	OutBuf="idiv ecx"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB CmpNum	D0Loaded=0	Promote=$ff	SymTemp.SymName=Op1Name	CALL SUB LoadReg	SymTemp.SymName=Op2Name	CALL SUB LoadReg	IF TDataType=BOOLVAR THEN		OutBuf="cmp al,dl"	ELSE		OutBuf="cmp "+Reg0Name+","+Reg1Name	END IF	CALL SUB OutFcnCodeData	IF SimpleCmp=0 THEN		OutBuf=SymType+"bl"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB CmpString	ediUsed=TRUE	OutBuf="mov edi,"+Op1Name	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+Op2Name	CALL SUB OutFcnCodeData	UseCmpStr=TRUE	OutBuf="call __CmpStr"	CALL SUB OutFcnCodeData	IF SimpleCmp=0 THEN		OutBuf=SymType+"bl"		CALL SUB OutFcnCodeData	END IFEND SUBNexToken:ExpEnd=0TokenLen=0TokenType=0QuoteFlag=0EscSeq=0NextByte=""TokenBuf=""TokenSaf=""NexToken1:INCR SrcNdxIF SrcNdx>LEN(SrcLine) THEN NexToken5TempByte=MID(SrcLine,SrcNdx,1)NextByte=MID(SrcLine,SrcNdx+1,1)AsciiByte=ASC(TempByte)IF AsciiByte=OBQUOTE AND EscSeq=0 THEN	IF QuoteFlag=0 AND TokenLen<>0 THEN NexToken5	CALL SUB NexToken3	IF QuoteFlag=1 THEN		TokenType=TTypQuote		GOTO NexToken6	ELSE		QuoteFlag=1		EscSeq=0		GOTO NexToken1	END IFEND IFIF QuoteFlag=1 THEN	IF EscSeq=$ff THEN		EscSeq=0	ELSE		IF AsciiByte=$60 THEN			EscSeq=$ff		END IF	END IF	CALL SUB NexToken3	GOTO NexToken1END IFIF TempByte="." THEN	IF TokenType=TTypInt THEN		TokenType=TTypFloat		CALL SUB NexToken3		GOTO NexToken1	END IF	IF TokenLen=0 THEN		IF NextByte>="0" AND NextByte<="9" THEN			TokenType=TTypFloat			CALL SUB NexToken3			GOTO NexToken1		END IF	END IFEND IFIF TempByte=";" THEN NexToken5; RemarkIF TempByte="<" OR TempByte=">" OR TempByte="=" THEN	IF TokenLen<>0 THEN NexToken5	TokenType=TTypRelOp	CALL SUB NexToken3	IF TempByte="=" THEN		GOTO NexToken6	END IF	IF NextByte=">" OR NextByte="=" THEN		INCR SrcNdx		TempByte=MID(SrcLine,SrcNdx,1)		CALL SUB NexToken3	END IF	GOTO NexToken6END IFIF AsciiByte=$20 OR AsciiByte=$09 THEN	IF TokenLen<>0 THEN		DECR SrcNdx		NextByte=" "		ExpEnd=$ff		GOTO NexTokDone	END IF	GOTO NexToken1END IFIF DimFlag=0 THEN	IF TempByte="(" OR TempByte=")" THEN		IF TokenLen<>0 THEN NexToken5		CALL SUB NexToken3		TokenType=TTypParen		GOTO NexToken6	END IFEND IFIF DimFlag=0 OR TempByte<>"," THEN;  special cond for multi-dim array	IF TempByte="," OR TempByte=";" OR TempByte=":" OR TempByte="." THEN		IF TokenLen<>0 THEN NexToken5		CALL SUB NexToken3		TokenType=TTypPunct		GOTO NexToken6	END IFEND IFIF TempByte="+" OR TempByte="-" OR TempByte="*" OR TempByte="/"  OR TempByte="&" OR TempByte="|" THEN	IF TokenLen<>0 THEN NexToken5	CALL SUB NexToken3	TokenType=TTypMath	GOTO NexToken6END IFIF DimFlag=$ff THEN NexToken2IF TempByte="$" OR TempByte="_" THEN NexToken2IF TempByte="!" AND ExclamationOK=TRUE THEN NexToken2IF TempByte>="0" AND TempByte<="9" THEN NexToken2IF TempByte>="A" AND TempByte<="Z" THEN NexToken2IF TempByte>="a" AND TempByte<="z" THEN NexToken2IF TokenLen<>0 THEN NexToken5CALL SUB NexToken3TokenType=TTypMiscGOTO NexToken6NexToken2:CALL SUB NexToken3GOTO NexToken1NexToken5:DECR SrcNdxNextByte=MID(SrcLine,SrcNdx+1,1)NexToken6:IF NextByte=" " OR ASC(NextByte)=9 OR NextByte=":" OR NextByte=";" THEN	ExpEnd=$ffEND IFIF NextByte="<" OR NextByte=">" OR NextByte="=" OR NextByte="" OR NextByte=";" THEN	ExpEnd=$ffEND IFNexTokDone:IF TokenType=TTypInt AND RIGHT(TokenBuf,1)="h" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="$"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="$"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	END IF	TokenBuf=TokenSaf	TokenType=TTypHexEND IFIF TokenType=TTypInt AND RIGHT(TokenBuf,1)="o" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="%"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="%"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	END IF	TokenBuf=TokenSaf	TokenType=TTypOctEND IFIF TokenType=TTypInt AND RIGHT(TokenBuf,1)="b" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="&"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="&"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	END IF	TokenBuf=TokenSaf	TokenType=TTypBinEND IFIF TokenType=TTypInt AND MID(TokenBuf,2,1)="x" THEN; C hex->Motorala	TokenSaf="$"+MID(TokenBuf,3,LEN(TokenBuf)-2)	TokenBuf=TokenSaf	TokenType=TTypHexEND IFRETURNNexToken3:INCR TokenLenTokenSaf=TokenSaf+TempByteIF TempByte>="A" AND TempByte<="Z" THEN	AsciiByte=LOR(AsciiByte,$20)	TempByte=CHR(AsciiByte)END IFTokenBuf=TokenBuf+TempByteIF TokenLen=1 THEN	IF TokenBuf="$" THEN		TokenType=TTypHex	END IF	IF TokenBuf>="0" AND TokenBuf<="9" THEN		TokenType=TTypInt	END IF	IF TokenBuf>="a" AND TokenBuf<="z" OR TokenBuf="_" THEN		TokenType=TTypSym	END IF	IF TokenBuf="!" AND ExclamationOK=TRUE THEN		TokenType=TTypSym	END IFEND IFRETURNBEGIN SUB UnDoToken	SrcNdx=SrcNdx-TokenLen	NextByte=""END SUBBEGIN SUB MacToken	TokenLen=0	TokenSaf=""	BEGIN LOOP		INCR SrcNdx		TempByte=MID(SrcLine,SrcNdx,1)		AsciiByte=ASC(TempByte)		IF AsciiByte=NewLine OR AsciiByte=0 THEN			DECR SrcNdx			EXIT SUB		END IF		IF AsciiByte=$2c THEN;  comma			IF TokenLen=0 THEN				TokenSaf=TempByte				TokenLen=1			ELSE				DECR SrcNdx			END IF			EXIT SUB		END IF		TokenSaf=TokenSaf+TempByte		INCR TokenLen	END LOOPEND SUBBEGIN SUB SymChk	SETVECTOR ByteArray=ADDR(TokenBuf)	SymbolValid=FALSE	IF ByteArray(1)<$61 OR ByteArray(1)>$7a THEN		IF ByteArray(1)<>$5f THEN			EXIT SUB		END IF	END IF	FOR I=2 TO TokenLen		IF ByteArray(I)<$61 OR ByteArray(I)>$7a THEN			IF ByteArray(I)<$30 OR ByteArray(I)>$39 THEN				IF ByteArray(I)<>$5f THEN					EXIT SUB				END IF			END IF		END IF	NEXT I	SymbolValid=TRUEEND SUB	BEGIN SUB ChkValidSymbol	SymbolValid=FALSE	TempInt=LEN(RootSymbol)	IF TempInt>28 THEN		EXIT SUB	END IF	TempByte=MID(RootSymbol,1,1)	BEGIN LOOP		EXIT IF TempByte>="A" AND TempByte<="Z"		EXIT IF TempByte>="a" AND TempByte<="z"		EXIT IF TempByte="_"		EXIT IF TempByte="!" AND ExclamationOK=TRUE		EXIT SUB	END LOOP	FOR LabNdx=2 TO TempInt	TempByte=MID(RootSymbol,LabNdx,1)		CONTINUE IF TempByte>="A" AND TempByte<="Z"		CONTINUE IF TempByte>="a" AND TempByte<="z"		CONTINUE IF TempByte="_"		CONTINUE IF TempByte>="0" AND TempByte<="9"		EXIT SUB	NEXT LabNdx	SymbolValid=TRUE	SymbolSaf=RootSymbolEND SUBBEGIN SUB ValidInt	IntOK=FALSE	IF LEN(TokenBuf)>10 THEN		EXIT SUB	END IF	TempByte=MID(TokenBuf,1,1)	BEGIN LOOP		EXIT IF TempByte>="0" AND TempByte<="9"		EXIT IF TempByte="-"		EXIT SUB	END LOOP	FOR ValidNdx=2 TO LEN(TokenBuf)		TempByte=MID(TokenBuf,ValidNdx,1)		CONTINUE IF TempByte>="0" AND TempByte<="9"		EXIT SUB	NEXT ValidNdx	IntOK=TRUEEND SUBBEGIN SUB ValidHex	HexOK=TRUE	IF LEN(TokenBuf)>9 THEN		EXIT SUB	END IF	FOR ValidNdx=1 TO LEN(TokenBuf)		TempByte=MID(TokenBuf,ValidNdx,1)		CONTINUE IF TempByte>="0" AND TempByte<="9"		CONTINUE IF TempByte>="a" AND TempByte<="f"		EXIT SUB	NEXT ValidNdx	HexOK=TRUEEND SUBBEGIN SUB ValidFlt	OneDot=FALSE	FloatOK=FALSE	IF LEN(TokenBuf)>21 THEN		EXIT SUB	END IF	ValidNdx=0	BEGIN LOOP		INCR ValidNdx		IF ValidNdx>LEN(TokenBuf) THEN			FloatOK=TRUE			EXIT SUB		END IF		TempByte=MID(TokenBuf,ValidNdx,1)		CONTINUE IF TempByte>="0" AND TempByte<="9"		IF TempByte="." THEN			IF OneDot=FALSE THEN				OneDot=TRUE			ELSE				ErrNo=ErrSyntax				EXIT SUB			END IF		END IF	END LOOPEND SUBBEGIN SUB SymSrch	SymFull=0	SymFound=FALSE	SymNdx=0	TempName=SymTemp.SymName	TempStr=TempName	TempInt=CHKWORD(TempStr)	BEGIN LOOP		INCR SymNdx		IF SymNdx>LastSym THEN			IF SymNdx>SymTabSiz THEN				SymFull=$ff			END IF			RETURN		END IF		CONTINUE IF SymTableKey(SymNdx)<>TempInt		EXIT IF SymTable(SymNdx).SymName=TempName	END LOOP	INCR SymTable(SymNdx).UseCount	SymFound=TRUEEND SUBBEGIN SUB SymSearch	CALL SUB SymSrch	IF SymFound=TRUE THEN	EXIT SUB	END IF	SymTemp.SymName=TokenSaf	CALL SUB SymSrchEND SUBBEGIN SUB SymInsert	IF SymFull=$ff THEN		ErrNo=ErrSymFul		EXIT SUB	END IF	SymTable(SymNdx)=SymTemp	LastSym=SymNdx	TempStr=SymTemp.SymName	SymTableKey(SymNdx)=CHKWORD(TempStr)END SUBBEGIN SUB KeyLook	KeyNdx=0	TempInt=CHKWORD(TokenBuf)	BEGIN LOOP		INCR KeyNdx		IF KeyNdx>LastKey THEN			KeyNdx=0			EXIT SUB		END IF		CONTINUE IF KeyTable(KeyNdx).KeyCheckWord<>TempInt		EXIT IF KeyTable(KeyNdx).KeyName=TokenBuf	END LOOPEND SUBBEGIN SUB ObjLook	ObjNdx=0	TempInt=CHKWORD(TokenBuf)	BEGIN LOOP		INCR ObjNdx		IF ObjNdx>LastObj THEN			ObjNdx=0			EXIT SUB	END IF	CONTINUE IF ObjTable(ObjNdx).ObjCheckWord<>TempInt	EXIT IF ObjTable(ObjNdx).ObjName=TokenBuf	END LOOPEND SUBBEGIN SUB CmpOps	Op1Class=0	AndOrFlag=$ff	CompFlag=$ff	GUIObjFlag=0;//	TextFlag=0;//		CmpOps1:	CmpOpFlag=FALSE	Promote=0	Demote=0	TmpUse=0	TmpVecUse=0	FTmpUse=0	ChrTmpUse=0	StrTmpUse=0	TypeFlag=0	TDataMod=0	CALL SUB ClrDatTyp	CALL SUB GetExp	ErrRet	IF GUIObjFlag<>0 THEN;//		CALL SUB UnDoToken;//		GUITargetFlag=0;//		CALL SUB ValidateObject;//		ErrMain;//		CALL SUB GUISource		Op1Name=GUITempName		Op1Type=GUIDataType		SELECT CASE Op1Type			CASE BOOLVAR				Op1Class=BOOLClass			CASE LONGVAR				Op1Class=INTClass			CASE STRINGVAR				Op1Class=STRClass		END SELECT		Op1Mod=0		Op1Detail=0	ELSE		CALL SUB ProcExp		ErrRet		CALL SUB ClassOp		Op1Name=TSymName		Op1Class=OpClass		Op1Type=TDataType		Op1Mod=TDataMod		Op1Detail=TDetail	END IF	IF TDataType=BOOLVAR THEN		IF NextByte="=" OR NextByte="<" THEN			CALL SUB NexToken			IF TokenBuf="=" THEN				SymType="sete "				SimpleOp="je "				SimpleStructOp="jne "			ELSE				SymType="setne "				SimpleOp="jne "				SimpleStructOp="je "			END IF			IF TokenBuf<>"=" AND TokenBuf<>"<>" THEN				ErrNo=ErrIVExp				EXIT SUB			END IF			GOTO CmpOps2		ELSE			Op2Name="true"			Op2Class=BOOLClass			Op2Type=1			Op2Mod=$04			Op2Detail=1			SymType="sete "			SimpleOp="je "			SimpleStructOp="jne "			GOTO CmpOps3		END IF	END IF	CALL SUB NexToken	IF TokenType<>1 THEN		ErrNo=ErrIVExp		EXIT SUB	END IF	SymType=""	SELECT CASE TokenBuf		CASE "="			SymType="sete "			SimpleOp="je "			SimpleStructOp="jne "		CASE "<"			SymType="setl "			SimpleOp="jl "			SimpleStructOp="jge "		CASE ">"			SymType="setg "			SimpleOp="jg "			SimpleStructOp="jle "		CASE "<="			SymType="setle "			SimpleOp="jle "			SimpleStructOp="jg "		CASE ">="			SymType="setge "			SimpleOp="jge "			SimpleStructOp="jl "		CASE "<>"			SymType="setne "			SimpleOp="jne "			SimpleStructOp="je "		CASE ELSE			ErrNo=ErrIVExp			EXIT SUB	END SELECT	CmpOps2:	GUIObjFlag=0	CmpOpFlag=TRUE	CALL SUB GetExp	ErrRet	IF GUIObjFlag<>0 THEN;//		CALL SUB UnDoToken;//		GUITargetFlag=0;//		CALL SUB ValidateObject;//		ErrMain;//		CALL SUB GUISource		Op2Name=GUITempName		Op2Type=GUIDataType		SELECT CASE Op2Type			CASE BOOLVAR				Op2Class=BOOLClass			CASE LONGVAR				Op2Class=INTClass			CASE STRINGVAR				Op2Class=STRClass		END SELECT		Op2Mod=0		Op2Detail=0	ELSE		CALL SUB ProcExp		ErrRet		CALL SUB ClassOp		Op2Name=TSymName		Op2Class=OpClass		Op2Type=TDataType		Op2Mod=TDataMod		Op2Detail=TDetail	END IF	TempInt=LOR(Op1Mod,TempBit)	TempInt2=LOR(Op2Mod,TempBit)	IF ComplexCmp=0 THEN		IF HasFcn=0 AND Op1Class=INTClass AND TempInt=TempBit AND Op2Class=INTClass AND Op2Mod=ConstBit THEN			CALL SUB NexToken			IF TokenBuf<>"or" AND TokenBuf<>"and" THEN				SimpleCmp=$ff				IF Op1Type=BYTEVAR AND Op2Detail>255 THEN					ErrNo=ErrOpRange					EXIT SUB				END IF				IF Op1Type=WORDVAR AND Op2Detail>65535 THEN					ErrNo=ErrOpRange					EXIT SUB				END IF				IF Op1Type=LONGVAR AND Op2Detail>$7fffffff THEN					ErrNo=ErrOpRange					EXIT SUB				END IF				OutBuf="cmp ["+Op1Name+"],"+STR(Op2Detail)				CALL SUB OutFcnCodeData				EXIT SUB			END IF			CALL SUB UnDoToken		END IF		IF HasFcn=0 AND Op1Class=BOOLClass AND TempInt=TempBit AND Op2Class=BOOLClass AND Op2Mod=ConstBit THEN			CALL SUB NexToken			IF TokenBuf<>"or" AND TokenBuf<>"and" THEN				SimpleCmp=$ff				OutBuf="cmp ["+Op1Name+"],"+STR(Op2Detail)				CALL SUB OutFcnCodeData				EXIT SUB			END IF			CALL SUB UnDoToken		END IF		IF HasFcn=0 AND Op1Class=INTClass AND Op1Mod<>ConstBit AND TempInt=TempBit AND Op2Class=INTClass AND TempInt2=TempBit THEN			CALL SUB NexToken			IF TokenBuf<>"or" AND TokenBuf<>"and" THEN				SimpleCmp=$ff				SELECT CASE Op1Type					CASE BYTEVAR						IF Op2Type=BYTEVAR THEN							OutBuf="mov al,["+Op2Name+"]"							CALL SUB OutFcnCodeData							OutBuf="cmp ["+Op1Name+"],al"							CALL SUB OutFcnCodeData							EXIT SUB						ELSE							IF Op2Type=WORDVAR THEN								OutBuf="xor ax,ax"								CALL SUB OutFcnCodeData								OutBuf="mov al,["+Op1Name+"]"									CALL SUB OutFcnCodeData							OutBuf="mov dx,["+Op2Name+"]"								CALL SUB OutFcnCodeData								OutBuf="cmp ax,dx"								CALL SUB OutFcnCodeData								EXIT SUB							ELSE								OutBuf="xor eax,eax"								CALL SUB OutFcnCodeData								OutBuf="mov al,["+Op1Name+"]"								CALL SUB OutFcnCodeData								OutBuf="mov edx,["+Op2Name+"]"								CALL SUB OutFcnCodeData								OutBuf="cmp eax,edx"								CALL SUB OutFcnCodeData								EXIT SUB							END IF						END IF												CASE WORDVAR						IF Op2Type=WORDVAR THEN							OutBuf="mov ax,["+Op2Name+"]"							CALL SUB OutFcnCodeData							OutBuf="cmp ["+Op1Name+"],ax"							CALL SUB OutFcnCodeData							RETURN						ELSE							IF Op2Type=BYTEVAR THEN								OutBuf="xor ax,ax"								CALL SUB OutFcnCodeData								OutBuf="mov al,["+Op2Name+"]"								CALL SUB OutFcnCodeData								OutBuf="cmp ["+Op1Name+"],ax"								CALL SUB OutFcnCodeData								EXIT SUB							ELSE								OutBuf="xor eax,eax"								CALL SUB OutFcnCodeData								OutBuf="mov ax,["+Op1Name+"]"								CALL SUB OutFcnCodeData								OutBuf="mov edx,["+Op2Name+"]"								CALL SUB OutFcnCodeData								OutBuf="cmp eax,edx"								CALL SUB OutFcnCodeData								EXIT SUB							END IF																				END IF					CASE LONGVAR						IF Op2Type=LONGVAR THEN							OutBuf="mov eax,["+Op2Name+"]"							CALL SUB OutFcnCodeData						ELSE							OutBuf="xor eax,eax"							CALL SUB OutFcnCodeData							IF Op2Type=WORDVAR THEN								OutBuf="mov ax,["+Op2Name+"]"								CALL SUB OutFcnCodeData							ELSE								OutBuf="mov al,["+Op2Name+"]"								CALL SUB OutFcnCodeData							END IF						END IF						OutBuf="cmp ["+Op1Name+"],eax"						CALL SUB OutFcnCodeData						EXIT SUB				END SELECT				OutBuf="cmp ["+Op1Name+"],eax"				CALL SUB OutFcnCodeData				EXIT SUB			END IF			CALL SUB UnDoToken		END IF	END IF	ComplexCmp=$ff		CmpOps3:	CALL SUB NexToken	IF TokenBuf<>"or" AND TokenBuf<>"and" AND InitTrue=0 THEN		SimpleCmp=$ff	END IF	CALL SUB UnDoToken	IF Op1Class=INTClass OR Op1Class=FLTClass OR Op1Class=BOOLClass THEN		CALL SUB CmpNum		ErrRet	END IF	IF Op1Class<>Op2Class THEN		EXIT IF Op1Class=INTClass AND Op2Class=FLTClass		EXIT IF Op1Class=FLTClass AND Op2Class=INTClass		ErrNo=ErrTypMis		EXIT SUB	END IF	IF Op1Class=STRClass THEN		CALL SUB CmpString	END IF	IF Op1Class=0 OR Op1Class=ARRClass OR Op1Class=CPXClass THEN		ErrNo=ErrIVExp		EXIT SUB	END IF	IF InitTrue=0 AND SimpleCmp=0 THEN		OutBuf="xor bh,bh"		CALL SUB OutFcnCodeData		InitTrue=$ff	END IF	IF SimpleCmp=0 THEN		IF AndOrFlag=0 THEN			OutBuf="and bh,bl"		ELSE			OutBuf="or bh,bl"		END IF		CALL SUB OutFcnCodeData	END IF	CALL SUB NexToken	IF TokenBuf="and" THEN		AndOrFlag=0		GOTO CmpOps1	END IF	IF TokenBuf="or" THEN		AndOrFlag=$ff		GOTO CmpOps1	END IFEND SUBBEGIN SUB ClrDatTyp	DMTemp=0	DMVector=0	DMMember=0	DMMulti=0	DMConst=0	DMAddr=0	DMArray=0END SUBBEGIN SUB GetRootSymbol	SubscrErr=0	RootSymbol=""	SubCtr=0	Subscript(1)=""	Subscript(2)=""	Subscript(3)=""	SubValue(1)=1	SubValue(2)=1	SubValue(3)=1	LabNdx=0	GtRtSym1:	INCR LabNdx	IF LabNdx>LEN(TokenSaf) THEN		EXIT SUB	END IF	TempByte=MID(TokenSaf,LabNdx,1)	IF TempByte<>"(" THEN		RootSymbol=RootSymbol+TempByte		GOTO GtRtSym1	END IF	IF RIGHT(TokenSaf,1)<>")" THEN		SubscrErr=$ff		EXIT SUB	END IF	GtRtSym2:	INCR SubCtr	IF SubCtr>2 THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	BEGIN LOOP		INCR LabNdx		TempByte=MID(TokenSaf,LabNdx,1)		IF TempByte=")" OR TempByte="," THEN			SymNdxSaf=SymNdx			TempStr=SymTemp.SymName			IF LEFT(Subscript(SubCtr),1)>="0" AND LEFT(Subscript(SubCtr),1)<="9" THEN				SubValue(SubCtr)=VAL(Subscript(SubCtr))			ELSE				SymTemp.SymName=Subscript(SubCtr)				CALL SUB SymSrch				IF SymFound=TRUE AND SymTable(SymNdx).DataType=COMPVAR OR SymTable(SymNdx).DataType=MACROVAR THEN					SubValue(SubCtr)=SymTable(SymNdx).Detail				ELSE					ErrNo=ErrUDSym					EXIT SUB				END IF			END IF			SymNdx=SymNdxSaf			SymTemp.SymName=TempStr			IF TempByte="," THEN GtRtSym2			EXIT SUB		END IF		Subscript(SubCtr)=Subscript(SubCtr)+TempByte	END LOOPEND SUBBEGIN SUB F1	; EOF(FileNum)	CALL SUB ClassOp	CALL SUB GetFileHandle2	ErrRet	IF TSubType=DEVICE THEN		ErrNo=ErrDevice		EXIT SUB	END IF	ImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUE	OutBuf="invoke GetFileSize,[_IOPthNum],0"	CALL SUB OutFcnCodeData	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CALL SUB CallErr	ImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUE	OutBuf="invoke SetFilePointer,[_IOPthNum],0,0,FILE_CURRENT"	CALL SUB OutFcnCodeData	CALL SUB CallErr	OpClass=BOOLClass	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	OutBuf="cmp eax,[_ArgSafe0]"	CALL SUB OutFcnCodeData	OutBuf="sete cl; Set result"	CALL SUB OutFcnCodeData	OutBuf="mov byte ["+SymTemp.SymName+"],cl"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F2	; LEN(String)	CALL SUB ClassOp	IF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis	RETURN	END IF	OutBuf="mov esi,"+SymTemp.SymName	CALL SUB OutFcnCodeData	CALL SUB GetIntTmp	ErrRet	UseStrLen=TRUE	OutBuf="call __StrLen"	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F3	; STR(Number)	CALL SUB ClassOp	CALL SUB LoadReg	ErrRet	IF OpClass<>INTClass AND OpClass<>FLTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF OpClass=INTClass THEN		IF FloatFlag<>0 THEN			OutBuf=";eax=eaxf;"			CALL SUB OutFcnCodeData			END IF		SELECT CASE FcnCode			CASE 69				TempInt=2			CASE 70				TempInt=8			CASE 3				TempInt=10			CASE 49				TempInt=16			CASE ELSE				ErrNo=ErrTypMis				EXIT SUB		END SELECT		ImportFcnTable(ptrltoa).ImportFcnUse=TRUE					OutBuf="cinvoke ltoa,eax,[_ConvBuf1],"+STR(TempInt)	ELSE		OutBuf=""	END IF	CALL SUB OutFcnCodeData	CALL SUB NumToAEND SUBBEGIN SUB NumToA	CALL SUB GetStrVec	ErrRet	ediUsed=TRUE	OutBuf="mov edi,"+SymTemp.SymName	CALL SUB OutFcnCodeData	OutBuf="mov esi,_ConvBuf1"	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F4	; VAL(String)	CALL SUB ClassOp	IF TDataType<>STRINGVAR OR DMArray<>0 THEN		ErrNo=ErrTypMis;  wrong type		EXIT SUB	END IF	IF Op1Class=FLTClass AND FcnCode=4 THEN		FcnCode=24	END IF	IF FcnCode=24 THEN		OutBuf=";eaxf=_AtoD();"	ELSE		OutBuf="mov esi,["+TSymName+"]"		CALL SUB OutFcnCodeData		UseAtoL=TRUE		OutBuf="call __AtoL"	END IF	CALL SUB OutFcnCodeData	IF FcnCode=24 THEN		INCR FloatFlag		OpClass=FLTClass		TDataType=FLOATVAR		CALL SUB GetFltTmp		ErrRet	ELSE		OpClass=INTClass		CALL SUB GetIntTmp		ErrRet	END IF	IF FcnCode=24 THEN		OutBuf=";"+SymTemp.SymName+"=eaxf;"	ELSE		OutBuf="mov ["+SymTemp.SymName+"],eax"	END IF	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F5	; LAND(Exp1,Exp2)	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF TSymName<>"~" THEN		CALL SUB LoadReg		ErrRet	END IF	INCR ExpNdx	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF TSymName<>"~" THEN		CALL SUB LoadReg		ErrRet	END IF	CALL SUB GetIntTmp	ErrRet	SELECT CASE FcnCode		CASE 5; LAND()			OutBuf="and eax,edx"		CASE 7; LOR()			OutBuf="or eax,edx"		CASE 9; MOD()			OutBuf="mov ecx,edx"			CALL SUB OutFcnCodeData			OutBuf="xor edx,edx"			CALL SUB OutFcnCodeData			OutBuf="idiv ecx"			CALL SUB OutFcnCodeData			OutBuf="mov eax,edx"		CASE 19; LXOR()			OutBuf="xor eax,edx"	END SELECT	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F6	; MID(String,Position,Quantity)	IF FcnCode=6 THEN		IF ExpRight-ExpLeft<>4 THEN			ErrNo=ErrFcn			EXIT SUB 		END IF	END IF	CALL SUB MidLftRtEND SUBBEGIN SUB MidLftRt	CALL SUB ClassOp	IF TDataType<>STRINGVAR THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF DMVector<>0 AND DMTemp=0 THEN		; need to make a temp vector		CALL SetTmpVec		ErrRet	END IF	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	INCR ExpNdx	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB LoadReg; first arg	ErrRet	SELECT CASE FcnCode		CASE 6; Mid$			INCR ExpNdx			CALL SUB ClassOp			IF OpClass<>INTClass THEN				ErrNo=ErrTypMis				EXIT SUB			END IF			CALL SUB LoadReg; second arg			ErrRet			UseMidStr=TRUE			OutBuf="call __MidStr"		CASE 8; Left$			OutBuf="mov edx,eax"			CALL SUB OutFcnCodeData			OutBuf="mov eax,1"			CALL SUB OutFcnCodeData			UseMidStr=TRUE			OutBuf="call __MidStr"		CASE 11; Right$			UseRightStr=TRUE			OutBuf="call __RightStr"		CASE 80; Tail$			UseTailStr=TRUE			OutBuf="call __TailStr"	END SELECT	CALL SUB OutFcnCodeData	ExpNdx=ExpLeft+1END SUBBEGIN SUB F7	; LOR(Exp1,Exp2)	CALL SUB F5END SUBBEGIN SUB F8	; LEFT(String,Quantity)	IF ExpRight-ExpLeft<>3 THEN		ErrNo=ErrFcn		EXIT SUB	END IF	CALL SUB MidLftRtEND SUBBEGIN SUB F9	; MOD(Exp1,Exp2)	CALL SUB F5END SUBBEGIN SUB F10	; CHR(Expr)	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB LoadReg	ErrRet	CALL SUB GetChrVec	ErrRet	OutBuf="mov [_ChrTmp"+STR(ChrTmpUse)+"],al"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F11	; RIGHT(String,Quantity)	IF Target<>0 THEN		ErrNo=ErrIVTarget		EXIT SUB	END IF	CALL SUB MidLftRtEND SUBBEGIN SUB F12	; ASC(String)	CALL SUB ClassOp	IF TDataType<>STRINGVAR OR DMArray<>0 THEN		ErrNo=ErrFcn		EXIT SUB	END IF	CALL SUB GetIntTmp	ErrRet	OutBuf="mov esi,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov al, byte [esi]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F13	; NOT(Boolean)	CALL SUB ClassOp	IF TDataType<>1 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OpClass=BOOLClass	TDataType=BOOLVAR	ErrRet	IF TSymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg		ErrMain	END IF	CALL SUB GetTmp	OutBuf="btc eax,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F14	; BUFADR(Buffer)	CALL SUB ClassOp	IF TDataType<>BUFFER THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB GetIntTmp	ErrRet	IF FcnCode=14 THEN		OutBuf="mov eax,["+TSymName+"]"	ELSE		OutBuf="mov eax,["+TSymName+"+4]"	END IF	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F15	; BUFSIZ(Buffer)	CALL SUB F14END SUBBEGIN SUB F16	; TAB()	IF PrintFlag=0 THEN		ErrNo=ErrFcn		EXIT SUB	END IF	TabFlag=$ff	CALL SUB ClassOp	IF OpClass=INTClass THEN		CALL SUB LoadReg		ErrRet		OutBuf="call __PrintTab"		CALL SUB OutFcnCodeData		CALL SUB CallErr	ELSE		ErrNo=ErrTypMis	END IFEND SUBBEGIN SUB F17	; TIMEDIFF(DateTime1,DateTime2)	CALL SUB ClassOp	IF TDataType<>DATETIME THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	FcnOp1Nam=TSymName	INCR ExpNdx	CALL SUB ClassOp	IF TDataType<>DATETIME THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	FcnOp2Nam=TSymName	ImportFcnTable(ptrSystemTimeToFileTime).ImportFcnUse=TRUE	OutBuf="invoke SystemTimeToFileTime,["+FcnOp1Nam+"],!dwLowDateTime1"	CALL SUB OutFcnCodeData	OutBuf="invoke SystemTimeToFileTime,["+FcnOp2Nam+"],!dwLowDateTime2"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[!dwLowDateTime1]"	CALL SUB OutFcnCodeData	OutBuf="mov edx,[!dwHighDateTime1]"	CALL SUB OutFcnCodeData	OutBuf="sub eax,[!dwLowDateTime2]"	CALL SUB OutFcnCodeData	OutBuf="sbb edx,[!dwHighDateTime2]"	CALL SUB OutFcnCodeData	OutBuf="mov ebx,10000000"	CALL SUB OutFcnCodeData	OutBuf="idiv ebx"	CALL SUB OutFcnCodeData	CALL SUB GetIntTmp	ErrRet	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F18	; ADDR(Var)	CALL SUB ClassOp	IF FloatFlag>0 THEN		DECR FloatFlag	END IF	IF TDataType>STRINGVAR AND TDataType<COMPLEX OR DMConst<>0 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF DMArray=0 THEN		CALL SUB GetBase	ELSE		IF DMVector=0 THEN			OutBuf="mov esi,"+TSymName			CALL SUB OutFcnCodeData		ELSE			OutBuf="mov esi,["+TSymName+"]"			CALL SUB OutFcnCodeData		END IF	END IF	OutBuf="mov eax,esi"	CALL SUB OutFcnCodeData	CALL SUB GetIntTmp	ErrRet	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F19	; LXOR(IntExpr)	CALL SUB F5END SUBBEGIN SUB F20	; LNOT(IntExpr)	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF TSymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg		ErrRet	END IF	CALL SUB GetIntTmp	ErrRet	OutBuf="not "+Reg0Name	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F21	; INDEX(Pointer,IntExpr)	CALL SUB ClassOp	IF DMAddr=0 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	FcnOp1Nam=TSymName	IF DMVector<>0 THEN		FcnOp1Nam=FcnOp1Nam+"._Ptr"	END IF	CALL SUB GetVarSiz	INCR ExpNdx	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB GetIntTmp	ErrRet	OutBuf="mov eax,"+TSymName	CALL SUB OutFcnCodeData	OutBuf="imul eax,"+STR(VarSize)	CALL SUB OutFcnCodeData	OutBuf="add eax,["+FcnOp1Nam+"]"	CALL SUB OutFcnCodeData	OutBuf="mov ["+SymTemp.SymName+"],eax"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB GetVarSiz	SELECT CASE TDataType		CASE COMPLEX			VarSize=SymTable(TDetail).DataSize		CASE STRINGVAR			VarSize=TDetail		CASE BOOLVAR			VarSize=1		CASE BYTEVAR			VarSize=1		CASE WORDVAR			VarSize=2		CASE LONGVAR			VarSize=4		CASE FLOATVAR			VarSize=8	END SELECTEND SUBBEGIN SUB F22	; SIZE(Var)	CALL SUB ClassOp	IF FloatFlag>0 THEN		DECR FloatFlag	END IF	IF TDataType<1 OR TDataType>6 THEN		IF TDataType=BUFFER THEN			VarSize=8		ELSE			IF TDataType=COMPLEX THEN				VarSize=TDataSize			ELSE				ErrNo=ErrTypMis				EXIT SUB			END IF		END IF	ELSE		VarSize=TDataSize	END IF	CALL SUB GetIntTmp	ErrRet	OutBuf="mov ["+SymTemp.SymName+"],"+STR(VarSize)	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F23	; IVAL(String)	CALL SUB F4END SUBBEGIN SUB F24	; FVAL(String)	CALL SUB F4END SUBBEGIN SUB F25	; TRIM$	CALL SUB F78END SUBBEGIN SUB F26	; LOF(FileNum)	CALL SUB ClassOp	CALL SUB GetFileHandle2	ErrRet	ImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUE	OutBuf="invoke GetFileSize,[_IOPthNum],0"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErr	CALL SUB GetIntTmp	ErrRet	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F27	; POF(FileNum)	CALL SUB ClassOp	CALL SUB GetFileHandle2	ErrRet	ImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUE	OutBuf="invoke SetFilePointer,[_IOPthNum],0,0,FILE_CURRENT"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErr	CALL SUB GetIntTmp	ErrRet	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F28	; SQR(Expr)	CALL SUB ClassOp	INCR FloatFlag	IF OpClass<>INTClass AND OpClass<>FLTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	SELECT CASE FcnCode		CASE 28			TempStr="sqrt"		CASE 31			TempStr="sin"		CASE 32			TempStr="cos"		CASE 33			TempStr="tan"		CASE 34			TempStr="asin"		CASE 35			TempStr="acos"		CASE 36			TempStr="atan"		CASE 37			TempStr="log"		CASE 38			TempStr="log10"	END SELECT	CALL SUB GetFltTmp	ErrRet	IF DMVector=0 THEN		OutBuf=";"+SymTemp.SymName+"="+TempStr+"((double)"+TSymName+");"	ELSE		OutBuf=";"+SymTemp.SymName+"="+TempStr+"(*((double*)"+TSymName+"._Ptr));"	END IF	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F29	; INT(FloatExpr)	CALL SUB ClassOp	IF FloatFlag>0 THEN		DECR FloatFlag	END IF	IF OpClass<>FLTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB GetIntTmp	ErrRet	IF DMVector=0 THEN		OutBuf=";"+SymTemp.SymName+"=(long)"+TSymName+";"	ELSE		OutBuf=";"+SymTemp.SymName+"=(long)*((double*)"+TSymName+"._Ptr);"	END IF	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F30	; ABS(Expr)	CALL SUB ClassOp	IF OpClass<>INTClass AND OpClass<>FLTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF SymTemp.SymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg	END IF	IF OpClass=INTClass THEN		CALL SUB GetIntTmp		ErrRet		ImportFcnTable(ptrabs).ImportFcnUse=TRUE		OutBuf="cinvoke abs,eax"		CALL SUB OutFcnCodeData		CALL SUB StoreD0Tmp	ELSE		CALL SUB GetFltTmp		ErrRet		OutBuf=";"+SymTemp.SymName+"=fabs("+TSymName+");"		CALL SUB OutFcnCodeData	END IF	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F31	; SIN(Expr)	CALL SUB F28END SUBBEGIN SUB F32	; COS(Expr)	CALL SUB F28END SUBBEGIN SUB F33	; TAN(Expr)	CALL SUB F28END SUBBEGIN SUB F34	; ASN(Expr)	CALL SUB F28END SUBBEGIN SUB F35	; ACS(Expr)	CALL SUB F28END SUBBEGIN SUB F36	; ATN(Expr)	CALL SUB F28END SUBBEGIN SUB F37	; LOG(Expr)	CALL SUB F28END SUBBEGIN SUB F38	; LOG10(Expr)	;END SUBBEGIN SUB F39	; PAD$	CALL SUB F78END SUBBEGIN SUB F40	; VacantEND SUBBEGIN SUB F41	; VacantEND SUBBEGIN SUB F42	; VacantEND SUBBEGIN SUB F43	; VacantEND SUBBEGIN SUB F44	; VacantEND SUBBEGIN SUB F45	; VacantEND SUBBEGIN SUB F46	; VacantEND SUBBEGIN SUB F47	; VacantEND SUBBEGIN SUB F48	; CHKWORD(STRING)	;code template is for ASC(STRING)	CALL SUB ClassOp	IF TDataType<>STRINGVAR OR DMArray<>0 THEN		ErrNo=ErrFcn		EXIT SUB	END IF	CALL SUB GetIntTmp	ErrRet	OutBuf="xor eax,eax"	CALL SUB OutFcnCodeData	OutBuf="mov esi,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov edx,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="xor ecx,ecx"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="xor ebx,ebx"	CALL SUB OutFcnCodeData	OutBuf="mov bl, byte [esi]"	CALL SUB OutFcnCodeData	OutBuf="or bl,bl"	CALL SUB OutFcnCodeData	OutBuf="je "+"_Lbl"+STR(LabelNum+1)	CALL SUB OutFcnCodeData	OutBuf="sal ebx,cl"	CALL SUB OutFcnCodeData	OutBuf="inc esi"	CALL SUB OutFcnCodeData	OutBuf="add cl,4"	CALL SUB OutFcnCodeData	OutBuf="add eax,ebx"	CALL SUB OutFcnCodeData	OutBuf="dec edx"	CALL SUB OutFcnCodeData	OutBuf="jne "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F49	; HEX(INT)	CALL SUB F3END SUBBEGIN SUB F50	; BITTST(ByteVar,Bit#)	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB LoadReg	ErrRet	INCR ExpNdx	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB LoadReg	ErrRet	OutBuf="bt eax,edx"	CALL SUB OutFcnCodeData	OpClass=BOOLClass	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	OutBuf="setc cl; Set result"	CALL SUB OutFcnCodeData	OutBuf="mov byte ["+SymTemp.SymName+"],cl"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F51	; SHL	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB LoadReg	ErrRet	INCR ExpNdx	CALL SUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB LoadReg	ErrRet	OutBuf="mov ecx,edx"	CALL SUB OutFcnCodeData	OpSizeStr="cl"	SELECT CASE FcnCode		CASE 51			TempStr="shl "		CASE 52			TempStr="shr "		CASE 53			TempStr="rol "		CASE 54			TempStr="ror "		CASE 55			TempStr="btc "			OpSizeStr="ecx"		CASE 56			TempStr="btr "			OpSizeStr="ecx"		CASE 57			TempStr="bts "			OpSizeStr="ecx"		CASE 62			TempStr="sal "		CASE 63			TempStr="sar "		CASE 64			TempStr="rcl "		CASE 65			TempStr="rcr "	END SELECT	OutBuf=TempStr+Reg0Name+","+OpSizeStr	CALL SUB OutFcnCodeData	CALL SUB GetIntTmp	ErrRet	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F52	; SHR	CALL SUB F51END SUBBEGIN SUB F53	; ROL	CALL SUB F51END SUBBEGIN SUB F54	; ROR	CALL SUB F51END SUBBEGIN SUB F55	; BITCHG	CALL SUB F51END SUBBEGIN SUB F56	; BITCLR	CALL SUB F51END SUBBEGIN SUB F57	; BITSET	CALL SUB F51END SUBBEGIN SUB F58	; SUBSTR(Str1,Str2,[StartPos])	CALL SUB ClassOp	IF TDataType<>STRINGVAR THEN		ErrNo=ErrIVType		EXIT SUB	END IF	IF DMVector<>0 AND DMTemp=0 THEN		CALL SetTmpVec		ErrRet	END IF	FcnOp1Nam=TSymName	INCR ExpNdx	CALL SUB ClassOp	IF TDataType<>STRINGVAR THEN		ErrNo=ErrIVType		EXIT SUB	END IF	IF DMVector<>0 AND DMTemp=0 THEN		CALL SetTmpVec		ErrRet	END IF	TempStr=TSymName	IF ExpRight-ExpLeft=4 THEN		INCR ExpNdx		CALL SUB ClassOp		IF OpClass<>INTClass THEN			ErrNo=ErrIVType			EXIT SUB		END IF	ELSE		TSymName="1"	END IF	CALL SUB GetIntTmp	ErrRet	OutBuf=";"+SymTemp.SymName+"=_SubStr(&"+FcnOp1Nam+",&"+TempStr+","+TSymName+");"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F59	; ZSTR(INT)	CALL SUB ClassOp	CALL SUB LoadReg	ErrRet	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB		END IF	OutBuf=";_ZLtoA(eax);"	CALL SUB OutFcnCodeData	CALL SUB NumToAEND SUBBEGIN SUB F60	; ZHEX(INT)	CALL SUB ClassOp	CALL SUB LoadReg	ErrRet	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf=";_ZLtoH(eax);"	CALL SUB OutFcnCodeData	CALL SUB NumToAEND SUBBEGIN SUB F61	; USING()	;END SUBBEGIN SUB F62	; SAL()	CALL SUB F51END SUBBEGIN SUB F63	; SAR()	CALL SUB F51END SUBBEGIN SUB F64	; RCL()	CALL SUB F51END SUBBEGIN SUB F65	; RCR()	CALL SUB F51END SUBBEGIN SUB F66	; TABLESIZE()	CALL SUB ClassOp	IF LAND(TDataMod,ArrayBit)<>ArrayBit THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB GetIntTmp	ErrRet	TempInt=TDataSize/TDataAddr	OutBuf="mov ["+SymTemp.SymName+"],"+STR(TempInt)	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F67	; FilTyp()	;GetFileTypeEND SUBBEGIN SUB F68	; CurDir()	; GetCurrentDirectoryEND SUBBEGIN SUB F69	; BIN()	CALL SUB F3END SUBBEGIN SUB F70	; OCT()	CALL SUB F3END SUBBEGIN SUB F71	; Vacant()END SUBBEGIN SUB F72	; RND()	CALL SUB GetIntTmp	ErrRet	OutBuf=";"+SymTemp.SymName+"=rand();"	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F73	; GETTICKCOUNT()	CALL SUB GetIntTmp	ErrRet	ImportFcnTable(ptrGetTickCount).ImportFcnUse=TRUE	OutBuf="invoke GetTickCount"	CALL SUB OutFcnCodeData	CALL SUB StoreD0Tmp	ExpTable(ExpNdx)=SymNdxEND SUBBEGIN SUB F74	; Vacant()END SUBBEGIN SUB F75	; Vacant()END SUBBEGIN SUB F76	; Vacant()END SUBBEGIN SUB F77	; Vacant()END SUBBEGIN SUB F78	; LCASE()	CALL SUB ClassOp	IF TDataType<>STRINGVAR OR DMArray<>0 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	ediUsed=TRUE	OutBuf="mov edi,_IOBuffer"	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	OutBuf="mov esi,_IOBuffer"	CALL SUB OutFcnCodeData	SELECT CASE FcnCode		CASE 25			UseTrim=TRUE			OutBuf="call __TrimStr"		CASE 39			UsePad=TRUE			OutBuf="call __PadStr"			CASE 78			UseLCase=TRUE			OutBuf="call __LCase"		CASE 79			UseUCase=TRUE			OutBuf="call __UCase"	END SELECT	CALL SUB OutFcnCodeData	ExpTable(ExpNdx)=96END SUBBEGIN SUB F79	; UCASE()	CALL SUB F78END SUBBEGIN SUB F80	; Tail(String,Start)	IF Target<>0 THEN		ErrNo=ErrIVTarget		EXIT SUB	END IF	CALL SUB MidLftRtEND SUBBEGIN SUB F81	; Vacant()END SUBBEGIN SUB F82	; Vacant()END SUBBEGIN SUB OutFcnCodeData	INCR AsmLineCtr	IF StartFlag=TRUE THEN		IF CodeBlockFlag=FALSE AND GUIFlag=FALSE THEN			CALL OutCode		ELSE			CALL OutFunction		END IF	ELSE		WRITE DataFile,OutBuf	END IFEND SUBBEGIN SUB OutUninitData	WRITE DimFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutDesc	WRITE DescFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutDeclare	WRITE DeclareFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutInitData	WRITE DataFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutPreCode	WRITE PreCodeFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutResource	WRITE ResourceFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutExport	WRITE ExportFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutInitCode	WRITE InitFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutLib	WRITE LibFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutProc	WRITE ProcFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutCode	IF DeferFlag=TRUE THEN		DeferFlag=FALSE		IF OutBuf="mov eax, dword [_Tmp1]" THEN			AsmLineCtr=AsmLineCtr-2			EXIT SUB		ELSE			TempStr=OutBuf			OutBuf="mov [_Tmp1],eax"			WRITE CodeFile,OutBuf			OutBuf=TempStr			WRITE CodeFile,OutBuf			EXIT SUB		END IF				END IF	IF OutBuf="mov [_Tmp1],eax" THEN		DeferFlag=TRUE		EXIT SUB	END IF	WRITE CodeFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB OutFunction	IF DeferFlag=TRUE THEN		DeferFlag=FALSE		IF OutBuf="mov eax, dword [_Tmp1]" THEN			AsmLineCtr=AsmLineCtr-2			EXIT SUB		ELSE			TempStr=OutBuf			OutBuf="mov [_Tmp1],eax"			WRITE FunctionFile,OutBuf			OutBuf=TempStr			WRITE FunctionFile,OutBuf			EXIT SUB		END IF				END IF	IF OutBuf="mov [_Tmp1],eax" THEN		DeferFlag=TRUE		EXIT SUB	END IF	WRITE FunctionFile,OutBuf	INCR AsmLineCtrEND SUBBEGIN SUB StoreD0Tmp	OutBuf="mov ["+SymTemp.SymName+"],eax"	CALL SUB OutFcnCodeData	D1Cleared=0END SUBBEGIN SUB OutWrite	IF PrintFlag=0 THEN		ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE		OutBuf="invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0"	ELSE		OutBuf=";STATUS=write(_PrtPthNum,_XferAddr,XferCount);"	END IF	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZEND SUBBEGIN SUB OutRead	ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE	OutBuf="invoke ReadFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	CALL SUB CallErrZEND SUBBEGIN SUB SetStatus	OutBuf="mov [STATUS],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB OutCRLF	OutBuf="mov [_XferAddr],_CRLF"	CALL SUB OutFcnCodeData	OutBuf="mov [XferCount],2"	CALL SUB OutFcnCodeData	OutBuf=";STATUS=write(_PrtPthNum,_XferAddr,XferCount);"	CALL SUB OutFcnCodeData	CALL SUB CallErr END SUBBEGIN SUB MacDefInc	INCR MacDefNdx	IF MacDefNdx>MacBufSiz THEN		DECR MacDefNdx		ErrNo=ErrMacBuf	END IFEND SUBBEGIN SUB IncConStk	INCR ConStkPtr	IF ConStkPtr>40 THEN		ErrNo=ErrNDeep	END IFEND SUBBEGIN SUB MakString	IF OpClass=BOOLClass THEN		IF TSymName<>"~" THEN			D0Loaded=0			CALL SUB LoadReg			ErrRet		END IF		UseBtoA=TRUE		OutBuf="call __BtoA"		CALL SUB OutFcnCodeData		CALL SUB NumToA		EXIT SUB	END IF	IF TSymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg		ErrRet	END IF	IF FloatFlag=0 THEN		ImportFcnTable(ptrltoa).ImportFcnUse=TRUE		OutBuf="cinvoke ltoa,eax,[_ConvBuf1],10"	ELSE		OutBuf=";_DtoA(eaxf);"	END IF	CALL SUB OutFcnCodeData	CALL SUB NumToAEND SUBBEGIN SUB ConStkChk	IF ConStkPtr<1 THEN		ErrNo=ErrUBCon		EXIT SUB	END IF	IF ConStk(ConStkPtr).ConType<>TempInt THEN		ErrNo=ErrUBCon	END IFEND SUBBEGIN SUB StrSiz	SymNdxSaf=SymNdx	TokenBuf=SymTemp.SymName	TempByte=LEFT(TempStr,1)	IF TempByte>="0" AND TempByte<="9" THEN		TempInt=VAL(TempStr)	ELSE		SymTemp.SymName=TempStr		CALL SUB SymSrch		IF SymFound=TRUE AND SymTable(SymNdx).DataType=COMPVAR OR SymTable(SymNdx).DataType=MACROVAR THEN			TempInt=SymTable(SymNdx).Detail		ELSE			ErrNo=ErrUDSym			EXIT SUB		END IF	END IF	SymNdx=SymNdxSaf	SymTemp.SymName=TokenBufEND SUBBEGIN SUB Remark	OutBuf="; LN:"+STR(BasicLineCtr)+" "+SrcLineEND SUBBEGIN SUB BldComment	OutBuf=";"+CommentEND SUBBEGIN SUB GetDataType	SELECT CASE TDataType		CASE BOOLVAR			DataTypeName=" byte "		CASE BYTEVAR			DataTypeName=" byte "		CASE WORDVAR			DataTypeName=" word "		CASE LONGVAR			DataTypeName=" dword "		CASE FLOATVAR			DataTypeName=" double "	END SELECT	IF LAND(TDataMod,PointerBit)=PointerBit THEN		DataTypeName=" dword "	END IFEND SUBBEGIN SUB VecSymNam	;CALL SUB GetDataType	VSymName=TSymName	TSymName="["+VSymName+"]"END SUBBEGIN SUB GetIntOp	CALL SUB GetExp	ErrRet	CALL SUB ProcOp2	ErrRet	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF SymTemp.SymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg	END IFEND SUBBEGIN SUB GetBoolOp	CALL SUB GetExp	ErrRet	CALL SUB ProcOp2	ErrRet	OutBuf="xor eax,eax"	CALL SUB OutFcnCodeData	IF OpClass<>BOOLClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF SymTemp.SymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg	END IFEND SUBBEGIN SUB GetGUINdx	CALL SUB Expr	ErrRet	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF SymTemp.SymName<>"~" THEN		D0Loaded=0		CALL SUB LoadReg	END IFEND SUBBEGIN SUB GetFltOp	CALL SUB Expr	ErrRet	IF OpClass<>FLTClass AND OpClass<>INTClass THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF TSymName="~" AND OpClass=INTClass THEN		TSymName="eax"	END IF	IF TSymName<>"~" OR OpClass=INTClass THEN		OutBuf=";eaxf="+TSymName+";"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB GetComma	CALL SUB NexToken	IF TokenBuf<>"," THEN		ErrNo=ErrSyntax	END IFEND SUBBEGIN SUB GetColon	CALL SUB NexToken	IF TokenBuf<>":" THEN		ErrNo=ErrSyntax	END IFEND SUBBEGIN SUB GetEqual	CALL SUB NexToken	IF TokenBuf<>"=" THEN		ErrNo=ErrSyntax	END IFEND SUBBEGIN SUB SubLoad	D0Loaded=0	CALL SUB LoadReg	ErrRet	IF FloatFlag<>0 THEN		OutBuf=";eax=eaxf;"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB ReadSource	IF InpFilPtr=1 THEN		INCR BasicLineCtr	END IF	SrcLine=""	SrcNdx=0	EndNdx=0	SrcLineChars=0	EndFound=FALSE	QuoteFlag=0	WhiteSpaceCtr=0	FirstValidChar=FALSE	BEGIN LOOP		GET InpFile(InpFilPtr),RawData		TempInt=XferCount		AsciiByte=ASC(RawData)		IF AsciiByte=$ff THEN			TempInt=0			EXIT SUB		END IF		IF TempInt=0 THEN			IF ASC(LastRawData)<>$0d THEN				RawData=CHR$($0d)				AsciiByte=ASC(RawData)				TempInt=1			ELSE					IF EndFound=FALSE THEN					EndNdx=EndNdx-WhiteSpaceCtr				END IF				EXIT SUB			END IF		END IF		LastRawData=RawData		IF AsciiByte=NewLine THEN			IF EndFound=FALSE THEN				EndNdx=EndNdx-WhiteSpaceCtr			END IF			EXIT SUB		END IF		INCR SrcLineChars		IF QuoteFlag=0 THEN			IF AsciiByte=OBQUOTE THEN				QuoteFlag=$ff			END IF		ELSE			IF AsciiByte=OBQUOTE THEN				QuoteFlag=0			END IF		END IF		IF AsciiByte=$3b THEN; Comment?			IF QuoteFlag=0 THEN				EndFound=TRUE				EndNdx=EndNdx-WhiteSpaceCtr			END IF		END IF		IF AsciiByte=$09 OR AsciiByte=$20 THEN			INCR WhiteSpaceCtr		ELSE			IF AsciiByte<>$0d THEN				WhiteSpaceCtr=0			END IF		END IF		IF FirstValidChar=FALSE THEN			IF AsciiByte<>$0a AND AsciiByte<>$0d AND AsciiByte<>$09 AND AsciiByte<>$20 THEN				FirstValidChar=TRUE				SrcLine=SrcLine+RawData				IF EndFound=FALSE THEN					INCR EndNdx				END IF			END IF		ELSE			IF AsciiByte<>$0d THEN; Temporary code?				SrcLine=SrcLine+RawData				IF EndFound=FALSE THEN					INCR EndNdx				END IF			END IF		END IF	END LOOPEND SUBBEGIN SUB GenCase	IF OpClass=INTClass THEN		OutBuf="mov edx,[_SwitchInt]"		CALL SUB OutFcnCodeData		OutBuf="cmp eax,edx"		CALL SUB OutFcnCodeData		OutBuf=SymType+"_Lbl"+STR(LabelNum)	ELSE		ediUsed=TRUE		OutBuf="mov edi,_SwitchStr"		CALL SUB OutFcnCodeData		OutBuf="mov esi,"+TSymName		CALL SUB OutFcnCodeData		UseCmpStr=TRUE		OutBuf="call __CmpStr"		CALL SUB OutFcnCodeData			OutBuf=SymType+"_Lbl"+STR(LabelNum)	END IF	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB EndCasex	TempInt=7	CALL SUB ConStkChk	ErrRet	OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"; get here if case not true	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB MainLoopInit	ediUsed=FALSE	DataLabel=FALSE	GetBaseFlag=FALSE	CALL SUB ClrDatTyp	DMReDim=0	CmpOpFlag=FALSE	InitTrue=0	IgnoreRightParen=0	SimpleCmp=0	ComplexCmp=0	HasFcn=0	Target=0	GUIObjFlag=0	TextFlag=0	PrintFlag=0	StatFlag=0	TabFlag=0	DevFlag=0	CreateObjectFlag=FALSE	FileIO=0	DiskIO=0	BufRWFlg=0	D1Cleared=0	LabelFlag=0	Op1Class=0	ReadFlag=0	CompFlag=0	Promote=0	Demote=0	TmpUse=0	TmpVecUse=0	FTmpUse=0	ChrTmpUse=0	StrTmpUse=0	DimFlag=0	TypeFlag=0	AliasFlag=0	TDataMod=0	EndSegFlag=FALSEEND SUBBEGIN SUB ClrDataRegs	IF TDataType<>LONGVAR AND TDataType<>BOOLVAR THEN; Check for pointer here also?		IF D1Cleared=0 THEN			IF D0Loaded=0 THEN				OutBuf="xor eax,eax"			ELSE				D1Cleared=$ff				OutBuf="xor edx,edx"			END IF			CALL SUB OutFcnCodeData		END IF	END IFEND SUBBEGIN SUB GetSymTempExpNdx	SymTemp=SymTable(ExpTable(ExpNdx))END SUBBEGIN SUB ChkLabel	CALL SUB TokenSym	ErrRet	IF SymFound=FALSE THEN		SymTemp.DataType=LABELVAR		CALL SUB ClrSym		SymTemp.Detail=LabelUnresolved		IF KeyNdx=2 THEN; Restore			SymTemp.DataMod=DataBit		END IF		CALL SUB SymInsert		ErrRet	END IFEND SUBBEGIN SUB MakeStrConst	INCR PoolCtr	OutBuf="_StrConst"+STR(PoolCtr)+" db "+TokenSaf+",0"	CALL SUB OutInitDataEND SUBBEGIN SUB MakeBuffer	Comment="Memory Buffer"	CALL SUB BldComment	CALL SUB OutInitData	OutBuf=BufName+" dd 0"	CALL SUB OutInitData	OutBuf=" dd 0"	CALL SUB OutInitDataEND SUBBEGIN SUB ReleaseBuffer	OutBuf="cmp ["+BufName+"+4],0"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="je "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUE	OutBuf="invoke  VirtualFree,["+BufName+"],0,MEM_RELEASE"	CALL SUB OutFcnCodeData	OutBuf="mov ["+BufName+"],0"	CALL SUB OutFcnCodeData	OutBuf="mov ["+BufName+"+4],0"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetBuffer	OutBuf="push eax"	CALL SUB OutFcnCodeData	OutBuf="cmp ["+BufName+"+4],0"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="je "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUE	OutBuf="invoke  VirtualFree,["+BufName+"],0,MEM_RELEASE"	CALL SUB OutFcnCodeData	OutBuf="mov ["+BufName+"],0"	CALL SUB OutFcnCodeData	OutBuf="mov ["+BufName+"+4],0"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="pop eax"	CALL SUB OutFcnCodeData	OutBuf="mov ["+BufName+"+4],eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUE	OutBuf="invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE"	CALL SUB OutFcnCodeData	OutBuf="mov ["+BufName+"],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB PushArgs	IgnoreRightParen=$ff	SymTemp=SymTable(SymNdx)	CALL SUB GetFcnTypes	CALL SUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	NeedComma=FALSE	Ctr3=0	BEGIN LOOP		IF Ctr3>TFcnArgs THEN			ErrNo=ErrFcnArgs			EXIT SUB		END IF		CALL SUB NexToken		IF TokenBuf=")" THEN			IF Ctr3<>TFcnArgs THEN				ErrNo=ErrFcnArgs			END IF			EXIT SUB			END IF		IF NeedComma=TRUE THEN			IF TokenSaf<>"," THEN				ErrNo=ErrSyntax				EXIT SUB			END IF			NeedComma=FALSE		ELSE			IF TokenSaf="," THEN				ErrNo=ErrSyntax				EXIT SUB			END IF		END IF		CONTINUE IF TokenSaf="," 		CALL SUB UnDoToken		CALL SUB Expr		ErrRet		INCR Ctr3		CALL SUB ArgPush		ErrRet		NeedComma=TRUE	END LOOPEND SUBBEGIN SUB PopArgs	SymTemp=SymTable(SymNdx)	CALL SUB GetFcnTypes	CALL SUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	NeedComma=FALSE	Ctr3=0	BEGIN LOOP		IF Ctr3>TFcnArgs THEN			ErrNo=ErrFcnArgs			EXIT SUB		END IF		CALL SUB NexToken		IF TokenBuf=")" THEN			IF Ctr3<>TFcnArgs THEN				ErrNo=ErrFcnArgs			END IF			EXIT SUB		END IF		IF NeedComma=TRUE THEN			IF TokenSaf<>"," THEN				ErrNo=ErrSyntax				EXIT SUB			END IF			NeedComma=FALSE		ELSE			IF TokenSaf="," THEN				ErrNo=ErrSyntax				EXIT SUB			END IF		END IF		CONTINUE IF TokenSaf="," 		INCR Ctr3		IF LEFT(TokenSaf,1)>="0" AND LEFT(TokenSaf,1)<="9" THEN			ErrNo=ErrIVParm			EXIT SUB		END IF		IF LEFT(TokenSaf,1)="$" THEN			ErrNo=ErrIVParm			EXIT SUB		END IF		SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=TRUE THEN			IF LAND(SymTable(SymNdx).DataMod,LocalBit)<>LocalBit THEN				ErrNo=ErrDupSym				EXIT SUB			END IF			ExistingSym=TRUE		ELSE			ExistingSym=FALSE		END IF		SymTemp.Detail=0		SELECT CASE FcnTypes(Ctr3)			CASE BOOLVAR				; Pop bool here			CASE LONGVAR				OutBuf=TokenSaf+" equ !FcnVar"+STR(Ctr3)				CALL SUB OutFcnCodeData				SymTemp.DataType=LONGVAR				SymTemp.DataMod=LocalBit				SymTemp.DataAddr=4			CASE FLOATVAR				; Pop float here			CASE STRINGVAR				OutBuf=TokenSaf+" equ !FcnVar"+STR(Ctr3)				CALL SUB OutFcnCodeData				OutBuf="mov esi,[!FcnVar"+STR(Ctr3)+"]"				CALL SUB OutFcnCodeData				OutBuf="mov eax,[esi]"				CALL SUB OutFcnCodeData				OutBuf="mov ["+TokenSaf+"],eax"				CALL SUB OutFcnCodeData				OutBuf="mov eax,[esi+4]"				CALL SUB OutFcnCodeData				OutBuf="mov ["+TokenSaf+"+4],eax"				CALL SUB OutFcnCodeData				OutBuf="mov ["+TokenSaf+"+8],0"				CALL SUB OutFcnCodeData				SymTemp.DataType=STRINGVAR				SymTemp.DataMod=LOR(VectorBit,LocalBit)		END SELECT		IF ExistingSym=FALSE THEN			CALL SUB SymInsert		ELSE			SymTable(SymNdx)=SymTemp		END IF		NeedComma=TRUE	END LOOPEND SUBBEGIN SUB GetFcnTypes	TFcnArgs=SymTemp.FcnArgs	TFcnDataType=SymTemp.FcnDataType	FcnTypes(1)=SymTemp.DataAddr	FcnTypes(2)=SymTemp.DataSize	FcnTypes(3)=SymTemp.ArrayDim1	FcnTypes(4)=SymTemp.ArrayDim2	FcnTypes(5)=SymTemp.ArrayDim3	FcnTypes(6)=SymTemp.ArrayDims	FcnTypes(7)=SymTemp.MiscEND SUBBEGIN SUB ChkInt	CALL SUB ValidInt	IF IntOK=FALSE THEN		ErrNo=ErrIVExp	END IFEND SUBBEGIN SUB ChkSym	CALL SUB TokenSym1	ErrRet	IF SymFound=FALSE THEN		ErrNo=ErrUDSym	END IFEND SUBBEGIN SUB ChkHex	CALL SUB ValidHex	IF HexOK=FALSE THEN		ErrNo=ErrIVExp	END IFEND SUBBEGIN SUB ChkFlt	CALL SUB ValidFlt	IF FloatOK=FALSE THEN		ErrNo=ErrIVExp	END IFEND SUBBEGIN SUB LoadNumericValue	IF TSymName<>"~" THEN		IF OpClass=INTClass THEN			D0Loaded=0			CALL SUB LoadReg		ELSE			;TSymName="eaxf"		END IF	ELSE		IF OpClass=INTClass THEN			TSymName="eax"		ELSE			;TSymName="eaxf"		END IF	END IFEND SUBBEGIN SUB PushNumeric	CALL SUB LoadNumericValue	OutBuf="mov [!FcnVar"+STR(Ctr3)+"],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB ProcFcnPrep	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	SymTable(SymNdx).Detail=LabelResolved	SymTemp=SymTable(SymNdx)	OutBuf=SymTemp.SymName+":"	CALL OutFunction	CALL SUB GetFcnTypesEND SUBBEGIN SUB ArgPush	SELECT CASE OpClass		CASE BOOLClass			IF FcnTypes(Ctr3)<>BOOLVAR THEN				ErrNo=ErrTypMis				EXIT SUB			END IF			; Push bool here		CASE INTClass			IF FcnTypes(Ctr3)<>LONGVAR THEN				ErrNo=ErrTypMis				EXIT SUB			END IF			CALL SUB PushNumeric		CASE FLTClass			IF FcnTypes(Ctr3)<>FLOATVAR THEN				ErrNo=ErrTypMis				EXIT SUB			END IF			CALL SUB PushNumeric		CASE STRClass			IF FcnTypes(Ctr3)<>STRINGVAR THEN				ErrNo=ErrTypMis				EXIT SUB			END IF			OutBuf="mov [!FcnVar"+STR(Ctr3)+"],"+TSymName			CALL SUB OutFcnCodeData		CASE ELSE			ErrNo=ErrTypMis			EXIT SUB		END SELECTEND SUBBEGIN SUB ChkUse	RESTORE MovArgLib	CALL SUB OutLibCodeText	IF UseReadFile=TRUE THEN		ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE		RESTORE ReadFileLib		CALL SUB OutLibCodeText	END IF	IF UseWriteFile=TRUE THEN		ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE		RESTORE WriteFileLib		CALL SUB OutLibCodeText	END IF	IF UseWriteOBComm=TRUE THEN		ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE		RESTORE WriteOBCommLib		CALL SUB OutLibCodeText	END IF	IF UseInpData=TRUE THEN		ImportFcnTable(ptrReadConsole).ImportFcnUse=TRUE		ImportFcnTable(ptratol).ImportFcnUse=TRUE		RESTORE InpDataLib		CALL SUB OutLibCodeText	END IF	IF UseData=TRUE THEN		ImportFcnTable(ptratol).ImportFcnUse=TRUE		RESTORE DataLib		CALL SUB OutLibCodeText	END IF	IF UseCmpStr=TRUE THEN		RESTORE CmpStrLib		CALL SUB OutLibCodeText	END IF	IF UseMovStr=TRUE THEN		RESTORE MovStrLib		CALL SUB OutLibCodeText	END IF	IF UseStrLen=TRUE THEN		RESTORE StrLenLib		CALL SUB OutLibCodeText	END IF	IF UseAtoL=TRUE THEN		ImportFcnTable(ptratol).ImportFcnUse=TRUE		RESTORE AtoLLib		CALL SUB OutLibCodeText	END IF	IF UseBtoA=TRUE THEN		RESTORE BtoALib		CALL SUB OutLibCodeText	END IF	IF UseSetStrConst=TRUE THEN		RESTORE SetStrConstLib		CALL SUB OutLibCodeText	END IF	IF UseMidStr=TRUE THEN		RESTORE MidStrLib		CALL SUB OutLibCodeText	END IF	IF UseSetRightBottom=TRUE THEN		RESTORE SetRightBottomLib		CALL SUB OutLibCodeText	END IF	IF UseRightStr=TRUE THEN		RESTORE RightStrLib		CALL SUB OutLibCodeText	END IF	IF UseTailStr=TRUE THEN		RESTORE TailStrLib		CALL SUB OutLibCodeText	END IF	IF UseLCase=TRUE THEN		RESTORE LCaseLib		CALL SUB OutLibCodeText	END IF	IF UseUCase=TRUE THEN		RESTORE UCaseLib		CALL SUB OutLibCodeText	END IF	IF UseShowHideFamily=TRUE THEN		RESTORE ShowHideFamilyLib		CALL SUB OutLibCodeText	END IF	IF UseEnableDisableFamily=TRUE THEN		RESTORE EnableDisableFamilyLib		CALL SUB OutLibCodeText	END IF	IF UsePad=TRUE THEN		RESTORE PadLib		CALL SUB OutLibCodeText	END IF	IF UseTrim=TRUE THEN		RESTORE TrimLib		CALL SUB OutLibCodeText	END IFEND SUBBEGIN SUB OutLibCodeText	BEGIN LOOP		READ OutBuf		EXIT IF OutBuf="ENDTEXT"		CALL OutLib	END LOOPEND SUBBEGIN SUB OutPreCodeText	BEGIN LOOP		READ OutBuf		EXIT IF OutBuf="ENDTEXT"		CALL SUB OutPreCode	END LOOPEND SUBBEGIN SUB OutUninitText	BEGIN LOOP		READ OutBuf		EXIT IF OutBuf="ENDTEXT"		CALL SUB OutUninitData	END LOOPEND SUBBEGIN SUB OutInitText	BEGIN LOOP		READ OutBuf		EXIT IF OutBuf="ENDTEXT"		CALL SUB OutInitData	END LOOPEND SUBBEGIN SUB ValidateParentObject	ParentFlag=$ff	CALL SUB ValidateObjectCommonEND SUBBEGIN SUB ValidateObject	ParentFlag=0	CALL SUB ValidateObjectCommon	END SUBBEGIN SUB ValidateObjectCommon	IF ParentFlag=0 THEN; ******??????		GUIArrayFlag=0	END IF	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ObjectType=0	ELSE		ObjectType=SymTable(SymNdx).DataType	END IF	IF LAND(SymTable(SymNdx).DataMod,ArrayBit)<>0 AND ParentFlag<>0 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	IF ObjectType=FORM THEN		FormExStyle="0"	END IF	IF ObjectType=TOOLWINDOW THEN		FormExStyle="WS_EX_TOOLWINDOW"	END IF	ObjectName=SymTable(SymNdx).SymName	IF ObjectType<100 THEN		ErrNo=ErrIVType		EXIT SUB	END IF	IF ParentFlag<>0 THEN		ObjectParent="!"+ObjectName+"+HandleOffs"		ObjectParentName="!"+ObjectName		EXIT SUB	END IF	CALL SUB ProcessObjectEND SUBBEGIN SUB ProcessObject	HandleName="edi+HandleOffs"	GUIArrayFlag=LAND(SymTable(SymNdx).DataMod,ArrayBit)	IF ObjectType=TIMER OR ObjectType=OBCOMM OR ObjectType=FAMILY OR ObjectType=OBZIP THEN		EXIT SUB	END IF	IF GUIArrayFlag<>0 THEN		OutBuf="mov edi,!"+ObjectName+"-768"		CALL SUB OutFcnCodeData		IF NextByte="." THEN; Must be event			EXIT SUB		END IF		CALL SUB NexToken		IF TokenBuf<>"(" THEN			ErrNo=ErrSyntax			EXIT SUB		END IF		IF ParentFlag=0 THEN; ??????????			TArrayDim1=SymTable(SymNdx).ArrayDim1		END IF		IgnoreRightParen=$ff		GUIObjFlag=0		CALL SUB GetGUINdx		ErrRet		IF CreateObjectFlag=TRUE THEN			OutBuf="mov [ArrayIndex],eax"			CALL SUB OutFcnCodeData		END IF		OutBuf="imul eax,768"		CALL SUB OutFcnCodeData		OutBuf="add edi,eax"		CALL SUB OutFcnCodeData		INCR SrcNdx; Point past ')'		IgnoreRightParen=0	ELSE		OutBuf="mov edi,!"+ObjectName		CALL SUB OutFcnCodeData	END IF	IF GUITargetFlag<>0 THEN		OutBuf="mov [!TargetGUIDesc],edi"		CALL SUB OutFcnCodeData	ELSE		OutBuf="mov [!SourceGUIDesc],edi"		CALL SUB OutFcnCodeData	END IF	END SUBBEGIN SUB GetStringOp	CALL SUB GetExp	ErrRet	CALL SUB ProcOp2	ErrRet	IF Op2Class<>STRClass THEN		ErrNo=ErrIVType	END IFEND SUBBEGIN SUB GetTextOp	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	SymTemp=SymTable(SymNdx)	IF SymTemp.DataType<>TEXT THEN		ErrNo=ErrIVType		EXIT SUB	END IF	IF SymTemp.DataMod=0 THEN		ErrNo=ErrTextNotDefined		EXIT SUB	END IF	TSymName=SymTemp.SymNameEND SUBBEGIN SUB RightBracket	TempInt=LEN(SrcLine)	FOR I=SrcNdx TO TempInt		IF MID(SrcLine,I,1)="]" THEN BracketFound	NEXT I	ErrNo=ErrSyntax	EXIT SUB	BracketFound:	SrcLineMod=I	MID(SrcLine,SrcLineMod,1)=CHR(0)END SUBBEGIN SEG GUIFatal	TempStr="GUI statement or declaration in Console program"	ErrNo=$ffEND SEG MainLoopBEGIN SUB TimerArray	CALL SUB NexToken	IF TokenBuf="." THEN; Must be event		CALL SUB UnDoToken		EXIT SUB	END IF	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	IgnoreRightParen=$ff	GUIObjFlag=0	CALL SUB GetGUINdx	ErrRet	OutBuf="mov ebx,eax"	CALL SUB OutFcnCodeData	OutBuf="shl ebx,16"	CALL SUB OutFcnCodeData	INCR SrcNdx; Point past ')'	IgnoreRightParen=0	HasSubscript=TRUEEND SUBBEGIN SUB OBCommArray	CALL SUB NexToken	IF TokenBuf="." THEN; Must be event		CALL SUB UnDoToken		EXIT SUB	END IF	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	IgnoreRightParen=$ff	GUIObjFlag=0	CALL SUB GetGUINdx	ErrRet	OutBuf="imul eax,100"	CALL SUB OutFcnCodeData	INCR SrcNdx; Point past ')'	IgnoreRightParen=0	HasSubscript=TRUEEND SUBBEGIN SEG GUITarget	HasSubscript=FALSE	IF ObjectType=FAMILY THEN		OutBuf="mov [_ArgSafe1],"+STR(ObjectDetail)		CALL SUB OutFcnCodeData		CALL SUB NexToken		IF TokenBuf<>"." THEN			ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB NexToken	FcnName=TokenBuf	EqualMain	SELECT CASE FcnName		CASE "enable"			CALL SUB GetBoolOp			ErrMain			OutBuf="mov [_ArgSafe2],eax"			CALL SUB OutFcnCodeData			UseEnableDisableFamily=TRUE			ImportFcnTable(ptrEnableWindow).ImportFcnUse=TRUE			OutBuf="call __EnableDisableFamily"			CALL SUB OutFcnCodeData			CASE "visible"			CALL SUB GetBoolOp				ErrMain				OutBuf="mov [_ArgSafe2],eax"				CALL SUB OutFcnCodeData				UseShowHideFamily=TRUE				ImportFcnTable(ptrShowWindow).ImportFcnUse=TRUE				OutBuf="call __ShowHideFamily"				CALL SUB OutFcnCodeData			CASE ELSE				ErrNo=ErrIVProp		END SELECT		EXIT SEG	END IF	IF ObjectType=TIMER THEN		IF ObjectArray<>0 THEN			CALL SUB TimerArray		END IF		CALL SUB NexToken		IF TokenBuf<>"." THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "time"				OutBuf="mov eax,"+STR(ObjectDetail)				CALL SUB OutFcnCodeData				IF ObjectArray<>0 THEN					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add eax,ebx"					CALL SUB OutFcnCodeData				END IF				OutBuf="mov [_ArgSafe0],eax"				CALL SUB OutFcnCodeData				EqualMain				CALL SUB GetIntOp				ErrMain				ImportFcnTable(ptrSetTimer).ImportFcnUse=TRUE				OutBuf="invoke SetTimer,[!OBMain],[_ArgSafe0],eax,NULL"				CALL SUB OutFcnCodeData			CASE "stop"				OutBuf="mov eax,"+STR(ObjectDetail)				CALL SUB OutFcnCodeData				IF ObjectArray<>0 THEN					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add eax,ebx"					CALL SUB OutFcnCodeData				END IF				ImportFcnTable(ptrKillTimer).ImportFcnUse=TRUE				OutBuf="invoke KillTimer,[!OBMain],eax"				CALL SUB OutFcnCodeData			CASE "timeout"				TempStr=ObjectName+"_"+TokenSaf				SymTemp.SymName=TempStr				CALL SUB MakeEvent				ErrMain				IF ObjectArray<>0 THEN					OutBuf="mov ecx,"+STR(ObjectArray)					CALL SUB OutInitCode					OutBuf="mov esi,!Timer+"+STR(ObjectDetail*4)					CALL SUB OutInitCode					INCR LabelNum					OutBuf="_Lbl"+STR(LabelNum)+":"					CALL SUB OutInitCode					OutBuf="mov dword [esi],"+TempStr					CALL SUB OutInitCode					OutBuf="add esi,4"					CALL SUB OutInitCode					OutBuf="dec ecx"					CALL SUB OutInitCode					OutBuf="jne _Lbl"+STR(LabelNum)					CALL SUB OutInitCode				ELSE					OutBuf="mov [!Timer+"+STR(ObjectDetail*4)+"],"+TempStr					CALL SUB OutInitCode				END IF			CASE ELSE				ErrNo=ErrIVProp		END SELECT		EXIT SEG	END IF	IF ObjectType=OBZIP THEN		CALL SUB NexToken		IF TokenBuf<>"." THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "createzipfile"				CALL SUB GetStringOp				ImportFcnTable(ptrzCreateNewZip).ImportFcnUse=TRUE				OutBuf="invoke zCreateNewZip,["+TSymName+"]"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "orderfile"				CALL SUB GetStringOp				ErrMain				ImportFcnTable(ptrzOrderFile).ImportFcnUse=TRUE				OutBuf="invoke zOrderFile,["+TSymName+"],["+TSymName+"],0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "compressfiles"				ImportFcnTable(ptrzCompressFiles).ImportFcnUse=TRUE				OutBuf="invoke zCompressFiles,0,0,2,0,-1,0,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "closezipfile"				ImportFcnTable(ptrzCloseZipFile).ImportFcnUse=TRUE				OutBuf="invoke zCloseZipFile"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "openzipfile"				CALL SUB GetStringOp				ErrMain				ImportFcnTable(ptrzOpenZipFile).ImportFcnUse=TRUE				OutBuf="invoke zOpenZipFile,["+TSymName+"]"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "extractall"				ImportFcnTable(ptrzExtractAll).ImportFcnUse=TRUE				OutBuf="invoke zExtractAll,0,0,1,0,0,0,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "selectfile"				CALL SUB GetIntOp				ErrMain				ImportFcnTable(ptrzSelectFile).ImportFcnUse=TRUE				OutBuf="invoke zSelectFile,eax,1"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "unselectfile"				CALL SUB GetIntOp				ErrMain				ImportFcnTable(ptrzSelectFile).ImportFcnUse=TRUE				OutBuf="invoke zSelectFile,eax,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "extractselected"				ImportFcnTable(ptrzExtractSelected).ImportFcnUse=TRUE				OutBuf="invoke zExtractSelected,0,0,1,0,0,0,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "extract"				ImportFcnTable(ptrzExtractOne).ImportFcnUse=TRUE				OutBuf="invoke zExtractOne,eax,0,0,1,0,0,0,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "cancel"				ImportFcnTable(ptrzCancelOperation).ImportFcnUse=TRUE				OutBuf="invoke zCancelOperation"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "unselectall"				ImportFcnTable(ptrzUnselectAll).ImportFcnUse=TRUE				OutBuf="invoke zUnselectAll"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "orderbywildcards"				CALL SUB GetStringOp				ErrMain				FcnName=TSymName				CommaMain				CALL SUB GetBoolOp				ErrMain				ImportFcnTable(ptrzOrderByWildcards).ImportFcnUse=TRUE				OutBuf="invoke zOrderByWildcards,["+FcnName+"],eax"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "deleteselected"				ImportFcnTable(ptrzDeleteFiles).ImportFcnUse=TRUE				OutBuf="invoke zDeleteFiles"				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE "getprogressinfo"				CALL SUB NexToken				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					ErrNo=ErrUDSym					EXIT SEG				END IF				SymTemp=SymTable(SymNdx)				IF SymTemp.DataType<>LONGVAR THEN					ErrNo=ErrIVType					EXIT SEG				END IF				CommaMain				CALL SUB NexToken				FcnName=TokenSaf				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					ErrNo=ErrUDSym					EXIT SEG				END IF				SymTemp=SymTable(SymNdx)				IF SymTemp.DataType<>LONGVAR THEN					ErrNo=ErrIVType					EXIT SEG				END IF				ImportFcnTable(ptrzGetRunTimeInfo).ImportFcnUse=TRUE				OutBuf="invoke zGetRunTimeInfo,+FcnName+","+TokenSaf				CALL SUB OutFcnCodeData				CALL SUB SetStatus			CASE ELSE				ErrNo=ErrIVProp		END SELECT		EXIT SEG	END IF	IF ObjectType=OBCOMM THEN		IF ObjectArray<>0 THEN			CALL SUB OBCommArray		END IF		CALL SUB NexToken		IF TokenBuf<>"." THEN			ErrNo=ErrSyntax			EXIT SEG		END IF		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "open"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName					CALL SUB OutFcnCodeData				END IF				OutBuf="mov [!TargetGUIDesc],edi"				CALL SUB OutFcnCodeData				OutBuf="add edi,!PortNameOffs"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrCreateFile).ImportFcnUse=TRUE				OutBuf="invoke CreateFile,edi,GENERIC_WRITE+GENERIC_READ,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus				CALL SUB CallErr				OutBuf="mov edi,[!TargetGUIDesc]"				CALL SUB OutFcnCodeData				OutBuf="mov [edi+!HandleOffs],eax"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrGetCommState).ImportFcnUse=TRUE				OutBuf="invoke GetCommState,eax,edi"				CALL SUB OutFcnCodeData				OutBuf="mov edi,[!TargetGUIDesc]"				CALL SUB OutFcnCodeData				OutBuf="xor eax,eax"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserRTSOffs]"				CALL SUB OutFcnCodeData				OutBuf="shl eax,12"				CALL SUB OutFcnCodeData				OutBuf="mov ebx,[edi+!fBitsOffs]"				CALL SUB OutFcnCodeData				OutBuf="and ebx,$cfff"				CALL SUB OutFcnCodeData				OutBuf="or ebx,eax"				CALL SUB OutFcnCodeData				OutBuf="mov [edi+!fBitsOffs],ebx"				CALL SUB OutFcnCodeData				OutBuf="xor eax,eax"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserDTROffs]"				CALL SUB OutFcnCodeData				OutBuf="shl eax,4"				CALL SUB OutFcnCodeData				OutBuf="mov ebx,[edi+!fBitsOffs]"				CALL SUB OutFcnCodeData				OutBuf="and ebx,$ffcf"				CALL SUB OutFcnCodeData				OutBuf="or ebx,eax"				CALL SUB OutFcnCodeData				OutBuf="mov [edi+!fBitsOffs],ebx"				CALL SUB OutFcnCodeData				OutBuf="xor eax,eax"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserParityCheckOffs]"				CALL SUB OutFcnCodeData				OutBuf="shl eax,1"				CALL SUB OutFcnCodeData				OutBuf="mov ebx,[edi+!fBitsOffs]"				CALL SUB OutFcnCodeData				OutBuf="and ebx,$fffd"				CALL SUB OutFcnCodeData				OutBuf="or ebx,eax"				CALL SUB OutFcnCodeData				OutBuf="mov [edi+!fBitsOffs],ebx"				CALL SUB OutFcnCodeData				OutBuf="xor eax,eax"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserDSRCheckOffs]"				CALL SUB OutFcnCodeData				OutBuf="shl eax,3"				CALL SUB OutFcnCodeData				OutBuf="mov ebx,[edi+!fBitsOffs]"				CALL SUB OutFcnCodeData				OutBuf="and ebx,$fff7"				CALL SUB OutFcnCodeData				OutBuf="or ebx,eax"				CALL SUB OutFcnCodeData				OutBuf="mov [edi+!fBitsOffs],ebx"				CALL SUB OutFcnCodeData				OutBuf="xor eax,eax"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserCTSCheckOffs]"				CALL SUB OutFcnCodeData				OutBuf="shl eax,2"				CALL SUB OutFcnCodeData				OutBuf="mov ebx,[edi+!fBitsOffs]"				CALL SUB OutFcnCodeData				OutBuf="and ebx,$fffb"				CALL SUB OutFcnCodeData				OutBuf="or ebx,eax"				CALL SUB OutFcnCodeData				OutBuf="mov [edi+!fBitsOffs],ebx"				CALL SUB OutFcnCodeData							OutBuf="mov dword eax,[edi+!UserBaudRateOffs]"				CALL SUB OutFcnCodeData				OutBuf="mov dword [edi+!BaudRateOffs],eax"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserParityOffs]"				CALL SUB OutFcnCodeData				OutBuf="mov byte [edi+!ParityOffs],al"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserByteSizeOffs]"				CALL SUB OutFcnCodeData				OutBuf="mov byte [edi+!ByteSizeOffs],al"				CALL SUB OutFcnCodeData				OutBuf="mov byte al,[edi+!UserStopBitsOffs]"				CALL SUB OutFcnCodeData				OutBuf="mov byte [edi+!StopBitsOffs],al"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrSetCommState).ImportFcnUse=TRUE				OutBuf="invoke SetCommState, dword [edi+!HandleOffs],edi"				CALL SUB OutFcnCodeData				OutBuf="mov edi, dword [!TargetGUIDesc]"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrSetCommMask).ImportFcnUse=TRUE				OutBuf="invoke SetCommMask, dword [edi+!HandleOffs],EV_ERR"				CALL SUB OutFcnCodeData			CASE "close"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!HandleOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!HandleOffs"					CALL SUB OutFcnCodeData							END IF				OutBuf="push edi"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUE				OutBuf="invoke CloseHandle, dword [edi]"				CALL SUB OutFcnCodeData				CALL SUB SetStatus				OutBuf="pop edi"				CALL SUB OutFcnCodeData				OutBuf="mov dword [edi],0"				CALL SUB OutFcnCodeData			CASE "binaryinput"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName					CALL SUB OutFcnCodeData				END IF				CALL SUB NexToken				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					ErrNo=ErrUDSym					EXIT SEG				END IF				IF SymTable(SymNdx).DataType<>BYTEVAR THEN					ErrNo=ErrTypMis					EXIT SEG				END IF				VarName=TokenSaf				CommaMain				CALL SUB GetIntOp				ErrMain						ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE				IF LAND(VectorBit,SymTable(SymNdx).DataMod)<>VectorBit THEN					OutBuf="invoke ReadFile, dword [edi+!HandleOffs],"+VarName+",eax,XferCount,0"				ELSE					OutBuf="invoke ReadFile, dword [edi+!HandleOffs],["+VarName+"],eax,XferCount,0"				END IF				CALL SUB OutFcnCodeData				CALL SUB SetStatus				CALL SUB CallErrZ			CASE "binaryoutput"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN					ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName					CALL SUB OutFcnCodeData				END IF				CALL SUB NexToken				SymTemp.SymName=TokenSaf				CALL SUB SymSrch				IF SymFound=FALSE THEN					ErrNo=ErrUDSym					EXIT SEG				END IF				IF SymTable(SymNdx).DataType<>BYTEVAR THEN					ErrNo=ErrTypMis					EXIT SEG				END IF				VarName=TokenSaf				CommaMain				CALL SUB GetIntOp				ErrMain						ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE				IF LAND(VectorBit,SymTable(SymNdx).DataMod)<>VectorBit THEN					OutBuf="invoke WriteFile, dword [edi+!HandleOffs],"+VarName+",eax,XferCount,0"				ELSE					OutBuf="invoke WriteFile, dword [edi+!HandleOffs],["+VarName+"],eax,XferCount,0"				END IF				CALL SUB OutFcnCodeData				CALL SUB SetStatus				CALL SUB CallErrZ			CASE "output"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!HandleOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!HandleOffs"					CALL SUB OutFcnCodeData				END IF				OutBuf="push edi"				CALL SUB OutFcnCodeData				EqualMain				CALL SUB GetStringOp				ErrMain				OutBuf="mov esi,["+TempStr+"]"				CALL SUB OutFcnCodeData				OutBuf="mov ebx,esi"				CALL SUB OutFcnCodeData				OutBuf="mov edx,["+TempStr+"+4]"				CALL SUB OutFcnCodeData				OutBuf="pop edi"				CALL SUB OutFcnCodeData				UseWriteOBComm=TRUE				ImportFcnTable(ptrGetLastError).ImportFcnUse=TRUE				OutBuf="call __WriteOBComm"				CALL SUB OutFcnCodeData			CASE "baudrate"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserBaudRateOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserBaudRateOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetIntOp				ErrMain				OutBuf="mov dword [edi],eax"				CALL SUB OutFcnCodeData			CASE "parity"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserParityOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserParityOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetIntOp				ErrMain				OutBuf="mov byte [edi],al"				CALL SUB OutFcnCodeData			CASE "rts"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserRTSOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserRTSOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetIntOp				ErrMain				OutBuf="mov byte [edi],al"				CALL SUB OutFcnCodeData			CASE "dtr"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserDTROffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserDTROffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetIntOp				ErrMain				OutBuf="mov byte [edi],al"				CALL SUB OutFcnCodeData			CASE "paritycheck"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserParityCheckOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserParityCheckOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB NexToken				IF TokenBuf="false" THEN					TempStr="0"				ELSE					TempStr="1"				END IF				OutBuf="mov byte [edi],"+TempStr				CALL SUB OutFcnCodeData			CASE "dsrcheck"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserDSRCheckOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserDSRCheckOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB NexToken				IF TokenBuf="false" THEN					TempStr="0"				ELSE					TempStr="1"				END IF				OutBuf="mov byte [edi],"+TempStr				CALL SUB OutFcnCodeData			CASE "ctscheck"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserCTSCheckOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserCTSCheckOffs"					CALL SUB OutFcnCodeData							END IF				EqualMain				CALL SUB NexToken				IF TokenBuf="false" THEN					TempStr="0"				ELSE					TempStr="1"				END IF				OutBuf="mov byte [edi],"+TempStr				CALL SUB OutFcnCodeData			CASE "stopbits"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserStopBitsOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserStopBitsOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetIntOp				ErrMain				OutBuf="mov byte [edi],al"				CALL SUB OutFcnCodeData			CASE "databits"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!UserByteSizeOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!UserByteSizeOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetIntOp				ErrMain				OutBuf="mov byte [edi],al"				CALL SUB OutFcnCodeData					CASE "portname"				IF ObjectArray<>0 THEN					OutBuf="mov edi,"+ObjectName+"+!PortNameOffs-100"					CALL SUB OutFcnCodeData					IF HasSubscript=FALSE THEN						ErrNo=ErrSyntax						EXIT SEG					END IF					OutBuf="add edi,eax"					CALL SUB OutFcnCodeData				ELSE					OutBuf="mov edi,"+ObjectName+"+!PortNameOffs"					CALL SUB OutFcnCodeData				END IF				EqualMain				CALL SUB GetStringOp				ErrMain				Op1Name=TempStr				CALL SUB GetTmpVec				Op2Name=TempStr				OutBuf="mov ["+TempStr+"],edi"				CALL SUB OutFcnCodeData				OutBuf="mov ["+TempStr+"+4],31"				CALL SUB OutFcnCodeData				OutBuf="mov ["+TempStr+"+8],0"				CALL SUB OutFcnCodeData				OutBuf="mov edi,"+Op2Name				CALL SUB OutFcnCodeData				OutBuf="mov esi,"+Op1Name				CALL SUB OutFcnCodeData				UseMovStr=TRUE				OutBuf="call __MovStr"				CALL SUB OutFcnCodeData			CASE ELSE				ErrNo=ErrIVProp		END SELECT		EXIT SEG	END IF	CALL SUB NexToken	IF TokenBuf<>"." THEN		ErrNo=ErrSyntax		EXIT SEG	END IF	CALL SUB NexToken	IF TokenBuf="intercept" THEN		TempStr=ObjectName+"_intercept"		SymTemp.SymName=TempStr		CALL SUB MakeEvent		ErrMain		INCR InterceptProcNum		OutBuf="mov dword [!"+ObjectName+"+"+STR(InterceptProcOffs)+"],!InterceptProc"+STR(InterceptProcNum)		CALL SUB OutInitCode			OutBuf="proc !InterceptProc"+STR(InterceptProcNum)+",!OBMain,wmsg,wparam,lparam"		CALL OutProc		OutBuf="enter"		CALL OutProc		OutBuf="push ebx esi edi"		CALL OutProc		OutBuf="mov [!PassEvent],0"		CALL OutProc		OutBuf="mov [!Desc],!"+ObjectName		CALL OutProc		OutBuf="call "+ObjectName+"_intercept"		CALL OutProc		OutBuf="cmp [!PassEvent],0"		CALL OutProc		OutBuf="je !NoPass"+STR(InterceptProcNum)		CALL OutProc		ImportFcnTable(ptrCallWindowProc).ImportFcnUse=TRUE		OutBuf="invoke CallWindowProc,[!"+ObjectName+"+492],[!hwnd],[wmsg],[wparam],[lparam]"		CALL OutProc		OutBuf="!NoPass"+STR(InterceptProcNum)+":"		CALL OutProc		OutBuf="jmp !Finish"		CALL OutProc		OutBuf=""		CALL OutProc		EXIT SEG	END IF	ObjectTypeSafe=ObjectType-99	SETVECTOR EventArray=[ObjTable(ObjectTypeSafe).ObjEventTable]	I=0	BEGIN LOOP		INCR I		IF EventArray(I).EVType="%" THEN NotEvent		IF EventArray(I).EVType=TokenBuf THEN EventFound	END LOOPEND SEG MainLoop	BEGIN SEG EventFound	DescOffs=EventArray(I).EVDescOffs	NotifyCode=EventArray(I).EVNotify	TempInt=EventArray(I).EVStatusBit	IF TempInt>31 THEN; Notify Event		TempInt=LAND(TempInt,$0000001f)		TGUINotifyEvents=SymTable(GUITargetSymNdx).GUINotifyEvents		IF BITTST(TGUINotifyEvents,TempInt)=TRUE THEN			ErrNo=ErrDupEvent			EXIT SEG		ELSE			TGUINotifyEvents=BITSET(TGUINotifyEvents,TempInt)			SymTable(GUITargetSymNdx).GUINotifyEvents=TGUINotifyEvents		END IF		DescOffs=TempInt		DescOffs=SHL(DescOffs,3)		DescOffs=DescOffs+256; ??????????	ELSE		TGUIEvents=SymTable(GUITargetSymNdx).GUIEvents		IF BITTST(TGUIEvents,TempInt)=TRUE THEN			ErrNo=ErrDupEvent			EXIT SEG		ELSE			TGUIEvents=BITSET(TGUIEvents,TempInt)			SymTable(GUITargetSymNdx).GUIEvents=TGUIEvents		END IF	END IF	TempStr=ObjectName+"_"+TokenSaf	SymTemp.SymName=TempStr	CALL SUB MakeEvent	ErrMain	IF GUIArrayFlag=0 THEN		OutBuf="mov [!"+ObjectName+"+"+STR(DescOffs)+"],"+ObjectName+"_"+TokenSaf		CALL SUB OutInitCode		IF DescOffs>=96 AND DescOffs<=380 THEN; Sub code for command event			OutBuf="mov [!"+ObjectName+"+"+STR(DescOffs)+"+4],"+STR(NotifyCode)			CALL SUB OutInitCode		END IF	ELSE		TArrayDim1=SymTable(GUITargetSymNdx).ArrayDim1		OutBuf="mov ecx,"+STR(TArrayDim1)		CALL SUB OutInitCode		OutBuf="mov esi,!"+ObjectName		CALL SUB OutInitCode		INCR LabelNum		OutBuf="_Lbl"+STR(LabelNum)+":"		CALL SUB OutInitCode		OutBuf="mov dword [esi+"+STR(DescOffs)+"],"+ObjectName+"_"+TokenSaf		CALL SUB OutInitCode		IF DescOffs>=96 AND DescOffs<=380 THEN; Sub code for command event			OutBuf="mov dword [esi+"+STR(DescOffs)+"+4],"+STR(NotifyCode)			CALL SUB OutInitCode		END IF		OutBuf="add esi,768"		CALL SUB OutInitCode		OutBuf="dec ecx"		CALL SUB OutInitCode		OutBuf="jne _Lbl"+STR(LabelNum)		CALL SUB OutInitCode		END IFEND SEG MainLoop	BEGIN SEG NotEvent	SETVECTOR PropArray=[ObjTable(ObjectTypeSafe).ObjPropTable]	I=0	BEGIN LOOP		INCR I		IF PropArray(I).PropName="%" THEN			ErrNo=ErrIVProp			EXIT SEG		END IF			IF PropArray(I).PropName=TokenBuf THEN			CALL SUB [PropArray(I).PropSet]			EXIT SEG		END IF	END LOOPEND SEG MainLoopBEGIN SUB GUISource	IF ObjectType=OBCOMM THEN		IF GUIArrayFlag<>0 THEN			OutBuf="mov edi,"+ObjectName+"-100"			CALL SUB OutFcnCodeData			CALL SUB NexToken			IF TokenBuf<>"(" THEN				ErrNo=ErrSyntax				EXIT SUB			END IF			IgnoreRightParen=$ff			GUIObjFlag=0			CALL SUB GetGUINdx			ErrRet			OutBuf="imul eax,100"			CALL SUB OutFcnCodeData			INCR SrcNdx; Point past ')'			IgnoreRightParen=0			OutBuf="add edi,eax"			CALL SUB OutFcnCodeData			OutBuf="mov [!SourceGUIDesc],edi"			CALL SUB OutFcnCodeData		ELSE			OutBuf="mov edi,"+ObjectName			CALL SUB OutFcnCodeData			END IF		OutBuf="mov [!SourceGUIDesc],edi"		CALL SUB OutFcnCodeData		CALL SUB NexToken		IF TokenBuf<>"." THEN			ErrNo=ErrSyntax			EXIT SUB		END IF		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "status"				ediUsed=TRUE				OutBuf="mov eax,edi"				CALL SUB OutFcnCodeData				OutBuf="add eax,!CommStatusOffs"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrClearCommError).ImportFcnUse=TRUE				OutBuf="invoke ClearCommError, dword [edi+!HandleOffs],CommError,eax"				CALL SUB OutFcnCodeData				OutBuf="mov edi,[!SourceGUIDesc]"				CALL SUB OutFcnCodeData				CALL SUB GetIntTmp				ErrRet				OutBuf="mov eax,[edi+!cbInQueOffs]"				CALL SUB OutFcnCodeData				CALL SUB StoreD0Tmp				GUITempName=TempStr				GUIDataType=LONGVAR			CASE "input"				ediUsed=TRUE				IF CmpOpFlag=FALSE THEN					TempStr="_IOBuffer"				ELSE					TempStr="_PrintBuf"				END IF				ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE				OutBuf="invoke ReadFile, dword [edi+!HandleOffs],["+TempStr+"],1,XferCount,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus				OutBuf="mov ["+TempStr+"+13],0"				CALL SUB OutFcnCodeData				OutBuf="mov edi,[!TargetGUIDesc]"				CALL SUB OutFcnCodeData				GUITempName=TempStr				GUIDataType=STRINGVAR			CASE "inputbuffer"				ediUsed=TRUE				IF CmpOpFlag=FALSE THEN					TempStr="_IOBuffer"				ELSE					TempStr="_PrintBuf"				END IF				OutBuf="mov [XferCount],0"				CALL SUB OutFcnCodeData				OutBuf="mov eax,edi"				CALL SUB OutFcnCodeData				OutBuf="add eax,!CommStatusOffs"				CALL SUB OutFcnCodeData				ImportFcnTable(ptrClearCommError).ImportFcnUse=TRUE				OutBuf="invoke ClearCommError, dword [edi+!HandleOffs],CommError,eax"				CALL SUB OutFcnCodeData				OutBuf="mov edi,[!SourceGUIDesc]"				CALL SUB OutFcnCodeData				OutBuf="mov eax,[edi+!cbInQueOffs]"				CALL SUB OutFcnCodeData				INCR LabelNum				OutBuf="cmp eax,0"				CALL SUB OutFcnCodeData				OutBuf="mov ["+TempStr+"+12],0"				CALL SUB OutFcnCodeData				OutBuf="je "+"_Lbl"+STR(LabelNum)				CALL SUB OutFcnCodeData				ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE				OutBuf="invoke ReadFile, dword [edi+!HandleOffs],["+TempStr+"],eax,XferCount,0"				CALL SUB OutFcnCodeData				CALL SUB SetStatus				OutBuf="mov eax,"+TempStr+"+13"				CALL SUB OutFcnCodeData				OutBuf="add eax,[XferCount]"				CALL SUB OutFcnCodeData				OutBuf="mov byte [eax],0"				CALL SUB OutFcnCodeData				OutBuf="_Lbl"+STR(LabelNum)+":"				CALL SUB OutFcnCodeData				GUITempName=TempStr				GUIDataType=STRINGVAR			CASE ELSE				ErrNo=ErrSyntax		END SELECT		EXIT SUB	END IF	IF ObjectType=OBZIP THEN		OutBuf="mov [!SourceGUIDesc],edi"		CALL SUB OutFcnCodeData		CALL SUB NexToken		IF TokenBuf<>"." THEN			ErrNo=ErrSyntax			EXIT SUB		END IF		CALL SUB NexToken		SELECT CASE TokenBuf			CASE "totalfiles"				ediUsed=TRUE				CALL SUB GetIntTmp				ErrRet				GUITempName=SymTemp.SymName				GUIDataType=LONGVAR				ImportFcnTable(ptrzGetTotalFiles).ImportFcnUse=TRUE				OutBuf="invoke zGetTotalFiles"				CALL SUB OutFcnCodeData				CALL SUB StoreD0Tmp			CASE "totalbytes"				ediUsed=TRUE				CALL SUB GetIntTmp				ErrRet				GUITempName=SymTemp.SymName				GUIDataType=LONGVAR				ImportFcnTable(ptrzGetTotalBytes).ImportFcnUse=TRUE				OutBuf="invoke zGetTotalBytes"				CALL SUB OutFcnCodeData				CALL SUB StoreD0Tmp			CASE "selectedfiles"				ediUsed=TRUE				CALL SUB GetIntTmp				ErrRet				GUITempName=SymTemp.SymName				GUIDataType=LONGVAR				ImportFcnTable(ptrzGetSelectedFiles).ImportFcnUse=TRUE				OutBuf="invoke zGetSelectedFiles"				CALL SUB OutFcnCodeData				CALL SUB StoreD0Tmp			CASE "selectedbytes"				ediUsed=TRUE				CALL SUB GetIntTmp				ErrRet				GUITempName=SymTemp.SymName				GUIDataType=LONGVAR				ImportFcnTable(ptrzGetSelectedBytes).ImportFcnUse=TRUE				OutBuf="invoke zGetSelectedBytes"				CALL SUB OutFcnCodeData				CALL SUB StoreD0Tmp			CASE "skippedfiles"				ediUsed=TRUE				CALL SUB GetIntTmp				ErrRet				GUITempName=SymTemp.SymName				GUIDataType=LONGVAR				ImportFcnTable(ptrzGetSkippedFiles).ImportFcnUse=TRUE				OutBuf="invoke zGetSkippedFiles"				CALL SUB OutFcnCodeData				CALL SUB StoreD0Tmp			CASE "filename"						CASE "fileext"						CASE "filepath"						CASE "filedate"						CASE "filetime"						CASE "filesize"									CASE "compressedfilesize"						CASE ELSE				ErrNo=ErrSyntax		END SELECT		EXIT SUB	END IF	CALL SUB NexToken	IF TokenBuf<>"." THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	CALL SUB NexToken	ObjectTypeSafe=ObjectType-99	SETVECTOR PropArray=[ObjTable(ObjectTypeSafe).ObjPropTable]	I=0	BEGIN LOOP		INCR I		IF PropArray(I).PropName="%" THEN			ErrNo=ErrIVProp			EXIT SUB		END IF			IF PropArray(I).PropName=TokenBuf THEN			CALL SUB [PropArray(I).PropGet]			GUIDataType=PropArray(I).PropDataType			EXIT SUB		END IF	END LOOPEND SUBBEGIN SUB pgMinimized	GUIFcnName="IsIconic"	ImportFcnTable(ptrIsIconic).ImportFcnUse=TRUE	CALL SUB GetWindowStateEND SUBBEGIN SUB pgEnabled	GUIFcnName="IsWindowEnabled"	ImportFcnTable(ptrIsWindowEnabled).ImportFcnUse=TRUE	CALL SUB GetWindowStateEND SUBBEGIN SUB pgVisible	GUIFcnName="IsWindowVisible"	ImportFcnTable(ptrIsWindowVisible).ImportFcnUse=TRUE	CALL SUB GetWindowStateEND SUBBEGIN SUB GetWindowState	ediUsed=TRUE	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke "+GUIFcnName+", dword ["+HandleName+"]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgCreated	ediUsed=TRUE	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+StatusOffs]"	CALL SUB OutFcnCodeData	OutBuf="and eax,1"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psRAEditReadOnly	EqualRet	CALL SUB GetBoolOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,REM_READONLY, dword ["+HandleName+"],0,eax"	CALL SUB OutFcnCodeData	END SUBBEGIN SUB psVisible	GUIFcnName="ShowWindow"	ImportFcnTable(ptrShowWindow).ImportFcnUse=TRUE	CALL SUB SetWindowStateEND SUBBEGIN SUB psEnabled	GUIFcnName="EnableWindow"	ImportFcnTable(ptrEnableWindow).ImportFcnUse=TRUE	CALL SUB SetWindowStateEND SUBBEGIN SUB psFlashWindow	GUIFcnName="FlashWindow"	ImportFcnTable(ptrFlashWindow).ImportFcnUse=TRUE	CALL SUB SetWindowStateEND SUBBEGIN SUB SetWindowState	EqualRet	CALL SUB GetBoolOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke "+GUIFcnName+", dword ["+HandleName+"],eax"	CALL SUB OutFcnCodeDataEND SUB BEGIN SUB pgCanUndo	GUIFcnName="EM_CANUNDO"	CALL SUB CanDoEND SUBBEGIN SUB pgCanReDo	GUIFcnName="EM_CANREDO"	CALL SUB CanDoEND SUBBEGIN SUB CanDo	ediUsed=TRUE	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgCanPaste	ediUsed=TRUE	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANPASTE,CF_TEXT,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgBackColor	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+BackColorOffs]"	CALL SUB OutFcnCodeData	OutBuf="cmp eax,$ffffffff"	CALL SUB OutFcnCodeData	INCR GUILabelNum	OutBuf="jne !HaveBackColor"+STR(GUILabelNum)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrGetDC).ImportFcnUse=TRUE	OutBuf="invoke GetDC, dword [edi]"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+HDCOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!SourceGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="invoke GetPixel,eax,3,3"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!SourceGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="mov [edi+BackColorOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="!HaveBackColor"+STR(GUILabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[edi+BackColorOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psSliderBackColor	TempBool=TRUE	CALL SUB psBackColor1END SUBBEGIN SUB psBackColor	TempBool=FALSE	CALL SUB psBackColor1END SUBBEGIN SUB psBackColor1	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="bts dword [edi+StatusOffs],WinChangeBackColor"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+BackColorOffs],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	IF TempBool=FALSE THEN		ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE		OutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"	ELSE		ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE		OutBuf="invoke SetFocus, dword ["+HandleName+"]"	END IF	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psMCBackColor	GUIFcnName="MCSC_BACKGROUND"	CALL SUB psMCColorEND SUBBEGIN SUB psMCTextColor	GUIFcnName="MCSC_TEXT"	CALL SUB psMCColorEND SUBBEGIN SUB psMCMonthBackColor	GUIFcnName="MCSC_MONTHBK"	CALL SUB psMCColorEND SUBBEGIN SUB psMCTitleBackColor	GUIFcnName="MCSC_TITLEBK"	CALL SUB psMCColorEND SUBBEGIN SUB psMCTitleForeColor	GUIFcnName="MCSC_TITLETEXT"	CALL SUB psMCColorEND SUBBEGIN SUB psMCTrailingTextColor	GUIFcnName="MCSC_TRAILINGTEXT"	CALL SUB psMCColorEND SUBBEGIN SUB psMCColor	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke SendMessage, dword ["+HandleName+"],MCM_SETCOLOR,"+GUIFcnName+",eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psButtonExBackColor	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBKGRCOL_IN,[_ArgSafe0],0"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBKGRCOL_OUT,[_ArgSafe0],0"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBKGRCOL_FOCUS,[_ArgSafe0],0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psButtonExForeColor	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETTEXTCOL_IN,[_ArgSafe0],0"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETTEXTCOL_OUT,[_ArgSafe0],0"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETTEXTCOL_FOCUS,[_ArgSafe0],0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psButtonExBitmap	EqualRet	CALL SUB GetIntOp	ErrRet	;IF TSubType<>BITMAP THEN	;	ErrNo=ErrIVType	;	RETURN	;END IF	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrRet	;IF TSubType<>BITMAP THEN	;	ErrNo=ErrIVType	;	RETURN	;END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],BTNEXM_SETBITMAP,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psButtonExStyle	EqualRet	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "normal"			TempStr="BTNEXM_SETNORMAL"		CASE "flat"			TempStr="BTNEXM_SETFLAT"		CASE "xpbutton"			TempStr="BTNEXM_SETXPBUTTON"		CASE "default"			TempStr="BTNEXM_SETDEFAULT"		CASE "checkbox"			TempStr="BTNEXM_SETXPCHECKBOX"		CASE "flatcheckbox"			TempStr="BTNEXM_SETFLATCHECKBOX"	END SELECT	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+TempStr+",0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psFormBackColor	EqualRet	OutBuf="invoke DeleteObject,dword [edi+ControlBrushOffs]"	CALL SUB OutFcnCodeData	CALL SUB GetIntOp	ErrRet	OutBuf="mov dword [edi+BackColorOffs],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	ImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUE	OutBuf="invoke CreateSolidBrush,eax"	CALL SUB OutFcnCodeData	OutBuf="mov [edi+ControlBrushOffs],eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetClassLong).ImportFcnUse=TRUE	OutBuf="invoke SetClassLong, dword ["+HandleName+"],GCL_HBRBACKGROUND,eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrUpdateWindow).ImportFcnUse=TRUE	OutBuf="invoke UpdateWindow, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psFamily	EqualRet	CALL SUB NexToken	IF TokenBuf="none" THEN		OutBuf="xor eax,eax"	ELSE		SymTemp.SymName=TokenSaf		CALL SUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			EXIT SUB		END IF		SymTemp=SymTable(SymNdx)		IF SymTemp.DataType<>FAMILY THEN			ErrNo=ErrIVProp			EXIT SUB		END IF		OutBuf="mov eax,"+STR(SymTable(SymNdx).Detail)	END IF	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+FamilyOffs],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgSBBackColor	ediUsed=TRUE	; To DoEND SUBBEGIN SUB pfSetParts	CALL SUB GetIntOp	ErrRet	CommaRet	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	IF SymTable(SymNdx).DataType<>LONGVAR OR SymTable(SymNdx).DataMod<>ArrayBit THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETPARTS,eax,"+TokenSaf	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetMonthCalSel	GUIFcnName="MCM_SETCURSEL"	CALL SUB pfMonthCalSelEND SUBBEGIN SUB pfGetMonthCalSel	GUIFcnName="MCM_GETCURSEL"	CALL SUB pfMonthCalSelEND SUBBEGIN SUB pfMonthCalSel	CALL SUB NexToken	ArgStr=TokenSaf	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	IF LAND(SymTable(SymNdx).DataMod,DateTimeBit)=0 THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,"+ArgStr	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetSBToolTip	GUIFcnName="SB_SETTIPTEXT"	CALL SUB SetSBTextEND SUBBEGIN SUB pfSetSBText	GUIFcnName="SB_SETTEXT"	CALL SUB SetSBTextEND SUBBEGIN SUB SetSBText	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CommaRet	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",eax,["+Op2Name+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psStyle	EqualRet	StyleCode=0	TempInt=0	SETVECTOR StyleArray=[ObjTable(ObjectTypeSafe).ObjStyleTable]	BEGIN LOOP		CALL SUB NexToken		EXIT IF TokenLen=0		IF TokenBuf<>"+" THEN			TempStr=TokenBuf			CALL SUB FindStyle			ErrRet			StyleCode=StyleCode+StyleArray(I).StyleValue			INCR TempInt		END IF	END LOOP	IF TempInt=0 THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	OutBuf="mov eax,$"+HEX$(StyleCode)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_STYLE,eax"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psGridBackColor	GUIFcnName="GM_SETBACKCOLOR"	ArgStr="BackColorOffs"	CALL SUB SetRAGridColorEND SUBBEGIN SUB psGridForeColor	GUIFcnName="GM_SETTEXTCOLOR"	ArgStr="ForeColorOffs"	CALL SUB SetRAGridColorEND SUBBEGIN SUB psGridGridColor	GUIFcnName="GM_SETGRIDCOLOR"	ArgStr="GridColorOffs"	CALL SUB SetRAGridColorEND SUBBEGIN SUB SetRAGridColor	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+"+ArgStr+"],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgForeColor	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+ForeColorOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psForeColor	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="bts dword [edi+StatusOffs],WinChangeForeColor"	CALL SUB OutFcnCodeData	OutBuf="mov dword [edi+ForeColorOffs],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgStatus	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+StatusOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgHDC	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+HDCOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgAddress	CALL SUB GetIntTmp	ErrRet	OutBuf="mov eax,edi"	CALL SUB OutFcnCodeData	OutBuf="add eax,768"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psInterceptOn	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_WNDPROC,dword [edi+InterceptProcOffs]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psInterceptOff	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_WNDPROC,dword [edi+InterceptSafeOffs]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgID	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+IDOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgHandle	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+HandleOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgLeft	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+LeftOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgTop	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+TopOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgWidth	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+WidthOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgHeight	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+HeightOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgRight	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+RightOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgBottom	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+BottomOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psLeft	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+LeftOffs],eax"; Left	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUE	OutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,dword [edi+LeftOffs],dword [edi+TopOffs],0,0,SWP_NOZORDER+SWP_NOSIZE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psTop	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+TopOffs],eax"; Top	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUE	OutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,dword [edi+LeftOffs],dword [edi+TopOffs],0,0,SWP_NOZORDER+SWP_NOSIZE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psWidth	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+WidthOffs],eax"; Width	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUE	OutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,0,0,dword [edi+WidthOffs],dword [edi+HeightOffs],SWP_NOZORDER+SWP_NOMOVE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psHeight	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+HeightOffs],eax"; Height	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUE	OutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,0,0,dword [edi+WidthOffs],dword [edi+HeightOffs],SWP_NOZORDER+SWP_NOMOVE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psRight	;END SUBBEGIN SUB psBottom	;END SUBBEGIN SUB pfBringToFront	CALL SUB ediUsedCheck	ImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUE	OutBuf="invoke SetWindowPos,dword ["+HandleName+"],HWND_TOPMOST,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUE	OutBuf="invoke InvalidateRect,dword[edi+HandleOffs],NULL,TRUE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVSetHeaderText	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ColpszText],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ColcchTextMax],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_Colmask],LVCF_TEXT"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],LVM_SETCOLUMN,[_ArgSafe0],!LV_Colmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVSetImage	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [!LV_ItemiItem],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_Itemmask],LVIF_IMAGE"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB NexToken	SymTemp.SymName=TokenSaf	ArgStr=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	IF SymTable(SymNdx).SubType<>IMAGELIST THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],LVM_SETIMAGELIST,LVSIL_SMALL,["+ArgStr+"]"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [!LV_ItemiImage],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ItemiSubItem],0"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],LVM_SETITEM,0,!LV_Itemmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVSetText	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [!LV_ItemiSubItem],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ItempszText],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ItemcchTextMax],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_Itemmask],LVIF_TEXT"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],LVM_SETITEMTEXT,[_ArgSafe0],!LV_Itemmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVSetColWidth	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],LVM_SETCOLUMNWIDTH,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVAddItem	OutBuf="invoke SendMessage, dword ["+HandleName+"],LVM_GETITEMCOUNT,0,0"	CALL SUB OutFcnCodeData	TempBool=TRUE	CALL SUB LVInsertEND SUBBEGIN SUB pfLVInsertItem	TempBool=FALSE	CALL SUB LVInsertEND SUBBEGIN SUB LVInsert	IF TempBool=FALSE THEN		CALL SUB GetIntOp		ErrRet		DecArrayNdx		OutBuf="mov [!LV_ItemiItem],eax"		CALL SUB OutFcnCodeData		CommaRet	ELSE		OutBuf="mov [!LV_ItemiItem],eax"		CALL SUB OutFcnCodeData	END IF	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ItempszText],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ItemcchTextMax],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_Itemmask],LVIF_TEXT"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],LVM_INSERTITEM,0,!LV_Itemmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVAddCol	TempBool=TRUE	CALL SUB LVColEND SUBBEGIN SUB pfLVInsertCol	TempBool=FALSE	CALL SUB LVColEND SUBBEGIN SUB LVCol	IF TempBool=FALSE THEN		CALL SUB GetIntOp		ErrRet		DecArrayNdx		OutBuf="mov [_ArgSafe0],eax"		CALL SUB OutFcnCodeData		CommaRet	ELSE		OutBuf="mov [_ArgSafe0],$ffff"		CALL SUB OutFcnCodeData	END IF	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ColpszText],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_ColcchTextMax],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!LV_Colcx],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!LV_Colmask],LVCF_TEXT+LVCF_WIDTH+LVCF_FMT"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "left"			TempStr="0"		CASE "right"			TempStr="1"		CASE "center"			TempStr="2"		CASE ELSE			ErrNo=ErrSyntax			EXIT SUB	END SELECT	OutBuf="mov [!LV_Colfmt],"+TempStr	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],LVM_INSERTCOLUMN,[_ArgSafe0],!LV_Colmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfAddTabItem	TempBool=TRUE	CALL TFItemEND SUBBEGIN SUB pfInsertTabItem	TempBool=FALSE	CALL TFItemEND SUBBEGIN SUB TFItem	IF TempBool=FALSE THEN		CALL SUB GetIntOp		ErrRet		DecArrayNdx		OutBuf="mov [_ArgSafe0],eax"		CALL SUB OutFcnCodeData		CommaRet	ELSE		OutBuf="mov [_ArgSafe0],$ffff"		CALL SUB OutFcnCodeData	END IF	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMText],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMTextMax],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMmask],TCIF_TEXT"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],TCM_INSERTITEM,[_ArgSafe0],!TC_ITEMmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfDeleteTabItem	CALL SUB ediUsedCheck	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="invoke SendMessage,dword ["+HandleName+"],TCM_DELETEITEM,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgTabSelect	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_GETCURSEL,0,0"	CALL SUB OutFcnCodeData	IncArrayNdx	CALL SUB StoreD0TmpEND SUBBEGIN SUB psTabSelect	EqualRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETCURSEL,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psRAEditLineNumberWidth	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_LINENUMBERWIDTH,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetItemSize	CALL SUB GetIntOp	ErrRet	OutBuf="mov ecx,eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	OutBuf="shl eax,16"	CALL SUB OutFcnCodeData	OutBuf="or eax,ecx"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETITEMSIZE,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgChecked	ediUsed=TRUE	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_GETCHECK,0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psPushed	EqualRet	CALL SUB GetBoolOp	ErrRet	CALL SUB ediUsedCheck		OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETSTATE,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psChecked	EqualRet	CALL SUB GetBoolOp	ErrRet	CALL SUB ediUsedCheck		OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETCHECK,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridAddCol	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "text"			OutBuf="mov [gc_ctype],TYPE_EDITTEXT"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			ErrRet			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "combo"			OutBuf="mov [gc_ctype],TYPE_COMBOBOX"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "check"			OutBuf="mov [gc_ctype],TYPE_CHECKBOX"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "long"			OutBuf="mov [gc_ctype],TYPE_EDITLONG"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "hotkey"			OutBuf="mov [gc_ctype],TYPE_HOTKEY"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "button"			OutBuf="mov [gc_ctype],TYPE_BUTTON"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "image"			OutBuf="mov [gc_ctype],TYPE_IMAGE"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "date"			OutBuf="mov [gc_ctype],TYPE_DATE"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE "time"			OutBuf="mov [gc_ctype],TYPE_TIME"			CALL SUB OutFcnCodeData			CALL SUB AddColCommon			OutBuf="mov [gc_lpszformat],0"			CALL SUB OutFcnCodeData		CASE ELSE			ErrNo=ErrSyntax			EXIT SUB	END SELECT	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],GM_ADDCOL,0,gc_colwt"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB AddColCommon	CommaRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [gc_colwt],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [gc_lpszhdrtext],eax"	CALL SUB OutFcnCodeData	CALL SUB GetColAlignment	ErrRet	OutBuf="mov [gc_halign],"+TempStr	CALL SUB OutFcnCodeData	CALL SUB GetColAlignment	ErrRet	OutBuf="mov [gc_calign],"+TempStr	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [gc_ctextmax],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetColAlignment	CommaRet	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "left"			TempStr="GA_ALIGN_LEFT"		CASE "center"			TempStr="GA_ALIGN_CENTER"		CASE "right"			TempStr="GA_ALIGN_RIGHT"		CASE ELSE			ErrNo=ErrSyntax			EXIT SUB	END SELECTEND SUBBEGIN SUB pfGridAddRow	OutBuf="invoke SendMessage,dword ["+HandleName+"],GM_ADDROW,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfUnDo	OutBuf="invoke SendMessage,dword ["+HandleName+"],EM_UNDO,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfReDo	OutBuf="invoke SendMessage,dword ["+HandleName+"],EM_REDO,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfPaste	OutBuf="invoke SendMessage,dword ["+HandleName+"],WM_PASTE,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfEmptyUndoBuffer	OutBuf="invoke SendMessage,dword ["+HandleName+"],EM_EMPTYUNDOBUFFER,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfCut	OutBuf="invoke SendMessage,dword ["+HandleName+"],WM_CUT,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfCopy	OutBuf="invoke SendMessage,dword ["+HandleName+"],WM_COPY,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psHeaderHeight	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],GM_SETHDRHEIGHT,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psRowHeight	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage,dword ["+HandleName+"],GM_SETROWHEIGHT,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridComboClear	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="invoke SendMessage,dword ["+HandleName+"],GM_COMBOCLEAR,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridClear	OutBuf="invoke SendMessage,dword ["+HandleName+"],GM_RESETCONTENT,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridSort	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CommaRet	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "ascending"			TempStr="0"		CASE "descending"			TempStr="1"		CASE "inverting"			TempStr="2"		CASE ELSE			ErrNo=ErrSyntax			EXIT SUB	END SELECT	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_COLUMNSORT,eax,"+TempStr	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridDeleteRow	CALL SUB GetIntOp	ErrRet	OutBuf="push eax"	CALL SUB OutFcnCodeData	DecArrayNdx	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_DELROW,eax,0"	CALL SUB OutFcnCodeData	OutBuf="pop eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURSEL,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridInsertRow	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_INSROW,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgHiLiteLine	;END SUBBEGIN SUB pfSetHiLiteLine	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="push eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="pop ebx"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETHILITELINE,ebx,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfRAEditGoto	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_LINEINDEX,eax,0"	CALL SUB OutFcnCodeData	OutBuf="mov [EditcpMin],eax"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen>0 THEN		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			EXIT SUB		END IF		CALL SUB GetIntOp		ErrRet		OutBuf="add eax,[EditcpMin]"		CALL SUB OutFcnCodeData	END IF	OutBuf="mov [EditcpMax],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_EXSETSEL,0,EditcpMin"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE	OutBuf="invoke SetFocus, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psRAEditBCKCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_BCKCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditTXTCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_TXTCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditSELBCKCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_SELBCKCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditSELTXTCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_SELTXTCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditCMNTCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_CMNTCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditSTRCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_STRCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditOPRCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_OPRCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditHILITE1	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_HILITE1],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditHILITE2	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_HILITE2],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditHILITE3	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_HILITE3],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditSELBARCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_BARCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditSELBARPEN	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_SELBARPEN],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditLNRCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_LNRCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB psRAEditNUMCOLOR	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [!RA_NUMCOLOR],eax"	CALL SUB OutFcnCodeData	CALL SUB SetRAEditColorsEND SUBBEGIN SUB SetRAEditColors	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETCOLOR,0,!RA_BCKCOLOR"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetHiliteWords	CALL SUB GetStringOp	ErrRet	VSymName=TSymName	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETHILITEWORDS,eax,["+VSymName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetRAFont	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	IF SymTable(SymNdx).SubType<>FONT THEN		ErrNo=ErrTypMis		EXIT SUB	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETFONT,0,"+TokenSaf	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfFind	OutBuf="mov [STATUS],0"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],6"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="mov eax,[fr_lpstrFindWhat]"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchTextPtr],eax"	CALL SUB OutFcnCodeData	OutBuf="xor ebx,ebx"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],0"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jnc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="or ebx,FR_DOWN"	CALL SUB OutFcnCodeData	OutBuf="mov ecx,[EditcpMax]"	CALL SUB OutFcnCodeData	OutBuf="dec ecx"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMin],ecx"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMax],$ffffffff"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jmp "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum-1)+":"	CALL SUB OutFcnCodeData	OutBuf="mov ecx,[EditcpMin]"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMin],ecx"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMax],0"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],1"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jnc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="or ebx,FR_WHOLEWORD"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],2"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jnc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="or ebx,FR_MATCHCASE"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="mov edi,!Edit"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_FINDTEXTEX,ebx,ft_SearchMin"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	OutBuf="cmp eax,$ffffffff"	CALL SUB OutFcnCodeData	OutBuf="je "+"_Lbl"+STR(LabelNum-4)	CALL SUB OutFcnCodeData	OutBuf="mov ebx,[ft_FoundMin]"	CALL SUB OutFcnCodeData	OutBuf="mov eax,[ft_FoundMax]"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE	OutBuf="invoke SetFocus, dword ["+HandleName+"]"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum-4)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSearch	OutBuf="mov [STATUS],0"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],6"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="mov eax,[fr_lpstrFindWhat]"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchTextPtr],eax"	CALL SUB OutFcnCodeData	OutBuf="xor ebx,ebx"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],0"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jnc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="or ebx,FR_DOWN"	CALL SUB OutFcnCodeData	OutBuf="mov ecx,[EditcpMax]"	CALL SUB OutFcnCodeData	OutBuf="dec ecx"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMin],ecx"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMax],$ffffffff"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jmp "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum-1)+":"	CALL SUB OutFcnCodeData	OutBuf="mov ecx,[EditcpMin]"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMin],ecx"	CALL SUB OutFcnCodeData	OutBuf="mov [ft_SearchMax],0"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],1"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jnc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="or ebx,FR_WHOLEWORD"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="bt [FLAGS],2"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jnc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="or ebx,FR_MATCHCASE"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="mov edi,!Edit"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_FINDTEXTEX,ebx,ft_SearchMin"	CALL SUB OutFcnCodeData	CALL SUB SetStatus	OutBuf="invoke SetFocus, dword ["+HandleName+"]"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum-4)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetDividerLine	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetBoolOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETDIVIDERLINE,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSelectAll	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,0,-1"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE	OutBuf="invoke SetFocus, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetFocus	CALL SUB ediUsedCheck	ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE	OutBuf="invoke SetFocus, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psCursorPos	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,eax,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgCursorPos	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSEL,"+GUITempName+",0"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+GUITempName+"]"	CALL SUB OutFcnCodeData	IncArrayNdx	CALL SUB StoreD0TmpEND SUBBEGIN SUB pfGetSel	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSEL,EditcpMin,EditcpMax"	CALL SUB OutFcnCodeData	IncArrayNdx	CALL SUB StoreD0TmpEND SUBBEGIN SUB pfSetSel	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="push eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="pop ebx"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetFocus).ImportFcnUse=TRUE	OutBuf="invoke SetFocus, dword ["+HandleName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridMoveRow	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov ebx,eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_MOVEROW,ebx,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgLine	ediUsed=TRUE	CALL SUB GetItemNumber	ErrRet	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="mov [_IOBuffer+12],_BufSize"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETLINE,eax,["+TempStr+"]"	CALL SUB OutFcnCodeData	OutBuf="mov ebx,_IOBuffer+12"	CALL SUB OutFcnCodeData	OutBuf="add ebx,eax"	CALL SUB OutFcnCodeData	OutBuf="mov byte [ebx],0"	CALL SUB OutFcnCodeData	GUITempName=TempStrEND SUBBEGIN SUB pgText	ediUsed=TRUE	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXT,_BufSize,["+TempStr+"]"	CALL SUB OutFcnCodeData	GUITempName=TempStrEND SUBBEGIN SUB pgSelText	ediUsed=TRUE	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSELTEXT,0,["+TempStr+"]"	CALL SUB OutFcnCodeData	GUITempName=TempStrEND SUBBEGIN SUB pfInsertText	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,eax,eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfAppendText	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,-1,-1"	CALL SUB OutFcnCodeData	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfReplaceSel	CALL SUB GetStringOp	ErrRet	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfReplaceText	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="push eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="pop ebx"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetTabText	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetStringOp	ErrRet	OutBuf="mov eax,["+TSymName+"]"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMText],eax"	CALL SUB OutFcnCodeData	OutBuf="mov eax,["+TSymName+"+4]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMTextMax],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMmask],TCIF_TEXT"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETITEM,[_ArgSafe0],!TC_ITEMmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetTabImage	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMImage],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!TC_ITEMmask],TCIF_IMAGE"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB NexToken	SymTemp.SymName=TokenSaf	ArgStr=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	IF SymTable(SymNdx).SubType<>IMAGELIST THEN		ErrNo=ErrIVType		EXIT SUB	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETIMAGELIST,0,["+ArgStr+"]"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen<>0 THEN		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			EXIT SUB		ELSE			CALL SUB GetIntOp			ErrRet			DecArrayNdx			OutBuf="mov [!TC_ITEMImage],eax"			CALL SUB OutFcnCodeData		END IF	END IF	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],TCM_SETITEM,[_ArgSafe0],!TC_ITEMmask"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psToolTip	OutBuf="add edi,TTTextOffs"	CALL SUB OutFcnCodeData	EqualRet	CALL SUB GetStringOp	ErrRet	IF ediUsed=TRUE THEN		OutBuf="mov edi,[!TargetGUIDesc]"		CALL SUB OutFcnCodeData		OutBuf="add edi,TTTextOffs"		CALL SUB OutFcnCodeData	END IF	Op1Name=TSymName	CALL SUB GetTmpVec	Op2Name=TempStr	OutBuf="mov ["+TempStr+"],edi"	CALL SUB OutFcnCodeData	OutBuf="mov ["+TempStr+"+4],99"	CALL SUB OutFcnCodeData	OutBuf="mov ["+TempStr+"+8],0"	CALL SUB OutFcnCodeData	OutBuf="mov edi,"+Op2Name	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+Op1Name	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="mov eax,edi"	CALL SUB OutFcnCodeData	OutBuf="add eax,TTcbSizeOffs"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="bts dword [edi+StatusOffs],WinTipExists"	CALL SUB OutFcnCodeData	OutBuf="jc "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, [!ToolTip],TTM_ADDTOOL,0,eax"	CALL SUB OutFcnCodeData	INCR LabelNum	OutBuf="jmp "+"_Lbl"+STR(LabelNum)	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum-1)+":"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, [!ToolTip],TTM_UPDATETIPTEXT,0,eax"	CALL SUB OutFcnCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psWBNavigate	GUIFcnName="WBM_NAVIGATE"	CALL SUB psTextCommonEND SUBBEGIN SUB psText	GUIFcnName="WM_SETTEXT"	CALL SUB psTextCommonEND SUB	BEGIN SUB psTextCommon	EqualRet	CALL SUB GUIStringPrep	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,[_IOBuffer]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GUIStringPrep	ediUsed=TRUE	CALL SUB GetStringOp	ErrRet	OutBuf="mov edi,_IOBuffer"	CALL SUB OutFcnCodeData	OutBuf="mov esi,"+TSymName	CALL SUB OutFcnCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psIcon	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>ICON THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETICON,ICON_BIG,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psButtonBitmap	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>BITMAP THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETIMAGE,IMAGE_BITMAP,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psStaticBitmap	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>BITMAP THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],STM_SETIMAGE,IMAGE_BITMAP,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psButtonIcon	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>ICON THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETIMAGE,IMAGE_ICON,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psSTIcon	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>ICON THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],STM_SETIMAGE,1,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetSBIcon	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>ICON THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETICON,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetGridRowColor	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [rc_backcolor],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [rc_textcolor],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETROWCOLOR,[_ArgSafe0],rc_backcolor"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psFont	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>FONT THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETFONT,eax,1"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgGridText	ediUsed=TRUE	CALL SUB GetRC	ErrRet	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_CELLCONVERT,ebx,["+TempStr+"]"	CALL SUB OutFcnCodeData	GUITempName=TempStrEND SUBBEGIN SUB psGridText	CALL SUB GetRC	ErrRet	EqualRet	CALL SUB GUIStringPrep	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,[_IOBuffer]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridEndEdit	CALL SUB GetRC	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_ENDEDIT,ebx,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgHeaderText	ediUsed=TRUE	CALL SUB GetColumn	ErrRet	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETHDRTEXT,ebx,["+TempStr+"]"	CALL SUB OutFcnCodeData	GUITempName=TempStr	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psHeaderText	CALL SUB GetColumn	ErrRet	EqualRet	CALL SUB GUIStringPrep	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETHDRTEXT,ebx,[_IOBuffer]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfGridComboAddItem	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="push eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="pop eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_COMBOADDSTRING,eax,["+TSymName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psGridValue	CALL SUB GetRC	ErrRet	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [_ArgSafe1],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,_ArgSafe1"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgGridValue	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	CALL SUB GetRC	ErrRet	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETCELLDATA,ebx,"+GUITempName	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB GetColumn	CALL SUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	IgnoreRightParen=$ff	GUIObjFlag=0	CALL SUB GetGUINdx	ErrRet	DecArrayNdx	OutBuf="mov ebx,eax"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenBuf<>")" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	IgnoreRightParen=0END SUBBEGIN SUB GetItemNumber	IgnoreRightParen=$ff	CALL SUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	GUIObjFlag=0	CALL SUB GetGUINdx	ErrRet	DecArrayNdx	CALL SUB NexToken	IF TokenBuf<>")" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	IgnoreRightParen=0END SUBBEGIN SUB GetRC	CALL SUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	GUIObjFlag=0	CALL SUB GetGUINdx	ErrRet	DecArrayNdx	CommaRet	OutBuf="mov ebx,eax"	CALL SUB OutFcnCodeData	OutBuf="shl ebx,16"	CALL SUB OutFcnCodeData	IgnoreRightParen=$ff	CALL SUB GetGUINdx	ErrRet	DecArrayNdx	OutBuf="or ebx,eax"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenBuf<>")" THEN		ErrNo=ErrSyntax		EXIT SUB	END IF	IgnoreRightParen=0END SUBBEGIN SUB pfRAEditLoadFile	CALL SUB GetStringOp	ErrRet	ImportFcnTable(ptrCreateFile).ImportFcnUse=TRUE	OutBuf="invoke CreateFile,["+TSymName+"],GENERIC_READ,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0"	CALL SUB OutFcnCodeData	OutBuf="mov [!FileHandle],eax"	CALL SUB OutFcnCodeData	OutBuf="cmp eax,-1"	CALL SUB OutFcnCodeData	INCR OELabelNum	OutBuf="jg _OELbl"+STR(OELabelNum)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrGetLastError).ImportFcnUse=TRUE	OutBuf="invoke GetLastError"	CALL SUB OutFcnCodeData	OutBuf="mov [err],eax"	CALL SUB OutFcnCodeData	OutBuf="jmp [_ErrVec]"	CALL SUB OutFcnCodeData	OutBuf="_OELbl"+STR(OELabelNum)+":"	CALL SUB OutFcnCodeData	CALL SUB NexToken	IF TokenLen>0 THEN		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			EXIT SUB		END IF		CALL SUB GetIntOp		ErrRet		OutBuf="Mov [_ArgSafe0],eax"	ELSE		OutBuf="Mov [_ArgSafe0],0"	END IF	CALL SUB OutFcnCodeData	ImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUE	OutBuf="invoke GetFileSize,[!FileHandle],0"	CALL SUB OutFcnCodeData	OutBuf="sub eax,[_ArgSafe0]"	CALL SUB OutFcnCodeData	OutBuf="inc eax"	CALL SUB OutFcnCodeData	OutBuf="mov [!FilBufSiz],eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUE	OutBuf="invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE"	CALL SUB OutFcnCodeData	OutBuf="mov [!FilBufAdr],eax"	CALL SUB OutFcnCodeData	OutBuf="mov edx,[!FilBufSiz]"	CALL SUB OutFcnCodeData	OutBuf="add eax,edx"	CALL SUB OutFcnCodeData	OutBuf="dec eax"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE	OutBuf="invoke ReadFile,[!FileHandle],[!FilBufAdr],edx,!FilBufSiz,0"	CALL SUB OutFcnCodeData	OutBuf="cmp eax,0"	CALL SUB OutFcnCodeData	INCR OELabelNum	OutBuf="jne _OELbl"+STR(OELabelNum)	CALL SUB OutFcnCodeData	OutBuf="invoke GetLastError"	CALL SUB OutFcnCodeData	OutBuf="mov [err],eax"	CALL SUB OutFcnCodeData	OutBuf="jmp [_ErrVec]"	CALL SUB OutFcnCodeData	OutBuf="_OELbl"+STR(OELabelNum)+":"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUE	OutBuf="invoke CloseHandle,[!FileHandle]"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETTEXT,0,[!FilBufAdr]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUE	OutBuf="invoke  VirtualFree,[!FilBufAdr],0,MEM_RELEASE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfRAEditSaveFile	CALL SUB GetStringOp	ErrRet	ImportFcnTable(ptrCreateFile).ImportFcnUse=TRUE	OutBuf="invoke CreateFile,["+TSymName+"],GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0"	CALL SUB OutFcnCodeData	OutBuf="mov [!FileHandle],eax"	CALL SUB OutFcnCodeData	OutBuf="cmp eax,-1"	CALL SUB OutFcnCodeData	INCR OELabelNum	OutBuf="jg _OELbl"+STR(OELabelNum)	CALL SUB OutFcnCodeData	ImportFcnTable(ptrGetLastError).ImportFcnUse=TRUE	OutBuf="invoke GetLastError"	CALL SUB OutFcnCodeData	OutBuf="mov [err],eax"	CALL SUB OutFcnCodeData	OutBuf="jmp [_ErrVec]"	CALL SUB OutFcnCodeData	OutBuf="_OELbl"+STR(OELabelNum)+":"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXTLENGTH,0,0"	CALL SUB OutFcnCodeData	OutBuf="mov [!FilBufSiz],eax"	CALL SUB OutFcnCodeData	OutBuf="inc [!FilBufSiz]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUE	OutBuf="invoke  VirtualAlloc,0,[!FilBufSiz],MEM_COMMIT,PAGE_READWRITE"	CALL SUB OutFcnCodeData	OutBuf="mov [!FilBufAdr],eax"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXT,[!FilBufSiz],[!FilBufAdr]"	CALL SUB OutFcnCodeData	OutBuf="mov edi,[!TargetGUIDesc]"	CALL SUB OutFcnCodeData	OutBuf="dec [!FilBufSiz]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE	OutBuf="invoke WriteFile,[!FileHandle],[!FilBufAdr],[!FilBufSiz],!FilBufSiz,0"	CALL SUB OutFcnCodeData	OutBuf="cmp eax,0"	CALL SUB OutFcnCodeData	INCR OELabelNum	OutBuf="jne _OELbl"+STR(OELabelNum)	CALL SUB OutFcnCodeData	OutBuf="invoke GetLastError"	CALL SUB OutFcnCodeData	OutBuf="mov [err],eax"	CALL SUB OutFcnCodeData	OutBuf="jmp [_ErrVec]"	CALL SUB OutFcnCodeData	OutBuf="_OELbl"+STR(OELabelNum)+":"	CALL SUB OutFcnCodeData	;OutBuf="mov eax,[_CRLF]"	;CALL SUB OutFcnCodeData	;OutBuf="mov [_XferAddr],eax"	;CALL SUB OutFcnCodeData	;OutBuf="mov [XferCount],1"	;CALL SUB OutFcnCodeData	;OutBuf="invoke WriteFile,[!FileHandle],[_XferAddr],[XferCount],XferCount,0"	;CALL SUB OutFcnCodeData	ImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUE	OutBuf="invoke CloseHandle,[!FileHandle]"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUE	OutBuf="invoke  VirtualFree,[!FilBufAdr],0,MEM_RELEASE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgComboBoxSelText	GUIFcnName="CB_GETCURSEL"	ArgStr="CB_GETLBTEXT"	CALL SUB pgBoxSelTextEND SUBBEGIN SUB pgListBoxSelText	GUIFcnName="LB_GETCURSEL"	ArgStr="LB_GETTEXT"	CALL SUB pgBoxSelTextEND SUBBEGIN SUB pgBoxSelText	ediUsed=TRUE	OutBuf="push edi"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeData	OutBuf="pop edi"	CALL SUB OutFcnCodeData	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+ArgStr+",eax,["+TempStr+"]"	CALL SUB OutFcnCodeData	GUITempName=TempStrEND SUBBEGIN SUB pgComboBoxSelItem	GUIFcnName="CB_GETCURSEL"	CALL SUB pgBoxSelItemEND SUBBEGIN SUB pgListBoxSelItem	GUIFcnName="LB_GETCURSEL"	CALL SUB pgBoxSelItemEND SUBBEGIN SUB pgBoxSelItem	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeData	IncArrayNdx	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgListBoxItemCount	GUIFcnName="LB_GETCOUNT"	CALL SUB pgItemCountEND SUBBEGIN SUB pgComboBoxItemCount	GUIFcnName="CB_GETCOUNT"	CALL SUB pgItemCountEND SUBBEGIN SUB pgItemCount	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgGridRow	GUIFcnName="GM_GETCURROW"	CALL SUB pgGridRowColEND SUBBEGIN SUB pgGridCol	GUIFcnName="GM_GETCURCOL"	CALL SUB pgGridRowColEND SUBBEGIN SUB pgGridRowCol	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUITempName+",0,0"	CALL SUB OutFcnCodeData	IncArrayNdx	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgGridSel	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETCURSEL,0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psGridRow	EqualRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURROW,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psGridCol	EqualRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURCOL,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfScrollCell	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SCROLLCELL,0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psGridSelEND SUBBEGIN SUB pfGridEnterEdit	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="invoke SendMessage, dword ["+HandleName+"],GM_ENTEREDIT,eax,[_ArgSafe0]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgGridCols	GUIFcnName="GM_GETCOLCOUNT"	CALL SUB pgGridRowColEND SUBBEGIN SUB pgGridRows	GUIFcnName="GM_GETROWCOUNT"	CALL SUB pgGridRowColEND SUBBEGIN SUB pgGridRowsCols	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgListBoxTopItem	GUIFcnName="LB_GETTOPINDEX"	CALL SUB pgTopItemEND SUBBEGIN SUB pgComboBoxTopItem	GUIFcnName="CB_GETTOPINDEX"	CALL SUB pgTopItemEND SUBBEGIN SUB pgTopItem	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	CALL SUB OutFcnCodeData	IncArrayNdx	CALL SUB StoreD0TmpEND SUBBEGIN SUB psListBoxTopItem	GUIFcnName="LB_SETTOPINDEX"	CALL SUB psTopItemEND SUBBEGIN SUB psComboBoxTopItem	GUIFcnName="CB_SETTOPINDEX"	CALL SUB psTopItemEND SUBBEGIN SUB psTopItem	EqualRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psListBoxSelItem	GUIFcnName="LB_SETCURSEL"	CALL SUB psBoxSelItemEND SUBBEGIN SUB psComboBoxSelItem	GUIFcnName="CB_SETCURSEL"	CALL SUB psBoxSelItemEND SUBBEGIN SUB psBoxSelItem	EqualRet	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgTextLength	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXTLENGTH,0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psDPMaxValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],DP_INIT,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psSBBackColor	GUIFcnName="SB_SETBKCOLOR"	ArgStr="Back"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psRichEditBackColor	GUIFcnName="EM_SETBKGNDCOLOR"	ArgStr="Back"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psProgressBarBackColor	GUIFcnName="$2001"	ArgStr="Back"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psProgressBarForeColor	GUIFcnName="WM_USER+9"	ArgStr="Fore"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psTVBackColor	GUIFcnName="TVM_SETBKCOLOR"	ArgStr="Back"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psLVBackColor	GUIFcnName="LVM_SETBKCOLOR"	ArgStr="Back"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psLVForeColor	GUIFcnName="LVM_SETTEXTCOLOR"	ArgStr="Fore"	TempBool=TRUE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psTVForeColor	GUIFcnName="TVM_SETTEXTCOLOR"	ArgStr="Fore"	TempBool=FALSE	CALL SUB psBackColorCommonEND SUBBEGIN SUB psBackColorCommon	EqualRet	CALL SUB GetIntOp	ErrRet	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+"+ArgStr+"ColorOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,[_ArgSafe0]"	CALL SUB OutFcnCodeData	IF TempBool=FALSE THEN		OutBuf="invoke SendMessage, dword ["+HandleName+"],LVM_SETTEXTBKCOLOR,0,[_ArgSafe0]"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB psDPBackColor	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+BackColorOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],DP_COLORBKG,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psDPFont	EqualRet	CALL SUB GetIntOp	ErrRet	IF TSubType<>FONT THEN		ErrNo=ErrIVType		EXIT SUB	END IF	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],DP_FONT,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psDPText	EqualRet	CALL SUB GUIStringPrep	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],DP_TEXT,[_IOBuffer],0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psDPValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],DP_COUNT,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgScrollBarValue	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+ScrollBarPosOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pgSpinnerValue	GUIFcnName="UDM_GETPOS"	CALL SUB PgValueEND SUBBEGIN SUB pgSliderValue	GUIFcnName="TBM_GETPOS"	CALL SUB PgValueEND SUBBEGIN SUB PgValue	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psSliderPageValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_SETPAGESIZE,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgSliderPageValue	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_GETPAGESIZE,0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psScrollBarValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov [edi+ScrollBarPosOffs],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],SBM_SETPOS,eax,TRUE"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psPageValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov [edi+ScrollBarPageOffs],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgPageValue	ediUsed=TRUE	CALL SUB GetIntTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="mov eax,[edi+ScrollBarPageOffs]"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB psSpinnerValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],UDM_SETPOS32,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psSliderValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_SETPOS,TRUE,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSliderRange	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_SETRANGEMIN,0,eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_SETRANGEMAX,0,eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psSpinnerBuddy	EqualRet	CALL SUB NexToken	SymTemp.SymName=TokenSaf	CALL SUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		EXIT SUB	END IF	IF SymTable(SymNdx).DataType<100 THEN		ErrNo=ErrIVType		EXIT SUB	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],UDM_SETBUDDY,[!"+TokenSaf+"],0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetSpinnerRange	CALL SUB GetIntOp	ErrRet	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],UDM_SETRANGE32,[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfScrollBarRange	GUIFcnName="SBM_SETRANGE"	CALL SUB pfSetRangeEND SUBBEGIN SUB pfProgressBarRange	GUIFcnName="PBM_SETRANGE32"	CALL SUB pfSetRangeEND SUBBEGIN SUB pfSetRange	CALL SUB GetIntOp	ErrRet	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	OutBuf="mov [edi+ScrollBarMinOffs],eax"	CALL SUB OutFcnCodeData	CommaMain	CALL SUB GetIntOp	ErrRet	OutBuf="mov [edi+ScrollBarMaxOffs],eax"	CALL SUB OutFcnCodeData	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",[_ArgSafe0],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfSetCharTable	CALL SUB GetIntOp	ErrRet	CommaRet	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "none"			FcnName="CT_NONE"		CASE "char"			FcnName="CT_CHAR"		CASE "oper"			FcnName="CT_OPER"		CASE "hichar"			FcnName="CT_HICHAR"		CASE "cmntchar"			FcnName="CT_CMNTCHAR"		CASE "string"			FcnName="CT_STRING"		CASE "cmntdblchar"			FcnName="CT_CMNTDBLCHAR"		CASE ELSE			ErrNo=ErrSyntax			EXIT SUB	END SELECT	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETCHARTAB,eax,"+FcnName	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgProgressBarValueediUsed=TRUEEND SUBBEGIN SUB psProgressBarValue	EqualRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],PBM_SETPOS,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgInterval	ediUsed=TRUEEND SUBBEGIN SUB psIntervalEND SUBBEGIN SUB pfStopEND SUBBEGIN SUB pfListBoxAddSorted	GUIFcnName="LB_ADDSTRING"	CALL SUB pfAddSortedEND SUBBEGIN SUB pfComboAddSorted	GUIFcnName="CB_ADDSTRING"	CALL SUB pfAddSortedEND SUBBEGIN SUB pfAddSorted	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,["+TSymName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfListBoxAddItem	GUIFcnName="LB_INSERTSTRING"	CALL SUB pfAddItemEND SUBBEGIN SUB pfComboAddItem	GUIFcnName="CB_INSERTSTRING"	CALL SUB pfAddItemEND SUBBEGIN SUB pfAddItem	CALL SUB GUIStringPrep	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",-1,[_IOBuffer]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfWBGoBack	GUIFcnName="WBM_GOBACK"	CALL SUB pfClearEND SUBBEGIN SUB pfWBGoForward	GUIFcnName="WBM_GOFORWARD"	CALL SUB pfClearEND SUBBEGIN SUB pfLVClear	GUIFcnName="LVM_DELETEALLITEMS"	CALL SUB pfClearEND SUBBEGIN SUB pfListBoxClear	GUIFcnName="LB_RESETCONTENT"	CALL SUB pfClearEND SUBBEGIN SUB pfComboClear	GUIFcnName="CB_RESETCONTENT"	CALL SUB pfClearEND SUBBEGIN SUB pfClear	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",0,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psDropped	EqualRet	CALL SUB GetBoolOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SHOWDROPDOWN,eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB psHiliteComboText	EqualRet	CALL SUB NexToken	SELECT CASE TokenBuf		CASE "true"			TempStr="$ffff0000"		CASE "false"			TempStr="$0000ffff"		CASE ELSE			ErrNo=ErrIVType			RETURN	END SELECT	OutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SETEDITSEL,0,"+TempStr	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgDropped	ediUsed=TRUE	TDataType=BOOLVAR	CALL SUB GetTmp	ErrRet	GUITempName=SymTemp.SymName	OutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETDROPPEDSTATE,0,0"	CALL SUB OutFcnCodeData	CALL SUB StoreD0TmpEND SUBBEGIN SUB pfListBoxInsertItem	GUIFcnName="LB_INSERTSTRING"	CALL SUB pfInsertItemEND SUBBEGIN SUB pfComboInsertItem	GUIFcnName="CB_INSERTSTRING"	CALL SUB pfInsertItemEND SUBBEGIN SUB pfInsertItem	CALL SUB GetIntOp	ErrRet	DecArrayNdx	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetStringOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",[_ArgSafe0],["+TSymName+"]"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfLVDeleteCol	GUIFcnName="LVM_DELETECOLUMN"	CALL SUB pfDeleteItemEND SUBBEGIN SUB pfLVDeleteItem	GUIFcnName="LVM_DELETEITEM"	CALL SUB pfDeleteItemEND SUBBEGIN SUB pfListBoxDeleteItem	GUIFcnName="LB_DELETESTRING"	CALL SUB pfDeleteItemEND SUBBEGIN SUB pfComboDeleteItem	GUIFcnName="CB_DELETESTRING"	CALL SUB pfDeleteItemEND SUBBEGIN SUB pfDeleteItem	CALL SUB GetIntOp	ErrRet	DecArrayNdx	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",eax,0"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfComboFindItem	GUIFcnName="CB_FINDSTRINGEXACT"	CALL SUB pfFindItemEND SUBBEGIN SUB pfListBoxFindItem	GUIFcnName="LB_FINDSTRINGEXACT"	CALL SUB pfFindItemEND SUBBEGIN SUB pfFindItem	CALL SUB GUIStringPrep	ErrRet	CALL SUB ediUsedCheck	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+",-1,[_IOBuffer]"	CALL SUB OutFcnCodeData	IncArrayNdx	OutBuf="mov [STATUS],eax"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfListBoxReplaceItem	GUIFcnName="LB"	CALL SUB psReplaceItemEND SUBBEGIN SUB pfComboReplaceItem	GUIFcnName="CB"	CALL SUB psReplaceItemEND SUBBEGIN SUB psReplaceItem	CALL SUB GetStringOp	ErrRet	ArgStr=TSymName	CommaRet	CALL SUB GUIStringPrep	CALL SUB ediUsedCheck	ErrRet	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+"_FINDSTRINGEXACT,-1,["+ArgStr+"]"	CALL SUB OutFcnCodeData	OutBuf="or eax,eax"	CALL SUB OutFcnCodeData	INCR GUILabelNum	OutBuf="js !ComboStringNotFound"+STR(GUILabelNum)	CALL SUB OutFcnCodeData	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+"_DELETESTRING,[_ArgSafe0],0"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+"_INSERTSTRING,[_ArgSafe0],[_IOBuffer]"	CALL SUB OutFcnCodeData	OutBuf="!ComboStringNotFound"+STR(GUILabelNum)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pfListBoxReplaceItemSorted	GUIFcnName="LB"	CALL SUB psReplaceItemEND SUBBEGIN SUB pfComboReplaceItemSorted	GUIFcnName="CB"	CALL SUB psReplaceItemSortedEND SUBBEGIN SUB psReplaceItemSorted	CALL SUB GetStringOp	ErrRet	ArgStr=TSymName	CommaRet	CALL SUB GUIStringPrep	CALL SUB ediUsedCheck	ErrRet	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+"_FINDSTRINGEXACT,-1,["+ArgStr+"]"	CALL SUB OutFcnCodeData	OutBuf="or eax,eax"	CALL SUB OutFcnCodeData	INCR GUILabelNum	OutBuf="js !ComboStringNotFound"+STR(GUILabelNum)	CALL SUB OutFcnCodeData	OutBuf="mov [_ArgSafe0],eax"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+"_DELETESTRING,[_ArgSafe0],0"	CALL SUB OutFcnCodeData	OutBuf="invoke SendMessage, dword ["+HandleName+"],"+GUIFcnName+"_ADDSTRING,[_ArgSafe0],[_IOBuffer]"	CALL SUB OutFcnCodeData	OutBuf="!ComboStringNotFound"+STR(GUILabelNum)+":"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB pgListBoxText	ediUsed=TRUE	CALL SUB GetItemNumber	ErrRet	IF CmpOpFlag=FALSE THEN		TempStr="_IOBuffer"	ELSE		TempStr="_PrintBuf"	END IF	OutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTEXT,eax,["+TempStr+"]"	CALL SUB OutFcnCodeData	GUITempName=TempStrEND SUBBEGIN SUB pgBad	ErrNo=ErrIVTypeEND SUBBEGIN SUB psBad	ErrNo=ErrIVTypeEND SUBBEGIN SUB pfBad	ErrNo=ErrIVTypeEND SUBBEGIN SUB MakeEvent	CALL SUB FcnFlagChk	ErrRet	EventFlag=TRUE	CodeBlockFlag=TRUE	CALL SUB SymSrch	IF SymFound=TRUE THEN; Label Found		IF SymTable(SymNdx).DataType<>LABELVAR THEN			ErrNo=ErrDupSym			EXIT SUB		END IF		IF SymTable(SymNdx).Detail=LabelUnresolved THEN			SymTable(SymNdx).Detail=LabelResolved		ELSE			ErrNo=ErrDupSym			EXIT SUB		END IF	ELSE		CALL SUB ClrDatTyp		TDataType=LABELVAR		SymTemp.DataType=LABELVAR		CALL SUB ClrSym		SymTemp.DataMod=0		SymTemp.Detail=LabelResolved		CALL SUB SymInsert		ErrRet	END IF	OutBuf=TempStr+":"	CALL SUB OutFcnCodeData	IF LCASE(SrcLine)="obmain.create" AND ProjectFlag=TRUE THEN		CALL SUB GenToolCode		INCR InpFilPtr		IF InpFilPtr>20 THEN			TempStr="Include Stack OverFlow"			ErrNo=$ff			GOTO MainLoop		END IF		OPEN "_OBMainFormFile.INC" FOR INPUT AS InpFile(InpFilPtr)	END IFEND SUBBEGIN SUB GenToolCode	OPEN "_OBMainFormFile.INC" FOR SCRATCH AS ToolFile	TempStr="SETPOSITION OBMain,"+STR(ControlArray(1).PuppetLeft)+","+STR(ControlArray(1).PuppetTop)+","+STR(ControlArray(1).PuppetWidth)+","+STR(ControlArray(1).PuppetHeight)	WRITE ToolFile,TempStr	TempStr="OBMain.TEXT="+CHR(OBQUOTE)+ControlArray(1).PuppetText+CHR(OBQUOTE)	WRITE ToolFile,TempStr	TempStr="OBMain.BACKCOLOR=$"+HEX(ControlArray(1).PuppetBackColor)	WRITE ToolFile,TempStr	TempStr="DIM OBLogFont AS LOGFONT"	WRITE ToolFile,TempStr	TempStr="DIM OBFont AS FONT"	WRITE ToolFile,TempStr	CALL SUB GenForms	CALL SUB GenControls	CLOSE ToolFileEND SUBBEGIN SUB GenForms	TempBool=TRUE	CALL SUB GenFormsAndControlsEND SUBBEGIN SUB GenControls	TempBool=FALSE	CALL SUB GenFormsAndControlsEND SUBBEGIN SUB GenFormsAndControls	FOR I=2 TO LastControl		CONTINUE IF ControlArray(I).PuppetType<>1 AND TempBool=TRUE		CONTINUE IF ControlArray(I).PuppetType=1 AND TempBool=FALSE		IF ControlArray(I).PuppetHandle<>0 THEN			IF ControlArray(I).PuppetArrayNdx=-1 THEN				TempStr="DIM "+ControlArray(I).PuppetName+" AS "+ToolPropMap(ControlArray(I).PuppetType).PropMapType				WRITE ToolFile,TempStr			ELSE				IF ControlArray(I).PuppetArraySize>0 THEN					TempStr="DIM "+Root(ControlArray(I).PuppetName)+"("+STR(ControlArray(I).PuppetArraySize)+") AS "+ToolPropMap(ControlArray(I).PuppetType).PropMapType					WRITE ToolFile,TempStr				END IF			END IF			TempLeft=ControlArray(I).PuppetLeft			TempTop=ControlArray(I).PuppetTop			IF ControlArray(I).PuppetOwner=1 OR ControlArray(I).PuppetType=1 THEN				PathVar=""			ELSE				PathVar=" IN "+ControlArray(ControlArray(I).PuppetOwner).PuppetName				TempLeft=TempLeft-ControlArray(ControlArray(I).PuppetOwner).PuppetLeft				TempTop=TempTop-ControlArray(ControlArray(I).PuppetOwner).PuppetTop			END IF			TempStr="CREATE "+ControlArray(I).PuppetName+","+STR(TempLeft)+","+STR(TempTop)+","+STR(ControlArray(I).PuppetWidth)+","+STR(ControlArray(I).PuppetHeight)+PathVar			WRITE ToolFile,TempStr			IF BITTST(ControlArray(I).PuppetStatus,WinVisible)=FALSE THEN				TempStr=ControlArray(I).PuppetName+".VISIBLE=FALSE"				WRITE ToolFile,TempStr			END IF			IF BITTST(ControlArray(I).PuppetStatus,WinEnabled)=FALSE THEN				TempStr=ControlArray(I).PuppetName+".ENABLED=FALSE"				WRITE ToolFile,TempStr			END IF			IF ToolPropMap(ControlArray(I).PuppetType).PropMapTextFlag=TRUE THEN				TempStr=ControlArray(I).PuppetName+".TEXT="+CHR(OBQUOTE)+ControlArray(I).PuppetText+CHR(OBQUOTE)				WRITE ToolFile,TempStr			END IF			IF ToolPropMap(ControlArray(I).PuppetType).PropMapBCEnab=TRUE THEN				TempStr=ControlArray(I).PuppetName+".BACKCOLOR=$"+HEX(ControlArray(I).PuppetBackColor)				WRITE ToolFile,TempStr			END IF			IF ToolPropMap(ControlArray(I).PuppetType).PropMapFCEnab=TRUE THEN				TempStr=ControlArray(I).PuppetName+".FORECOLOR=$"+HEX(ControlArray(I).PuppetForeColor)				WRITE ToolFile,TempStr			END IF			IF ControlArray(I).PuppetToolTip<>"" THEN				TempStr=ControlArray(I).PuppetName+".TOOLTIP="+CHR(OBQUOTE)+ControlArray(I).PuppetToolTip+CHR(OBQUOTE)				WRITE ToolFile,TempStr			END IF			IF ControlArray(I).PuppetType=26 THEN				INCR BitmapNum				TempStr="DIM OBBitmap"+STR(BitmapNum)+" AS BITMAP"				WRITE ToolFile,TempStr				TempStr="CREATE OBBitmap"+STR(BitmapNum)+","+ControlArray(I).PuppetImage				WRITE ToolFile,TempStr				TempStr=ControlArray(I).PuppetName+".BITMAP=OBBitmap"+STR(BitmapNum)				WRITE ToolFile,TempStr			END IF		END IF	NEXT IEND SUBBEGIN SUB ChkForIMM	TempInt=IVAL(TSymName)	IF ForDataType=BYTEVAR AND TempInt>254 THEN		ErrNo=ErrOpRange		EXIT SUB	END IF	IF ForDataType=WORDVAR AND TempInt>65534 THEN		ErrNo=ErrOpRange		EXIT SUB	END IF	IF ForDataType=LONGVAR AND TempInt>$7fffffff THEN		ErrNo=ErrOpRange		EXIT SUB	END IFEND SUBBEGIN SUB SetPos	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+LeftOffs],eax"; Left	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+TopOffs],eax"; Top	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+WidthOffs],eax"; Width	CALL SUB OutFcnCodeData	CommaRet	CALL SUB GetIntOp	ErrRet	CALL SUB ediUsedCheck	OutBuf="mov dword [edi+HeightOffs],eax"; Height	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB SetPosFromTable	UseSetRightBottom=TRUE	OutBuf="call __SetRightBottom"	CALL SUB OutFcnCodeData	ImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUE	OutBuf="invoke SetWindowPos, dword ["+HandleName+"],HWND_TOP, dword [edi+LeftOffs], dword ["	OutBuf=OutBuf+"edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs],SWP_NOZORDER"	CALL SUB OutFcnCodeDataEND SUBBEGIN SUB IncrArrayNdx	IF ArrayBase=1 THEN		OutBuf="inc eax"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB DecrArrayNdx	IF ArrayBase=1 THEN		OutBuf="dec eax"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB FormatCompileTime	SETDEFAULTCURSOR	TempName=STR$((GETTICKCOUNT()-StartTime))	SELECT CASE LEN(TempName)		CASE 4			TempStr=LEFT(TempName,1)+"."+RIGHT(TempName,3)		CASE 5			TempStr=LEFT(TempName,2)+"."+RIGHT(TempName,3)		CASE ELSE			TempStr="."+TempName	END SELECT	TempName=TempStr+" Seconds"END SUBBEGIN SUB ShowError	SETDEFAULTCURSOR	WARNINGBOX "Error",TempStr,MB_OK	FOR I=1 TO InpFilPtr		CLOSE InpFile(InpFilPtr)	NEXT I	CLOSE DeclareFile	DELETE "_DeclareFile"	CLOSE PreCodeFile	DELETE "_PreCodeFile"	CLOSE CodeFile	DELETE "_CodeFile"	CLOSE DataFile	DELETE "_DataFile"	CLOSE DimFile	DELETE "_DimFile"	CLOSE DescFile	DELETE "_DescFile"	CLOSE InitFile	DELETE "_InitFile"	CLOSE FunctionFile	DELETE "_FunctionFile"	CLOSE LibFile	DELETE "_LibFile"	CLOSE ProcFile	DELETE "_ProcFile"	CLOSE ExportFile	DELETE "_ExportFile"	CLOSE ResourceFile	DELETE "_ResourceFile"	CALL SUB ShowMode	IF BasicLineCtr>0 THEN		Edit.GOTO BasicLineCtr,SrcLineChars	END IFEND SUBBEGIN SUB ShowMode	IF TextMode=TRUE THEN		StatusBarSafe4="Edit Text"		StatusBar.SETTEXT 4,StatusBarSafe4	ELSE		StatusBarSafe4="Edit Objects"		StatusBar.SETTEXT 4,StatusBarSafe4	END IFEND SUBBEGIN SUB GetDataTypeString	SELECT CASE TempInt		CASE 0			TempStr="CONST"		CASE 1			TempStr="BOOLEAN"		CASE 2			TempStr="BYTE"		CASE 3			TempStr="INT"		CASE 4			TempStr="LONG"		CASE 5			TempStr="FLOAT"		CASE 6			TempStr="STRING"		CASE 7			TempStr="LABEL"		CASE 8			TempStr="MACRO"		CASE 9			TempStr="OPER"		CASE 10			TempStr="FCN"		CASE 11			TempStr="PROC"		CASE 12			TempStr="TYPE"		CASE 13			TempStr="VOID"		CASE 14			TempStr="STRUCT"		CASE 15			TempStr="BUFFER"		CASE 16			TempStr="LBLPTR"		CASE 17			TempStr="MENU"		CASE 18			TempStr="TEXT"		CASE ELSE			TempStr="OBJECT"	END SELECTEND SUBBEGIN SUB FormatNumber2	MAKEUPPER TempStr	TempName=TempStr	TempInt=LEN(TempName)	SELECT CASE TempInt		CASE 1			TempStr="0"+TempName		CASE ELSE			TempStr=TempName	END SELECTEND SUBBEGIN SUB FormatNumber4	MAKEUPPER TempStr	TempName=TempStr	TempInt=LEN(TempName)	SELECT CASE TempInt		CASE 1			TempStr="000"+TempName		CASE 2			TempStr="00"+TempName		CASE 3			TempStr="0"+TempName		CASE ELSE			TempStr=TempName	END SELECTEND SUBBEGIN SUB FormatNumber8	MAKEUPPER TempStr	TempName=TempStr	TempInt=LEN(TempName)	SELECT CASE TempInt		CASE 1			TempStr="0000000"+TempName		CASE 2			TempStr="000000"+TempName		CASE 3			TempStr="00000"+TempName		CASE 4			TempStr="0000"+TempName		CASE 5			TempStr="000"+TempName		CASE 6			TempStr="00"+TempName		CASE 7			TempStr="0"+TempName		CASE ELSE			TempStr=TempName	END SELECTEND SUBSymbolGrid.HEADERCLICK	SymbolGrid.SORT GridCol,INVERTINGEND EVENTTimer1.TIMEOUT	Timer1.STOP	EditfChanged=0	StatusBar.SETTEXT 5,"Not Changed"	Changed=FALSE	;// ENABLEMENUITEMMainMenu,mnuSave,FALSE	Button(3).ENABLED=FALSEEND EVENTOBMain.SYSTEM	SELECT CASE STATUS		CASE $f060			IF Changed=TRUE THEN				IF TextMode=FALSE THEN					CALL SUB ModeChange				END IF				TempName=SaveFileName+" Not Saved"				TempStr="Save?"				WARNINGBOX TempName,TempStr,MB_YESNOCANCEL				IF STATUS=IDYES THEN					IF FileName="Untitled" THEN						CALL SUB SaveAs						IF STATUS=0 THEN							EXIT EVENT						END IF						END					ELSE						CALL SUB SaveEdit						IF LCASE(Extension)=".obp" THEN							CALL SUB WriteTools						END IF						;// ENABLEMENUITEMMainMenu,mnuSave,FALSE						Button(3).ENABLED=FALSE						StatusBar.SETTEXT 5,"Not Changed"						Changed=FALSE						END					END IF				ELSE					IF STATUS=IDCANCEL THEN						EXIT EVENT					END IF					PASSEVENT				END IF			ELSE				PASSEVENT			END IF		CASE $f120			IF TextMode=FALSE THEN				Timer4.TIME=200			END IF			PASSEVENT		CASE ELSE			PASSEVENT	END SELECTEND EVENTBEGIN SUB Assemble	SHELL "fasm "+AsmFileName+">_Fasm"	CALL SUB FormatCompileTime					OPEN "_fasm" FOR INPUT AS StatusFile	READ StatusFile,TempStr	READ StatusFile,TempStr	CLOSE StatusFile	MSGBOX TempName,TempStr,MB_OK	CALL SUB ShowModeEND SUBBEGIN SUB CompileToExe	ExpFlag=FALSE	AsmOutFlag=FALSE	NoGen=FALSE	IF Extension=".asm" THEN		IF Changed=TRUE THEN			WARNINGBOX "File Not Saved","Save?",MB_YESNO			IF STATUS=IDYES THEN				IF FileName="Untitled" THEN					CALL SUB SaveAs				ELSE					CALL SUB SaveEdit					IF LCASE(Extension)=".obp" THEN						CALL SUB WriteTools					END IF					;// ENABLEMENUITEMMainMenu,mnuSave,FALSE					Button(3).ENABLED=FALSE					Changed=FALSE					StatusBar.SETTEXT 5,"Not Changed"				END IF			ELSE				SETDEFAULTCURSOR				EXIT SUB			END IF		END IF		AsmFileName=BareFileName+Extension		StartTime=GETTICKCOUNT()		StatusBarSafe4="Compiling"		StatusBar.SETTEXT 4,StatusBarSafe4		CALL SUB Assemble		EXIT SUB	END IF	CALL SUB CompileCommonEND SUBBEGIN SUB CompileToAsm	ExpFlag=FALSE	AsmOutFlag=TRUE	NoGen=FALSE	CALL SUB CompileCommonEND SUBBEGIN SUB TestCompile	ExpFlag=FALSE	AsmOutFlag=FALSE	NoGen=TRUE	CALL SUB CompileCommonEND SUBBEGIN SUB CompileCommon	CALL SUB HideSpider	StatusBarSafe4="Compiling"	StatusBar.SETTEXT 4,StatusBarSafe4	CALL SUB CompileEND SUBBEGIN SUB PostCompile	Edit.SETFOCUSEND SUBBEGIN SUB NewCmd	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IF	Button(6).ENABLED=FALSE	IF Changed=TRUE THEN		TempName=SaveFileName+" Not Saved"		TempStr="Save?"		WARNINGBOX TempName,TempStr,MB_YESNOCANCEL		IF STATUS=IDYES THEN			IF FileName="Untitled" THEN				CALL SUB SaveAs			ELSE				CALL SUB SaveEdit				IF LCASE(Extension)=".obp" THEN					CALL SUB WriteTools				END IF				;// ENABLEMENUITEMMainMenu,mnuSave,FALSE				Button(3).ENABLED=FALSE				StatusBar.SETTEXT 5,"Not Changed"				Changed=FALSE			END IF		ELSE			IF STATUS=IDCANCEL THEN				EXIT SUB			END IF		END IF	END IF	ENABLEMENUITEM EditPopUp,emnuReturnToSource,FALSE	CALL SUB ClearAll	Edit.TEXT=""	OBMain.TEXT=ProgramName+"    [Untitled]" 	FileName="Untitled"	IF NewWindow.CREATED=FALSE THEN		CREATE NewWindow,100,100,350,120 APPWINDOW CHILD		NewWindow.TEXT="New"		CREATE NewButton(1),10,10,100,20 IN NewWindow		NewButton(1).TEXT="Window Proj"		CREATE NewButton(2),120,10,100,20 IN NewWindow		NewButton(2).TEXT="Windows Pgm"		CREATE NewButton(3),230,10,100,20 IN NewWindow		NewButton(3).TEXT="Console Pgm"		CREATE NewButton(4),10,40,100,20 IN NewWindow		NewButton(4).TEXT="DLL"		CREATE NewButton(5),120,40,100,20 IN NewWindow		NewButton(5).TEXT="Control"		CREATE NewButton(6),230,40,100,20 IN NewWindow		NewButton(6).TEXT="Include File"		CREATE NewButton(7),10,70,100,20 IN NewWindow		NewButton(7).TEXT="Asm Pgm"		CREATE NewButton(8),120,70,100,20 IN NewWindow		NewButton(8).TEXT="GUI DLL"		CREATE CancelButton,230,70,100,20 IN NewWindow		CancelButton.TEXT="Cancel"		CREATE NewName,5,10,340,20 IN NewWindow		NewName.TEXT=""		NewName.VISIBLE=FALSE		NewName.INTERCEPTON		CREATE NewLabel,10,40,340,20 IN NewWindow		NewLabel.TEXT=""		NewLabel.VISIBLE=FALSE		CREATE NewOKButton,10,65,150,20 IN NewWindow		NewOKButton.TEXT="OK"		NewOKButton.VISIBLE=FALSE		CREATE NewCancelButton,180,65,150,20 IN NewWindow		NewCancelButton.TEXT="Cancel"		NewCancelButton.VISIBLE=FALSE	ELSE		NewWindow.VISIBLE=TRUE		NewButton(1).VISIBLE=TRUE		NewButton(2).VISIBLE=TRUE		NewButton(3).VISIBLE=TRUE		NewButton(4).VISIBLE=TRUE		NewButton(5).VISIBLE=TRUE		NewButton(6).VISIBLE=TRUE		NewButton(7).VISIBLE=TRUE		NewButton(8).VISIBLE=TRUE		CancelButton.VISIBLE=TRUE		NewName.VISIBLE=FALSE		NewLabel.VISIBLE=FALSE		NewOKButton.VISIBLE=FALSE		NewCancelButton.VISIBLE=FALSE	END IFEND SUBNewButton.COMMAND	NewButtonCode=ArrayIndex	NewButton(1).VISIBLE=FALSE	NewButton(2).VISIBLE=FALSE	NewButton(3).VISIBLE=FALSE	NewButton(4).VISIBLE=FALSE	NewButton(5).VISIBLE=FALSE	NewButton(6).VISIBLE=FALSE	NewButton(7).VISIBLE=FALSE	NewButton(8).VISIBLE=FALSE	CancelButton.VISIBLE=FALSE	NewName.VISIBLE=TRUE	NewLabel.VISIBLE=TRUE	NewOKButton.VISIBLE=TRUE	NewCancelButton.VISIBLE=TRUE	NewName.TEXT=""	NewName.SETFOCUS	SELECT CASE NewButtonCode		CASE 1			NewLabel.TEXT="New Windows Project Name"		CASE 2			NewLabel.TEXT="New Windows Program Name"		CASE 3			NewLabel.TEXT="New Console Program Name"		CASE 4			NewLabel.TEXT="New DLL Name"		CASE 5			NewLabel.TEXT="New Control Name"		CASE 6			NewLabel.TEXT="New Include File Name"		CASE 7			NewLabel.TEXT="New Assembler Program Name"		CASE 7			NewLabel.TEXT="New GUI DLL Name"	END SELECTEND EVENTNewOKButton.COMMAND	IF NewName.TEXT="" THEN		MSGBOX "Error","No Program Name",MB_OK		NewName.SETFOCUS		RETURN	END IF	BareFileName=NewName.TEXT	OBMain.TEXT=ProgramName+"     ["+FileName+"]"	SELECT CASE NewButtonCode		CASE 1			Extension=".obp"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB ProjectButtonAction			END IF		CASE 2			Extension=".obw"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB WindowPgmButtonAction			END IF		CASE 3			Extension=".obc"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB ConsolePgmButtonAction			END IF		CASE 4			Extension=".obl"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB DLLButtonAction			END IF		CASE 5			Extension=".obo"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile		IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB ControlButtonAction			END IF		CASE 6			Extension=".inc"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB IncludeButtonAction			END IF		CASE 7			Extension=".asm"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB AsmButtonAction			END IF		CASE 8			Extension=".obd"			TempStr=BareFileName+Extension			STATUS=OPEN TempStr FOR INPUT AS TestFile			IF STATUS<>-1 THEN				WARNINGBOX TempStr,"File Exists",MB_OK				CLOSE TestFile				EXIT EVENT			ELSE				CALL SUB GUIDLLButtonAction			END IF	END SELECT	FileName=BareFileName+Extension	SaveFileName=FileName	SourceFileName=SaveFileName	OBMain.TEXT=ProgramName+"     ["+FileName+"]"END EVENTNewName.INTERCEPT	IF wmsg=$102 THEN		IF wparam=$0d THEN			CALL SUB NewOKButton_COMMAND		END IF	END IF	PASSEVENTEND EVENTBEGIN SUB ProjectButtonAction	Edit.TEXT="; Dimension Variables"+CHR($0d)+CHR($0d)+"OBMain.CREATE"+CHR($0d)+CHR($0d)+"END EVENT"+CHR($0d)+CHR($0d)	;Edit.SETDIVIDERLINE 3,TRUE	;Edit.SETDIVIDERLINE 6,TRUE	Edit.GOTO 4	Button(6).ENABLED=TRUE	ENABLEMENUITEM EditPopUp,emnuViewObject,TRUE	ClearToolsFlag=TRUE	CALL SUB NewDone	IF TextMode=TRUE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB WindowPgmButtonAction	Edit.TEXT="; Dimension Variables"+CHR($0d)+CHR($0d)+"OBMain.CREATE"+CHR($0d)+CHR($0d)+"END EVENT"+CHR($0d)+CHR($0d)	;Edit.SETDIVIDERLINE 3,TRUE	;Edit.SETDIVIDERLINE 6,TRUE	Edit.GOTO 4	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	CALL SUB NewDone	EventCombo1.ENABLED=FALSE	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB ConsolePgmButtonAction	Edit.TEXT="; Dimension Variables"+CHR($0d)+CHR($0d)+"; Code Section"+CHR($0d)	Edit.GOTO 4	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	CALL SUB NewDone	EventCombo1.ENABLED=FALSE	IF TextMode=FALSE THEN	CALL SUB ModeChange	END IFEND SUBBEGIN SUB DLLButtonAction	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB ControlButtonAction	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB IncludeButtonAction	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	CALL SUB NewDone	EventCombo1.ENABLED=FALSE	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB AsmButtonAction	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	CALL SUB NewDone	EventCombo1.ENABLED=FALSE	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB GUIDLLButtonAction	Button(6).ENABLED=FALSE	ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	CALL SUB NewDone	EventCombo1.ENABLED=FALSE	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IFEND SUBBEGIN SUB ClearAll	CALL SUB HideSpider	PropGrid.GRIDCLEAR	StyleGrid.GRIDCLEAR	ExStyleGrid.GRIDCLEAR	FormCombo.CLEAR	ControlCombo.CLEAR	EventCombo1.CLEAR	EventCombo2.CLEAR	EventCombo1.TEXT=""	EventCombo2.TEXT=""	FOR ControlPtr=2 TO ControlTableSize		CALL SUB CleanControl	NEXT ControlPtr	FOR I=1 TO ControlTableSize		PuppetIDDispenser(I)=FALSE	NEXT I	FOR I=1 TO TableSize(ToolPropMap)		ToolPropMap(I).PropMapCount=0	NEXT I	ControlCount=0	LastControl=1	PlacePtr=1	CurrentFormPtr=1	CurrentFormName="OBMain"END SUBBEGIN SUB FileExists	ON ERROR	WARNINGBOX TempStr,"File Exists",MB_OKEND SUBNewCancelButton.COMMAND	NewWindow.VISIBLE=FALSEEND EVENTCancelButton.COMMAND	NewWindow.VISIBLE=FALSEEND EVENTNewWindow.SYSTEM	NewWindow.VISIBLE=FALSEEND EVENTBEGIN SUB NewDone	Edit.EMPTYUNDOBUFFER	;// ENABLEMENUITEMMainMenu,mnuSave,FALSE	Button(3).ENABLED=FALSE	StatusBar.SETTEXT 5,"Not Changed"	Changed=FALSE	NewWindow.VISIBLE=FALSE	Edit.ENABLED=TRUE	Edit.SETFOCUSEND SUBBEGIN SUB OpenCmd	IF TextMode=FALSE THEN		CALL SUB ModeChange	END IF	CaptureEnabled=FALSE	RELEASECAPTURE	IF Changed=TRUE THEN		TempName=SaveFileName+" Not Saved"		TempStr="Save?"		WARNINGBOX TempName,TempStr,MB_YESNOCANCEL		IF STATUS=IDYES THEN			IF FileName="Untitled" THEN				CALL SUB SaveAs			ELSE				CALL SUB SaveEdit				IF LCASE(Extension)=".obp" THEN					CALL SUB WriteTools				END IF				;// ENABLEMENUITEMMainMenu,mnuSave,FALSE				Button(3).ENABLED=FALSE				StatusBar.SETTEXT 5,"Not Changed"				Changed=FALSE			END IF		ELSE			IF STATUS=IDCANCEL THEN				EXIT SUB			END IF		END IF	END IF	TempStr=FileName	FileName=""	OPENDIALOG FileName,FileFilter,InitDir 	IF STATUS<>0 THEN		I=LEN(FileName)+1		BEGIN LOOP			DECR I			EXIT IF I=1			EXIT IF MID(FileName,I,1)=CHR($5c)		END LOOP		INCR I		SaveFileName=TAIL(FileName,I)		FileName=SaveFileName		SourceFileName=SaveFileName		BareFileName=LEFT(FileName,LEN(FileName)-4)		Extension=LCASE(RIGHT(FileName,4))		OBMain.TEXT=ProgramName+"     ["+FileName+"]"		OpenFlag=TRUE		CALL SUB LoadSource		Timer1.TIME=50		StatusBar.SETTEXT 5,"Not Changed"		Changed=FALSE	ELSE		FileName=TempStr	END IF	ENABLEMENUITEM EditPopUp,emnuReturnToSource,FALSE	IF TextMode=TRUE THEN		Edit.ENABLED=TRUE		Edit.SETFOCUS	ELSE	CaptureEnabled=TRUE	END IFEND SUBBEGIN SUB LoadSource	Edit.EMPTYUNDOBUFFER	IF LCASE(Extension)=".obp" THEN		CALL SUB ClearAll		LoadToolsFlag=TRUE		Edit.LOADFILE FileName,ToolBlockSize+1		OPEN FileName FOR INPUT AS EditFile		SEEK EditFile,LOF(EditFile)-ToolBlockSize		GET EditFile,TempInt		GET EditFile,TempInt		GET EditFile,ShowGrid		GET EditFile,SnapToGrid		GET EditFile,GridSize		GET EditFile,GridColor		GET EditFile,TempInt		GET EditFile,LastControl		GET EditFile,ControlCount		DECR ControlCount		GET EditFile,ControlArray		GET EditFile,ToolPropMapCount		CLOSE EditFile		FOR I=1 TO 50			ToolPropMap(I).PropMapCount=ToolPropMapCount(I)		NEXT I		Button(6).ENABLED=TRUE		ENABLEMENUITEM EditPopUp,emnuViewObject,TRUE		IF OpenFlag=TRUE THEN			OpenFlag=FALSE			CALL SUB ModeChange		END IF	ELSE		IF TextMode=FALSE THEN			CALL SUB ModeChange		END IF		Edit.LOADFILE FileName		EventCombo1.ENABLED=FALSE		ENABLEMENUITEM EditPopUp,emnuViewObject,FALSE	END IFEND SUBBEGIN SUB SaveCmd	CaptureEnabled=FALSE	RELEASECAPTURE	IF FileName="Untitled" THEN		CALL SUB SaveAs	ELSE		Edit.EMPTYUNDOBUFFER		CALL SUB SaveEdit		IF LCASE(Extension)=".obp" THEN			CALL SUB WriteTools		END IF		;// ENABLEMENUITEMMainMenu,mnuSave,FALSE		Button(3).ENABLED=FALSE		StatusBar.SETTEXT 5,"Not Changed"		Changed=FALSE	END IF	Edit.SETFOCUS	CaptureEnabled=TRUEEND SUBBEGIN SUB SaveEdit	CALL SUB RemoveEars	Edit.SAVEFILE SaveFileNameEND SUBBEGIN SUB SaveAsCmd	CALL SUB SaveAs	EditfChanged=0	StatusBar.SETTEXT 5,"Not Changed"	Changed=FALSE	;// ENABLEMENUITEMMainMenu,mnuSave,FALSE	Button(3).ENABLED=FALSE	Edit.SETFOCUSEND SUBFindText.CHANGE	TempStr=FindText.TEXT	IF LEN(TempStr)>0 THEN		FindNext.ENABLED=TRUE	ELSE		FindNext.ENABLED=FALSE	END IFEND EVENTFRFindText.CHANGE	TempStr=FRFindText.TEXT	IF LEN(TempStr)>0 THEN		FRFindNext.ENABLED=TRUE		FRReplace.ENABLED=TRUE		FRReplaceAll.ENABLED=TRUE	ELSE		FRFindNext.ENABLED=FALSE		FRReplace.ENABLED=FALSE		FRReplaceAll.ENABLED=FALSE	END IFEND EVENTFindNext.COMMAND	FindStr=FindText.TEXT	fr_lpstrFindWhat=ADDR(FindStr)	FLAGS=$08	IF DownButton.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,0)	END IF	IF MatchWholeWord.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,1)	END IF	IF MatchCase.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,2)	END IF	Edit.FIND	FindStr=FindStr+" Not Found"	IF STATUS=-1 THEN		MSGBOX "Find",FindStr,MB_OK	ELSE		FindText.SETFOCUS	END IFEND EVENTQuickFind.CHANGE	FLAGS=$09	IF QuickFind.TEXT="" THEN		QuickFindPrev.ENABLED=FALSE		QuickFindNext.ENABLED=FALSE		QuickFind.BACKCOLOR=$ffffff		RETURN	ELSE		QuickFindPrev.ENABLED=TRUE		QuickFindNext.ENABLED=TRUE	END IF	CALL SUB QuickFindText	QuickFind.SETFOCUSEND EVENTQuickFindPrev.COMMAND	FLAGS=$08	CALL SUB QuickFindTextEND EVENTQuickFindNext.COMMAND	FLAGS=$09	CALL SUB QuickFindTextEND EVENTBEGIN SUB QuickFindText	FindStr=QuickFind.TEXT	fr_lpstrFindWhat=ADDR(FindStr)	Edit.FIND	IF STATUS=-1 THEN		QuickFind.BACKCOLOR=$ff		Timer5.TIME=1000	ELSE		QuickFind.BACKCOLOR=$ffffff	END IFEND SUBTimer4.TIMEOUT	Timer4.STOP	CALL SUB PaintGrid	CALL SUB RedrawPartsEND EVENTTimer5.TIMEOUT	Timer5.STOP	QuickFind.BACKCOLOR=$ffffffEND EVENTFRFindNext.COMMAND	CALL SUB GetTextToReplaceEND EVENTFRReplace.COMMAND	SelectStr=Edit.SELTEXT	FindStr=SelectStr	IF TextFound=FALSE OR FindStr<>SelectStr THEN		CALL SUB GetTextToReplace		IF TextFound=FALSE THEN			RETURN		END IF	END IF		TempStr=FRReplaceText.TEXT	Edit.REPLACESEL TempStr	FindStr=FRFindText.TEXT	fr_lpstrFindWhat=ADDR(FindStr)	FLAGS=$08	FLAGS=BITSET(FLAGS,0); Forces downward search	IF FRMatchWholeWord.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,1)	END IF	IF FRMatchCase.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,2)	END IF	Edit.FIND	IF STATUS=-1 THEN		TextFound=FALSE	ELSE		TextFound=TRUE	END IFEND EVENTFRReplaceAll.COMMAND	REPEAT		SelectStr=Edit.SELTEXT		FindStr=SelectStr		IF TextFound=FALSE OR FindStr<>SelectStr THEN			CALL SUB GetTextToReplace			IF TextFound=FALSE THEN				EXIT EVENT			END IF		END IF		TempStr=FRReplaceText.TEXT		Edit.REPLACESEL TempStr		FindStr=FRFindText.TEXT		fr_lpstrFindWhat=ADDR(FindStr)		FLAGS=$08		FLAGS=BITSET(FLAGS,0); Forces downward search		IF FRMatchWholeWord.CHECKED=TRUE THEN			FLAGS=BITSET(FLAGS,1)		END IF		IF FRMatchCase.CHECKED=TRUE THEN			FLAGS=BITSET(FLAGS,2)		END IF	Edit.FIND	UNTIL STATUS=-1	TextFound=FALSEEND EVENTCancel.COMMAND	FindWindow.VISIBLE=FALSE	FindWindowActive=FALSEEND EVENTFindWindow.SYSTEM	FindWindow.VISIBLE=FALSE	FindWindowActive=FALSEEND EVENTFRCancel.COMMAND	FindReplaceWindow.VISIBLE=FALSEEND EVENTFindReplaceWindow.SYSTEM	FindReplaceWindow.VISIBLE=FALSEEND EVENTBEGIN SUB GetFindDialog	IF FindWindow.CREATED=FALSE THEN		CREATE FindWindow,400,300,360,125 APPWINDOW CHILD		FindWindow.TEXT="Find"		CREATE UpDown,160,45,100,45 IN FindWindow		UpDown.FONT=Font1		UpDown.Text="Direction"		CREATE UpButton,5,20,40,15 IN UpDown		UpButton.FONT=Font1		UpButton.TEXT="&Up"		CREATE DownButton,45,20,50,15 IN UpDown		DownButton.FONT=Font1		DownButton.TEXT="&Down"		CREATE FindText,70,5,190,20 IN FindWindow		FindText.FONT=Font1		FindText.INTERCEPTON		CREATE FindWhat,5,8,50,15 IN FindWindow		FindWhat.FONT=Font1		FindWhat.TEXT="Fi&nd what:"		CREATE MatchWholeWord,5,50,130,15 IN FindWindow		MatchWholeWord.FONT=Font1		MatchWholeWord.TEXT="Match &whole word only"		CREATE MatchCase,5,75,75,15 IN FindWindow		MatchCase.FONT=Font1		MatchCase.TEXT="Match &case"		CREATE FindNext,270,5,75,25 IN FindWindow		FindNext.TOOLTIP="Find Next"		FindNext.FONT=Font1		FindNext.TEXT="&Find Next" IN FindWindow		CREATE Cancel,270,35,75,25 IN FindWindow		Cancel.TOOLTIP="Cancel"		Cancel.FONT=Font1		Cancel.TEXT="Cancel"		FindText.TEXT=""		DownButton.CHECKED=TRUE		UpButton.CHECKED=FALSE		MatchWholeWord.CHECKED=FALSE		MatchCase.CHECKED=FALSE		FindNext.ENABLED=FALSE	ELSE		FindWindow.VISIBLE=TRUE	END IF	FindWindowActive=TRUE	FindText.SETFOCUS	;FindText.HILITE=FALSEEND SUBFindText.INTERCEPT	IF wmsg=$102 THEN		IF wparam=$0d THEN			CALL SUB FindNext_COMMAND		END IF		IF wparam=$1b THEN			CALL SUB Cancel_COMMAND		END IF	END IF	PASSEVENTEND EVENTBEGIN SUB GetFindReplaceDialog	IF FindReplaceWindow.CREATED=FALSE THEN		CREATE FindReplaceWindow,400,300,360,150 APPWINDOW CHILD		FindReplaceWindow.TEXT="Replace"		CREATE FRFindText,70,5,190,20 IN FindReplaceWindow		FRFindText.FONT=Font1		FRFindText.INTERCEPTON		CREATE FRFindWhat,5,8,60,15 IN FindReplaceWindow		FRFindWhat.FONT=Font1		FRFindWhat.TEXT="Fi&nd what:"		CREATE FRReplaceText,70,35,190,20 IN FindReplaceWindow		FRReplaceText.FONT=Font1		CREATE FRReplaceWith,5,38,60,15 IN FindReplaceWindow		FRReplaceWith.FONT=Font1		FRReplaceWith.TEXT="Re&place with:"		CREATE FRMatchWholeWord,5,75,130,15 IN FindReplaceWindow		FRMatchWholeWord.FONT=Font1		FRMatchWholeWord.TEXT="Match &whole word only"		CREATE FRMatchCase,5,100,75,15 IN FindReplaceWindow		FRMatchCase.FONT=Font1		FRMatchCase.TEXT="Match &case"		CREATE FRFindNext,270,5,75,25 IN FindReplaceWindow		FRFindNext.FONT=Font1		FRFindNext.TEXT="&Find Next" IN FindReplaceWindow		CREATE FRReplace,270,35,75,25 IN FindReplaceWindow		FRReplace.FONT=Font1		FRReplace.TEXT="&Replace"		CREATE FRReplaceAll,270,65,75,25 IN FindReplaceWindow		FRReplaceAll.FONT=Font1		FRReplaceAll.TEXT="Replace &All"			CREATE FRCancel,270,95,75,25 IN FindReplaceWindow		FRCancel.FONT=Font1		FRCancel.TEXT="Cancel"		FRFindText.TEXT=""		FRFindNext.ENABLED=FALSE		FRReplace.ENABLED=FALSE		FRReplaceAll.ENABLED=FALSE	ELSE		FindReplaceWindow.VISIBLE=TRUE	END IF	FRWindowActive=TRUE	FRFindText.SETFOCUSEND SUBFRFindText.INTERCEPT	IF wmsg=$102 THEN		IF wparam=$0d THEN			CALL SUB FRFindNext_COMMAND		END IF		IF wparam=$1b THEN			CALL SUB FRCancel_COMMAND		END IF	END IF	PASSEVENTEND EVENTBEGIN SUB GetTextToReplace	FindStr=FRFindText.TEXT	fr_lpstrFindWhat=ADDR(FindStr)	FLAGS=$08	FLAGS=BITSET(FLAGS,0); Forces downward search	IF FRMatchWholeWord.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,1)	END IF	IF FRMatchCase.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,2)	END IF	Edit.FIND	IF STATUS=-1 THEN		TextFound=FALSE		FindStr=FindStr+" Not Found"		MSGBOX "Replace",FindStr,MB_OK		RETURN	ELSE		TextFound=TRUE	END IFEND SUBBEGIN SUB FindStyle	I=0	BEGIN LOOP		INCR I		IF StyleArray(I).StyleName="%" THEN			ErrNo=ErrIVProp			RETURN		END IF			IF StyleArray(I).StyleName=TempStr AND StyleArray(I).StyleType=STYLE THEN			RETURN		END IF	END LOOPEND SUBEdit.CONTEXTMENU	SHOWPOPUP EditPopUp,CursorPosX,CursorPosYEND EVENTBEGIN SUB DeleteControl	ControlPtrSafe=ControlPtr	ControlName=ControlArray(ControlPtr).PuppetName	DeleteOwnerPtr=ControlPtr	MultiDelete=FALSE	IF ControlArray(ControlPtr).PuppetType<>1 THEN		CALL SUB ControlDelete		FOR ControlPtr=2 TO LastControl			IF ControlArray(ControlPtr).PuppetOwner=DeleteOwnerPtr THEN				ControlName=ControlArray(ControlPtr).PuppetName				MultiDelete=TRUE				CALL ControlDelete			END IF		NEXT ControlPtr	ELSE		FOR ControlPtr=2 TO LastControl			IF ControlArray(ControlPtr).PuppetForm=DeleteOwnerPtr THEN				ControlName=ControlArray(ControlPtr).PuppetName				MultiDelete=TRUE				CALL ControlDelete			END IF		NEXT ControlPtr		ControlPtr=DeleteOwnerPtr		ControlName=ControlArray(ControlPtr).PuppetName		CALL SUB CleanControl		DECR ControlCount		FormCombo.FINDITEM ControlName		FormCombo.DELETEITEM STATUS		EventCombo1.FINDITEM ControlName		EventCombo1.DELETEITEM STATUS		ControlName="OBMain"		CALL SUB FindFormByName		CALL SUB FormComboAction		FormCombo.TEXT="OBMain"	END IF	INVALIDATERECT FormWindow	ControlPtr=ControlPtrSafe	;CALL SUB refresh_commandEND SUBBEGIN SUB ControlDelete	CALL SUB SetChanged	PuppetIDDispenser(ControlArray(ControlPtr).PuppetID-100)=FALSE	IF ControlPtr=LastControl THEN		DECR LastControl		BEGIN LOOP			EXIT IF ControlArray(LastControl).PuppetHandle<>0			DECR LastControl		END LOOP	END IF	IF ControlArray(ControlPtr).PuppetArrayNdx<>-1 THEN		RootSymbol=Root(ControlArray(ControlPtr).PuppetName)		ControlArray(ControlPtr).PuppetArrayNdx=0		CALL SUB OrderArrays	END IF	CALL SUB CleanControl	DECR ControlCount	ControlNameSafe=ControlName	ControlName=CurrentFormName	ControlCombo.TEXT=ControlName	IF MultiSelectItemCount=0 AND MultiDelete=FALSE THEN		CALL SUB ControlComboAction; Force ControlCombo selection of parent	END IF	ControlName=ControlNameSafe	ControlCombo.TEXT=OwnerName	ControlCombo.FINDITEM ControlName	ControlCombo.DELETEITEM STATUS	EventCombo1.FINDITEM ControlName	EventCombo1.DELETEITEM STATUS	Spider(Belly).VISIBLE=FALSEEND SUBBEGIN SUB CopyToClipBoard	ClipBoard(ClipBoardPtr)=ControlArray(ControlPtr)	ClipBoard(ClipBoardPtr).PuppetHandle=ControlPtr	FOR K=1 TO 4		ClipBoard(ClipBoardPtr).PuppetEars(K)=0	NEXT KEND SUBBEGIN SUB PasteControl	CALL SUB FindEmptyControlSlot	INCR ControlCount	ControlArray(PlacePtr)=ClipBoard(ClipBoardPtr)	CALL SUB GetControlID	FOR ClipBoardNdx=1 TO ClipBoardItemCount		IF ClipBoard(ClipBoardNdx).PuppetOwner=ControlArray(PlacePtr).PuppetHandle THEN			ClipBoard(ClipBoardNdx).PuppetID=PlacePtr		END IF	NEXT ClipBoardNdx	TempControlType=ClipBoard(ClipBoardPtr).PuppetControlType	TempExStyle=ClipBoard(ClipBoardPtr).PuppetExStyle	TempStr=ClipBoard(ClipBoardPtr).PuppetText	TempStyle=ClipBoard(ClipBoardPtr).PuppetStyle	TempLeft=PasteX+ClipBoard(ClipBoardPtr).PuppetLeft	SpiderLeft=TempLeft	TempTop=PasteY+ClipBoard(ClipBoardPtr).PuppetTop	SpiderTop=TempTop	TempWidth=ClipBoard(ClipBoardPtr).PuppetWidth	TempHeight=ClipBoard(ClipBoardPtr).PuppetHeight		IF SnapToGrid=TRUE THEN		SpiderWidth=TempWidth		SpiderHeight=TempHeight		CALL SUB SetSnap		TempLeft=SpiderLeft		TempTop=SpiderTop		TempWidth=SpiderWidth		TempHeight=SpiderHeight	END IF	IF ClipBoard(ClipBoardPtr).PuppetOwner=ClipBoard(ClipBoardPtr).PuppetForm THEN				ControlArray(PlacePtr).PuppetOwner=CurrentFormPtr	ELSE		ControlArray(PlacePtr).PuppetOwner=ClipBoard(ClipBoardPtr).PuppetID	END IF	TempHandle=FormWindow.HANDLE	ControlArray(PlacePtr).PuppetLeft=TempLeft	ControlArray(PlacePtr).PuppetTop=TempTop	OwnerPtr=CurrentFormPtr	ControlArray(PlacePtr).PuppetForm=CurrentFormPtr	ControlName=ClipBoard(ClipBoardPtr).PuppetName	CALL SUB ChkDupControlName	IF ControlFound=FALSE THEN		TempStr=ControlName	ELSE		IF ControlArray(PlacePtr).PuppetArrayNdx=-1 THEN			ToolButtonNdx=ControlArray(PlacePtr).PuppetType			BEGIN LOOP				CALL SUB MakeName				CALL SUB ChkDupControlName				EXIT IF ControlFound=FALSE			END LOOP			ControlArray(PlacePtr).PuppetName=ControlName		ELSE			HighestArrayNdx=0			RootSymbol=Root(ControlArray(PlacePtr).PuppetName)			FOR ArrayNdx=2 TO LastControl				IF Root(ControlArray(ArrayNdx).PuppetName)=RootSymbol THEN					IF ControlArray(ArrayNdx).PuppetArrayNdx>HighestArrayNdx Then						HighestArrayNdx=ControlArray(ArrayNdx).PuppetArrayNdx					END IF				END IF			NEXT ArrayNdx			INCR HighestArrayNdx			ControlName=RootSymbol+"("+STR(HighestArrayNdx)+")"			ControlArray(PlacePtr).PuppetName=ControlName			ControlArray(PlacePtr).PuppetArrayNdx=HighestArrayNdx			CALL SUB OrderArrays		END IF		TempStr=ControlName	END IF	CALL SUB CreatePuppet	TempStr=ClipBoard(ClipBoardPtr).PuppetText	invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]	ControlCombo.ADDITEMSORTED ControlName	IF ClipBoard(ClipBoardPtr).PuppetArrayNdx=-1 THEN					EventCombo1.ADDITEMSORTED ControlName		HiliteControlName=ControlArray(PlacePtr).PuppetName		CALL SUB AddHiliteName	END IF	TempHandle=TempInt	ControlPtr=PlacePtr	RGB=ControlArray(ControlPtr).PuppetBackColor	CALL SUB SetBackColor	RGB=ControlArray(ControlPtr).PuppetForeColor	CALL SUB SetForeColor	IF ClipBoard(ClipBoardPtr).PuppetType=26 THEN		IF ClipBoard(ClipBoardPtr).PuppetImage<>"" THEN		LOAD ToolBitmap,ClipBoard(ClipBoardPtr).PuppetImage		invoke SendMessage, dword [TempHandle],STM_SETIMAGE,IMAGE_BITMAP,eax		END IF	END IFEND SUBBEGIN SUB FindEvent	TempInt=MenuID-evmnu1+1	TempStr=Root(ControlName)+"."+UCASE(EventArray(TempInt).EVType)	Edit.GOTO 1	fr_lpstrFindWhat=ADDR(TempStr)	FLAGS=$09	Edit.FIND	IF STATUS=-1 THEN		CALL SUB AddEvent	ELSE		Edit.GOTO EditLine+1	END IF	Edit.SETFOCUS	CALL SUB ModeChangeEND SUBEventCombo2.SELECT	TempName=EventCombo2.SELTEXT	TempStr=EventCombo1.TEXT	TempStr=TempStr+"."+TempName	Edit.GOTO 1	fr_lpstrFindWhat=ADDR(TempStr)	FLAGS=$09	Edit.FIND	IF STATUS=-1 THEN		CALL SUB AddEvent	ELSE		Edit.GOTO EditLine+1	END IF	EventCombo2.ENABLED=FALSE	EventCombo1.TEXT="Select Control"	Timer2.TIME=50	Edit.SETFOCUSEND EVENTBEGIN SUB AddEvent	TempStr=TempStr+CHR($0d)+CHR($0d)+"END EVENT"+CHR($0d)+CHR($0d)	Edit.APPENDTEXT TempStr	;Edit.SETDIVIDERLINE EditLine-4,TRUE	;Edit.SETDIVIDERLINE EditLine-1,TRUE	Edit.goto EditLine-3END SUBTimer2.TIMEOUT	Timer2.STOP	EventCombo2.TEXT=""END EVENTFormWindow.RBUTTONDOWN	IF PlacePart=TRUE THEN		RELEASECAPTURE		FormWindow.ENABLED=FALSE		CaptureEnabled=FALSE		IF ArrayWindow.CREATED=FALSE THEN			CREATE ArrayWindow,340,150,190,264 APPWINDOW CHILD			ArrayWindow.TEXT="Array"			ArrayWindow.BACKCOLOR=$c0c0c0			CREATE ArrayName,20,10,140,20 IN ArrayWindow			ArrayName.TEXT=""			ArrayName.BACKCOLOR=$ffffff			ArrayName.FORECOLOR=$0			CREATE ArrayNameLbl,20,40,140,20 IN ArrayWindow			ArrayNameLbl.TEXT="Array Name"			ArrayNameLbl.BACKCOLOR=$c0c0c0			ArrayNameLbl.FORECOLOR=$0			CREATE ArrayCancel,20,200,50,20 IN ArrayWindow			ArrayCancel.TEXT="Cancel"			ArrayCancel.BACKCOLOR=$ff			ArrayCancel.FORECOLOR=$ffff			CREATE ArrayPlace,90,200,70,20 IN ArrayWindow			ArrayPlace.TEXT="Place"			ArrayPlace.BACKCOLOR=$ff00			ArrayPlace.FORECOLOR=$ffff			CREATE ArrayRows,90,70,70,20 IN ArrayWindow			ArrayRows.TEXT=""			ArrayRows.BACKCOLOR=$ffffff			ArrayRows.FORECOLOR=$0			CREATE ArrayCols,90,100,70,20 IN ArrayWindow			ArrayCols.TEXT=""			ArrayCols.BACKCOLOR=$ffffff			ArrayCols.FORECOLOR=$0			CREATE ArrayHSpacing,90,130,70,20 IN ArrayWindow			ArrayHSpacing.TEXT=""			ArrayHSpacing.BACKCOLOR=$ffffff			ArrayHSpacing.FORECOLOR=$0			CREATE ArrayVSpacing,90,160,70,20 IN ArrayWindow			ArrayVSpacing.TEXT=""			ArrayVSpacing.BACKCOLOR=$ffffff			ArrayVSpacing.FORECOLOR=$0			CREATE ArrayRowsLbl,10,70,70,20 IN ArrayWindow			ArrayRowsLbl.TEXT="Rows"			ArrayRowsLbl.BACKCOLOR=$c0c0c0			ArrayRowsLbl.FORECOLOR=$0			CREATE HeightLbl,10,100,70,20 IN ArrayWindow			HeightLbl.TEXT="Columns"			HeightLbl.BACKCOLOR=$c0c0c0			HeightLbl.FORECOLOR=$0			CREATE HSpaceLbl,10,130,70,20 IN ArrayWindow			HSpaceLbl.TEXT="H Spacing"			HSpaceLbl.BACKCOLOR=$c0c0c0			HSpaceLbl.FORECOLOR=$0			CREATE VSpaceLbl,10,160,70,20 IN ArrayWindow			VSpaceLbl.TEXT="V Spacing"			VSpaceLbl.BACKCOLOR=$c0c0c0			VSpaceLbl.FORECOLOR=$0		ELSE			ArrayWindow.VISIBLE=TRUE		END IF		PlaceArray=TRUE		SETDEFAULTCURSOR		EXIT EVENT	END IF	RBDown=TRUE	ControlPtrSafe=ControlPtr	ControlPtr=OverControl	ControlName=ControlArray(ControlPtr).PuppetName	OwnerName=ControlArray(ControlArray(ControlPtr).PuppetOwner).PuppetName	FcnName=ControlArray(ControlPtr).PuppetName	Spider(Belly).VISIBLE=TRUE	IF ControlArray(ControlPtr).PuppetType<>1 THEN; Not Form		ControlCombo.TEXT=ControlArray(ControlPtr).PuppetName		CALL SUB InitSpider		CALL SUB PlaceSpiderLegs	ELSE		ControlCombo.TEXT=FormCombo.TEXT		CALL SUB HideSpider		SETPOSITION Spider(Belly),CursorPosX,CursorPosY,0,0	END IF	ControlNdx=ControlPtr	ToolButtonNdx=ControlArray(ControlPtr).PuppetType	CALL SUB PopulateToolBox	CALL SUB ControlArrayToToolBoxEND EVENTArrayCancel.COMMAND	ArrayWindow.VISIBLE=FALSE	PlacePart=FALSE	PlaceArray=FALSE	INVALIDATERECT FormWindow	FormWindow.ENABLED=TRUE	CaptureEnabled=TRUEEND EVENTArrayPlace.COMMAND	ArrayWindow.VISIBLE=FALSE	SETSTOCKCURSOR CROSS	CALL SUB PaintGrid	CALL SUB RedrawParts	FormWindow.ENABLED=TRUE	CaptureEnabled=TRUEEND EVENTArrayWindow.SYSTEM	IF STATUS=$f060 THEN		ArrayWindow.VISIBLE=FALSE		PlacePart=FALSE		PlaceArray=FALSE		INVALIDATERECT FormWindow		CaptureEnabled=TRUE	END IFEND EVENTFormWindow.RBUTTONUP	IF PlacePart=TRUE THEN		EXIT EVENT	END IF	RBDown=FALSE	PasteX=CursorPosX	PasteY=CursorPosY	IF MultiSelectItemCount>0 AND ControlArray(ControlPtr).PuppetGroup=0 THEN		ENABLEMENUITEM FormPopUp,fwmnuGroup,TRUE	ELSE		ENABLEMENUITEM FormPopUp,fwmnuGroup,FALSE	END IF	IF ControlArray(ControlPtr).PuppetType=1 THEN		ENABLEMENUITEM FormPopUp,fwmnuCut,FALSE		ENABLEMENUITEM FormPopUp,fwmnuCopy,FALSE		IF ClipBoardItemCount=0 THEN			ENABLEMENUITEM FormPopUp,fwmnuPaste,FALSE		ELSE			ENABLEMENUITEM FormPopUp,fwmnuPaste,TRUE		END IF		IF ControlPtr=1 THEN			ENABLEMENUITEM FormPopUp,fwmnuDelete,FALSE		ELSE			ENABLEMENUITEM FormPopUp,fwmnuDelete,TRUE		END IF	ELSE		ENABLEMENUITEM FormPopUp,fwmnuCut,TRUE		ENABLEMENUITEM FormPopUp,fwmnuCopy,TRUE		ENABLEMENUITEM FormPopUp,fwmnuPaste,FALSE		ENABLEMENUITEM FormPopUp,fwmnuDelete,TRUE	END IF	TempInt=ControlArray(ControlPtr).PuppetType	FOR I=1 TO EventMenuCount		DELETEMENUITEM EventPopUp,evmnu1+I-1	NEXT I	SETVECTOR EventArray=[ToolPropMap(TempInt).PropMapEventTable]	I=0	EventMenuCount=0	BEGIN LOOP		INCR I		EXIT IF EventArray(I).EVType="%"		TempStr=UCASE(EventArray(I).EVType)		APPENDMENUITEM EventPopUp,evmnu1+I-1,TempStr		INCR EventMenuCount	END LOOP	GETCURSORPOSITION	SHOWPOPUP FormPopUp,CursorPosX,CursorPosY	CALL SUB PaintGrid	CALL SUB RedrawPartsEND EVENTFormWindow.LBUTTONDOWN	LBDown=TRUE	LeftButtonX=CursorPosX	LeftButtonY=CursorPosY	MoveCtr=GridSize	ControlPtrSafe=ControlPtr	ControlPtr=OverControl	ControlName=ControlArray(ControlPtr).PuppetName	Spider(Belly).VISIBLE=TRUE	IF PlacePart=TRUE THEN		IF ToolButtonNdx=8 THEN			ComboFlag=TRUE		ELSE			ComboFlag=FALSE		END IF		SpiderLeft=CursorPosX		SpiderTop=CursorPosY		SpiderWidth=0		SpiderHeight=0		OwnerPtr=OverControl		SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight		OwnerName=ControlArray(OverControl).PuppetName		PropGrid.TEXT(2,2)=OwnerName		TempHandle=FormWindow.HANDLE	ELSE		IF SpiderFound=TRUE THEN			ControlPtr=ControlPtrSafe			IF ControlArray(ControlPtr).PuppetType=8 THEN				ComboFlag=TRUE			ELSE				ComboFlag=FALSE			END IF			IF ControlArray(ControlPtr).PuppetType=1 THEN; Bulletproofing				RETURN			END IF			OwnerPtr=ControlArray(ControlPtr).PuppetOwner			SizeSel=SpiderPtr			CALL SUB InitSpider			IF MultiSelectItemCount=0 THEN				SizeControl=TRUE			END IF		ELSE			IF ControlArray(ControlPtr).PuppetType=8 THEN				ComboFlag=TRUE			ELSE				ComboFlag=FALSE			END IF			IF ControlArray(ControlPtr).PuppetType<>1 THEN; Not Form				ControlCombo.TEXT=ControlArray(ControlPtr).PuppetName				OwnerPtr=ControlArray(ControlPtr).PuppetOwner				IF MultiSelectItemCount>0 THEN					IF ControlArray(ControlPtr).PuppetEars(1)<>0 THEN						MultiItemMove=TRUE						MultiFrameDeltaX=ControlArray(ControlPtr).PuppetLeft-MultiFrameLeft						MultiFrameDeltaY=ControlArray(ControlPtr).PuppetTop-MultiFrameTop					ELSE						CALL SUB RemoveEars					END IF				END IF				MoveControl=TRUE				CALL SUB InitSpider				CALL SUB HideSpiderLegs			ELSE				CALL SUB RemoveEars				ControlCombo.TEXT=FormCombo.TEXT				CALL SUB HideSpiderLegs				DrawBox=TRUE				SETPOSITION Spider(Belly),CursorPosX,CursorPosY,0,0			END IF		END IF		ControlNdx=ControlPtr		ToolButtonNdx=ControlArray(ControlPtr).PuppetType		CALL SUB PopulateToolBox		CALL SUB ControlArrayToToolBox	END IFEND EVENTBEGIN SUB InitSpider	MouseOffsX=CursorPosX-ControlArray(ControlPtr).PuppetLeft	MouseOffsY=CursorPosY-ControlArray(ControlPtr).PuppetTop	SpiderLeft=ControlArray(ControlPtr).PuppetLeft	SpiderTop=ControlArray(ControlPtr).PuppetTop	SpiderWidth=ControlArray(ControlPtr).PuppetWidth	IF ComboFlag=FALSE THEN		SpiderHeight=ControlArray(ControlPtr).PuppetHeight	ELSE		SpiderHeight=25	END IF	Spider(Belly).LEFT=SpiderLeft	Spider(Belly).TOP=SpiderTop	Spider(Belly).WIDTH=SpiderWidth	Spider(Belly).HEIGHT=SpiderHeightEND SUBFormWindow.MOUSEMOVE	IF RBDown=TRUE THEN		RETURN	END IF	GETCURSORPOSITION	IF LBDown=FALSE THEN		IF CursorPosX<ControlArray(CurrentFormPtr).PuppetLeft OR CursorPosX>ControlArray(CurrentFormPtr).PuppetLeft+ControlArray(CurrentFormPtr).PuppetWidth OR CursorPosY<ControlArray(CurrentFormPtr).PuppetTop+20 OR CursorPosY>ControlArray(CurrentFormPtr).PuppetTop+ControlArray(CurrentFormPtr).PuppetHeight THEN			RELEASECAPTURE			StatusBar.SETTEXT 1,"Off Form"			StatusBar.SETTEXT 2,"Off Form"			StatusBar.SETTEXT 3,"Off Form"			SETDEFAULTCURSOR			RETURN		ELSE			IF CaptureEnabled=TRUE THEN				SETCAPTURE FormWindow				IF PlacePart=TRUE THEN					SETSTOCKCURSOR CROSS				END IF			END IF		END IF	END IF	SCREENTOCLIENT FormWindow	TempStr="X-Pos="+STR(CursorPosX)	StatusBar.SETTEXT 1,TempStr	TempStr="Y-Pos="+STR(CursorPosY)	StatusBar.SETTEXT 2,TempStr	IF MoveControl=TRUE THEN		SpiderLeft=CursorPosX-MouseOffsX		SpiderTop=CursorPosY-MouseOffsY		SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight		PropGrid.TEXT(6,2)=STR(CursorPosX-MouseOffsX)		PropGrid.TEXT(7,2)=STR(CursorPosY-MouseOffsY)		IF MultiItemMove=TRUE THEN			CALL SUB MoveMultiFrame		ELSE			CALL SUB RefreshSpider		END IF		EXIT EVENT	END IF	IF DrawBox=TRUE THEN		CALL SUB DrawFrame		EXIT EVENT	END IF	IF PlacePart=TRUE AND LBDown=TRUE THEN		CALL SUB SetChanged		CALL SUB DrawFrame		PropGrid.TEXT(6,2)=STR(SpiderLeft)		PropGrid.TEXT(7,2)=STR(SpiderTop)		PropGrid.TEXT(8,2)=STR(SpiderWidth)		PropGrid.TEXT(9,2)=STR(SpiderHeight)		EXIT EVENT	END IF	IF SizeControl=TRUE THEN		PropGrid.TEXT(6,2)=STR(SpiderLeft)		PropGrid.TEXT(7,2)=STR(SpiderTop)		PropGrid.TEXT(8,2)=STR(SpiderWidth)		PropGrid.TEXT(9,2)=STR(SpiderHeight)		IF SizeSel=E OR SizeSel=SE OR SizeSel=NE THEN			SpiderWidth=CursorPosX-SpiderLeft		END IF		IF SizeSel=S OR SizeSel=SE OR SizeSel=SW THEN			SpiderHeight=CursorPosY-SpiderTop		END IF		IF SizeSel=W OR SizeSel=NW OR SizeSel=SW THEN			SpiderRight=SpiderLeft+SpiderWidth			SpiderLeft=CursorPosX			SpiderWidth=SpiderRight-SpiderLeft		END IF		IF SizeSel=N OR SizeSel=NW OR SizeSel=NE THEN			SpiderBottom=SpiderTop+SpiderHeight			SpiderTop=CursorPosY			SpiderHeight=SpiderBottom-SpiderTop		END IF		SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight		CALL SUB PlaceSpiderLegs		CALL SUB RefreshSpider		EXIT EVENT	END IF	CALL SUB FindControlByPosition	IF SpiderFound=TRUE THEN		;	ELSE		IF ControlFound=TRUE THEN			TempStr=ControlArray(ControlNdx).PuppetName			StatusBar.SETTEXT 3,TempStr		ELSE			StatusBar.SETTEXT 3,CurrentFormName		END IF	END IFEND EVENTBEGIN SUB DrawFrame	IF LeftButtonX<CursorPosX THEN		SpiderLeft=LeftButtonX		SpiderWidth=CursorPosX-LeftButtonX	ELSE		SpiderLeft=CursorPosX		SpiderWidth=LeftButtonX-CursorPosX	END IF	IF LeftButtonY<CursorPosY THEN		SpiderTop=LeftButtonY		SpiderHeight=CursorPosY-LeftButtonY	ELSE		SpiderTop=CursorPosY		SpiderHeight=LeftButtonY-CursorPosY	END IF	SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight	CALL SUB RefreshSpiderEND SUBBEGIN SUB MoveMultiFrame	MultiFrameLeft=SpiderLeft-MultiFrameDeltaX	MultiFrameTop=SpiderTop-MultiFrameDeltaY	SETPOSITION MultiFrame,MultiFrameLeft,MultiFrameTop,MultiFrameWidth,MultiFrameHeight	RectLeft=MultiFrameLeft	RectTop=MultiFrameTop	RectRight=MultiFrameLeft+MultiFrameWidth	RectBottom=MultiFrameTop+MultiFrameHeight	invoke InvalidateRect,[!FormWindow],RectLeft,TRUE	DECR MoveCtr	IF MoveCtr=0 THEN		CALL SUB PaintGrid		MoveCtr=GridSize	END IFEND SUBBEGIN SUB RefreshSpider	RectLeft=SpiderLeft	RectTop=SpiderTop	RectRight=SpiderLeft+SpiderWidth	RectBottom=SpiderTop+SpiderHeight	invoke InvalidateRect,[!FormWindow],RectLeft,TRUE	DECR MoveCtr	IF MoveCtr=0 THEN		CALL SUB PaintGrid		MoveCtr=GridSize	END IFEND SUBBEGIN SUB SpiderPositionToControl	IF ControlArray(ControlPtr).PuppetLeft<>TempLeft THEN		DeltaX=TempLeft-ControlArray(ControlPtr).PuppetLeft		ControlArray(ControlPtr).PuppetLeft=TempLeft		CALL SUB SetChanged	ELSE		DeltaX=0	END IF	IF ControlArray(ControlPtr).PuppetTop<>TempTop THEN		DeltaY=TempTop-ControlArray(ControlPtr).PuppetTop		ControlArray(ControlPtr).PuppetTop=TempTop		CALL SUB SetChanged	ELSE		DeltaY=0	END IF	IF SizeControl=FALSE THEN		invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[SpiderWidth],[SpiderHeight],SWP_SHOWWINDOW+SWP_NOZORDER		invoke SetWindowPos,[TempHandle],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE+SWP_NOZORDER	END IFEND SUBBEGIN SUB SpiderSizeToControl	IF ControlArray(ControlPtr).PuppetWidth<>SpiderWidth THEN		ControlArray(ControlPtr).PuppetWidth=SpiderWidth		CALL SUB SetChanged	END IF	IF ComboFlag=FALSE THEN		IF ControlArray(ControlPtr).PuppetHeight<>SpiderHeight THEN			ControlArray(ControlPtr).PuppetHeight=SpiderHeight			CALL SUB SetChanged		END IF	ELSE		ControlArray(ControlPtr).PuppetHeight=200	END IF	invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[SpiderWidth],[SpiderHeight],SWP_SHOWWINDOW+SWP_NOZORDER	invoke SetWindowPos,[TempHandle],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE+SWP_NOZORDEREND SUBFormWindow.LBUTTONUP	LBDown=FALSE	Spider(Belly).VISIBLE=FALSE	MoveCtr=GridSize	IF MoveControl=TRUE THEN		MoveControl=FALSE		TempHandle=ControlArray(ControlPtr).PuppetHandle		SpiderLeft=CursorPosX-MouseOffsX		SpiderTop=CursorPosY-MouseOffsY		IF SnapToGrid=TRUE THEN			CALL SUB SetSnap		END IF		IF ComboFlag=TRUE THEN			SpiderHeight=25		END IF			CALL SUB PlaceSpiderLegs		TempLeft=SpiderLeft		TempTop=SpiderTop		IF ControlArray(ControlPtr).PuppetType=1 THEN; Bulletproofing			EXIT EVENT		END IF		CALL SUB SpiderPositionToControl		ControlNdx=ControlPtr		CALL SUB ControlArrayToToolBox		IF MultiItemMove=TRUE THEN			FOR ControlNdx=2 TO LastControl				IF ControlNdx<>ControlPtr THEN					IF ControlArray(ControlNdx).PuppetEars(1)<>0 THEN						TempHandle=ControlArray(ControlNdx).PuppetHandle						TempLeft=ControlArray(ControlNdx).PuppetLeft+DeltaX						ControlArray(ControlNdx).PuppetLeft=TempLeft						TempTop=ControlArray(ControlNdx).PuppetTop+DeltaY						ControlArray(ControlNdx).PuppetTop=TempTop						invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],0,0,SWP_NOZORDER+SWP_NOSIZE						CALL SUB MoveEars						CALL SUB MoveMultiFrame					END IF				ELSE					TempLeft=ControlArray(ControlNdx).PuppetLeft					TempTop=ControlArray(ControlNdx).PuppetTop					CALL SUB MoveEars				END IF			NEXT ControlNdx		ELSE			IF ControlArray(ControlPtr).PuppetOwner<>ControlArray(ControlPtr).PuppetForm THEN				ControlArray(ControlPtr).PuppetChildXOffs=TempLeft-ControlArray(ControlArray(ControlPtr).PuppetOwner).PuppetLeft				ControlArray(ControlPtr).PuppetChildYOffs=TempTop-ControlArray(ControlArray(ControlPtr).PuppetOwner).PuppetTop			ELSE				FOR ControlNdx=2 TO LastControl					IF ControlArray(ControlNdx).PuppetOwner=ControlPtr THEN						TempLeft=ControlArray(ControlPtr).PuppetLeft+ControlArray(ControlNdx).PuppetChildXOffs						ControlArray(ControlNdx).PuppetLeft=TempLeft						TempTop=ControlArray(ControlPtr).PuppetTop+ControlArray(ControlNdx).PuppetChildYOffs						ControlArray(ControlNdx).PuppetTop=TempTop						TempHandle=ControlArray(ControlNdx).PuppetHandle						invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],0,0,SWP_NOZORDER+SWP_NOSIZE					END IF				NEXT ControlNdx			END IF		END IF		CALL SUB PaintGrid		CALL SUB RedrawParts		EXIT EVENT	END IF	IF SizeControl=TRUE THEN		SizeControl=FALSE		TempHandle=ControlArray(ControlPtr).PuppetHandle		IF SnapToGrid=TRUE THEN			CALL SUB SetSnap		END IF		IF ComboFlag=TRUE THEN			SpiderHeight=25		END IF		CALL SUB PlaceSpiderLegs		TempLeft=SpiderLeft		TempTop=SpiderTop		IF ControlArray(ControlPtr).PuppetType=1 THEN; Bulletproofing			EXIT EVENT		END IF		CALL SUB SpiderPositionToControl		IF ControlArray(ControlPtr).PuppetOwner<>ControlArray(ControlPtr).PuppetForm THEN			ControlArray(ControlPtr).PuppetChildXOffs=TempLeft-ControlArray(ControlArray(ControlPtr).PuppetOwner).PuppetLeft			ControlArray(ControlPtr).PuppetChildYOffs=TempTop-ControlArray(ControlArray(ControlPtr).PuppetOwner).PuppetTop		END IF			CALL SUB SpiderSizeToControl		ControlNdx=ControlPtr		CALL SUB ControlArrayToToolBox		CALL SUB ScreenRefresh		CALL SUB PaintGrid		CALL SUB RedrawParts		;CALL SUB refresh_command		EXIT EVENT	END IF	IF DrawBox=TRUE THEN		BoxLeft=SpiderLeft		BoxTop=SpiderTop		BoxRight=SpiderLeft+SpiderWidth		BoxBottom=SpiderTop-SpiderHeight		CALL SUB FindBoxContents		CALL SUB HideSpider		DrawBox=FALSE		CALL SUB PaintGrid		CALL SUB RedrawParts		EXIT EVENT	END IF	IF PlacePart=TRUE THEN		ControlPtr=PlacePtr		IF SnapToGrid=TRUE THEN			CALL SUB SetSnap		END IF		IF ComboFlag=TRUE THEN			SpiderHeight=25		END IF		IF ControlArray(OwnerPtr).PuppetType=1 THEN;''			;		END IF		TempLeft=SpiderLeft		TempTop=SpiderTop		TempWidth=SpiderWidth		TempHeight=SpiderHeight		ControlArray(PlacePtr).PuppetLeft=TempLeft		ControlArray(PlacePtr).PuppetTop=TempTop		ControlArray(PlacePtr).PuppetWidth=TempWidth		IF ComboFlag=TRUE THEN			ControlArray(PlacePtr).PuppetHeight=200		ELSE			ControlArray(PlacePtr).PuppetHeight=TempHeight		END IF		IF OwnerPtr=1 THEN			ControlArray(PlacePtr).PuppetOwner=CurrentFormPtr		ELSE			ControlArray(PlacePtr).PuppetOwner=OwnerPtr			ControlArray(PlacePtr).PuppetChildXOffs=TempLeft-ControlArray(OwnerPtr).PuppetLeft			ControlArray(PlacePtr).PuppetChildYOffs=TempTop-ControlArray(OwnerPtr).PuppetTop		END IF		TempOwnerForm=CurrentFormPtr		ControlArray(PlacePtr).PuppetForm=TempOwnerForm		CALL SUB PopulateToolBox		BEGIN LOOP			CALL SUB MakeName			CALL SUB ChkDupControlName			EXIT IF ControlFound=FALSE		END LOOP		ControlArray(PlacePtr).PuppetName=ControlName		ControlArray(PlacePtr).PuppetType=ToolButtonNdx		CALL SUB GetControlID		SELECT CASE ToolButtonNdx			CASE 3; BUTTON				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType2				CALL SUB CreatePuppet			CASE 4; STATICTEXT					TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType26				CALL SUB CreatePuppet			CASE 5; FRAME				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType6				CALL SUB CreatePuppet			CASE 6; SLIDER				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType8				CALL SUB CreatePuppet			CASE 7; TEXTBOX				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType5				CALL SUB CreatePuppet			CASE 8; COMBOBOX				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType4				CALL SUB CreatePuppet			CASE 9; LISTBOX				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType7				CALL SUB CreatePuppet			CASE 10; RADIOBUTTON						TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType19				CALL SUB CreatePuppet			CASE 11; CHECKBOX				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType18				CALL SUB CreatePuppet			CASE 12; PROGRESSBAR				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType10				CALL SUB CreatePuppet			CASE 13; CALENDAR				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType11				CALL SUB CreatePuppet			CASE 14; TABFOLDER				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType14				CALL SUB CreatePuppet			CASE 20; RAEdit				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType22				CALL SUB CreatePuppet			CASE 21; RAGrid				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType23				CALL SUB CreatePuppet			CASE 22; LISTVIEW				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType25				CALL SUB CreatePuppet			CASE 24; TREEVIEW				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType13				CALL SUB CreatePuppet			CASE 25; DATETIMEPICK				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType32				CALL SUB CreatePuppet			CASE 26; IMAGE				TempStr="***"				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType33				CALL SUB CreatePuppet			CASE 27; DRAWPROGRESS				TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType30				CALL SUB CreatePuppet			CASE 28; ButtonEx					TempStr=ControlArray(PlacePtr).PuppetName				ControlArray(PlacePtr).PuppetText=TempStr				mov [TempControlType],!ControlType35				CALL SUB CreatePuppet		END SELECT		ControlArray(PlacePtr).PuppetForeColor=0		IF ToolButtonNdx=20 THEN			ControlArray(PlacePtr).PuppetBackColor=$c0f0f0		ELSE			IF ToolButtonNdx=21 THEN				ControlArray(PlacePtr).PuppetBackColor=$ffffff			ELSE				IF ToolButtonNdx=12 THEN					ControlArray(PlacePtr).PuppetBackColor=$c0c0c0					ControlArray(PlacePtr).PuppetForeColor=$800000				ELSE					Timer3.TIME=100				END IF			END IF		END IF		ControlArray(PlacePtr).PuppetControlType=TempControlType		ControlArray(PlacePtr).PuppetStatus=$07		invoke SetWindowPos,[TempInt],HWND_TOP,0,0,0,0,SWP_NOMOVE+SWP_NOSIZE+SWP_NOZORDER		CALL SUB PlaceSpiderLegs		ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName		ControlCombo.TEXT=ControlArray(PlacePtr).PuppetName		EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName		HiliteControlName=ControlArray(PlacePtr).PuppetName		CALL SUB AddHiliteName		EventCombo1.TEXT="Select Control"		ControlArray(PlacePtr).PuppetArrayNdx=-1		ControlNdx=PlacePtr		;CALL SUB PopulateToolBox		CALL SUB ControlArrayToToolBox		PlacePart=FALSE		PlaceArray=FALSE		SETDEFAULTCURSOR	END IF	CALL SUB PaintGrid	CALL SUB RedrawPartsEND EVENTBEGIN SUB MakeName	ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1	ControlName=ToolPropMap(ToolButtonNdx).PropMapName+STR(ToolPropMap(ToolButtonNdx).PropMapCount)END SUBBEGIN SUB CreatePuppet	invoke CreateWindowEx,[TempExStyle],[TempControlType],[TempStr],[TempStyle],[TempLeft],[TempTop],[TempWidth],[TempHeight], dword [!FormWindow],dword [ControlID],[!hinstance],0	mov [TempInt],eax	ControlArray(PlacePtr).PuppetHandle=TempInt	IF ControlArray(PlacePtr).PuppetType=8 THEN; ComboBox		invoke GetComboBoxInfo,[TempInt],!cbSize		mov eax,[!hwndCombo]		mov [TempInt2],eax		ControlArray(PlacePtr).PuppethwndCombo=TempInt2		mov eax,[!hwndItem]		mov [TempInt2],eax		ControlArray(PlacePtr).PuppethwndItem=TempInt2		mov eax,[!hwndList]		mov [TempInt2],eax		ControlArray(PlacePtr).PuppethwndList=TempInt2		invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]	END IF	IF ControlArray(PlacePtr).PuppetType=9 THEN; ListBox		invoke SendMessage, dword [TempInt],LB_INSERTSTRING,-1,[TempStr]	END IF		IF ControlArray(PlacePtr).PuppetType=12 THEN; ProgressBar			invoke SendMessage, dword [TempInt],PBM_SETPOS,50,0		END IF	IF ControlArray(PlacePtr).PuppetType=14 THEN; TabFolder		TempStr=ControlArray(PlacePtr).PuppetName		mov eax,[TempStr]		mov [!TC_ITEMText],eax		mov [!TC_ITEMTextMax],10		mov [!TC_ITEMmask],TCIF_TEXT		invoke SendMessage,dword [TempInt],TCM_INSERTITEM,1,!TC_ITEMmask		TempStr="Tab2"		mov eax,[TempStr]		mov [!TC_ITEMText],eax		mov [!TC_ITEMTextMax],5		mov [!TC_ITEMmask],TCIF_TEXT		invoke SendMessage,dword [TempInt],TCM_INSERTITEM,2,!TC_ITEMmask		TempStr="Tab3"		mov eax,[TempStr]		mov [!TC_ITEMText],eax		mov [!TC_ITEMTextMax],5		mov [!TC_ITEMmask],TCIF_TEXT		invoke SendMessage,dword [TempInt],TCM_INSERTITEM,3,!TC_ITEMmask	END IF	IF ControlArray(PlacePtr).PuppetType=20 THEN; RAEdit		invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]	END IF	IF ControlArray(PlacePtr).PuppetType=21 THEN; RAGrid		invoke SendMessage,[TempInt],GM_SETHDRHEIGHT,0,21		TempStr=ControlArray(PlacePtr).PuppetName		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		mov [gc_ctype],TYPE_EDITTEXT		mov eax,100		mov [gc_colwt],eax		mov eax,[_TmpVec1]		mov [gc_halign],GA_ALIGN_CENTER		mov [gc_calign],GA_ALIGN_LEFT		mov eax,31		mov [gc_ctextmax],eax		mov [gc_lpszformat],0		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 2"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 3"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 4"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 5"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 6"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 7"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 8"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 9"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		TempStr="Header 10"		mov eax,[TempStr]		mov [gc_lpszhdrtext],eax		invoke SendMessage,dword [TempInt],GM_ADDCOL,0,gc_colwt		FOR I=1 TO 100			invoke SendMessage,dword [TempInt],GM_ADDROW,0,0		NEXT I	END IF	IF ControlArray(PlacePtr).PuppetType=27 THEN; Image		;invoke SendMessage, dword [TempHandle],STM_SETIMAGE,IMAGE_BITMAP,[ImageBMP]	END IFEND SUBBEGIN SUB ScreenRefresh	FormWindow.VISIBLE=FALSE	FormWindow.VISIBLE=TRUE	;CALL SUB PaintGrid	;ALL SUB RedrawPartsEND SUBTimer3.TIMEOUT	Timer3.STOP	TempInt=ControlArray(PlacePtr).PuppetHandle	invoke GetDC,[TempInt]	invoke GetPixel,eax,2,2	mov [TempInt2],eax	ControlArray(PlacePtr).PuppetBackColor=TempInt2	PropGrid.TEXT(10,2)="$"+HEX(TempInt2)END EVENTBEGIN SUB FindControlByPosition	SpiderFound=FALSE	ControlFound=FALSE	IF SpiderPlaced=TRUE AND PlacePart=FALSE THEN		FOR SpiderNdx=2 TO 9			IF CursorPosX>=Spider(SpiderNdx).LEFT AND CursorPosX<=Spider(SpiderNdx).RIGHT AND CursorPosY>=Spider(SpiderNdx).TOP AND CursorPosY<=Spider(SpiderNdx).BOTTOM THEN				SpiderPtr=SpiderNdx				SpiderFound=TRUE				IF MultiSelectItemCount=0 THEN					SELECT CASE SpiderNdx						CASE NW							SETSTOCKCURSOR SIZENWSE						CASE N							SETSTOCKCURSOR SIZENS						CASE NE							SETSTOCKCURSOR SIZENESW						CASE W							SETSTOCKCURSOR SIZEWE						CASE E							SETSTOCKCURSOR SIZEWE						CASE SW							SETSTOCKCURSOR SIZENESW						CASE S							SETSTOCKCURSOR SIZENS						CASE SE							SETSTOCKCURSOR SIZENWSE					END SELECT				END IF				EXIT SUB			END IF		NEXT SpiderNdx	END IF	IF PlacePart=FALSE THEN		SETDEFAULTCURSOR	END IF	ControlNdx=LastControl+1	BEGIN LOOP		DECR ControlNdx		IF ControlNdx=1 THEN			OverControl=CurrentFormPtr			EXIT SUB		END IF		CALL SUB GetPuppetPosition		IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinVisible)=TRUE AND ControlArray(ControlNdx).PuppetForm=CurrentFormPtr AND ControlArray(ControlNdx).PuppetType<>1 THEN			IF CursorPosX>=TempLeft AND CursorPosX<=TempLeft+TempWidth AND CursorPosY>=TempTop AND CursorPosY<=TempTop+TempHeight THEN				ControlFound=TRUE				OverControl=ControlNdx				EXIT SUB			END IF		END IF	END LOOPEND SUBBEGIN SUB FindBoxContents	MultiFrameLeft=$7fffffff	MultiFrameTop=$7fffffff	MultiFrameWidth=0	MultiFrameHeight=0	ControlNdx=LastControl+1	IF LeftButtonX<CursorPosX THEN		BoxLeft=LeftButtonX		BoxRight=CursorPosX		TempBool=TRUE	ELSE		BoxLeft=CursorPosX		BoxRight=LeftButtonX		TempBool=FALSE	END IF	IF LeftButtonY<CursorPosY THEN		BoxTop=LeftButtonY		BoxBottom=CursorPosY	ELSE		BoxTop=CursorPosY		BoxBottom=LeftButtonY	END IF	BEGIN LOOP		DECR ControlNdx		IF ControlNdx=1 THEN			MultiFrameLeft=MultiFrameLeft-8			MultiFrameTop=MultiFrameTop-8			MultiFrameWidth=MultiFrameWidth-MultiFrameLeft+8			MultiFrameHeight=MultiFrameHeight-MultiFrameTop+8			SETPOSITION MultiFrame,MultiFrameLeft,MultiFrameTop,MultiFrameWidth,MultiFrameHeight			MultiFrame.VISIBLE=TRUE			EXIT SUB		END IF		CALL GetPuppetPosition		IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinVisible)=TRUE AND ControlArray(ControlNdx).PuppetForm=CurrentFormPtr AND ControlArray(ControlNdx).PuppetType<>1 THEN			IF TempBool=FALSE THEN				IF BoxBottom>TempTop AND BoxTop<TempTop+TempHeight AND BoxLeft<TempLeft+TempWidth AND BoxRight>TempLeft THEN					CALL SUB PuppetInBox				END IF			ELSE				IF BoxBottom>TempTop+TempHeight AND BoxTop<TempTop AND BoxLeft<TempLeft AND BoxRight>TempLeft+TempWidth THEN					CALL SUB PuppetInBox				END IF			END IF		END IF	END LOOPEND SUBBEGIN SUB PuppetInBox	CALL SUB AttachEars	INCR MultiSelectItemCount	IF TempLeft<MultiFrameLeft THEN		MultiFrameLeft=TempLeft	END IF	IF TempTop<MultiFrameTop THEN		MultiFrameTop=TempTop	END IF	IF TempLeft+TempWidth>MultiFrameWidth THEN		MultiFrameWidth=TempLeft+TempWidth	END IF	IF TempTop+TempHeight>MultiFrameHeight THEN		MultiFrameHeight=TempTop+TempHeight	END IFEND SUBBEGIN SUB PopulateToolBox	CALL SUB PopulatePropGrid	CALL SUB PopulateStyleGrid	CALL SUB PopulateExStyleGridEND SUBBEGIN SUB PopulatePropGrid	PropGrid.GRIDCLEAR	SETVECTOR PropArray=[ToolPropMap(ToolButtonNdx).PropMapPropTable]	FOR I=1 TO 16		PropGrid.ADDROW		PropGrid.TEXT(I,1)=UCASE(PropArray(I).PropName)		IF PropArray(I).PropValid=TRUE THEN			PropValidTable(I)=TRUE		ELSE			PropValidTable(I)=FALSE			PropGrid.TEXT(I,2)="***"		END IF	NEXT IEND SUBBEGIN SUB PopulateStyleGrid	StyleGrid.GRIDCLEAR	IF PlacePart=TRUE THEN		TempStyle=0	ELSE		TempStyle=ControlArray(ControlPtr).PuppetStyle	END IF	SETVECTOR StyleArray=[ToolPropMap(ToolButtonNdx).PropMapStyleTable]	I=2	StyleGridRow=0	BEGIN LOOP		INCR I		IF StyleArray(I).StyleName="%" THEN			EXIT SUB		END IF		CONTINUE IF StyleArray(I).StyleType=EXSTYLE		StyleGrid.ADDROW		INCR StyleGridRow		StyleGrid.TEXT(StyleGridRow,1)=UCASE(StyleArray(I).StyleName)		IF PlacePart=TRUE THEN			IF StyleArray(I).StyleDefault=TRUE THEN				StyleGrid.VALUE(StyleGridRow,2)=1				TempStyle=TempStyle+StyleArray(I).StyleValue				ControlArray(PlacePtr).PuppetStyle=TempStyle			END IF		ELSE			TempInt=StyleArray(I).StyleValue			IF LAND(TempInt,TempStyle)=TempInt THEN				StyleGrid.VALUE(StyleGridRow,2)=1			END IF		END IF		CALL SUB MakeHex8		TempStr=TempStr+HEX(StyleArray(I).StyleValue)		StyleGrid.TEXT(StyleGridRow,3)=TempStr	END LOOPEND SUBBEGIN SUB PopulateExStyleGrid	ExStyleGrid.GRIDCLEAR	IF PlacePart=TRUE THEN		TempExStyle=0	ELSE		TempExStyle=ControlArray(ControlPtr).PuppetExStyle	END IF	SETVECTOR StyleArray=[ToolPropMap(ToolButtonNdx).PropMapStyleTable]	I=2	ExStyleGridRow=0	BEGIN LOOP		INCR I		IF StyleArray(I).StyleName="%" THEN			EXIT SUB		END IF		CONTINUE IF StyleArray(I).StyleType=STYLE		ExStyleGrid.ADDROW		INCR ExStyleGridRow		ExStyleGrid.TEXT(ExStyleGridRow,1)=UCASE(StyleArray(I).StyleName)		IF PlacePart=TRUE THEN			IF StyleArray(I).StyleDefault=TRUE THEN				ExStyleGrid.VALUE(ExStyleGridRow,2)=1				TempExStyle=TempExStyle+StyleArray(I).StyleValue				ControlArray(PlacePtr).PuppetExStyle=TempExStyle			END IF		ELSE			TempInt=StyleArray(I).StyleValue			IF LAND(TempInt,TempStyle)=TempInt THEN				ExStyleGrid.VALUE(ExStyleGridRow,2)=1			END IF		END IF		CALL SUB MakeHex8		TempStr=TempStr+HEX(StyleArray(I).StyleValue)		ExStyleGrid.TEXT(ExStyleGridRow,3)=TempStr	END LOOPEND SUBBEGIN SUB MakeHex8	SELECT CASE LEN(HEX(StyleArray(I).StyleValue))		CASE 1			TempStr="   $0000000"		CASE 2			TempStr="   $000000"		CASE 3			TempStr="   $00000"		CASE 4			TempStr="   $0000"		CASE 5			TempStr="   $000"		CASE 6			TempStr="   $00"		CASE 7			TempStr="   $0"		CASE 8			TempStr="   $"		END SELECTEND SUBBEGIN SUB ColorChangeTrap	cmp [!Desc],0	je NotDesc	PASSEVENT	ret	NotDesc:	FOR PI=2 TO LastControl		IF ControlArray(PI).PuppetHandle=lparam OR ControlArray(PI).PuppethwndCombo=lparam OR ControlArray(PI).PuppethwndItem=lparam OR ControlArray(PI).PuppethwndList=lparam THEN			PTempInt=ControlArray(PI).PuppetStatus			PTempInt=LAND(PTempInt,$18)			IF PTempInt<>0 THEN				IF PTempInt=$08 THEN					PTempInt=ControlArray(PI).PuppetBackColor					mov eax,[PTempInt]					mov [!dsBackColor],eax					call !BackColorChange					jmp !Finish				ELSE							IF PTempInt=$10 OR PTempInt=$18 THEN						PTempInt=ControlArray(PI).PuppetBackColor						mov eax,[PTempInt]						mov [!dsBackColor],eax						PTempInt=ControlArray(PI).PuppetForeColor						mov eax,[PTempInt]						mov [!dsForeColor],eax						call !BothColorChange						jmp !Finish										END IF				END IF				EXIT SUB			END IF		END IF	NEXT PI	PASSEVENTEND SUBToolButton.COMMAND	ToolButtonNdx=ArrayIndex	PlacePtr=0	CALL SUB RemoveEars	CALL SUB ToolButtonActionEND EVENTBEGIN SUB ToolButtonAction	INCR ControlCount	IF ControlCount>ControlTableSize THEN		DECR ControlCount		WARNINGBOX "OmniBasic","Out of Control Space",MB_OK		EXIT SUB	END IF	SELECT CASE ToolButtonNdx		CASE 1; Form			FormNotChanged=TRUE			IF LoadToolsFlag=FALSE THEN				TempLeft=340				TempTop=150				TempWidth=640				TempHeight=480			ELSE				TempLeft=ControlArray(PlacePtr).PuppetLeft				TempTop=ControlArray(PlacePtr).PuppetTop				TempWidth=ControlArray(PlacePtr).PuppetWidth				TempHeight=ControlArray(PlacePtr).PuppetHeight			END IF			IF FormWindow.CREATED=FALSE THEN				CREATE FormWindow,TempLeft,TempTop,TempWidth,TempHeight, CHILD				ControlArray(PlacePtr).PuppetName="OBMain"				IF LoadToolsFlag=FALSE THEN					ControlArray(PlacePtr).PuppetText="OBMain"				END IF				TrapColorChangeEvent ColorChangeTrap				ControlArray(PlacePtr).PuppetName=CurrentFormName				CREATE Spider(Belly),0,0,0,0,BASE+WHITEFRAME IN FormWindow				Spider(Belly).BRINGTOFRONT				Spider(Belly).BACKCOLOR=$ffffffff				Spider(Belly).VISIBLE=FALSE				CREATE MultiFrame,0,0,0,0,BASE+WHITEFRAME IN FormWindow				MultiFrame.BACKCOLOR=$ffffffff				MultiFrame.VISIBLE=FALSE				FOR I=2 TO 9					CREATE Spider(I),0,0,0,0,BASE+WHITEFRAME IN FormWindow					Spider(I).BRINGTOFRONT					Spider(I).VISIBLE=FALSE				NEXT I				LastKey=TABLESIZE(KeyTable)				FOR KeyNdx=1 TO LastKey					KeyTable(KeyNdx).KeyCheckWord=CHKWORD(KeyTable(KeyNdx).KeyName)				NEXT KeyNdx				;CALL SUB PaintGrid				;CALL SUB RedrawParts			ELSE				IF PlacePtr<>1 THEN					CALL SUB FindEmptyControlSlot					ControlPtr=PlacePtr					ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1					ControlArray(PlacePtr).PuppetName="Form"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)					ControlArray(PlacePtr).PuppetText=ControlArray(PlacePtr).PuppetName				END IF				SETPOSITION FormWindow,TempLeft,TempTop,TempWidth,TempHeight			END IF			ControlNdx=CurrentFormPtr			CALL SUB HideObjects			CurrentFormName=ControlArray(PlacePtr).PuppetName			CurrentFormPtr=PlacePtr			ControlArray(PlacePtr).PuppetHandle=$ffffffff			ControlArray(PlacePtr).PuppetType=1			ControlArray(PlacePtr).PuppetStyle=$10cf0000			IF LoadToolsFlag=FALSE THEN				invoke GetSysColor,COLOR_BTNFACE				mov [RGB],eax				ControlArray(PlacePtr).PuppetBackColor=RGB			END IF			FormWindow.BACKCOLOR=ControlArray(PlacePtr).PuppetBackColor			FormWindow.TEXT=ControlArray(PlacePtr).PuppetText			ControlArray(PlacePtr).PuppetText=ControlArray(PlacePtr).PuppetName			FormCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetText			FormCombo.TEXT=ControlArray(PlacePtr).PuppetText			ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName			EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName			HiliteControlName=ControlArray(PlacePtr).PuppetName			CALL SUB AddHiliteName			EventCombo1.TEXT="Select Control"			EventCombo1.ENABLED=TRUE			ControlCombo.TEXT=ControlArray(PlacePtr).PuppetText			ControlArray(PlacePtr).PuppetArrayNdx=-1			ControlArray(PlacePtr).PuppetLeft=TempLeft			ControlArray(PlacePtr).PuppetTop=TempTop			ControlArray(PlacePtr).PuppetWidth=TempWidth			ControlArray(PlacePtr).PuppetHeight=TempHeight			ControlArray(PlacePtr).PuppetStatus=$03			ControlNdx=PlacePtr			CALL SUB ControlArrayToToolBox			FormNotChanged=FALSE			EXIT SUB		CASE 2; ToolWindow			EXIT SUB			CASE 3; BUTTON		CASE 4; STATICTEXT		CASE 5; FRAME		CASE 6; SLIDER		CASE 7; TEXTBOX		CASE 8; COMBOBOX		CASE 9; LISTBOX		CASE 10; RADIOBUTTON		CASE 11; CHECKBOX		CASE 12; PROGRESSBAR		CASE 13; CALENDAR			CASE 14; TABFOLDER		CASE 16; STATUSBAR			CALL SUB CreateStatusBar			EXIT SUB		CASE 20; RAEdit		CASE 21; RAGrid			CASE 22; LISTVIEW			CASE 23; TOOLBAR			CALL SUB CreateToolBar			EXIT SUB		CASE 24; TREEVIEW			CASE 25; DATETIMEPICK			CASE 26; IMAGE		CASE 27; DRAWPROGRESS			CASE 28; ButtonEx					CASE ELSE			EXIT SUB	END SELECT	PlacePart=TRUE	CALL SUB PaintGrid	CALL SUB RedrawParts	CALL SUB HideSpider	CALL SUB FindEmptyControlSlotEND SUBBEGIN SUB CreateStatusBar	CALL SUB FindEmptyControlSlot	CALL SUB GetControlID	ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1			ControlArray(PlacePtr).PuppetName="Status"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)	ControlArray(PlacePtr).PuppetText="***"	ControlArray(PlacePtr).PuppetArrayNdx=-1	ControlArray(PlacePtr).PuppetType=16	ControlArray(PlacePtr).PuppetOwner=1	invoke CreateWindowEx,0,!ControlType17,NULL,$50000810,0,0,0,0, dword [!FormWindow],dword [TempInt],[!hinstance],0	mov [TempHandle],eax	ControlArray(PlacePtr).PuppetHandle=TempHandle	ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName	EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName	HiliteControlName=ControlArray(PlacePtr).PuppetName	CALL SUB AddHiliteName	ControlCombo.TEXT=ControlArray(PlacePtr).PuppetName	invoke GetClientRect,[TempHandle],RectLeft	ControlArray(PlacePtr).PuppetLeft=RectLeft	ControlArray(PlacePtr).PuppetTop=RectTop	TempInt2=RectRight-RectLeft	ControlArray(PlacePtr).PuppetWidth=TempInt2	TempInt2=RectBottom-RectTop	ControlArray(PlacePtr).PuppetHeight=TempInt2	ControlArray(PlacePtr).PuppetForeColor=0	ControlArray(PlacePtr).PuppetStatus=$07	ControlNdx=PlacePtr	CALL SUB ControlArrayToToolBoxEND SUBBEGIN SUB CreateToolBar	CALL SUB FindEmptyControlSlot	CALL SUB GetControlID	ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1			ControlArray(PlacePtr).PuppetName="ToolBar"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)	ControlArray(PlacePtr).PuppetText="***"	ControlArray(PlacePtr).PuppetArrayNdx=-1	ControlArray(PlacePtr).PuppetType=23	ControlArray(PlacePtr).PuppetOwner=1	invoke CreateWindowEx,0,!ControlType16,NULL,$50000810,0,0,0,0, dword [!FormWindow],dword [TempInt],[!hinstance],0	mov [TempHandle],eax	ControlArray(PlacePtr).PuppetHandle=TempHandle	ControlCombo.ADDITEMSORTED ControlArray(PlacePtr).PuppetName	EventCombo1.ADDITEMSORTED ControlArray(PlacePtr).PuppetName	HiliteControlName=ControlArray(PlacePtr).PuppetName	CALL SUB AddHiliteName	ControlCombo.TEXT=ControlArray(PlacePtr).PuppetName	invoke GetClientRect,[TempHandle],RectLeft	ControlArray(PlacePtr).PuppetLeft=0; Temporary	ControlArray(PlacePtr).PuppetTop=0; Temporary	TempInt2=RectRight-RectLeft	ControlArray(PlacePtr).PuppetWidth=TempInt2	TempInt2=RectBottom-RectTop	ControlArray(PlacePtr).PuppetHeight=TempInt2	ControlArray(PlacePtr).PuppetForeColor=0	ControlArray(PlacePtr).PuppetStatus=$07	ControlNdx=PlacePtr	CALL SUB ControlArrayToToolBoxEND SUBBEGIN SUB AddHiliteName	szControlNames=szControlNames+" "+TempControlName	Edit.SETHILITEWORDS szControlNames,$FF00FFEND SUBBEGIN SUB FindEmptyControlSlot	FOR PlacePtr=1 TO LastControl+1		IF ControlArray(PlacePtr).PuppetHandle=0 THEN			IF PlacePtr>LastControl THEN				INCR LastControl			END IF			IF LastControl>ControlTableSize THEN				LastControl=ControlTableSize				ControlNdx=0			END IF			CALL SUB SetChanged			EXIT SUB		END IF	NEXT PlacePtr	PlacePtr=0END SUBFormWindow.MOVE	ControlPtr=CurrentFormPtr	GetWindowRect FormWindow	IF FormNotChanged=FALSE THEN		CALL SUB SetChanged		ControlArray(ControlPtr).PuppetLeft=RectLeft		ControlArray(ControlPtr).PuppetTop=RectTop	END IF	ControlCombo.TEXT=FormCombo.TEXT	ControlNdx=ControlPtr	CALL SUB ControlArrayToToolBox	CALL SUB PaintGrid	CALL SUB RedrawPartsEND EVENTFormWindow.RESIZE	ControlPtr=CurrentFormPtr	GetWindowRect FormWindow	IF FormNotChanged=FALSE THEN		CALL SUB SetChanged		ControlArray(ControlPtr).PuppetWidth=RectRight-RectLeft		ControlArray(ControlPtr).PuppetHeight=RectBottom-RectTop	END IF	ControlCombo.TEXT=FormCombo.TEXT	ControlNdx=ControlPtr	CALL SUB ControlArrayToToolBox	CALL SUB PaintGrid	CALL SUB RedrawPartsEND EVENTBEGIN SUB CleanControl	TempHandle=ControlArray(ControlPtr).PuppetHandle	IF ControlArray(ControlPtr).PuppetType<>1 THEN		invoke DestroyWindow,[TempHandle]	END IF	ControlArray(ControlPtr).PuppetHandle=0	ControlArray(ControlPtr).PuppetID=0	ControlArray(ControlPtr).PuppetOwner=0	ControlArray(ControlPtr).PuppetArrayNdx=-1	ControlArray(ControlPtr).PuppetLeft=0	ControlArray(ControlPtr).PuppetTop=0	ControlArray(ControlPtr).PuppetWidth=0	ControlArray(ControlPtr).PuppetHeight=0	ControlArray(ControlPtr).PuppetBackColor=0	ControlArray(ControlPtr).PuppetForeColor=0	ControlArray(ControlPtr).PuppetType=0	ControlArray(ControlPtr).PuppetStatus=0	ControlArray(ControlPtr).PuppetFamily=0	ControlArray(ControlPtr).PuppetGroup=0	FOR K=1 TO 4		IF ControlArray(ControlPtr).PuppetEars(K)<>0 THEN			TempHandle=ControlArray(ControlPtr).PuppetEars(K)			invoke DestroyWindow,[TempHandle]			ControlArray(ControlPtr).PuppetEars(K)=0		END IF	NEXT K	ControlArray(ControlPtr).PuppetControlType=0	ControlArray(ControlPtr).PuppetArraySize=0	ControlArray(ControlPtr).PuppetFont=0	ControlArray(ControlPtr).PuppetForm=0	ControlArray(ControlPtr).PuppethwndCombo=0	ControlArray(ControlPtr).PuppethwndItem=0	ControlArray(ControlPtr).PuppethwndList=0	ControlArray(ControlPtr).PuppetIcon=0	ControlArray(ControlPtr).PuppetStyle=0	ControlArray(ControlPtr).PuppetExStyle=0	ControlArray(ControlPtr).PuppetText=""	ControlArray(ControlPtr).PuppetName=""	ControlArray(ControlPtr).PuppetImage=""	ControlArray(ControlPtr).PuppetToolTip=""END SUBBEGIN SUB ControlArrayToToolBox	PropGrid.TEXT(1,2)=ControlArray(ControlNdx).PuppetName	IF ControlArray(ControlNdx).PuppetOwner=0 THEN		PropGrid.TEXT(2,2)="None"	ELSE		PropGrid.TEXT(2,2)=ControlArray(ControlArray(ControlNdx).PuppetOwner).PuppetName	END IF	IF ControlArray(ControlNdx).PuppetArrayNdx<1 THEN		PropGrid.TEXT(3,2)="***"	ELSE		PropGrid.TEXT(3,2)=STR(ControlArray(ControlNdx).PuppetArrayNdx)	END IF	IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinVisible)=TRUE THEN		PropGrid.TEXT(4,2)="TRUE"	ELSE	PropGrid.TEXT(4,2)="FALSE"	END IF	IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinEnabled)=TRUE THEN		PropGrid.TEXT(5,2)="TRUE"	ELSE		PropGrid.TEXT(5,2)="FALSE"	END IF	PropGrid.TEXT(6,2)=STR(ControlArray(ControlNdx).PuppetLeft)	PropGrid.TEXT(7,2)=STR(ControlArray(ControlNdx).PuppetTop)	PropGrid.TEXT(8,2)=STR(ControlArray(ControlNdx).PuppetWidth)	PropGrid.TEXT(9,2)=STR(ControlArray(ControlNdx).PuppetHeight)	PropGrid.TEXT(10,2)="$"+HEX(ControlArray(ControlNdx).PuppetBackColor)	PropGrid.TEXT(11,2)="$"+HEX(ControlArray(ControlNdx).PuppetForeColor)	PropGrid.TEXT(12,2)=ControlArray(ControlNdx).PuppetText	PropGrid.TEXT(14,2)=ControlArray(ControlNdx).PuppetImage	PropGrid.TEXT(15,2)=ControlArray(ControlNdx).PuppetToolTipEND SUBPropGrid.BUTTONCLICK	CALL SUB SetChanged	SELECT CASE GridRow		TempHandle=ControlArray(ControlPtr).PuppetHandle		CASE 4; Visible			IF BITTST(ControlArray(ControlPtr).PuppetStatus,WinVisible)=TRUE THEN				PropGrid.TEXT(GridRow,2)="FALSE"				ControlArray(ControlPtr).PuppetStatus=BITCLR(ControlArray(ControlPtr).PuppetStatus,WinVisible)				invoke ShowWindow, dword [TempHandle],SW_HIDE				CALL SUB HideSpider			ELSE				PropGrid.TEXT(GridRow,2)="TRUE"				ControlArray(ControlPtr).PuppetStatus=BITSET(ControlArray(ControlPtr).PuppetStatus,WinVisible)				invoke ShowWindow, dword [TempHandle],SW_SHOW				CALL SUB PlaceSpider			END IF		CASE 5; Enabled			IF BITTST(ControlArray(ControlPtr).PuppetStatus,WinEnabled)=TRUE THEN				PropGrid.TEXT(GridRow,2)="FALSE"				ControlArray(ControlPtr).PuppetStatus=BITCLR(ControlArray(ControlPtr).PuppetStatus,WinEnabled)				invoke EnableWindow, dword [TempHandle],FALSE				ELSE				PropGrid.TEXT(GridRow,2)="TRUE"				ControlArray(ControlPtr).PuppetStatus=BITSET(ControlArray(ControlPtr).PuppetStatus,WinEnabled)				invoke EnableWindow, dword [TempHandle],TRUE			END IF		CASE 10; BackColor			IF PropValidTable(10)=FALSE THEN				EXIT EVENT			END IF			CaptureEnabled=FALSE			COLORDIALOG RGB			IF RGB<>$ffffffff THEN				CALL SUB SetBackColor				CALL SUB ScreenRefresh			END IF			CaptureEnabled=TRUE		CASE 11; ForeColor			IF PropValidTable(11)=FALSE THEN				EXIT EVENT			END IF			CaptureEnabled=FALSE			COLORDIALOG RGB			IF RGB<>$ffffffff THEN				CALL SUB SetForeColor				CALL SUB ScreenRefresh			END IF			CaptureEnabled=TRUE		CASE 14; BITMAP			IF PropValidTable(14)=FALSE THEN				EXIT EVENT			END IF			CaptureEnabled=FALSE			BMPInitDir="C:\"			BMPFileFilter="Bitmap",0,"*.bmp",0,"JPG",0,"*.jpg",0,"GIF",0,"*.gif",0,"WMF",0,"*.wmf",0,0			OPENDIALOG BMPFileName,BMPFileFilter,BMPInitDir 			IF STATUS<>0 THEN				LOAD ToolBitmap,BMPFileName				invoke SendMessage, dword [TempHandle],STM_SETIMAGE,IMAGE_BITMAP,eax				PropGrid.TEXT(14,2)=BMPFileName				ControlArray(ControlPtr).PuppetImage=BMPFileName			END IF			CaptureEnabled=TRUE	END SELECTEND EVENTStyleGrid.CHECKCLICK	CALL SUB SetChanged	TempStr=StyleGrid.TEXT(GridRow,3)	TempStr=RIGHT(TempStr,9)	IF StyleGrid.VALUE(GridRow,2)=0 THEN		ControlArray(ControlPtr).PuppetStyle=ControlArray(ControlPtr).PuppetStyle+VAL(TempStr)	ELSE		ControlArray(ControlPtr).PuppetStyle=ControlArray(ControlPtr).PuppetStyle-VAL(TempStr)	END IF	TempInt=ControlArray(ControlPtr).PuppetStyle	IF ControlArray(ControlPtr).PuppetType=1 THEN; Form		EXIT EVENT	END IF	TempHandle=ControlArray(ControlPtr).PuppetHandle	invoke SetWindowLong, dword [TempHandle],GWL_STYLE,[TempInt]	invoke InvalidateRect, dword [TempHandle],NULL,TRUEEND EVENTExStyleGrid.CHECKCLICK	CALL SUB SetChanged	TempStr=ExStyleGrid.TEXT(GridRow,3)	TempStr=RIGHT(TempStr,9)	IF ExStyleGrid.VALUE(GridRow,2)=0 THEN		ControlArray(ControlPtr).PuppetExStyle=ControlArray(ControlPtr).PuppetExStyle+VAL(TempStr)	ELSE		ControlArray(ControlPtr).PuppetExStyle=ControlArray(ControlPtr).PuppetExStyle-VAL(TempStr)	END IFEND EVENTBEGIN SUB SetChanged	Changed=TRUE	Button(3).ENABLED=TRUE	StatusBar.SETTEXT 5,"Changed"	ENABLEMENUITEM MainMenu,mnuSave,TRUEEND SUBStyleGrid.HEADERCLICK	IF GridCol=1 THEN		StyleGrid.VISIBLE=FALSE		ExStyleGrid.VISIBLE=TRUE	END IFEND EVENTExStyleGrid.HEADERCLICK	IF GridCol=1 THEN		ExStyleGrid.VISIBLE=FALSE		StyleGrid.VISIBLE=TRUE	END IFEND EVENTPropGrid.AFTERSELCHANGE	IF GridCol=2 THEN		; Need to check here if form or control ***********************		TempHandle=ControlArray(ControlPtr).PuppetHandle		SELECT CASE GridRow			CASE 1				ControlName=PropGrid.TEXT(1,2)				ControlNameSafe=ControlArray(ControlPtr).PuppetName				IF ControlNameSafe="OBMain" THEN					PropGrid.TEXT(1,2)="OBMain"					EXIT EVENT				END IF				IF ControlName=ControlNameSafe THEN					EXIT EVENT				END IF				CALL SUB ChkDupControlName				IF ControlFound=TRUE THEN					PropGrid.TEXT(1,2)=ControlNameSafe					EXIT EVENT				END IF				TokenBuf=LCASE(ControlName)				CALL SUB KeyLook				IF KeyNdx<>0 THEN					;TempStr="Symbol is Keyword"					PropGrid.TEXT(1,2)=ControlNameSafe					EXIT EVENT				END IF				CALL SUB ParseControlName				IF SymbolValid=FALSE THEN					PropGrid.TEXT(1,2)=ControlNameSafe					EXIT EVENT				END IF		END SELECT	END IFEND EVENTPropGrid.BEFOREEDIT	CALL SUB SetChanged	IF GridCol=2 THEN		; Need to check here if form or control ***********************		TempHandle=ControlArray(ControlPtr).PuppetHandle		SELECT CASE GridRow			CASE 1				ControlName=PropGrid.TEXT(1,2)				ControlNameSafe=ControlArray(ControlPtr).PuppetName				ControlArray(ControlPtr).PuppetArrayNdx=VAL(TempStr)				ControlArray(ControlPtr).PuppetName=ControlName				ControlCombo.REPLACEITEMSORTED ControlNameSafe,ControlName				ControlCombo.TEXT=ControlName				EventCombo1.REPLACEITEMSORTED ControlNameSafe,ControlName				IF TempStr="-1" THEN					PropGrid.TEXT(3,2)="***"				ELSE					PropGrid.TEXT(3,2)=TempStr					RootSymbol=ControlName					CALL SUB OrderArrays				END IF			CASE 2				TempStr=PropGrid.TEXT(2,2)			CASE 3				;TempStr=PropGrid.TEXT(3,2)			CASE 4				TempStr=PropGrid.TEXT(4,2)			CASE 5				TempStr=PropGrid.TEXT(5,2)			CASE 6				CALL SUB UpdatePosition			CASE 7				CALL SUB UpdatePosition			CASE 8				CALL SUB UpdatePosition			CASE 9				CALL SUB UpdatePosition			CASE 10				TempStr=PropGrid.TEXT(10,2)				RGB=VAL(TempStr)				CALL SUB SetBackColor				CALL SUB ScreenRefresh			CASE 11				TempStr=PropGrid.TEXT(11,2)				RGB=VAL(TempStr)				CALL SUB SetForeColor				CALL SUB ScreenRefresh			CASE 12				TempStr=PropGrid.TEXT(12,2)				ControlArray(ControlPtr).PuppetText=TempStr				IF ControlArray(ControlPtr).PuppetType=1 THEN; Form					FormWindow.TEXT=TempStr				ELSE					invoke SendMessage,[TempHandle],WM_SETTEXT,0,[TempStr]				END IF			CASE 13				TempStr=PropGrid.TEXT(13,2)			CASE 14				TempStr=PropGrid.TEXT(14,2)			CASE 15				TempStr=PropGrid.TEXT(15,2)				ControlArray(ControlPtr).PuppetToolTip=TempStr			END SELECT	END IF	;CALL SUB refresh_commandEND EVENTBEGIN SUB SetBackColor	PropGrid.TEXT(10,2)="$"+HEX(RGB)	ControlArray(ControlPtr).PuppetBackColor=RGB	IF ControlArray(ControlPtr).PuppetType=1 THEN; Form		ControlArray(CurrentFormPtr).PuppetBackColor=RGB		FormWindow.BACKCOLOR=RGB	ELSE		ControlArray(ControlPtr).PuppetBackColor=RGB		IF ControlArray(ControlPtr).PuppetType=21 THEN; RAGrid			invoke SendMessage, dword [TempHandle],GM_SETBACKCOLOR,[RGB],0		ELSE			IF ControlArray(ControlPtr).PuppetType=20 THEN; RAEdit				;invoke SendMessage, dword [TempHandle],REM_SETCOLOR,0,!RA_BCKCOLOR			ELSE				IF ControlArray(ControlPtr).PuppetType>=4 AND ControlArray(ControlPtr).PuppetType<=11 THEN					TempInt=ControlArray(ControlPtr).PuppetStatus					ControlArray(ControlPtr).PuppetStatus=BITSET(TempInt,WinChangeBackColor)					IF ControlArray(ControlPtr).PuppetType=6 THEN; Slider						invoke SetFocus,[TempHandle]					ELSE						invoke InvalidateRect, dword [TempHandle],NULL,TRUE					END IF				ELSE					IF ControlArray(ControlPtr).PuppetType=12 THEN; ProgressBar						invoke SendMessage, dword [TempHandle],$2001,0,[RGB]					ELSE						IF ControlArray(ControlPtr).PuppetType=28 THEN							invoke SendMessage, dword [TempHandle],BTNEXM_SETBKGRCOL_IN,[RGB],0							invoke SendMessage, dword [TempHandle],BTNEXM_SETBKGRCOL_OUT,[RGB],0							invoke SendMessage, dword [TempHandle],BTNEXM_SETBKGRCOL_FOCUS,[RGB],0						END IF					END IF				END IF			END IF		END IF	END IFEND SUBBEGIN SUB SetForeColor	PropGrid.TEXT(11,2)="$"+HEX(RGB)	ControlArray(ControlPtr).PuppetForeColor=RGB	IF ControlArray(ControlPtr).PuppetType=21 THEN; RAGrid		TempInt=ControlArray(ControlPtr).PuppetBackColor		invoke SendMessage, dword [TempHandle],GM_SETTEXTCOLOR,[TempInt],0	ELSE		IF ControlArray(ControlPtr).PuppetType>=4 AND ControlArray(ControlPtr).PuppetType<=11 THEN			TempInt=ControlArray(ControlPtr).PuppetStatus			ControlArray(ControlPtr).PuppetStatus=BITSET(TempInt,WinChangeForeColor)			invoke InvalidateRect, dword [TempHandle],NULL,TRUE		ELSE			IF ControlArray(ControlPtr).PuppetType=12 THEN; ProgressBar				invoke SendMessage, dword [TempHandle],WM_USER+9,0,[RGB]			ELSE				IF ControlArray(ControlPtr).PuppetType=28 THEN					invoke SendMessage, dword [TempHandle],BTNEXM_SETTEXTCOL_IN,[RGB],0					invoke SendMessage, dword [TempHandle],BTNEXM_SETTEXTCOL_OUT,[RGB],0					invoke SendMessage, dword [TempHandle],BTNEXM_SETTEXTCOL_FOCUS,[RGB],0				END IF			END IF		END IF	END IFEND SUBBEGIN SUB UpdatePosition	TempStr=PropGrid.text(6,2)	TempLeft=VAL(TempStr)	ControlArray(ControlPtr).PuppetLeft=TempLeft	TempStr=PropGrid.text(7,2)	TempTop=VAL(TempStr)	ControlArray(ControlPtr).PuppetTop=TempTop	TempStr=PropGrid.text(8,2)	TempWidth=VAL(TempStr)	ControlArray(ControlPtr).PuppetWidth=TempWidth	TempStr=PropGrid.text(9,2)	IF ControlArray(ControlPtr).PuppetType=8 THEN		TempHeight=25	ELSE		TempHeight=VAL(TempStr)		ControlArray(ControlPtr).PuppetHeight=TempHeight	END IF	IF ControlArray(ControlPtr).PuppetType=1 THEN; Form		SETPOSITION FormWindow,TempLeft,TempTop,TempWidth,TempHeight	ELSE		TempHandle=ControlArray(ControlPtr).PuppetHandle		invoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[TempWidth],[TempHeight],SWP_NOZORDER+SWP_NOSIZE	END IF	CALL SUB PlaceSpider	CALL SUB PaintGrid	CALL SUB RedrawParts	;;CALL SUB refresh_commandEND SUBToolBox.SYSTEM	;IF STATUS=$f060 THEN	;	ToolBox.VISIBLE=FALSE	;END IF	IF STATUS=$f030 THEN		IF MinMaxFlag=FALSE THEN			CALL SUB MakeMax		ELSE			CALL SUB MakeMin		END IF	END IF	MinMaxFlag=NOT(MinMaxFlag)END EVENTBEGIN SUB MakeMax	SETPOSITION ToolBox,3,85,300,631	SETPOSITION FormCombo,0,184,295,160	SETPOSITION ControlCombo,0,210,295,160	;ToolBox.HEIGHT=605	;FormCombo.TOP=184	;MinMax.TOP=184	FOR I=1 TO 30		ToolButton(I).VISIBLE=TRUE	NEXT IEND SUBBEGIN SUB MakeMin	SETPOSITION ToolBox,3,85,300,77	SETPOSITION FormCombo,0,0,295,160	SETPOSITION ControlCombo,0,26,295,160	;ToolBox.HEIGHT=50	;FormCombo.TOP=0	;MinMax.TOP=0	FOR I=1 TO 30		ToolButton(I).VISIBLE=FALSE	NEXT IEND SUBEventCombo1.SELECT	EventCombo2.ENABLED=TRUE	ControlName=EventCombo1.SELTEXT	CALL SUB FindControlByRootName	TempInt=ControlArray(ControlNdx).PuppetType	EventCombo2.CLEAR	EventCombo2.TEXT="Select Event"	SETVECTOR EventArray=[ToolPropMap(TempInt).PropMapEventTable]	I=0	BEGIN LOOP		INCR I		EXIT IF EventArray(I).EVType="%"		TempStr=UCASE(EventArray(I).EVType)		EventCombo2.ADDITEMSORTED TempStr	END LOOPEND EVENTBEGIN SUB HideObjects	ControlCombo.Clear	CALL SUB HideSpider	FOR ControlNdx=2 TO LastControl		IF ControlArray(ControlNdx).PuppetForm=CurrentFormPtr THEN			TempHandle=ControlArray(ControlNdx).PuppetHandle			invoke ShowWindow, dword [TempHandle],SW_HIDE		END IF	NEXT ControlNdxEND SUBBEGIN SUB ShowObjects	CALL SUB HideSpider	FOR ControlNdx=2 TO LastControl		IF ControlArray(ControlNdx).PuppetForm=CurrentFormPtr THEN			TempHandle=ControlArray(ControlNdx).PuppetHandle			TempStr=ControlArray(ControlNdx).PuppetName			ControlCombo.ADDITEMSORTED TempStr			IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinVisible)=TRUE THEN				invoke ShowWindow, dword [TempHandle],SW_SHOW			END IF			IF BITTST(ControlArray(ControlNdx).PuppetStatus,WinEnabled)=FALSE THEN				invoke EnableWindow, dword [TempHandle],FALSE			END IF		END IF	NEXT ControlNdx	ControlPtr=CurrentFormPtr	ControlNdx=ControlPtr	CALL SUB ControlArrayToToolBox	FormWindow.TEXT=ControlArray(ControlPtr).PuppetText	FormWindow.BACKCOLOR=ControlArray(ControlPtr).PuppetBackColor	SETPOSITION FormWindow,ControlArray(CurrentFormPtr).PuppetLeft,ControlArray(CurrentFormPtr).PuppetTop,ControlArray(CurrentFormPtr).PuppetWidth,ControlArray(CurrentFormPtr).PuppetHeightEND SUBBEGIN SUB FindFormByName	FOR ControlNdx=1 TO LastControl		IF ControlArray(ControlNdx).PuppetName=ControlName THEN			CurrentFormPtr=ControlNdx			ControlPtr=ControlNdx			EXIT SUB		END IF	NEXT ControlNdxEND SUBControlCombo.SELECT	ControlName=ControlCombo.SELTEXT	CALL SUB ControlComboActionEND EVENTFormCombo.SELECT	CALL SUB RemoveEars	ControlName=FormCombo.SELTEXT	CALL SUB FormComboActionEND EVENTBEGIN SUB FormComboAction	FormNotChanged=TRUE	IF ControlName<>CurrentFormName THEN		CALL SUB HideObjects		ControlCombo.CLEAR		ControlCombo.ADDITEM ControlName		CurrentFormName=ControlName		CALL SUB FindFormByName		CALL SUB ShowObjects		ControlCombo.TEXT=ControlName		CALL SUB PaintGrid		CALL SUB RedrawParts	END IF	FormNotChanged=FALSEEND SUBBEGIN SUB ControlComboAction	CALL SUB FindControlByName	ControlPtrSafe=ControlPtr	ControlPtr=ControlNdx	CALL SUB GetPuppetPosition	ToolButtonNdx=ControlArray(ControlPtr).PuppetType	CALL SUB PopulateToolBox	CALL SUB ControlArrayToToolBox	IF ControlArray(ControlPtr).PuppetType<>1 AND BITTST(ControlArray(ControlPtr).PuppetStatus,WinVisible)=TRUE THEN		CALL SUB SetSpider	ELSE		CALL SUB HideSpider	END IF	;CALL SUB RedrawParts	;;CALL SUB refresh_commandEND SUBBEGIN SUB PlaceSpider	ControlNdx=ControlPtr	CALL SUB GetPuppetPosition	FOR I=2 TO 9		Spider(I).VISIBLE=FALSE	NEXT I	CALL SUB SetSpiderEND SUBBEGIN SUB SetSpider	IF ControlNdx>1 THEN		SETPOSITION Spider(Belly),TempLeft,TempTop,TempWidth,TempHeight		SETPOSITION Spider(NW),TempLeft-6,TempTop-6,6,6		SETPOSITION Spider(N),TempLeft+TempWidth/2-3,TempTop-6,6,6		SETPOSITION Spider(NE),TempLeft+TempWidth,TempTop-6,6,6		SETPOSITION Spider(W),TempLeft-6,TempTop+TempHeight/2-3,6,6		SETPOSITION Spider(E),TempLeft+TempWidth,TempTop+TempHeight/2-3,6,6		SETPOSITION Spider(SW),TempLeft-6,TempTop+TempHeight,6,6		SETPOSITION Spider(S),TempLeft+TempWidth/2-3,TempTop+TempHeight,6,6		SETPOSITION Spider(SE),TempLeft+TempWidth,TempTop+TempHeight,6,6		CALL SUB ShowSpiderLegs		SpiderPlaced=TRUE	ELSE		CALL SUB HideSpiderLegs		SpiderPlaced=FALSE	END IFEND SUBBEGIN SUB PlaceSpiderLegs	IF SizeControl=FALSE THEN		FOR I=2 TO 9			DESTROY Spider(I)		NEXT I		CREATE Spider(NW),SpiderLeft-6,SpiderTop-6,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(N),SpiderLeft+SpiderWidth/2-3,SpiderTop-6,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(NE),SpiderLeft+SpiderWidth,SpiderTop-6,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(W),SpiderLeft-6,SpiderTop+SpiderHeight/2-3,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(E),SpiderLeft+SpiderWidth,SpiderTop+SpiderHeight/2-3,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(SW),SpiderLeft-6,SpiderTop+SpiderHeight,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(S),SpiderLeft+SpiderWidth/2-3,SpiderTop+SpiderHeight,6,6,BASE+WHITEFRAME IN FormWindow		CREATE Spider(SE),SpiderLeft+SpiderWidth,SpiderTop+SpiderHeight,6,6,BASE+WHITEFRAME IN FormWindow		FOR I=2 TO 9			Spider(I).VISIBLE=FALSE		NEXT I	ELSE		SETPOSITION Spider(NW),SpiderLeft-6,SpiderTop-6,6,6		SETPOSITION Spider(N),SpiderLeft+SpiderWidth/2-3,SpiderTop-6,6,6		SETPOSITION Spider(NE),SpiderLeft+SpiderWidth,SpiderTop-6,6,6		SETPOSITION Spider(W),SpiderLeft-6,SpiderTop+SpiderHeight/2-3,6,6		SETPOSITION Spider(E),SpiderLeft+SpiderWidth,SpiderTop+SpiderHeight/2-3,6,6		SETPOSITION Spider(SW),SpiderLeft-6,SpiderTop+SpiderHeight,6,6		SETPOSITION Spider(S),SpiderLeft+SpiderWidth/2-3,SpiderTop+SpiderHeight,6,6		SETPOSITION Spider(SE),SpiderLeft+SpiderWidth,SpiderTop+SpiderHeight,6,6		END IF	IF MoveControl=FALSE THEN		CALL SUB ShowSpiderLegs	END IF	SETPOSITION Spider(Belly),SpiderLeft,SpiderTop,SpiderWidth,SpiderHeight	SpiderPlaced=TRUEEND SUBBEGIN SUB HideSpider	Spider(Belly).VISIBLE=FALSE	CALL SUB HideSpiderLegs	SpiderPlaced=FALSEEND SUBBEGIN SUB HideSpiderLegs	FOR I=2 TO 9		Spider(I).VISIBLE=FALSE	NEXT IEND SUBBEGIN SUB ShowSpiderLegs	IF MultiSelectItemCount=0 THEN		FOR I=2 TO 9			Spider(I).VISIBLE=TRUE		NEXT I	END IFEND SUBBEGIN SUB GetPuppetPosition	TempLeft=ControlArray(ControlNdx).PuppetLeft	TempTop=ControlArray(ControlNdx).PuppetTop	OwnerPtr=ControlArray(ControlNdx).PuppetOwner			TempWidth=ControlArray(ControlNdx).PuppetWidth	IF ControlArray(ControlNdx).PuppetType=8 THEN; ComboBox		TempHeight=25	ELSE		TempHeight=ControlArray(ControlNdx).PuppetHeight	END IFEND SUBBEGIN SUB FindControlByName	FOR ControlNdx=1 TO LastControl		IF ControlArray(ControlNdx).PuppetName=ControlName THEN			ControlFound=TRUE			CALL SUB ControlArrayToToolBox			EXIT SUB		END IF	NEXT ControlNdx	ControlFound=FALSEEND SUBBEGIN SUB FindControlByRootName	FOR ControlNdx=1 TO LastControl		IF Root(ControlArray(ControlNdx).PuppetName)=ControlName THEN			ControlFound=TRUE			CALL SUB ControlArrayToToolBox			EXIT SUB		END IF	NEXT ControlNdx	ControlFound=FALSEEND SUBBEGIN SUB ChkDupControlName	FOR ControlNdx=1 TO LastControl		IF ControlArray(ControlNdx).PuppetName=ControlName THEN			ControlFound=TRUE			EXIT SUB		END IF	NEXT ControlNdx	ControlFound=FALSEEND SUBrefresh.command;exit eventcontrolndx.text=str(ControlNdx)controlptr.text=str(ControlPtr)controlcount.text=str(ControlCount)controlname.text=ControlNamecontrolptrsafe.text=str(ControlPtrSafe)lastcontrol.text=str(LastControl)dbggrid.gridclearif showcclipboard.checked=false then	for I=1 to LastControl		dbggrid.addrow		dbggrid.value(I,1)=I		dbggrid.text(I,2)=hex(ControlArray(I).PuppetHandle)			dbggrid.value(I,3)=ControlArray(I).PuppetID		dbggrid.value(I,4)=ControlArray(I).PuppetOwner		dbggrid.value(I,5)=ControlArray(I).PuppetArrayNdx		dbggrid.value(I,6)=ControlArray(I).PuppetLeft		dbggrid.value(I,7)=ControlArray(I).PuppetTop		dbggrid.value(I,8)=ControlArray(I).PuppetWidth		dbggrid.value(I,9)=ControlArray(I).PuppetHeight		dbggrid.text(I,10)=hex(ControlArray(I).PuppetBackColor)		dbggrid.text(I,11)=hex(ControlArray(I).PuppetForeColor)		;dbggrid.text(I,10)=str(ControlArray(I).PuppetChildXOffs)		;dbggrid.text(I,11)=str(ControlArray(I).PuppetChildYOffs)		dbggrid.value(I,12)=ControlArray(I).PuppetType		dbggrid.text(I,13)=hex(ControlArray(I).PuppetStatus)		dbggrid.value(I,14)=ControlArray(I).PuppetFont		dbggrid.value(I,15)=ControlArray(I).PuppetIcon		dbggrid.text(I,16)=hex(ControlArray(I).PuppetControlType)		dbggrid.text(I,17)=ControlArray(I).PuppetText		dbggrid.text(I,18)=ControlArray(I).PuppetName		dbggrid.value(I,19)=ControlArray(I).PuppetForm		dbggrid.text(I,20)=hex(ControlArray(I).PuppetEars(1))		dbggrid.value(I,21)=ControlArray(I).PuppetArraySize	next Ielse	for I=1 to ClipBoardItemCount		dbggrid.addrow		dbggrid.value(I,1)=I		dbggrid.text(I,2)=hex(ClipBoard(I).PuppetHandle)			dbggrid.value(I,3)=ClipBoard(I).PuppetID		dbggrid.value(I,4)=ClipBoard(I).PuppetOwner		dbggrid.value(I,5)=ClipBoard(I).PuppetArrayNdx		dbggrid.value(I,6)=ClipBoard(I).PuppetLeft		dbggrid.value(I,7)=ClipBoard(I).PuppetTop		dbggrid.value(I,8)=ClipBoard(I).PuppetWidth		dbggrid.value(I,9)=ClipBoard(I).PuppetHeight		dbggrid.text(I,10)=hex(ClipBoard(I).PuppetBackColor)		dbggrid.text(I,11)=hex(ClipBoard(I).PuppetForeColor)		;dbggrid.text(I,10)=str(ClipBoard(I).PuppetChildXOffs)		;dbggrid.text(I,11)=str(ClipBoard(I).PuppetChildYOffs)		dbggrid.value(I,12)=ClipBoard(I).PuppetType		dbggrid.text(I,13)=hex(ClipBoard(I).PuppetStatus)		dbggrid.value(I,14)=ClipBoard(I).PuppetFont		dbggrid.value(I,15)=ClipBoard(I).PuppetIcon		dbggrid.text(I,16)=hex(ClipBoard(I).PuppetControlType)		dbggrid.text(I,17)=ClipBoard(I).PuppetText		dbggrid.text(I,18)=ClipBoard(I).PuppetName		dbggrid.value(I,19)=ClipBoard(I).PuppetForm		dbggrid.text(I,20)=hex(ClipBoard(I).PuppetEars(1))		dbggrid.value(I,21)=ClipBoard(I).PuppetArraySize	next Iend ifend eventBEGIN SUB PaintGrid	IF ShowGrid=TRUE THEN		I=-GridSize		J=0		GETCLIENTRECT FormWindow		GETDC FormWindow		BEGIN LOOP			I=I+GridSize			IF I>=RectRight THEN				I=0				J=J+GridSize				IF J>=RectBottom THEN					RELEASEDC FormWindow					RETURN				END IF			END IF			SETPIXEL FormWindow,I,J,GridColor		END LOOP	END IFEND SUBBEGIN SUB RedrawParts	FOR I=2 TO LastControl		IF ControlArray(I).PuppetHandle<>0 AND ControlArray(I).PuppetForm=CurrentFormPtr THEN			TempHandle=ControlArray(I).PuppetHandle			invoke InvalidateRect, dword [TempHandle],NULL,TRUE		END IF	NEXT IEND SUBBEGIN SUB SetSnap	TempInt=MOD(SpiderLeft,GridSize)	IF TempInt<>0 THEN		IF TempInt<GridSize/2 THEN			SpiderLeft=SpiderLeft-TempInt		ELSE			TempInt=GridSize-TempInt			SpiderLeft=SpiderLeft+TempInt		END IF	END IF	TempInt=MOD(SpiderTop,GridSize)	IF TempInt<>0 THEN		IF TempInt<GridSize/2 THEN			SpiderTop=SpiderTop-TempInt		ELSE			TempInt=GridSize-TempInt			SpiderTop=SpiderTop+TempInt		END IF	END IF	TempInt=MOD(SpiderWidth,GridSize)	IF TempInt<>0 THEN		IF TempInt<GridSize/2 THEN			SpiderWidth=SpiderWidth-TempInt		ELSE			TempInt=GridSize-TempInt			SpiderWidth=SpiderWidth+TempInt		END IF	END IF	TempInt=MOD(SpiderHeight,GridSize)	IF TempInt<>0 THEN		IF TempInt<GridSize/2 THEN			SpiderHeight=SpiderHeight-TempInt		ELSE			TempInt=GridSize-TempInt			SpiderHeight=SpiderHeight+TempInt		END IF	END IFEND SUBBEGIN SUB SetGridSize	FormWindow.VISIBLE=FALSE	FormWindow.VISIBLE=TRUE	CALL SUB PaintGrid	CALL SUB RedrawPartsEND SUBBEGIN SUB UnCheckGridSize	CHECKMENUITEM GridSizePopUp,gsmnu5,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu10,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu15,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu20,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu25,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu30,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu35,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu40,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu45,FALSE	CHECKMENUITEM GridSizePopUp,gsmnu50,FALSEEND SUBBEGIN SUB UnCheckGridColor	CHECKMENUITEM GridColorPopUp,gcmnuBlack,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuWhite,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuRed,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuGreen,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuBlue,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuYellow,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuMagenta,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuDkRed,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuDkGreen,FALSE	CHECKMENUITEM GridColorPopUp,gcmnuDkBlue,FALSEEND SUBBEGIN SUB SetGridColor	FormWindow.VISIBLE=FALSE	FormWindow.VISIBLE=TRUE	CALL SUB PaintGrid	CALL SUB RedrawPartsEND SUBBEGIN SUB GetControlID	FOR I=1 TO ControlTableSize		IF PuppetIDDispenser(I)=FALSE THEN			PuppetIDDispenser(I)=TRUE			ControlID=I+100			ControlArray(PlacePtr).PuppetID=ControlID			EXIT SUB		END IF	NEXT IEND SUBOBMain.RESIZE	GETCLIENTRECT OBMain	SETPOSITION Edit,0,50,RectRight-RectLeft,RectBottom-RectTop-70	SETPOSITION BackGround,0,25,RectRight-RectLeft,RectBottom-RectTop-45	MOVEWINDOW StatusBar,0,0,0,0	SETPOSITION EventCombo1,0,25,(RectRight-RectLeft)/2,400	SETPOSITION EventCombo2,(RectRight-RectLeft)/2+5,25,(RectRight-RectLeft)/2-4,400	IF RectRight>850 THEN		SETPOSITION QuickFind,RectRight-205,0,205,20		SETPOSITION QuickFindNext,RectRight-255,0,20,20		SETPOSITION QuickFindPrev,RectRight-230,0,20,20		QuickFind.VISIBLE=FALSE		QuickFind.VISIBLE=TRUE		QuickFindNext.VISIBLE=FALSE		QuickFindNext.VISIBLE=TRUE		QuickFindPrev.VISIBLE=FALSE		QuickFindPrev.VISIBLE=TRUE	ELSE		QuickFind.VISIBLE=FALSE		QuickFindNext.VISIBLE=FALSE		QuickFindPrev.VISIBLE=FALSE	END IFEND EVENTScratchPadWindow.RESIZE	GETCLIENTRECT ScratchPadWindow	SETPOSITION ScratchPadText,RectLeft,RectTop,RectRight-RectLeft,RectBottom-RectTop	SETPOSITION StatusBar,0,0,0,0END EVENTBEGIN SUB ediUsedCheck	IF ediUsed=TRUE THEN		OutBuf="mov edi,[!TargetGUIDesc]"		CALL SUB OutFcnCodeData	END IFEND SUBBEGIN SUB WriteTools	OPEN FileName FOR APPEND AS EditFile	FOR I=1 TO 50		ToolPropMapCount(I)=ToolPropMap(I).PropMapCount	NEXT I	TempInt=$ffffffff	PUT EditFile,TempInt	PUT EditFile,TempInt	PUT EditFile,ShowGrid	PUT EditFile,SnapToGrid	PUT EditFile,GridSize	PUT EditFile,GridColor	PUT EditFile,TempInt	PUT EditFile,LastControl	PUT EditFile,ControlCount	PUT EditFile,ControlArray	PUT EditFile,ToolPropMapCount	CLOSE EditFileEND SUBBEGIN SUB AttachEars	EarLeft=ControlArray(ControlNdx).PuppetLeft-4	EarTop=ControlArray(ControlNdx).PuppetTop-4	;CALL SUB CheckChild	TempInt=ControlArray(ControlNdx).PuppetID+$1001	invoke CreateWindowEx,0,!ControlType26,0,$50000008,[EarLeft],[EarTop],4,4, dword [!FormWindow], dword [TempInt],[!hinstance],0	mov [EarHandle],eax	ControlArray(ControlNdx).PuppetEars(1)=EarHandle	EarLeft=ControlArray(ControlNdx).PuppetLeft+ControlArray(ControlNdx).PuppetWidth	EarTop=ControlArray(ControlNdx).PuppetTop-4	;CALL SUB CheckChild	TempInt=ControlArray(ControlNdx).PuppetID+$1002	invoke CreateWindowEx,0,!ControlType26,0,$50000008,[EarLeft],[EarTop],4,4, dword [!FormWindow], dword [TempInt],[!hinstance],0	mov [EarHandle],eax	ControlArray(ControlNdx).PuppetEars(2)=EarHandle	EarLeft=ControlArray(ControlNdx).PuppetLeft-4	IF ControlArray(ControlNdx).PuppetType=8 THEN		EarTop=ControlArray(ControlNdx).PuppetTop+25	ELSE		EarTop=ControlArray(ControlNdx).PuppetTop+ControlArray(ControlNdx).PuppetHeight	END IF	;CALL SUB CheckChild	TempInt=ControlArray(ControlNdx).PuppetID+$1003	invoke CreateWindowEx,0,!ControlType26,0,$50000008,[EarLeft],[EarTop],4,4, dword [!FormWindow], dword [TempInt],[!hinstance],0	mov [EarHandle],eax	ControlArray(ControlNdx).PuppetEars(3)=EarHandle	EarLeft=ControlArray(ControlNdx).PuppetLeft+ControlArray(ControlNdx).PuppetWidth	;IF ControlArray(ControlNdx).PuppetOwner<>ControlArray(ControlNdx).PuppetForm THEN	;	EarLeft=EarLeft+ControlArray(ControlArray(ControlNdx).PuppetOwner).PuppetLeft	;END IF	TempInt=ControlArray(ControlNdx).PuppetID+$1003	invoke CreateWindowEx,0,!ControlType26,0,$50000008,[EarLeft],[EarTop],4,4, dword [!FormWindow], dword [TempInt],[!hinstance],0	mov [EarHandle],eax	ControlArray(ControlNdx).PuppetEars(4)=EarHandleEND SUBBEGIN SUB CheckChild	IF ControlArray(ControlNdx).PuppetOwner<>ControlArray(ControlNdx).PuppetForm THEN		EarLeft=EarLeft+ControlArray(ControlArray(ControlNdx).PuppetOwner).PuppetLeft		EarTop=EarTop+ControlArray(ControlArray(ControlNdx).PuppetOwner).PuppetTop	END IFEND SUBBEGIN SUB MoveEars	EarLeft=ControlArray(ControlNdx).PuppetLeft-4	EarTop=ControlArray(ControlNdx).PuppetTop-4	EarHandle=ControlArray(ControlNdx).PuppetEars(1)	invoke SetWindowPos,[EarHandle],HWND_TOP,[EarLeft],[EarTop],0,0,SWP_NOZORDER+SWP_NOSIZE	EarLeft=ControlArray(ControlNdx).PuppetLeft+ControlArray(ControlNdx).PuppetWidth	EarTop=ControlArray(ControlNdx).PuppetTop-4	EarHandle=ControlArray(ControlNdx).PuppetEars(2)	invoke SetWindowPos,[EarHandle],HWND_TOP,[EarLeft],[EarTop],0,0,SWP_NOZORDER+SWP_NOSIZE	EarLeft=ControlArray(ControlNdx).PuppetLeft-4	IF ControlArray(ControlNdx).PuppetType=8 THEN		EarTop=ControlArray(ControlNdx).PuppetTop+25	ELSE		EarTop=ControlArray(ControlNdx).PuppetTop+ControlArray(ControlNdx).PuppetHeight	END IF	EarHandle=ControlArray(ControlNdx).PuppetEars(3)	invoke SetWindowPos,[EarHandle],HWND_TOP,[EarLeft],[EarTop],0,0,SWP_NOZORDER+SWP_NOSIZE	EarLeft=ControlArray(ControlNdx).PuppetLeft+ControlArray(ControlNdx).PuppetWidth	EarHandle=ControlArray(ControlNdx).PuppetEars(4)	invoke SetWindowPos,[EarHandle],HWND_TOP,[EarLeft],[EarTop],0,0,SWP_NOZORDER+SWP_NOSIZEEND SUBBEGIN SUB RemoveEars	IF MultiSelectItemCount>0 THEN		FOR I=2 TO LastControl			IF ControlArray(I).PuppetEars(1)<>0 THEN				FOR J=1 TO 4					EarHandle=ControlArray(I).PuppetEars(J)					ControlArray(I).PuppetEars(J)=0					invoke DestroyWindow,[EarHandle]				NEXT J			END IF		NEXT I	END IF	MultiSelectItemCount=0	MultiFrame.VISIBLE=FALSE	MultiItemMove=FALSEEND SUBBEGIN SUB SetClipBoardXY	LowestClipBoardX=$7fffffff	LowestClipBoardY=$7fffffff	FOR K=1 TO ClipBoardItemCount		IF ClipBoard(K).PuppetLeft<LowestClipBoardX THEN			LowestClipBoardX=ClipBoard(K).PuppetLeft		END IF		IF ClipBoard(K).PuppetTop<LowestClipBoardY THEN			LowestClipBoardY=ClipBoard(K).PuppetTop		END IF	NEXT K	FOR K=1 TO ClipBoardItemCount		ClipBoard(K).PuppetLeft=ClipBoard(K).PuppetLeft-LowestClipBoardX		ClipBoard(K).PuppetTop=ClipBoard(K).PuppetTop-LowestClipBoardY	NEXT KEND SUBBEGIN SUB ParseControlName	TokenBuf=LCASE(ControlName)	TokenSaf=ControlName	CALL SUB GetRootSymbol 	CALL SUB ChkValidSymbol 	IF SymbolValid=FALSE THEN 		EXIT SUB 	END IF 	IF RIGHT(ControlName,1)<>")" THEN 		IF LEN(ControlName)>LEN(RootSymbol) THEN 			; 		ELSE 			SymbolValid=TRUE 			TempStr="-1" 		END IF 		EXIT SUB 	ELSE 		SymbolValid=FALSE 		ControlName=RootSymbol 		CALL SUB ChkDupControlName 		IF ControlFound=TRUE AND ControlNdx<>ControlPtr THEN 			EXIT SUB 		END IF 		ControlName=TokenSaf 		IF MID(TokenBuf,LabNdx,1)<>"(" THEN 			EXIT SUB 		END IF 		TempStr="" 		FOR LabNdx=LabNdx+1 TO LEN(TokenSaf)-1 			TempByte=MID(TokenSaf,LabNdx,1) 			TempStr=TempStr+TempByte			CONTINUE IF TempByte>="0" AND TempByte<="9" 			EXIT SUB 		NEXT LabNdx 		SymbolValid=TRUE 	END IFEND SUBBEGIN FCN Root(RootName)	FOR RootPtr=1 TO LEN(RootName)		IF MID(RootName,RootPtr,1)="(" THEN			RETURN LEFT(RootName,RootPtr-1)		END IF	NEXT RootPtr	RETURN RootNameEND FCNBEGIN SUB OrderArrays	FirstArrayPtr=0	HighestArrayNdx=0	FOR ArrayNdx=2 TO LastControl		IF Root(ControlArray(ArrayNdx).PuppetName)=RootSymbol THEN		OBMain.text=RootSymbol+" Havis"			IF FirstArrayPtr=0 THEN				FirstArrayPtr=ArrayNdx			END IF			IF ControlArray(ArrayNdx).PuppetArrayNdx>HighestArrayNdx THEN				HighestArrayNdx=ControlArray(ArrayNdx).PuppetArrayNdx			END IF			ControlArray(ArrayNdx).PuppetArraySize=0		END IF	NEXT ArrayNdx	IF FirstArrayPtr<>0 THEN		ControlArray(FirstArrayPtr).PuppetArraySize=HighestArrayNdx	END IFEND SUB;OBMain.PAINT;mov eax,[wparam];mov [TempInt],eax;IF FormWindow.HDC=TempInt THEN;	CALL SUB PaintGrid;END IF;END EVENT