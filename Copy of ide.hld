; OmniBasic Copyright 1995-2005 Innomation Systems, Inc.; All Rights Reserved;; This source file is provided for educational, documentary, and porting; purposes only. The recipient agrees to hold this information in strict; confidence. The recipient agrees to these terms by accepting this software; source code. Violations may result in criminal and/or civil penalties under; the copyright and trade secret laws of the United States of America.; Edition History; 10-19-02 OmniBasic release 1.44 as base for adaptation; 11-16-02 Began conversion to x86 asm; 01-22-05 Converted to IDE$exok; ************************************ IDE DIM's Here ********************************************MACRO DestroyWindow	USEIMPORT DestroyWindow	invoke DestroyWindow,[~1] END MACRODIM EditPopUp AS MENUDIM FormPopUp AS MENUDIM ObjectPool(500) AS PUPPETTYPE PuppetData PuppetHandle AS LONG PuppetID AS LONG PuppetOwner AS LONG PuppetArray AS LONG PuppetLeft AS LONG PuppetTop AS LONG PuppetWidth AS LONG PuppetHeight AS LONG PuppetBackColor AS LONG PuppetForeColor AS LONG PuppetType AS LONG PuppetStatus AS LONG PuppetFont AS LONG PuppetIcon AS LONG PuppetText AS STRING*64 PuppetName AS STRING*32END TYPEDIM ControlArray(500) AS PuppetData VECTORDIM ControlNdx AS LONGDIM ControlPosNdx AS LONGDIM ControlCount AS LONGDIM ControlFound AS BOOLEANDIM ControlPosValid AS LONGDIM ControlName AS STRING*32DIM TempHandle AS LONGDIM TempLeft AS LONGDIM TempTop AS LONGDIM TempWidth AS LONGDIM TempHeight AS LONGDIM MouseDown AS BOOLEANDIM XOffset AS LONGDIM YOffset AS LONGDIM Spider(9) AS STATICTEXTDIM NewWindow AS TOOLWINDOWDIM NewWindowConstructed AS BOOLEANDIM ProjectButton AS BUTTONDIM WindowPgmButton AS BUTTONDIM ConsolePgmButton AS BUTTONDIM GotoWindow AS TOOLWINDOWDIM GotoWindowConstructed AS BOOLEANDIM GotoText AS TEXTBOXDIM GotoButton AS BUTTONDIM FindWindow AS TOOLWINDOWDIM FindWindowConstructed AS BOOLEANDIM FindWindowActive AS BOOLEANDIM UpDown AS FRAMEDIM UpButton AS RADIOBUTTONDIM DownButton AS RADIOBUTTONDIM MatchWholeWord AS CHECKBOXDIM MatchCase AS CHECKBOXDIM FindNext AS BUTTONDIM Cancel AS BUTTONDIM FindText AS COMBOBOXDIM FindWhat AS STATICTEXTDIM FindReplaceWindow AS TOOLWINDOWDIM FRWindowConstructed AS BOOLEANDIM FRWindowActive AS BOOLEANDIM FRMatchWholeWord AS CHECKBOXDIM FRMatchCase AS CHECKBOXDIM FRFindNext AS BUTTONDIM FRReplace AS BUTTONDIM FRReplaceAll AS BUTTONDIM FRCancel AS BUTTONDIM FRFindText AS COMBOBOXDIM FRReplaceText AS COMBOBOXDIM FRFindWhat AS STATICTEXTDIM FRReplaceWith AS STATICTEXTDIM Button(24) AS ICONBUTTONDIM sbParts(6) AS LONGDIM GraphicConstructed AS BOOLEANDIM ToolBox AS FORMDIM ToolButton(30) AS BUTTONDIM FormCombo AS COMBOBOXDIM ControlCombo AS COMBOBOXDIM MinMax AS BUTTONDIM PropGrid AS RAGRIDDIM StyleGrid AS RAGRIDDIM FormWindow AS FORMDIM MinMaxFlag AS BOOLEANDIM FormWindowConstructed AS BOOLEANDIM StyleGridRow AS LONGDIM UnDoFlag AS BOOLEANDIM ReDoFlag AS BOOLEANDim lf As LOGFONTDim lRet AS LONGDim szFont AS STRINGDIM szRegs AS STRING*1000DIM szAsmInst AS STRING*1000DIM szBasicInst AS STRING*1000DIM szGUIInst AS STRING*1000DIM szGUIProps AS STRING*1000DIM szGUIProps2 AS STRING*1000DIM szMasm AS STRING*1000DIM szFcns AS STRING*1000DIM szDataType AS STRING*1000DIM LF1 AS LOGFONTDIM Font1 AS FONTDIM OmniIcon AS ICONDIM NewIcon AS ICONDIM OpenIcon AS ICONDIM SaveIcon AS ICONDIM SaveIcon2 AS ICONDIM SaveAsIcon AS ICONDIM PrintIcon AS ICONDIM ToolIcon AS ICONDIM EditIcon AS ICONDIM UnDoIcon AS ICONDIM ReDoIcon AS ICONDIM DeleteIcon AS ICONDIM CutIcon AS ICONDIM CopyIcon AS ICONDIM PasteIcon AS ICONDIM GoToIcon AS ICONDIM FindIcon AS ICONDIM ReplaceIcon AS ICONDIM CompileToExeIcon AS ICONDIM CompileToAsmIcon AS ICONDIM CompileForErrIcon AS ICONDIM CompileForDebugIcon AS ICONDIM SymbolsIcon AS ICONDIM UnusedSymIcon AS ICONDIM RunIcon AS ICONDIM HelpIcon AS ICONDIM font AS FONTDIM RAFont(3) AS FONTDIM Edit AS RAEDITDIM SymbolGrid AS RAGRIDDIM BackGround AS STATICTEXTDIM StatusBar AS STATUSBARDIM ToolBar AS TOOLBARDIM FileName AS STRINGDIM SaveFileName AS STRINGDIM FileFilter AS TEXTDIM Extension AS STRING*4DIM InitDir AS STRINGDIM Changed AS BOOLEANDIM BasicAsm AS BOOLEANDIM TempBool AS BOOLEANDIM TextMode AS BOOLEANDIM ToolView AS BOOLEANDIM PropView AS BOOLEANDIM StyleView AS BOOLEANDIM ShowSymbols AS BOOLEANDIM FindStr AS STRINGDIM SelectStr AS STRINGDIM ReplaceStr AS STRINGDIM FontStr AS STRINGDIM RGB AS LONGDIM row AS LONGDIM col AS LONGDIM StatusBarSafe1 AS STRING*32DIM StatusBarSafe2 AS STRING*32DIM StatusBarSafe3 AS STRING*32DIM StatusBarSafe4 AS STRING*32DIM StatusBarSafe5 AS STRING*32;*********************************** Compiler Macros, DIM's, CONST's etc *************************; MACROSMACRO GenConstCONST ~2=~3CONST ptr~2=~3-99OutBuf="!~1_~2 equ ~3"GOSUB OutUninitDataENDMACROMACRO IncArrayNdxGOSUB IncrArrayNdxENDMACROMACRO DecArrayNdxGOSUB DecrArrayNdxENDMACROMACRO GenEquateCONST ~1=~2OutBuf="~1 equ ~2"GOSUB OutDeclareENDMACROMACRO GenExportWRITE ExportFile,OutBufINCR AsmLineCtrENDMACROMACRO GenResourceWRITE ResourceFile,OutBufINCR AsmLineCtrENDMACROMACRO IncExpNdxINCR ExpNdxExpLen=ExpNdxENDMACROMACRO CommaRetGOSUB GetCommaErrRetENDMACROMACRO CommaMainGOSUB GetCommaErrMainENDMACROMACRO ColonRetGOSUB GetColonErrRetENDMACROMACRO ColonMainGOSUB GetColonErrMainENDMACROMACRO EqualRetGOSUB GetEqualErrRetENDMACROMACRO EqualMainGOSUB GetEqualErrMainENDMACROMACRO MakeLongIF LAND(TDataMod,PointerBit)=PointerBit THEN	TDataType=LONGVARENDIFENDMACROMACRO ErrRetIF ErrNo<>0 THEN	RETURNENDIFENDMACROMACRO ErrMainIF ErrNo<>0 THEN MainLoopENDMACROMACRO ErrGUIIF GUIFlag=0 THEN GUIFatalENDMACROENUM 1 ErrUDSym ErrIVSNam ErrTypMis ErrIVExp ErrSyntax ErrDupSym ErrSymFul ErrUDFcn ErrIVType ErrIVMod ErrMacArg ErrIVDir ErrDupMac ErrEndStr ErrMacNst ErrMacBuf ErrIVMac ErrEndm ErrUBCon ErrNDeep ErrDecFcn ErrIVParm ErrParam ErrCpxExp ErrIVFunc ErrTmpUse ErrParen ErrFcn ErrIVTarg ErrFSNest ErrTblArr ErrEndFcn ErrArrSub ErrEndProc ErrEndTbl ErrTblArgs ErrFcnArgs ErrTypeFcn ErrDupEvent ErrIVProp ErrEndEvent ErrOpRange ErrTextArray ErrTextDefined ErrTextNotDefinedEND ENUMENUM 0 COMPVAR BOOLVAR BYTEVAR WORDVAR LONGVAR FLOATVAR STRINGVAR LABELVAR MACROVAR OPER FCN PROC TYPE VOIDX COMPLEX BUFFER LABELPTR MENU TEXT PUPPETEND ENUMENUM 0 NONE FILE DEVICE FONT ICON CURSOR BITMAP HANDLEEND ENUM;CONST TIMER=999CONST STYLE=1CONST EXSTYLE=2ENUM 1 STDCTL COMCTL CUSCTL DLLCTL TIMCTL OCXCTLEND ENUM; Must keep this ENUM in sync with ImportLibTableENUM 1ptrkernel32ptruser32ptrgdiptrcomctlptrcomdlgptrshellptradvapiptrwinmmptrmsvcrtptrcsmdllptrricheditEND ENUM; Must keep this ENUM in sync with ImportFcnTableENUM 1ptrBeepptrCloseHandleptrCreateDirectoryptrCreateFileptrCreatePipeptrCreateProcessptrDeleteFileptrExitProcessptrGetCommandLineptrGetCurrentProcessptrGetCurrentDirectoryptrGetFileSizeptrGetFileTypeptrGetFullPathNameptrGetLastErrorptrGetLocalTimeptrGetModuleHandleptrGetStdHandleptrGetTickCountptrLoadLibraryptrReadConsoleptrReadFileptrRemoveDirectoryptrSetCurrentDirectoryptrSetFilePointerptrVirtualAllocptrVirtualFreeptrWinExecptrWriteConsoleptrWriteFileptrAppendMenuptrCallWindowProcptrCheckDlgButtonptrCheckMenuItemptrCheckRadioButtonptrChildWindowFromPointptrCreateIconFromResourceptrCreateMenuptrCreatePopupMenuptrCreateWindowExptrDefWindowProcptrDeleteMenuptrDestroyWindowptrDispatchMessageptrDrawMenuBarptrEnableMenuItemptrEnableWindowptrFlashWindowptrGetAncestorptrGetClientRectptrGetComboBoxInfoptrGetCursorPosptrGetMessageptrGetParentptrGetWindowRectptrHiliteMenuItemptrInvalidateRectptrInsertMenuptrInsertMenuItemptrIsWindowEnabledptrIsWindowVisibleptrKillTimerptrLoadCursorptrLoadIconptrLoadMenuptrMessageBoxptrModifyMenuptrPostMessageptrMoveWindowptrPostQuitMessageptrRedrawWindowptrRegisterClassptrRegisterWindowMessageptrReleaseCaptureptrRemoveMenuptrScreenToClientptrSendMessageptrSetCaptureptrSetClassLongptrSetFocusptrSetMenuptrSetMenuItemBitmapsptrSetTimerptrGetWindowLongptrSetWindowLongptrSetWindowPosptrShowWindowptrUpdateWindowptrTrackPopupMenuExptrTranslateMessageptrCreateFontIndirectptrCreateSolidBrushptrDeleteObjectptrGetPixelptrGetBkColorptrSetBkColorptrSetBkModeptrGetStockObjectptrSetTextColorptrCreateMappedBitmapptrInitCommonControlsExptrTrackMouseEventptrChooseFontptrChooseColorptrGetOpenFileNameptrGetSaveFileNameptrFindTextptrReplaceTextptrDragAcceptFilesptrShellNotifyIconptrRegCreateKeyExptrRegCloseKeyptrsndPlaySoundptrabsptratolptrltoaptrprintfptrputsptrsprintfptrsystemptrCSMGetDriveHandleptrCSMDriveStatusptrCSMReadBlockptrCSMReleaseDriveHandleptrCSMWriteBlockptrCreateTextServicesEND ENUMCONST ArrayBit=$0001CONST PointerBit=$0002CONST ConstBit=$0004CONST MultiBit=$0008CONST MemberBit=$0010CONST VectorBit=$0020CONST TempBit=$0040CONST DataBit=$0080CONST ReDimBit=$0100CONST UsrFcnBit=$0200CONST CalledBit=$0400CONST SubClassedBit=$0800CONST InterceptBit=$1000; **** Not Used ****CONST TextDefinedBit=$2000CONST LogFontBit=$4000CONST InitDataBit=$8000CONST TmpVec=$60CONST ArrayMsk=$fffeCONST evActivateUsed=0CONST evCommandUsed=1CONST evMouseDownUsed=2CONST evMouseHoverUsed=3CONST evLButtonDownUsed=4CONST evLButtonUpUsed=5CONST evScrollUsed=6CONST evSysCommandUsed=7CONST evKeyDownUsed=8CONST evKeyUpUsed=9CONST evClickUsed=10CONST evChangeUsed=11CONST evSelectUsed=12CONST evCreateUsed=13CONST evResizeUsed=14CONST evMoveUsed=15CONST evMouseActivateUsed=16CONST evMouseHoverUsed=17CONST evMouseLeaveUsed=18CONST evMouseMoveUsed=19CONST evMouseWheelUsed=20CONST evDestroyUsed=21CONST evDblClickUsed=22CONST evRButtonDownUsed=23CONST evRButtonUpUsed=24CONST evContextMenuUsed=25CONST evReserved2Used=26CONST evReserved3Used=27CONST evReserved4Used=28CONST evReserved5Used=29CONST evReserved6Used=30CONST evReserved7Used=31CONST evNotify1Used=32CONST evNotify2Used=33CONST evNotify3Used=34CONST evNotify4Used=35CONST evNotify5Used=36CONST evNotify6Used=37CONST evNotify7Used=38CONST evNotify8Used=39CONST evNotify9Used=40CONST evNotify10Used=41CONST evNotify11Used=42CONST evNotify12Used=43CONST evNotify13Used=44CONST evNotify14Used=45CONST evNotify15Used=46CONST evNotify16Used=47CONST evNotify17Used=48CONST evNotify18Used=49CONST evNotify19Used=50CONST evNotify20Used=51CONST evNotify21Used=52CONST evNotify22Used=53CONST evNotify23Used=54CONST evNotify24Used=55CONST evNotify25Used=56CONST evNotify260Used=57CONST evNotify271Used=58CONST evNotify28Used=59CONST evNotify29Used=60CONST evNotify30Used=61CONST evNotify31Used=62CONST evNotify32Used=63CONST NULLClass=0CONST INTClass=1CONST STRClass=2CONST ARRClass=3CONST CPXClass=4CONST FLTClass=5CONST BOOLClass=6CONST OBJClass=7CONST FRMClass=8CONST LBLClass=9CONST TTypRelOp=1CONST TTypPunct=2CONST TTypMath=3CONST TTypQuote=4CONST TTypSym=5CONST TTypInt=6CONST TTypHex=7CONST TTypParen=8CONST TTypMisc=9CONST TTypFloat=10CONST TTypOct=11CONST TTypBin=12CONST PTArrOpn=3CONST PTArrCls=4CONST PTFcnOpn=5CONST PTFcnCls=6CONST PTCpxOpn=24CONST PTFCpxCls=25CONST NumTemps=15CONST OBQUOTE=$22CONST LabelResolved=$ffCONST LabelUnresolved=0CONST _BufSize=1000CONST MacBufSiz=50000CONST ExpTabSiz=300CONST UserSym=317;  set to first user symbol in PreDefinedCONST SymTabSiz=3000; Asm Constants and VariablesTYPE IconData	idReserved AS INTEGER	idType AS INTEGER	idCount AS INTEGER	bWidth AS BYTE	bHeight AS BYTE	bColorCount AS BYTE	bReserved AS BYTE	wPlanes AS INTEGER	wBitCount AS INTEGER	dwBytesInRes AS LONG	dwImageOffset AS LONGEND TYPEDIM IconDir AS IconDataDIM ErrLineNum AS LONGDIM TextFound AS BOOLEANDIM IconCursorFlag AS BOOLEANDIM DeferFlag AS BOOLEANDIM ediUsed AS BOOLEANDIM ExclamationOK AS BOOLEANDIM DataLabel AS BOOLEANDIM CmpOpFlag AS BOOLEANDIM FindReplaceFlag AS BYTEDIM ByteArray(1) AS BYTE VECTORDIM MenuOp AS BYTEDIM FindReplace AS BYTEDIM OpenSave AS BYTEDIM TConst AS BYTEDIM D0Const AS BYTEDIM D1Const AS BYTEDIM FormExStyle AS STRING*100DIM ObjectCtr AS LONGDIM EnumVal AS LONGDIM EnumStep AS LONGDIM MenuIDNum AS LONGDIM TConstVal AS LONGDIM D0ConstVal AS LONGDIM D1ConstVal AS LONGDIM StartTime AS LONGDIM GUITempName AS STRING*28DIM GUIDataType AS INTEGERDIM GUITargetFlag AS BYTE;//DIM GUIObjFlag AS BYTE;//DIM GUIArrayFlag AS BYTEDIM TextFlag AS BYTEDIM ParentFlag AS BYTEDIM NotifyCode AS LONGDIM DescOffs AS LONGDIM SrcLineMod AS LONGDIM StyleCode AS LONGDIM TempStyle AS STRING*10DIM TempExStyle AS STRING*100DIM ObjectParent AS STRING*32DIM ObjectParentName AS STRING*30DIM HandleName AS STRING*28DIM ObjectType AS LONGDIM ObjectTypeSafe AS LONGDIM IgnoreRightParen AS BYTEDIM FcnTypes(8) AS BYTEDIM ProcFlag AS BYTEDIM FcnFlag AS BYTEDIM ProcFcnFlag AS BYTEDIM EventFlag AS BYTEDIM ProcFcn AS BYTEDIM InitTrue AS BYTEDIM HasFcn AS BYTEDIM SimpleCmp AS BYTEDIM ComplexCmp AS BYTEDIM PathIsVector AS BYTEDIM RepeatFlag AS BYTEDIM RepeatCnt AS LONGDIM ArrayDetail AS LONGDIM ArrayDataType AS INTEGERDIM CpxArrayOffset AS LONGDIM OpSizeStr AS STRING*16DIM ForDataType AS INTEGERDIM D1Cleared AS BYTEDIM TableNdx AS LONGDIM TableTypeNdx AS LONGDIM TableName AS STRING*28DIM TableElements AS LONGDIM TableCounter AS LONGDIM CommaCounter AS LONGDIM ObjectName AS STRING*28DIM ObjectNameSafe AS STRING*28DIM MenuWindowName AS STRING*28DIM MenuBarName AS STRING*28DIM MenuTitleName AS STRING*28DIM MenuItemName AS STRING*28DIM I AS LONGDIM J AS LONGDIM FirstValidChar AS BOOLEANDIM InFlag AS BOOLEANDIM ChildFlag AS BOOLEANDIM FilBufSiz AS LONGDIM FilBufAdr AS LONGDIM ANSIArgCtr AS LONGDIM ObjType AS BYTEDIM ObjClass AS LONGDIM TempObjClass AS LONGDIM ObjSubClass AS LONGDIM GUIFlag AS BYTEDIM GUITargetSymNdx AS LONGDIM HaltFlag AS BOOLEANDIM AsmOutFlag AS BOOLEANDIM DLLFlag AS BOOLEANDIM FloatFlag AS BYTEDIM ExpFlag AS BOOLEANDIM SubCtr AS BYTEDIM SubCtrSaf AS BYTEDIM MultiFlag AS BYTEDIM SubValue(3) AS LONGDIM SubValSaf(3) AS LONGDIM PrintPathFlag AS BYTEDIM Comment AS STRING*64DIM DirFlag AS BYTEDIM CrOpFlag AS BYTEDIM StatFlag AS BYTEDIM LopCtrNum AS LONGDIM LastSym AS LONGDIM LastKey AS LONGDIM LastImportFcn AS LONGDIM LastImportLib AS LONGDIM LastObj AS LONGDIM StartFlag AS BOOLEANDIM DataFlag AS BOOLEANDIM SelectFlag AS BOOLEANDIM CaseFlag AS BOOLEANDIM CaseElseFlag AS BOOLEANDIM CaseToFlag AS BOOLEANDIM XBufSize AS LONGDIM B AS STRING*10DIM BufRWFlg AS BYTEDIM NewLine AS BYTEDIM Fmt AS STRING*79DIM StringNum AS LONGDIM VectorFlag AS BYTEDIM VectorName AS STRING*28DIM DtaRegNum AS BYTEDIM LoopVars(100) AS STRING*28DIM LopVarNdx AS LONGDIM FcnName AS STRING*28DIM FcnDataMod AS LONGDIM FcnSymNdx AS LONGDIM NumArgs AS BYTEDIM TFcnArgs AS LONGDIM FloatOK AS BYTEDIM OneDot AS BYTEDIM LastExpression AS LONGDIM NoGen AS BOOLEANDIM OptNdx AS LONGDIM Opt AS STRING*1DIM CondValid AS BYTEDIM CondOp1 AS LONGDIM CondOp2 AS LONGDIM GenFlag(20) AS BYTEDIM GFNdx AS LONGDIM AddInst AS STRING*5DIM DecInc AS STRING*3DIM MsgName AS STRING*28DIM VarSize AS LONGDIM SetMask AS BYTEDIM ArrayBase AS BYTEDIM TmpMax AS BYTEDIM TmpVecMax AS BYTEDIM FTmpMax AS BYTEDIM ChrTmpMax AS BYTEDIM StrTmpMax AS BYTEDIM PrintFlag AS BYTEDIM TabFlag AS BYTEDIM DevFlag AS BYTEDIM LastStmt AS STRING*8DIM FcnCode AS BYTEDIM FileStat AS BYTEDIM DiskIO AS BYTEDIM FileIO AS BYTEDIM ReadFlag AS BYTEDIM AndOrFlag AS BYTEDIM CompFlag AS BYTEDIM Promote AS BYTEDIM Demote AS BYTEDIM DataOp AS BYTEDIM MathOp AS BYTEDIM LdRegName AS STRING*16DIM Reg0Name AS STRING*16DIM Reg1Name AS STRING*16DIM _DataType AS STRING*16DIM DWSafe AS STRING*3DIM D0Loaded AS BYTEDIM Target AS BYTEDIM TmpUse AS LONGDIM TmpVecUse AS LONGDIM FTmpUse AS LONGDIM ChrTmpUse AS LONGDIM StrTmpUse AS LONGDIM Op1Class AS BYTEDIM Operator AS BYTEDIM Op2Class AS BYTEDIM OpClass AS BYTEDIM Op1Type AS BYTEDIM Op1Mod AS LONGDIM Op1Detail AS LONGDIM Op2Type AS BYTEDIM Op2Mod AS LONGDIM Op2Detail AS LONGDIM Op1Name AS STRING*42DIM Op2Name AS STRING*42DIM SwitchClass AS BYTEDIM Op1DataSize AS LONGDIM Op2DataSize AS LONGDIM LNFlag AS BYTEDIM VarName AS STRING*28DIM BufName AS STRING*28DIM BufDataSize AS LONGDIM AccMode AS STRING*40DIM CreatMode AS STRING*40DIM PathVar AS STRING*42DIM PathName AS STRING*28DIM ToSubFlag AS BYTEDIM ToSub AS STRING*5DIM DigDec AS BYTEDIM TFcnDataType AS BYTEDIM FcnSpec AS BYTEDIM JmpArgs AS LONGDIM LabelNum AS LONGDIM OELabelNum AS LONGDIM SCLabelNum AS LONGDIM TableNum AS LONGDIM ObjectID AS LONGDIM ProcNum AS LONGDIM InterceptProcNum AS LONGTYPE ConStruct	TermLabel AS LONG	ContLabel AS LONG	LoopName AS STRING*28	ConType AS BYTE	ConLine AS LONG	LoopVec AS LONG	LoopLabel AS LONG	NoStep AS BYTE	ImmTo AS BYTE	ImmToVal AS STRING*10	ImmStep AS BYTE	ImmStepVal AS STRING*10	NegImmStep AS BYTEEND TYPEDIM ConStk(40) AS ConStructDIM ConStkPtr AS LONGDIM StatusFile AS FILEDIM InpFile(20) AS FILEDIM InpFilPtr AS LONGDIM DeclareFile AS FILEDIM CodeFile AS FILEDIM PreCodeFile AS FILEDIM DataFile AS FILEDIM DimFile AS FILEDIM DescFile AS FILEDIM InitFile AS FILEDIM FunctionFile AS FILEDIM ImportFile AS FILEDIM ExportFile AS FILEDIM ResourceFile AS FILEDIM BitMapFile AS FILEDIM OutFile AS FILEDIM RawData AS STRING*1DIM LastRawData AS STRING*1DIM TempStr AS STRING*_BufSizeDIM FcnOp1Nam AS STRING*28DIM FcnOp2Nam AS STRING*28DIM TempName AS STRING*28DIM ToolButtonNdx AS LONGDIM TempInt AS LONGDIM TempInt2 AS LONGDIM TempLabel AS LABELDIM TempLabel2 AS LABELDIM StringLength AS LONGDIM TempByte AS STRING*1DIM ErrNo AS LONGDIM NextByte AS STRING*1DIM AsciiByte AS BYTEDIM Konstant AS LONGDIM StringCnt AS LONGDIM StringLen AS LONGDIM LoopNum AS LONGTYPE Symbol	SymName AS STRING*28	DataType AS INTEGER	SubType AS INTEGER	DataMod AS LONG	Detail AS LONG	DataAddr AS LONG	DataSize AS LONG	ArrayDim1 AS LONG	ArrayDim2 AS LONG	ArrayDim3 AS LONG	GUIEvents AS LONG	GUINotifyEvents AS LONG	ArrayDims AS BYTE	Misc AS BYTE	FcnDataType AS BYTE	FcnArgs AS BYTEEND TYPEDIM SymTable(SymTabSiz) AS SymbolDIM SymTableKey(SymTabSiz) AS LONGTYPE KeyData	KeyCheckWord AS LONG	KeyName AS STRING*20	KeyLabel AS LABELEND TYPETYPE ObjData	ObjCheckWord AS LONG	ObjSource AS LONG	ObjName AS STRING*32	ObjTypeName AS STRING*32	ObjExStyle AS STRING*32	ObjPropTable AS LABEL	ObjStyleTable AS LABEL	ObjEventTable AS LABELEND TYPETYPE PropData	PropName AS STRING*32	PropGet AS LABEL	PropSet AS LABEL	PropDataType AS INTEGER	PropValid AS BOOLEANEND TYPEDIM PropArray(1) AS PropData VECTORDIM PropValidTable(14) AS BOOLEANTYPE StyleData	StyleName AS STRING*32	StyleValue AS LONG	StyleType AS BYTE	StyleDefault AS BOOLEANEND TYPEDIM StyleArray(1) AS StyleData VECTORTYPE EventData	EVType AS STRING*32	EVStatusBit AS LONG	EVDescOffs AS LONG	EVNotify AS LONGEND TYPEDIM EventArray(1) AS EventData VECTORTYPE ImportFcnData	ImportLibUseNdx AS BYTE	ImportFcnAlias AS STRING*28	ImportFcnName AS STRING*28	ImportFcnUse AS BOOLEAN	ImportFcnLastUsed AS BOOLEANEND TYPETYPE ImportLibData	ImportLibAlias AS STRING*28	ImportLibName AS STRING*28	ImportLibUse AS BOOLEAN	ImportLibLastUsed AS BOOLEANEND TYPE; Use FlagsDIM UseReadFile AS BOOLEANDIM UseWriteFile AS BOOLEANDIM UseSetStrConst AS BOOLEANDIM UseTrmStr AS BOOLEANDIM UsePrtUsing AS BOOLEANDIM UseData AS BOOLEANDIM UseMovStr AS BOOLEANDIM UseCmpStr AS BOOLEANDIM UseStrLen AS BOOLEANDIM UseSubStr AS BOOLEANDIM UseMidStr AS BOOLEANDIM UseRightStr AS BOOLEANDIM UseClrConv AS BOOLEANDIM UseAtoD AS BOOLEANDIM UseAtoL AS BOOLEANDIM UseNumScan AS BOOLEANDIM UseZLtoH AS BOOLEANDIM UseZLtoA AS BOOLEANDIM UseLtoA AS BOOLEANDIM UseDtoA AS BOOLEANDIM UseLtoH AS BOOLEANDIM UsePrintStr AS BOOLEANDIM UsePrintTab AS BOOLEANDIM UseInpData AS BOOLEANDIM UseBtoA AS BOOLEANDIM UseLCase AS BOOLEANDIM UseUCase AS BOOLEANDIM UseTailStr AS BOOLEANDIM UseIncZRank AS BOOLEANDIM UseSetRightBottom AS BOOLEANDIM UMFlag AS BYTEDIM CVTemp AS LONGDIM CVOp AS STRING*2DIM NeedComma AS BYTEDIM MacExFlag AS BYTEDIM MacBuf(MacBufSiz) AS BYTEDIM MacDefNdx AS LONGDIM MacExNdx AS LONGDIM MacTblPtr AS LONGDIM MacArgBuf(16) AS STRING*100DIM MacArgPtr AS LONGDIM MaxArgNum AS BYTEDIM PoolCtr AS LONGDIM SymNdx AS LONGDIM SymNdxSaf AS LONGDIM DataSymNdx AS LONGDIM SymType AS STRING*32DIM SimpleOp AS STRING*8DIM SimpleStructOp AS STRING*8DIM ArraySize AS LONGDIM ForNdx AS LONGDIM DataTemp AS BYTEDIM TSymName AS STRING*28DIM VSymName AS STRING*28DIM TDataType AS INTEGERDIM AliasDataType AS INTEGERDIM TSubType AS INTEGERDIM TblDataType AS INTEGERDIM TDataMod AS LONGDIM VDataMod AS LONGDIM TDetail AS LONGDIM VDetail AS LONGDIM TDataAddr AS LONGDIM VDataAddr AS LONGDIM TDataSize AS LONGDIM TArrayDims AS BYTEDIM TArrayDim1 AS LONGDIM TArrayDim2 AS LONGDIM TArrayDim3 AS LONGDIM TGUIEvents AS LONGDIM TGUINotifyEvents AS LONGDIM ExpTable(ExpTabSiz) AS LONGDIM TypePtr AS LONGDIM TypeFlag AS BYTEDIM AliasFlag AS BYTEDIM LastEntry AS SymbolDIM SymTemp AS SymbolDIM SrcLine AS STRING*_BufSizeDIM SrcLineSaf AS STRING*_BufSizeDIM OutBuf AS STRING*_BufSizeDIM TokenBuf AS STRING*_BufSizeDIM ExpEnd AS BYTEDIM TokenLen AS LONGDIM ExpLen AS LONGDIM LastGroup AS BYTEDIM TokenType AS BYTEDIM LastByte AS BYTEDIM IsOperator AS BYTEDIM WasOperator AS BYTEDIM TokenSaf AS STRING*_BufSizeDIM RootSym AS STRING*29DIM Subscript(3) AS STRING*28DIM SubscrErr AS BYTEDIM KeyWord AS STRING*29DIM KeyNdx AS LONGDIM ObjNdx AS LONGDIM SymbolSaf AS STRING*29DIM NumberOK AS BYTEDIM HexOK AS BYTEDIM SymbolOK AS BYTEDIM IntOK AS BYTEDIM DimFlag AS BYTEDIM DimOK AS BYTEDIM BasicLineCtr AS LONGDIM AsmLineCtr AS LONGDIM QuoteFlag AS BYTEDIM EscSeq AS BYTEDIM ParenStk(100) AS BYTEDIM ParenCnt AS BYTEDIM FcnCtr AS BYTEDIM AECtr AS BYTEDIM LevelCnt AS BYTEDIM SymFull AS BYTEDIM SymFound AS BOOLEANDIM ErrCnt AS LONGDIM VarBytRem AS LONGDIM TypeBytes AS LONGDIM TypeVars AS LONGDIM TypeNdx AS LONGDIM LabelFlag AS BYTEDIM DMTemp AS BYTEDIM DMVector AS BYTEDIM DMMember AS BYTEDIM DMMulti AS BYTEDIM DMConst AS BYTEDIM DMAddr AS BYTEDIM DMArray AS BYTEDIM DMReDim AS BYTEDIM DMSubClassed AS BYTEDIM EndFound AS BYTEDIM AsmFileName AS STRINGDIM BareFileName AS STRINGDIM UseFilNam AS STRINGDIM Ctr1 AS LONGDIM Ctr2 AS LONGDIM Ctr3 AS LONGDIM WhiteSpaceCtr AS LONGDIM SrcNdx AS LONGDIM EndNdx AS LONGDIM SrcNdxCpy AS LONGDIM SrcNdxSaf AS LONGDIM ExpEndSaf AS BYTEDIM NumberNdx AS LONGDIM ValidNdx AS LONGDIM LabNdx AS LONGDIM ExpNdx AS LONGDIM ExpLeft AS LONGDIM ExpRight AS LONGDIM PType AS LONG; Pupput Descripor StructureCONST PuppetHandleOffs=0CONST PuppetIDOffs=4CONST PuppetOwnerOffs=8CONST PuppetArrayOffs=12CONST PuppetLeftOffs=16CONST PuppetTopOffs=20CONST PuppetWidthOffs=24CONST PuppetHeightOffs=28CONST PuppetBackColorOffs=32CONST PuppetForeColorOffs=36CONST PuppetTypeOffs=40CONST PuppetStatusOffs=44CONST PuppetFontOffs=48CONST PuppetIconOffs=52CONST PuppetTextOffs=56CONST PuppetNameOffs=72;Object Descriptor StructureCONST HandleOffs=0CONST IDOffs=4CONST OwnerOffs=8CONST ArrayOffs=12CONST LeftOffs=16CONST TopOffs=20CONST RightOffs=24CONST BottomOffs=28CONST BackColorOffs=32CONST ForeColorOffs=36CONST TypeOffs=40CONST StatusOffs=44CONST evActivateOffs=48CONST evCommandOffs=52CONST evMouseActivateOffs=56CONST evMouseHoverOffs=60CONST evMouseLeaveOffs=64CONST evMouseMoveOffs=68CONST evMouseWheelOffs=72CONST evScrollOffs=76CONST evCreateOffs=80CONST evDestroy=84CONST evKeyDownOffs=88CONST evKeyUpOffs=92CONST evDblClickOffs=96CONST cdDblClickOffs=100CONST evClickOffs=104CONST cdClickOffs=108CONST evChangeOffs=112CONST cdChangeOffs=116CONST evSelectOffs=120CONST cdSelectOffs=124CONST evNotify1Offs=128CONST cdNotify1Offs=132CONST evNotify2Offs=136CONST cdNotify2Offs=140CONST evNotify3Offs=144CONST cdNotify3Offs=148CONST evNotify4Offs=152CONST cdNotify4Offs=156CONST evNotify5Offs=160CONST cdNotify5Offs=164CONST evNotify6Offs=168CONST cdNotify6Offs=172CONST evNotify7Offs=176CONST cdNotify7Offs=180CONST evNotify8Offs=184CONST cdNotify8Offs=188CONST evNotify9Offs=192CONST cdNotify9Offs=196CONST evNotify10Offs=200CONST cdNotify10Offs=204CONST evNotify11Offs=208CONST cdNotify11Offs=212CONST evNotify12Offs=216CONST cdNotify12Offs=220CONST evNotify13Offs=224CONST cdNotify13Offs=228CONST evNotify14Offs=232CONST cdNotify14Offs=236CONST evNotify15Offs=240CONST cdNotify15Offs=244CONST evNotify16Offs=248CONST cdNotify16Offs=252CONST evNotify17Offs=256CONST cdNotify17Offs=260CONST evNotify18Offs=264CONST cdNotify18Offs=268CONST evNotify19Offs=272CONST cdNotify19Offs=276CONST evNotify20Offs=280CONST cdNotify20Offs=284CONST evNotify21Offs=288CONST cdNotify21Offs=292CONST evNotify22Offs=296CONST cdNotify22Offs=300CONST evNotify23Offs=304CONST cdNotify23Offs=308CONST evNotify24Offs=312CONST cdNotify24Offs=316CONST evNotify25Offs=320CONST cdNotify25Offs=324CONST evNotify26Offs=328CONST cdNotify26Offs=332CONST evNotify27Offs=336CONST cdNotify27Offs=340CONST evNotify28Offs=344CONST cdNotify28Offs=348CONST evNotify29Offs=352CONST cdNotify29Offs=356CONST evNotify30Offs=360CONST cdNotify30Offs=364CONST evNotify31Offs=368CONST cdNotify31Offs=372CONST evNotify32Offs=376CONST cdNotify32Offs=380CONST evSysCommandOffs=384CONST evResizeOffs=388CONST evMoveOffs=392CONST evLButtonDownOffs=396CONST evLButtonUpOffs=400CONST evRButtonDownOffs=404CONST evRButtonUpOffs=408CONST ToolTipHandleOffs=412CONST evContextMenuOffs=416CONST evReserved2Offs=420CONST evReserved3Offs=424CONST evReserved4Offs=428CONST evReserved5Offs=432CONST evReserved6Offs=436CONST evReserved7Offs=440CONST Reserved1Offs=444CONST Reserved2Offs=448CONST Reserved3Offs=452CONST Reserved4Offs=456CONST Reserved5Offs=460CONST Reserved6Offs=464CONST Reserved7Offs=468CONST Reserved8Offs=472CONST ZRankOffs=476; Sequential update numberCONST WidthOffs=480CONST HeightOffs=484CONST ControlBrushOffs=488CONST InterceptSafeOffs=492CONST InterceptProcOffs=496CONST Extra1Offs=500CONST Extra2Offs=504CONST DoNoUseOffs=508;******************************************* IDE Code Starts Here ********************************OBMain.CREATEBasicAsm=TRUETextMode=TRUEToolView=TRUEPropView=TRUEStyleView=TRUEGraphicConstructed=FALSEMENU OBMain	MENUBAR MainMenu		MENUTITLE FileMenu,"File"			MENUITEM mnuNew,"New"			MENUITEM mnuOpen,"Open"			MENUITEM mnuSave,"Save"			MENUITEM mnuSaveAs,"Save As"			MENUSEPARATOR			MENUITEM mnuPrint,"Print"			MENUSEPARATOR			MENUITEM mnuExit,"Exit"			REM		MENUTITLE EditMenu,"Edit"			MENUITEM mnuUnDo,"Undo"			MENUITEM mnuReDo,"Redo",			MENUSEPARATOR			MENUITEM mnuCut,"Cut"			MENUITEM mnuCopy,"Copy"			MENUITEM mnuPaste,"Paste"			MENUSEPARATOR			MENUITEM mnuSelectAll,"Select All",			MENUSEPARATOR			MENUITEM mnuGotoLine,"Goto Line"			MENUSEPARATOR			MENUITEM mnuFind,"Find"			MENUITEM mnuReplace,"Replace"		MENUTITLE ViewMenu,"View"			MENUITEM mnuToolBox,"ToolBox"			MENUITEM mnuPropertyBox,"PropertyBox"			MENUITEM mnuStyleBox,"StyleView"		MENUTITLE OptionMenu,"Option"			MENUITEM mnuPreferences,"Preferences"			MENUSEPARATOR			MENUITEM mnuFont,"Font"		MENUTITLE ColorMenu,"Colors"			MENUITEM mnuStatement,"Statements"			MENUSEPARATOR			MENUITEM mnuFunctions,"Functions"			MENUSEPARATOR			MENUITEM mnuRegisters,"Registers"			MENUSEPARATOR			MENUITEM mnuAsm,"Asm"			MENUSEPARATOR			MENUITEM mnuDataType,"DataType"		MENUTITLE CompileMenu,"Compile"			MENUITEM mnuCompile,"Compile To EXE"			MENUITEM mnuAssemble,"Compile To .ASM"			MENUITEM mnuTestCompile,"Compile Errors"			MENUSEPARATOR			MENUITEM mnuRun,"Run"		MENUTITLE DebugMenu,"Debug"			MENUITEM mnuStart,"Start"			MENUITEM mnuStop,"Stop"			MENUITEM mnuStep,"Step"			MENUITEM mnuEnd,"End"		MENUTITLE HelpMenu,"Help"			MENUITEM mnuHelp,"Help"			MENUSEPARATOR			MENUITEM mnuAbout,"About"							END MENUDISABLEMENUITEM MainMenu,mnuSaveButton(3).ICON=SaveIcon2SETPOSITION OBMain,0,0,1024,740CONSTRUCT StatusBar,0,0,0,0sbParts(1)=0sbParts(2)=100sbParts(3)=200sbParts(4)=300sbParts(5)=400sbParts(6)=500StatusBar.SETPARTS 6,sbParts;CONSTRUCT ToolBar,0,0,0,0CONSTRUCT Edit,0,38,1015,634CONSTRUCT BackGround,0,42,1015,630BackGround.VISIBLE=FALSEBackGround.BACKCOLOR=$b0a080lf.lfHeight=-12lf.lfFaceName="Courier New"CreateFont RAFont(1),lflf.lfItalic=1CreateFont RAFont(2),lflf.lfHeight=-10lf.lfFaceName="Terminal"lf.lfItalic=0CreateFont RAFont(3),lfEdit.setfont RAFontszRegs="AH AL AX BH BL BP BX CH CL CR0 CR2 CR3 CS CX DH DI DL DR0 DR1 DR2 DR3 DR6 DR7 DS DX EAX EBP EBX ECX EDI EDX ES ESI ESP FS GS MM0 MM1 MM2 MM3 MM4 MM5 MM6 MM7 SI SP SS ST TR3 TR4 TR5 TR6 TR7 XMM0 XMM1 XMM2 XMM3"Edit.sethilitewords szRegs,$0080ffszGUIInst="FINDITEM FINDITEMEXACT PASSINTERCEPTEVENT CREATEICON CREATECURSOR CREATEBITMAP CHECKMENUITEM UNCHECKMENUITEM MENU ENDMENU PRINTDIALOG PAGEDIALOG FONTDIALOG COLORDIALOG REPLACEDIALOG ENDEVENT SHOW DESTROY SETCAPTURE RELEASECAPTURE GETCURSORPOSITION SCREENTOCLIENT GETWINDOWRECT MENUBAR MENUTITLE MENUITEM MENUSEPARATOR PASSSYSTEMEVENT CONSTRUCT SETPOSITION CREATEFONT SETFOCUS FIND SETSTYLE MSGBOX WARNINGBOX INFOBOX QUESTIONBOX ERRORBOX DISABLEMENUITEM ENABLEMENUITEM FINDDIALOG OPENDIALOG SAVEDIALOG"Edit.sethilitewords szGUIInst,$ff;szGUIProps="ADDRESS INTERCEPTON INTERCEPTOFF ID VISIBLE ENABLED TOP WIDTH HEIGHT BOTTOM ZRANK BACKCOLOR ICON FLASHWINDOW RESIZE FLAT 3D MOVE MOUSEMOVE LBUTTONDOWN LBUTTONUP RBUTTONDOWN RBUTTONUP BACKCOLOR FORECOLOR FONT ICON COMMAND ADDITEM ADDITEMSORTED INSERTITEM CLEAR SELITEM TOPITEM SELTEXT ITEMCOUNT CHANGE SCROLL AUTOTICKS BOTH ENABLESELRANGE FIXEDLENGTH NOTICKS NOTHUMB VERT VALUE CHECKED INTERVAL STOP LINE LOADFILE SETDIVIDERLINE SAVEFILE TEXTCOLOR SELBACKCOLOR SELTEXTCOLOR COMMENTCOLOR STRINGCOLOR OPERATORCOLOR HILITE1COLOR HILITE2COLOR HILITE3COLOR SELBARCOLOR SELBARPENCOLOR LINENUMCOLOR SETFONT GRIDCOLOR HEADERTEXT ADDROW ADDCOL DELETEROW INSERTROW MOVEROW HEADERHEIGHT ROWHEIGHT GRIDCLEAR COMBOCLEAR SORT CLICK HEADERCLICK BUTTONCLICK CHECKCLICK IMAGECLICK BEFORESELCHANGE AFTERSELCHANGE BEFOREEDIT AFTEREDIT USERCONVERT DROPPED SELECTALL SETSEL GETSEL INSERTTEXT APPENDTEXT REPLACETEXT REPLACESEL CURSORPOS";Edit.SETHILITEWORDS szGUIProps,$ffszGUIProps2=" CREATE CUT COPY PASTE UNDO REDO"Edit.SETHILITEWORDS szGUIProps2,$ffszAsmInst="DB DW DD ALIGN EQU INVOKE CINVOKE AAA AAD AAM AAS ADC ADD AND CALL CBW CLC CLD CLI CMC CMP CMPS CMPSB CMPSW CWD DAS DEC DIV DAA ESC HLT IDIV IMUL IN INC INT INTO IRET JA JAE JB JBE JC JCXZ JE JG JGE JL JLE JMP JNA JNAE JNB JNBE JNC JNE JNG JNGE JNL JNLE JNO JNP JNS JNZ JO JP JPE JPO JS JZ LAHF LDS LEA LES LODS LODSB LODSW LOOP LOOPE LOOPEW LOOPNE LOOPNEW LOOPNZ LOOPNZW LOOPW LOOPZ LOOPZW MOV MOVS MOVSB MOVSW MUL NEG NOP NOT OR OUT POP POPF PUSH PUSHF RCL RCR RET RETF RETN ROL ROR SAHF SAL SAR SBB SCAS SCASB SCASW SETE SHL SHR STC STD STI STOS STOSB STOSW SUB TEST WAIT XCHG XLAT XLATB XOR"Edit.sethilitewords szAsmInst,$FFszBasicInst="READCARD WRITECARD USEIMPORT IMPORTFUNCTION EXPORTFUNCTION BEGINLOOP SHOWPOPUP POPUPMENU TEXTBLOCK ENDTEXT ENDTYPE MAKELOWER MAKEUPPER SWAP PROGRAM ENDCASE ENDSELECT WEND PROCEDURE FUNCTION DECLARE RANDOMIZE ENDPROCEDURE ENDFUNCTION CALL CHDIR MKDIR RMDIR INCLUDE FREEZE DIGITS SETVEC REDIM PLAYWAVE ENDWXIT DECIMAL EXCHANGE BEEP BUFREAD BUFWRITE BASE SHELL FPRINT FINPUTEXITIF UNTIL REPEAT ENDLOOP BUFFER REM ENDWHILE WHILE OPEN GET PUT READ INPUT SEEK EVENT TRUE FALSE AS MENU GOTO GOSUB FOR TO ENDIF PRINT ELSE IF THEN BEGIN LOOP END DATA TABLE SELECT CASE DIM TYPE ENDTABLE LET CONST MACRO ENDMACRO INCR DECR NEXT RESTORE TEXT WRITE RETURN CLOSE AND CREATE DELETE ON ERROR OR ENUM ENDENUM POKE"Edit.sethilitewords szBasicInst,$FFszFcns="TABLESIZE TAIL UCASE LCASE GETTICKCOUNT RND OCT BIN RCR RCL SAR SAL SUBSTR BITSET BITCLR BITCHG ROR ROL SHR SHL BITTST CHKWORD HEX LOG10 LOG ATN ACS ASN TAN COS SIN INT SQR FILPOS FILSIZ TRIM FVAL IVAL SIZE INDEX NOT LNOT EOF LAND LOR LXOR LEN STR VAL ADDR MID LEFT RIGHT ABS MOD CHR ASC NOT BUFADR BUFSIZ TAB PEEK"Edit.sethilitewords szFcns,$FF00FFszDataType="RAEDIT RAGRID TOOLWINDOW LISTVIEW HANDLE BITMAP CURSOR ICON FONT DEVICE FILE BYTE INTEGER LONG FLOAT LABEL POINTER VECTOR ALIAS BOOLEAN STRING WORD DWORD BUTTON FORM COMBOBOX LISTBOX TEXTBOX STATICBOX STATICTEXT CHECKBOX FRAME RADIOBUTTON SLIDER STATUSBAR PROGRESSBAR TOOLBAR SPINNER CALENDAR HEADER TREEVIEW TABFOLDER BUTTONLISTBOX RICHEDIT ICONBUTTON STATICICON TIMER"Edit.sethilitewords szDataType,$808000Edit.backcolor=$ffffffEdit.linenumcolor=$0000a0SaveFileName=""EditfChanged=0StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSEInitDir="C:\nb"FileFilter="OB Project",0,"*.obp",0,"OB Window",0,"*.obw",0,"OB Console",0,"*.obc",0,"Assembler",0,"*.asm",0,"All Files",0,"*.*",0,0TempStr=ProgramName+"    [Untitled]" OBMain.TEXT=TempStrFileName="Untitled"Edit.SETFOCUSCONSTRUCT Button(1),5,0,32,32CONSTRUCT Button(2),40,0,32,32CONSTRUCT Button(3),75,0,32,32CONSTRUCT Button(4),110,0,32,32CONSTRUCT Button(5),145,0,32,32CONSTRUCT Button(6),200,0,32,32CONSTRUCT Button(7),255,0,32,32CONSTRUCT Button(8),290,0,32,32CONSTRUCT Button(9),325,0,32,32CONSTRUCT Button(10),360,0,32,32CONSTRUCT Button(11),395,0,32,32CONSTRUCT Button(12),430,0,32,32CONSTRUCT Button(13),465,0,32,32CONSTRUCT Button(14),500,0,32,32CONSTRUCT Button(15),535,0,32,32CONSTRUCT Button(16),590,0,32,32CONSTRUCT Button(17),625,0,32,32CONSTRUCT Button(18),660,0,32,32CONSTRUCT Button(19),695,0,32,32CONSTRUCT Button(20),730,0,32,32CONSTRUCT Button(21),765,0,32,32CONSTRUCT Button(22),820,0,32,32;CONSTRUCT Button(23),795,0,32,32CONSTRUCT Button(24),980,0,32,32Button(7).ENABLED=FALSEButton(8).ENABLED=FALSECREATEICON OmniIcon,ColrefOBMain.ICON=OmniIconCREATEICON NewIcon,NewButton(1).ICON=NewIconCREATEICON OpenIcon,OpenFoldButton(2).ICON=OpenIconCREATEICON SaveIcon,Floppy3CREATEICON SaveIcon2,Floppy6Button(3).ICON=SaveIcon2CREATEICON SaveAsIcon,Floppy4Button(4).ICON=SaveAsIconCREATEICON PrintIcon,prtr2Button(5).ICON=PrintIconCREATEICON ToolIcon,Newicon2Button(6).ICON=ToolIconCREATEICON EditIcon,DocCREATEICON UnDoIcon,UndoButton(7).ICON=UnDoIconCREATEICON ReDoIcon,RedoButton(8).ICON=ReDoIconCREATEICON DeleteIcon,DeleteButton(9).ICON=DeleteIconCREATEICON CutIcon,CutButton(10).ICON=CutIconCREATEICON CopyIcon,CopyButton(11).ICON=CopyIconCREATEICON PasteIcon,PasteButton(12).ICON=PasteIconCREATEICON GoToIcon,Point02Button(13).ICON=GoToIconCREATEICON FindIcon,binoculrButton(14).ICON=FindIconCREATEICON ReplaceIcon,Key06Button(15).ICON=ReplaceIconCREATEICON CompileToExeIcon,panelButton(16).ICON=CompileToExeIconCREATEICON CompileToAsmIcon,asmiconButton(17).ICON=CompileToAsmIconCREATEICON CompileForErrIcon,prop0Button(18).ICON=CompileForErrIconCREATEICON CompileForDebugIcon,BinaryButton(19).ICON=CompileForDebugIconCREATEICON SymbolsIcon,qrlistButton(20).ICON=SymbolsIconCREATEICON UnusedSymIcon,questionButton(21).ICON=UnusedSymIconCREATEICON RunIcon,executeButton(22).ICON=RunIconCREATEICON HelpIcon,Question2Button(24).ICON=HelpIconLF1.lfHeight=10LF1.lfFaceName="MS Sans Serif"CreateFont Font1,LF1POPUPMENU EditPopUp	MENUITEM menugreen,"Green"	MENUITEM menured,"Red"	MENUITEM menuwhite,"White"	MENUSEPARATOR	MENUITEM menuexit,"Exit"END MENUPOPUPMENU FormPopUp	MENUITEM menupurple,"Purple"	MENUITEM menuyellow,"Yellow"	MENUITEM menugray,"Gray"END MENUFormWindowConstructed=FALSESETVEC ControlArray=ADDR(ObjectPool)MinMaxFlag=TRUEControlCount=0ControlPosValid=0END EVENTMENU.commandSELECT CASE MenuID	CASE mnuNew		GOSUB NewCmd	CASE mnuOpen		GOSUB OpenCmd	CASE mnuSave		GOSUB SaveCmd	CASE mnuSaveAs		GOSUB SaveAsCmd	CASE mnuPrint	CASE mnuExit		IF Changed=TRUE THEN			TempName=SaveFileName+" Not Saved"			TempStr="Save?"			WARNINGBOX TempName,TempStr,MB_YESNOCANCEL			IF STATUS=IDYES THEN				IF FileName="Untitled" THEN					GOSUB SaveAs					IF STATUS=0 THEN						RETURN					ENDIF					GOTO Quit				ELSE					Edit.SAVEFILE SaveFileName					DISABLEMENUITEM MainMenu,mnuSave					Button(3).ICON=SaveIcon2					StatusBarSafe5="Not Changed"					StatusBar.SETTEXT 5,StatusBarSafe5					Changed=FALSE					GOTO Quit				ENDIF			ELSE				IF STATUS=IDNO THEN					GOTO Quit				ELSE					RETURN				ENDIF			ENDIF		ENDIF		GOTO Quit	CASE mnuUnDo		Edit.UNDO	CASE mnuReDo		Edit.REDO	CASE mnuCut		Edit.CUT	CASE mnuCopy		Edit.COPY	CASE mnuPaste		Edit.PASTE	CASE mnuSelectAll		Edit.SELECTALL	CASE mnuGotoLine		GOSUB GotoLine		GotoText.SETFOCUS	CASE mnuFind		GOSUB GetFindDialog	CASE mnuReplace		GOSUB GetFindReplaceDialog	CASE mnuPreferences	CASE mnuToolBox	CASE mnuPropertyBox	CASE mnuStyleBox	CASE mnuFont		FONTDIALOG FontStr	CASE mnuStatement		COLORDIALOG RGB		EXITIF RGB=$ffffffff		Edit.sethilitewords szBasicInst,RGB		Edit.sethilitewords szGUIInst,RGB		Edit.visible=false		Edit.visible=true	CASE mnuFunctions		COLORDIALOG RGB		EXITIF RGB=$ffffffff		Edit.sethilitewords szFcns,RGB		Edit.visible=false		Edit.visible=true	CASE mnuRegisters		COLORDIALOG RGB		EXITIF RGB=$ffffffff		Edit.sethilitewords szRegs,RGB		Edit.visible=false		Edit.visible=true	CASE mnuAsm		COLORDIALOG RGB		EXITIF RGB=$ffffffff		Edit.sethilitewords szAsmInst,RGB		Edit.visible=false		Edit.visible=true	CASE mnuDataType		COLORDIALOG RGB		EXITIF RGB=$ffffffff		Edit.sethilitewords szDataType,RGB		Edit.visible=false		Edit.visible=true	CASE mnuCompile		GOSUB CompileToExe	CASE mnuAssemble		GOSUB CompileToAsm	CASE mnuTestCompile		GOSUB TestCompile	CASE mnuStart	CASE mnuStop	CASE mnuStep	CASE mnuEnd	CASE mnuHelp	CASE mnuAbout		case menugreen;;;		Edit.backcolor=$ff00	case menured		Edit.backcolor=$ff	case menuwhite		Edit.backcolor=$ffffff	case menuexit		end	case menupurple;;;		FormWindow.backcolor=$ff00ff			case menuyellow		FormWindow.backcolor=$ffff	case menugray		FormWindow.backcolor=$c0c0c0	case menuexitEND SELECTEND EVENTSaveAs:FileName=SaveFileNameSAVEDIALOG FileName,FileFilter,InitDirIF STATUS<>0 THEN	Edit.EMPTYUNDOBUFFER	Edit.SAVEFILE FileName	SaveFileName=FileName	BareFileName=LEFT(FileName,LEN(FileName)-4)	Extension=RIGHT(FileName,4)	TempStr=ProgramName+"     ["+FileName+"]"	OBMain.TEXT=TempStrENDIFRETURNEdit.CHANGEStatusBarSafe1="Line "+STR(EditLine)StatusBar.SETTEXT 1,StatusBarSafe1StatusBarSafe2="Column "+STR(EditcpLine)StatusBar.SETTEXT 2,StatusBarSafe2StatusBarSafe3=STR(EditnLines)+" Lines"StatusBar.SETTEXT 3,StatusBarSafe3StatusBarSafe4="Edit Text"StatusBar.SETTEXT 4,StatusBarSafe4IF EditfChanged<>0 THEN	StatusBarSafe5="Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=TRUE	ENABLEMENUITEM MainMenu,mnuSave	Button(3).ICON=SaveIconENDIFIF Edit.CANUNDO=TRUE THEN	ENABLEMENUITEM MainMenu,mnuUnDo	Button(7).ENABLED=TRUEELSE	DISABLEMENUITEM MainMenu,mnuUnDo	Button(7).ENABLED=FALSE	StatusBarSafe5="Not Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=FALSE	DISABLEMENUITEM MainMenu,mnuSave	Button(3).ICON=SaveIcon2ENDIFIF Edit.CANREDO=TRUE THEN	ENABLEMENUITEM MainMenu,mnuReDo	Button(8).ENABLED=TRUEELSE	DISABLEMENUITEM MainMenu,mnuReDo	Button(8).ENABLED=FALSEENDIF;IF Edit.CANPASTE=TRUE THEN;	ENABLEMENUITEM MainMenu,mnuPaste;ELSE;	DISABLEMENUITEM MainMenu,mnuPaste;ENDIFEND EVENTGotoText.CHANGETempStr=GotoText.TEXTIF LEN(TempStr)=0 THEN	GotoButton.ENABLED=FALSEELSE	GotoButton.ENABLED=TRUEENDIFEND EVENTGotoButton.COMMANDTempStr=GotoText.TEXTTempInt=VAL(TempStr)Edit.GOTO TempIntGotoText.TEXT=""GotoWindow.VISIBLE=FALSEEND EVENTGotoWindow.SYSTEMGotoWindow.VISIBLE=FALSEEND EVENTButton.COMMANDSELECT CASE ArrayIndex	CASE 1		GOSUB NewCmd	CASE 2		GOSUB OpenCmd	CASE 3		GOSUB SaveCmd	CASE 4		GOSUB SaveAsCmd	CASE 5	CASE 6		IF TextMode=TRUE THEN			StatusBar.SETTEXT 1,""			StatusBar.SETTEXT 2,""			StatusBar.SETTEXT 3,""			StatusBar.SETTEXT 4,""			StatusBar.SETTEXT 5,""			FOR I=1 TO 22				IF I<>3 AND I<>6 AND I<>7 AND I<>8 THEN					Button(I).ENABLED=FALSE				END IF			NEXT I			IF Button(7).ENABLED=TRUE THEN				UnDoFlag=TRUE			ELSE				UnDoFlag=FALSE			ENDIF			Button(7).ENABLED=FALSE			IF Button(8).ENABLED=TRUE THEN				ReDoFlag=TRUE			ELSE				ReDoFlag=FALSE			ENDIF			Button(8).ENABLED=FALSE			IF GraphicConstructed=FALSE THEN				CONSTRUCT ToolBox,3,85,300,631 CHILD				ToolBox.TEXT="Toolbox"				ToolBox.VISIBLE=FALSE				CONSTRUCT ToolButton(1),0,4,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(1).TEXT="Form"				CONSTRUCT ToolButton(2),98,4,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(2).TEXT="ToolWindow"				CONSTRUCT ToolButton(3),196,4,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(3).TEXT="Button"				CONSTRUCT ToolButton(4),0,22,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(4).TEXT="StaticBox"				CONSTRUCT ToolButton(5),98,22,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(5).TEXT="Frame"				CONSTRUCT ToolButton(6),196,22,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(6).TEXT="Slider"				CONSTRUCT ToolButton(7),0,40,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(7).TEXT="TextBox"				CONSTRUCT ToolButton(8),98,40,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(8).TEXT="ComboBox"				CONSTRUCT ToolButton(9),196,40,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(9).TEXT="ListBox"				CONSTRUCT ToolButton(10),0,58,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(10).TEXT="RadioButton"				CONSTRUCT ToolButton(11),98,58,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(11).TEXT="CheckBox"				CONSTRUCT ToolButton(12),196,58,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(12).TEXT="ProgressBar"				CONSTRUCT ToolButton(13),0,76,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(13).TEXT="Calendar"				CONSTRUCT ToolButton(14),98,76,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(14).TEXT="TabFolder"				CONSTRUCT ToolButton(15),196,76,98,18,VISIBLE+CHILD+FLAT IN ToolBox				SETSTYLE ToolButton(15),$8000,TRUE				ToolButton(15).TEXT="Spinner"				CONSTRUCT ToolButton(16),0,94,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(16).TEXT="StatusBar"				CONSTRUCT ToolButton(17),98,94,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(17).TEXT="Header"				CONSTRUCT ToolButton(18),196,94,98,18,VISIBLE+CHILD+FLAT IN ToolBox				SETSTYLE ToolButton(18),$8000,TRUE				ToolButton(18).TEXT="ButtonListBox"				CONSTRUCT ToolButton(19),0,112,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(19).TEXT="RichEdit"				CONSTRUCT ToolButton(20),98,112,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(20).TEXT="RAEdit"				CONSTRUCT ToolButton(21),196,112,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(21).TEXT="RAGrid"				CONSTRUCT ToolButton(22),0,130,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(22).TEXT="ListView"				CONSTRUCT ToolButton(23),98,130,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(23).TEXT="ToolBar"				CONSTRUCT ToolButton(24),196,130,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(24).TEXT=""				CONSTRUCT ToolButton(25),0,148,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(25).TEXT=""				CONSTRUCT ToolButton(26),98,148,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(26).TEXT=""				CONSTRUCT ToolButton(27),196,148,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(27).TEXT=""				CONSTRUCT ToolButton(28),0,166,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(28).TEXT=""				CONSTRUCT ToolButton(29),98,166,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(29).TEXT=""				CONSTRUCT ToolButton(30),196,166,98,18,VISIBLE+CHILD+FLAT IN ToolBox				ToolButton(30).TEXT=""				CONSTRUCT FormCombo,0,184,245,160 IN ToolBox				CONSTRUCT MinMax,245,184,46,24 IN ToolBox				CONSTRUCT ControlCombo,0,210,290,160 IN ToolBox				MinMax.TEXT="Min"				CONSTRUCT PropGrid,0,236,295,185 IN ToolBox				PropGrid.HEADERHEIGHT=21				PropGrid.ADDCOL TEXT,100,"Property",CENTER,LEFT,31				PropGrid.ADDCOL TEXT,174,"Value",CENTER,LEFT,31				CONSTRUCT StyleGrid,0,421,295,185 IN ToolBox				StyleGrid.HEADERHEIGHT=21				StyleGrid.ADDCOL TEXT,114,"Style",CENTER,LEFT,31				StyleGrid.ADDCOL CHECK,60,"On/Off",CENTER,CENTER,31				StyleGrid.ADDCOL TEXT,100,"Value",CENTER,LEFT,31				ToolButtonNdx=1				FormWindow.VISIBLE=FALSE				GraphicConstructed=TRUE				ToolButtonNdx=1				GOSUB PopulateToolBox			ELSE				BackGround.VISIBLE=TRUE				ToolBox.VISIBLE=TRUE				FormWindow.VISIBLE=TRUE			ENDIF			TextMode=FALSE			FindWindow.VISIBLE=FALSE			FindReplaceWindow.VISIBLE=FALSE			Edit.VISIBLE=FALSE			GotoWindow.VISIBLE=FALSE			BackGround.VISIBLE=TRUE			IF ToolView=TRUE THEN				ToolBox.VISIBLE=TRUE			ENDIF			FormWindow.VISIBLE=TRUE			StatusBarSafe4="Edit Objects"			StatusBar.SETTEXT 4,StatusBarSafe4			Button(6).ICON=EditIcon		ELSE			StatusBar.SETTEXT 1,StatusBarSafe1			StatusBar.SETTEXT 2,StatusBarSafe2			StatusBar.SETTEXT 3,StatusBarSafe3			StatusBar.SETTEXT 4,StatusBarSafe4			StatusBar.SETTEXT 5,StatusBarSafe5			FOR I=1 TO 22				IF I<>3 AND I<>6 AND I<>7 AND I<>8 THEN					Button(I).ENABLED=TRUE				ENDIF				NEXT I			IF UnDoFlag=TRUE THEN				Button(7).ENABLED=TRUE			ELSE								Button(7).ENABLED=FALSE			ENDIF			IF ReDoFlag=TRUE THEN				Button(8).ENABLED=TRUE			ELSE				Button(8).ENABLED=FALSE			ENDIF			TextMode=TRUE			IF FindWindowActive THEN				FindWindow.VISIBLE=TRUE			ENDIF			IF FRWindowActive THEN				FindReplaceWindow.VISIBLE=TRUE			ENDIF			Edit.VISIBLE=TRUE			BackGround.VISIBLE=FALSE			ToolBox.VISIBLE=FALSE				IF FormWindowConstructed=TRUE THEN					FormWindow.VISIBLE=FALSE				ENDIF			StatusBarSafe4="Edit Text"			StatusBar.SETTEXT 4,StatusBarSafe4			Button(6).ICON=ToolIcon		ENDIF	CASE 7		Edit.UNDO	CASE 8		Edit.REDO	CASE 9					CASE 10		Edit.CUT		CASE 11		Edit.COPY		CASE 12		Edit.PASTE		CASE 13		GOSUB GotoLine		GotoText.SETFOCUS	CASE 14		GOSUB GetFindDialog	CASE 15		GOSUB GetFindReplaceDialog			CASE 16		GOSUB CompileToExe		GOSUB PostCompile		CASE 17		GOSUB CompileToAsm		GOSUB PostCompile		CASE 18		GOSUB TestCompile		GOSUB PostCompile		CASE 19		;Edit.APPENDTEXT "Havis"		;OBMain.text=TempStr	CASE 20		IF ShowSymbols=TRUE THEN			ShowSymbols=FALSE			DESTROY SymbolGrid			Edit.ENABLED=TRUE		ELSE			IF UserSym>=LastSym THEN				WARNINGBOX "Symbol Table","No Symbols In Table",MB_OK				RETURN			ENDIF			ShowSymbols=TRUE			Edit.ENABLED=FALSE			CONSTRUCT SymbolGrid,0,42,1015,630			SymbolGrid.BACKCOLOR=$ff0000			SymbolGrid.FORECOLOR=$ffffff			SymbolGrid.HEADERHEIGHT=20			SymbolGrid.ROWHEIGHT=20			SymbolGrid.ADDCOL TEXT,40,"#",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,225,"Symbol Name",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,100,"DataType",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,45,"Sub",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Modifer",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Detail",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Addr",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Size",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Dim1",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Dim2",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Dim3",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Events",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,90,"Notify",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,45,"Dims",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,45,"Misc",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,45,"FDT",CENTER,LEFT,31			SymbolGrid.ADDCOL TEXT,45,"Args",CENTER,LEFT,31			FOR I=UserSym TO LastSym				J=I-UserSym+1				SymbolGrid.ADDROW				TempStr=STR(J)				GOSUB FormatNumber4				SymbolGrid.TEXT(J,1)=TempStr				TempStr=SymTable(I).SymName				SymbolGrid.TEXT(J,2)=TempStr				TempInt=SymTable(I).DataType				GOSUB GetDataType				SymbolGrid.TEXT(J,3)=TempStr				TempStr=HEX(SymTable(I).SubType)				GOSUB FormatNumber4				SymbolGrid.TEXT(J,4)=TempStr				TempStr=HEX(SymTable(I).DataMod)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,5)=TempStr				TempStr=HEX(SymTable(I).Detail)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,6)=TempStr				TempStr=HEX(SymTable(I).DataAddr)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,7)=TempStr				TempStr=HEX(SymTable(I).DataSize)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,8)=TempStr				TempStr=HEX(SymTable(I).ArrayDim1)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,9)=TempStr				TempStr=HEX(SymTable(I).ArrayDim2)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,10)=TempStr				TempStr=HEX(SymTable(I).ArrayDim3)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,11)=TempStr				TempStr=HEX(SymTable(I).GUIEvents)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,12)=TempStr				TempStr=HEX(SymTable(I).GUINotifyEvents)				GOSUB FormatNumber8				SymbolGrid.TEXT(J,13)=TempStr				TempStr=HEX(SymTable(I).ArrayDims)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,14)=TempStr				TempStr=HEX(SymTable(I).Misc)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,15)=TempStr				TempStr=HEX(SymTable(I).FcnDataType)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,16)=TempStr				TempStr=HEX(SymTable(I).FcnArgs)				GOSUB FormatNumber2				SymbolGrid.TEXT(J,17)=TempStr			NEXT I		ENDIF		CASE 21		CASE 22		SHELL BareFileName	CASE 23		CASE 24END SELECTEND EVENTGotoLine:IF GotoWindowConstructed=FALSE THEN	CONSTRUCT GotoWindow,100,100,110,90	GotoWindow.TEXT="Goto Line"	GotoWindowConstructed=TRUE	CONSTRUCT GotoText,10,10,80,20 IN GotoWindow	CONSTRUCT GotoButton,10,40,80,20 IN GotoWindow	GotoButton.TEXT="Goto Line"ELSE	GotoWindow.VISIBLE=TRUE	GotoText.SETFOCUSENDIFGotoButton.ENABLED=FALSERETURNToolBox.SYSTEMIF STATUS=$f060 THEN	ToolBox.VISIBLE=FALSEENDIFEND EVENTFormWindow.SYSTEM; Do NothingEND EVENTToolBox.RESIZE;SETPOSITION ToolBox,3,85,300,155END EVENT; *************************************** Compiler Code Starts Here ******************************; StartCompile:IF Changed=TRUE THEN	WARNINGBOX "File Not Saved","Save?",MB_YESNO	IF STATUS=IDYES THEN		IF FileName="Untitled" THEN			GOSUB SaveAs		ELSE			Edit.SAVEFILE SaveFileName			DISABLEMENUITEM MainMenu,mnuSave			Button(3).ICON=SaveIcon2		ENDIF	ELSE		RETURN	ENDIFENDIFEdit.EMPTYUNDOBUFFERChanged=FALSEDISABLEMENUITEM MainMenu,mnuSaveButton(3).ICON=SaveIcon2StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5StartTime=GETTICKCOUNT()SELECT CASE Extension	CASE ".obc"		GUIFlag=0	CASE ".obw"		GUIFlag=$ff	CASE ELSE		TempStr="No Recognized Extension"		WARNINGBOX "Error",TempStr,MB_OK		RETURNEND SELECTON ERROR GOTO NoInpFileInpFilPtr=1OPEN InpFile(InpFilPtr),FileName:READON ERROR GOTO NoDeclareFileDELETE "_DeclareFile"NoDeclareFile:CREATE DeclareFile,"_DeclareFile":WRITE+TEXTON ERROR GOTO NoPreCodeFileDELETE "_PreCodeFile"NoPreCodeFile:CREATE PreCodeFile,"_PreCodeFile":WRITE+TEXTON ERROR GOTO NoCodeFileDELETE "_CodeFile"NoCodeFile:CREATE CodeFile,"_CodeFile":WRITE+TEXTON ERROR GOTO NoDataFileDELETE "_DataFile"NoDataFile:CREATE DataFile,"_DataFile":WRITE+TEXTON ERROR GOTO NoDimFileDELETE "_DimFile"NoDimFile:CREATE DimFile,"_DimFile":WRITE+TEXTON ERROR GOTO NoDescFileDELETE "_DescFile"NoDescFile:CREATE DescFile,"_DescFile":WRITE+TEXTON ERROR GOTO NoInitFileDELETE "_InitFile"NoInitFile:CREATE InitFile,"_InitFile":WRITE+TEXTON ERROR GOTO NoFunctionFileDELETE "_FunctionFile"NoFunctionFile:CREATE FunctionFile,"_FunctionFile":WRITE+TEXTON ERROR GOTO NoExportFileDELETE "_ExportFile"NoExportFile:CREATE ExportFile,"_ExportFile":WRITE+TEXTON ERROR GOTO NoResourceFileDELETE "_ResourceFile"NoResourceFile:CREATE ResourceFile,"_ResourceFile":WRITE+TEXTON ERRORUseReadFile=FALSEUseWriteFile=FALSEUseSetStrConst=FALSEUseTrmStr=FALSEUsePrtUsing=FALSEUseData=FALSEUseMovStr=FALSEUseCmpStr=FALSEUseStrLen=FALSEUseSubStr=FALSEUseMidStr=FALSEUseRightStr=FALSEUseClrConv=FALSEUseAtoD=FALSEUseAtoL=FALSEUseNumScan=FALSEUseZLtoH=FALSEUseZLtoA=FALSEUseLtoA=FALSEUseDtoA=FALSEUseLtoH=FALSEUsePrintStr=FALSEUsePrintTab=FALSEUseInpData=FALSEUseBtoA=FALSEUseLCase=FALSEUseUCase=FALSEUseTailStr=FALSEUseIncZRank=FALSEUseSetRightBottom=FALSEGFNdx=1DataLabel=FALSEExclamationOK=FALSEGenFlag(GFNdx)=$ffSETVEC ByteArray=ADDR(TokenBuf)DeferFlag=FALSEEnumVal=0EnumStep=1FindReplaceFlag=0XBufSize=_BufSizeSelectFlag=FALSECaseFlag=FALSECaseElseFlag=FALSEProcFlag=0FcnFlag=0EventFlag=0ProcFcnFlag=0DataFlag=FALSELastSym=UserSym-1StartFlag=FALSELopCtrNum=-1ArrayBase=1;  default to base 1PrintPathFlag=0DtaRegNum=0TmpMax=0TmpVecMax=0FTmpMax=0ChrTmpMax=0StrTmpMax=0ErrCnt=0LastStmt=""ConStkPtr=0LopVarNdx=0StringNum=0LabelNum=0OELabelNum=0SCLabelNum=0TableNum=0ObjectID=100MenuIDNum=999ProcNum=0InterceptProcNum=0LoopNum=0MacExFlag=0BasicLineCtr=0AsmLineCtr=0ErrNo=0PoolCtr=0VarBytRem=0GOSUB MainLoopInitFOR LopVarNdx=1 to 100	LoopVars(LopVarNdx)="%"NEXT LopVarNdxFOR MacDefNdx=1 TO MacBufSiz	MacBuf(MacDefNdx)=0NEXT MacDefNdxMacDefNdx=1RESTORE PreDefTblSymNdx=0InitSym:INCR SymNdxREAD TempStrIF TempStr="%" THEN LoadKeyWordsSymTemp.SymName=TempStrREAD SymTemp.DataTypeREAD SymTemp.DataModREAD SymTemp.DetailREAD SymTemp.DataAddrREAD SymTemp.DataSizeSymTable(SymNdx)=SymTempSymTableKey(SymNdx)=CHKWORD(TempStr)GOTO InitSymLoadKeyWords:TABLE ImportLibTable AS ImportLibData "kernel32","kernel32.dll",FALSE,FALSE "user32","User32.dll",FALSE,FALSE "gdi","GDI32.DLL",FALSE,FALSE "comctl","COMCTL32.DLL",FALSE,FALSE "comdlg","COMDLG32.DLL",FALSE,FALSE "shell","SHELL32.DLL",FALSE,FALSE "advapi","ADVAPI32.DLL",FALSE,FALSE "winmm","WINMM.DLL",FALSE,FALSE "msvcrt","msvcrt.dll",FALSE,FALSE "csmdll","csmdll.dll",FALSE,FALSE "richedit","RichEd20.dll",FALSE,FALSEENDTABLETABLE ImportFcnTable AS ImportFcnData ptrkernel32,"Beep","Beep",FALSE,FALSE ptrkernel32,"CloseHandle","CloseHandle",FALSE,FALSE ptrkernel32,"CreateDirectory","CreateDirectoryA",FALSE,FALSE ptrkernel32,"CreateFile","CreateFileA",FALSE,FALSE ptrkernel32,"CreatePipe","CreatePipe",FALSE,FALSE ptrkernel32,"CreateProcess","CreateProcessA",FALSE,FALSE ptrkernel32,"DeleteFile","DeleteFileA",FALSE,FALSE ptrkernel32,"ExitProcess","ExitProcess",FALSE,FALSE ptrkernel32,"GetCommandLine","GetCommandLineA",FALSE,FALSE ptrkernel32,"GetCurrentProcess","GetCurrentProcess",FALSE,FALSE ptrkernel32,"GetCurrentDirectory","GetCurrentDirectoryA",FALSE,FALSE ptrkernel32,"GetFileSize","GetFileSize",FALSE,FALSE ptrkernel32,"GetFileType","GetFileType",FALSE,FALSE ptrkernel32,"GetFullPathName","GetFullPathNameA",FALSE,FALSE ptrkernel32,"GetLastError","GetLastError",FALSE,FALSE ptrkernel32,"GetLocalTime","GetLocalTime",FALSE,FALSE ptrkernel32,"GetModuleHandle","GetModuleHandleA",FALSE,FALSE ptrkernel32,"GetStdHandle","GetStdHandle",FALSE,FALSE ptrkernel32,"GetTickCount","GetTickCount",FALSE,FALSE ptrkernel32,"LoadLibrary","LoadLibraryA",FALSE,FALSE ptrkernel32,"ReadConsole","ReadConsoleA",FALSE,FALSE ptrkernel32,"ReadFile","ReadFile",FALSE,FALSE ptrkernel32,"RemoveDirectory","RemoveDirectoryA",FALSE,FALSE ptrkernel32,"SetCurrentDirectory","SetCurrentDirectoryA",FALSE,FALSE ptrkernel32,"SetFilePointer","SetFilePointer",FALSE,FALSE ptrkernel32,"VirtualAlloc","VirtualAlloc",FALSE,FALSE ptrkernel32,"VirtualFree","VirtualFree",FALSE,FALSE ptrkernel32,"WinExec","WinExec",FALSE,FALSE ptrkernel32,"WriteConsole","WriteConsoleA",FALSE,FALSE ptrkernel32,"WriteFile","WriteFile",FALSE,FALSE ptruser32,"AppendMenu","AppendMenuA",FALSE,FALSE ptruser32,"CallWindowProc","CallWindowProcA",FALSE,FALSE ptruser32,"CheckDlgButton","CheckDlgButton",FALSE,FALSE ptruser32,"CheckMenuItem","CheckMenuItem",FALSE,FALSE ptruser32,"CheckRadioButton","CheckRadioButton",FALSE,FALSE ptruser32,"ChildWindowFromPoint","ChildWindowFromPoint",FALSE,FALSE ptruser32,"CreateIconFromResource","CreateIconFromResource",FALSE,FALSE ptruser32,"CreateMenu","CreateMenu",FALSE,FALSE ptruser32,"CreatePopupMenu","CreatePopupMenu",FALSE,FALSE ptruser32,"CreateWindowEx","CreateWindowExA",FALSE,FALSE ptruser32,"DefWindowProc","DefWindowProcA",FALSE,FALSE ptruser32,"DeleteMenu","DeleteMenu",FALSE,FALSE ptruser32,"DestroyWindow","DestroyWindow",FALSE,FALSE ptruser32,"DispatchMessage","DispatchMessageA",FALSE,FALSE ptruser32,"DrawMenuBar","DrawMenuBar",FALSE,FALSE ptruser32,"EnableMenuItem","EnableMenuItem",FALSE,FALSE ptruser32,"EnableWindow","EnableWindow",FALSE,FALSE ptruser32,"FlashWindow","FlashWindow",FALSE,FALSE ptruser32,"GetAncestor","GetAncestor",FALSE,FALSE ptruser32,"GetClientRect","GetClientRect",FALSE,FALSE ptruser32,"GetComboBoxInfo","GetComboBoxInfo",FALSE,FALSE ptruser32,"GetCursorPos","GetCursorPos",FALSE,FALSE ptruser32,"GetMessage","GetMessageA",FALSE,FALSE ptruser32,"GetParent","GetParent",FALSE,FALSE ptruser32,"GetWindowRect","GetWindowRect",FALSE,FALSE ptruser32,"HiliteMenuItem","HiliteMenuItem",FALSE,FALSE ptruser32,"InvalidateRect","InvalidateRect",FALSE,FALSE ptruser32,"InsertMenu","InsertMenuA",FALSE,FALSE ptruser32,"InsertMenuItem","InsertMenuItemA",FALSE,FALSE ptruser32,"IsWindowEnabled","IsWindowEnabled",FALSE,FALSE ptruser32,"IsWindowVisible","IsWindowVisible",FALSE,FALSE ptruser32,"KillTimer","KillTimer",FALSE,FALSE ptruser32,"LoadCursor","LoadCursorA",FALSE,FALSE ptruser32,"LoadIcon","LoadIconA",FALSE,FALSE ptruser32,"LoadMenu","LoadMenuA",FALSE,FALSE ptruser32,"MessageBox","MessageBoxA",FALSE,FALSE ptruser32,"ModifyMenu","ModifyMenuA",FALSE,FALSE ptruser32,"PostMessage","PostMessageA",FALSE,FALSE ptruser32,"MoveWindow","MoveWindow",FALSE,FALSE ptruser32,"PostQuitMessage","PostQuitMessage",FALSE,FALSE ptruser32,"RedrawWindow","RedrawWindow",FALSE,FALSE ptruser32,"RegisterClass","RegisterClassA",FALSE,FALSE ptruser32,"RegisterWindowMessage","RegisterWindowMessageA",FALSE,FALSE ptruser32,"ReleaseCapture","ReleaseCapture",FALSE,FALSE ptruser32,"RemoveMenu","RemoveMenu",FALSE,FALSE ptruser32,"ScreenToClient","ScreenToClient",FALSE,FALSE ptruser32,"SendMessage","SendMessageA",FALSE,FALSE ptruser32,"SetCapture","SetCapture",FALSE,FALSE ptruser32,"SetClassLong","SetClassLongA",FALSE,FALSE ptruser32,"SetFocus","SetFocus",FALSE,FALSE ptruser32,"SetMenu","SetMenu",FALSE,FALSE ptruser32,"SetMenuItemBitmaps","SetMenuItemBitmaps",FALSE,FALSE ptruser32,"SetTimer","SetTimer",FALSE,FALSE ptruser32,"GetWindowLong","GetWindowLongA",FALSE,FALSE ptruser32,"SetWindowLong","SetWindowLongA",FALSE,FALSE ptruser32,"SetWindowPos","SetWindowPos",FALSE,FALSE ptruser32,"ShowWindow","ShowWindow",FALSE,FALSE ptruser32,"UpdateWindow","UpdateWindow",FALSE,FALSE ptruser32,"TrackPopupMenuEx","TrackPopupMenuEx",FALSE,FALSE ptruser32,"TranslateMessage","TranslateMessage",FALSE,FALSE ptrgdi,"CreateFontIndirect","CreateFontIndirectA",FALSE,FALSE ptrgdi,"CreateSolidBrush","CreateSolidBrush",FALSE,FALSE ptrgdi,"DeleteObject","DeleteObject",FALSE,FALSE ptrgdi,"GetPixel","GetPixel",FALSE,FALSE ptrgdi,"GetBkColor","GetBkColor",FALSE,FALSE ptrgdi,"SetBkColor","SetBkColor",FALSE,FALSE ptrgdi,"SetBkMode","SetBkMode",FALSE,FALSE ptrgdi,"GetStockObject","GetStockObject",FALSE,FALSE ptrgdi,"SetTextColor","SetTextColor",FALSE,FALSE ptrcomctl,"CreateMappedBitmap","CreateMappedBitmap",FALSE,FALSE ptrcomctl,"InitCommonControlsEx","InitCommonControlsEx",FALSE,FALSE ptrcomctl,"TrackMouseEvent","_TrackMouseEvent",FALSE,FALSE ptrcomdlg,"ChooseFont","ChooseFontA",FALSE,FALSE ptrcomdlg,"ChooseColor","ChooseColorA",FALSE,FALSE ptrcomdlg,"GetOpenFileName","GetOpenFileNameA",FALSE,FALSE ptrcomdlg,"GetSaveFileName","GetSaveFileNameA",FALSE,FALSE ptrcomdlg,"FindText","FindTextA",FALSE,FALSE ptrcomdlg,"ReplaceText","ReplaceTextA",FALSE,FALSE ptrshell,"DragAcceptFiles","DragAcceptFiles",FALSE,FALSE ptrshell,"ShellNotifyIcon","Shell_NotifyIcon",FALSE,FALSE ptradvapi,"RegCreateKeyEx","RegCreateKeyExA",FALSE,FALSE ptradvapi,"RegCloseKey","RegCloseKey",FALSE,FALSE ptrwinmm,"sndPlaySound","sndPlaySoundA",FALSE,FALSE ptrmsvcrt,"abs","abs",FALSE,FALSE ptrmsvcrt,"atol","atol",FALSE,FALSE ptrmsvcrt,"ltoa","_ltoa",FALSE,FALSE ptrmsvcrt,"printf","printf",FALSE,FALSE ptrmsvcrt,"puts","puts",FALSE,FALSE ptrmsvcrt,"sprintf","sprintf",FALSE,FALSE ptrmsvcrt,"system","system",FALSE,FALSE ptrcsmdll,"CSMGetDriveHandle","CSMGetDriveHandle",FALSE,FALSE ptrcsmdll,"CSMDriveStatus","CSMDriveStatus",FALSE,FALSE ptrcsmdll,"CSMReadBlock","CSMReadBlock",FALSE,FALSE ptrcsmdll,"CSMReleaseDriveHandle","CSMReleaseDriveHandle",FALSE,FALSE ptrcsmdll,"CSMWriteBlock","CSMWriteBlock",FALSE,FALSE ptrrichedit,"CreateTextServices","CreateTextServices",FALSE,FALSEENDTABLETABLE FormPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,FALSE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBad,psFormBackColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "FONT",pgBad,psFont,LONGVAR,FALSE "icon",pgBad,psIcon,LONGVAR,TRUE "TOOLTIP",pgBad,psBad,LONGVAR,FALSE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "flashwindow",pgBad,psFlashWindow,BOOLVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE FormStyleTable AS StyleData "base",$00000000,STYLE,FALSE "default",$00000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "overlapped",$00000000,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE FormEventTable AS EventData "create",evCreateUsed,evCreateOffs,0 "system",evSysCommandUsed,evSysCommandOffs,0 "resize",evResizeUsed,evResizeOffs,0 "move",evMoveUsed,evMoveOffs,0 "mousemove",evMouseMoveUsed,evMouseMoveOffs,0 "lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0 "lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0 "rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0 "rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0 "%",0,0,0ENDTABLETABLE ToolWindowPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,FALSE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBad,psFormBackColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "FONT",pgBad,psFont,LONGVAR,FALSE "icon",pgBad,psIcon,LONGVAR,TRUE "TOOLTIP",pgBad,psBad,LONGVAR,FALSE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "flashwindow",pgBad,psFlashWindow,BOOLVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ToolWindowStyleTable AS StyleData "base",$00000000,STYLE,FALSE "default",$00000000,STYLE,FALSE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ToolWindowEventTable AS EventData "create",evCreateUsed,evCreateOffs,0 "system",evSysCommandUsed,evSysCommandOffs,0 "resize",evResizeUsed,evResizeOffs,0 "move",evMoveUsed,evMoveOffs,0 "mousemove",evMouseMoveUsed,evMouseMoveOffs,0 "lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0 "lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0 "rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0 "rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0 "%",0,0,0ENDTABLETABLE ButtonPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "BACKCOLOR",pgBad,psBad,LONGVAR,FALSE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "icon",pgBad,psIcon,LONGVAR,TRUE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "pushed",pgBad,psPushed,BOOLVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ButtonStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "defpushbutton",$00000001,STYLE,TRUE "left",$00000100,STYLE,FALSE "right",$00000200,STYLE,FALSE "center",$00000300,STYLE,FALSE "top",$00000400,STYLE,FALSE "bottom",$00000800,EXSTYLE,FALSE "flat",$00008000,STYLE,FALSE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ButtonEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "lbuttondown",evLButtonDownUsed,evLButtonDownOffs,0 "lbuttonup",evLButtonUpUsed,evLButtonUpOffs,0 "rbuttondown",evRButtonDownUsed,evRButtonDownOffs,0 "rbuttonup",evRButtonUpUsed,evRButtonUpOffs,0 "%",0,0,0ENDTABLETABLE StaticIconPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "icon",pgBad,psSTIcon,LONGVAR,TRUE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE StaticIconStyleTable AS StyleData "base",$50000103,STYLE,FALSE "default",$50000303,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "icon",$00000003,STYLE,TRUE "centerimage",$00000200,STYLE,TRUE "notify",$00000100,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE StaticIconEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE ComboBoxPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "deleteitem",pfComboDeleteItem,pfComboDeleteItem,LONGVAR,FALSE "additem",pfComboAddItem,pfComboAddItem,LONGVAR,FALSE "additemsorted",pfComboAddSorted,pfComboAddSorted,LONGVAR,FALSE "insertitem",pfComboInsertItem,pfComboInsertItem,LONGVAR,FALSE "clear",pfComboClear,pfComboClear,LONGVAR,FALSE "selitem",pgComboBoxSelItem,psComboBoxSelItem,LONGVAR,FALSE "topitem",pgComboBoxTopItem,psComboBoxTopItem,LONGVAR,FALSE "seltext",pgComboBoxSelText,psBad,STRINGVAR,FALSE "itemcount",pgComboBoxItemCount,psBad,LONGVAR,FALSE "dropped",pgDropped,psDropped,BOOLVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ComboBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50200102,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "vscroll",$00200000,STYLE,TRUE "dropdown",$00000002,STYLE,TRUE "sort",$00000100,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ComboBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "change",evChangeUsed,evChangeOffs,5 "select",evSelectUsed,evSelectOffs,9 "scroll",evScrollUsed,evScrollOffs,0 "%",0,0,0ENDTABLETABLE TextBoxPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "setsel",pfSetSel,pfSetSel,LONGVAR,FALSE "selectall",pfSelectAll,pfSelectAll,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE TextBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "left",$00000000,STYLE,FALSE "center",$00000001,STYLE,FALSE "right",$00000002,STYLE,FALSE "uppercase",$00000008,STYLE,FALSE "lowercase",$00000010,STYLE,FALSE "password",$00000020,STYLE,FALSE "autovscroll",$00000040,STYLE,FALSE "autohscroll",$00000080,STYLE,FALSE "nohidesel",$00000100,STYLE,FALSE "oemconvert",$00000400,STYLE,FALSE "readonly",$00000800,STYLE,FALSE "wantreturn",$00001000,STYLE,FALSE "number",$00002000,STYLE,FALSE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE TextBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "change",evChangeUsed,evChangeOffs,$300 "%",0,0,0ENDTABLETABLE FramePropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,FALSE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE FrameStyleTable AS StyleData "base",$50000007,STYLE,FALSE "default",$50000007,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "groupbox",$00000007,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE FrameEventTable AS EventData "%",0,0,0ENDTABLETABLE ListBoxPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "deleteitem",pfListBoxDeleteItem,pfListBoxDeleteItem,LONGVAR,FALSE "additem",pfListBoxAddItem,pfListBoxAddItem,LONGVAR,FALSE "additemsorted",pfListBoxAddSorted,pfListBoxAddSorted,LONGVAR,FALSE "insertitem",pfListBoxInsertItem,pfListBoxInsertItem,LONGVAR,FALSE "clear",pfListBoxClear,pfListBoxClear,LONGVAR,FALSE "selitem",pgListBoxSelItem,psListBoxSelItem,LONGVAR,FALSE "topitem",pgListBoxTopItem,psListBoxTopItem,LONGVAR,FALSE "seltext",pgListBoxSelText,psBad,STRINGVAR,FALSE "itemcount",pgListBoxItemCount,psBad,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ListBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50a00003,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "sort",$00000002,STYLE,TRUE "vscroll",$00200000,STYLE,TRUE "hscroll",$00100000,STYLE,FALSE "border",$0080000,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ListBoxEventTable AS EventData "select",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE SliderPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "value",pgSliderValue,psSliderValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE SliderStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000100,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "autoticks",$00000001,STYLE,TRUE "both",$00000008,STYLE,FALSE "enableselrange"$00000020,STYLE,FALSE "fixedlength",$00000040,STYLE,FALSE "noticks",$00000010,STYLE,FALSE "nothumb",$00000080,STYLE,FALSE "vert",$00000002,STYLE,FALSE "horz",$00000000,STYLE,FALSE "top",$00000004,STYLE,FALSE "bottom",$00000000,STYLE,FALSE "top",$00000004,STYLE,FALSE "left",$00000004,STYLE,FALSE "right",$00000000,STYLE,FALSE "tooltips"$00000100,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE SliderEventTable AS EventData "scroll",evScrollUsed,evScrollOffs,0 "%",0,0,0ENDTABLETABLE SpinnerPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBad,psBackColor,LONGVAR,TRUE "forecolor",pgBad,psBad,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE SpinnerStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "child",$40000000,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE SpinnerEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE ProgressBarPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "value",pgProgressBarValue,psProgressBarValue,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ProgressBarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ProgressBarEventTable AS EventData "%",0,0,0ENDTABLETABLE CalendarPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE CalendarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE CalendarEventTable AS EventData "%",0,0,0ENDTABLETABLE HeaderPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE HeaderStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE HeaderEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE TreeViewPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgForeColor,psForeColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE TreeViewStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE TreeViewEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE TabFolderPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE TabFolderStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE TabFolderEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE ButtonListBoxPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ButtonListBoxStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000003,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "sort",$00000002,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ButtonListBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE ToolBarPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ToolBarStyleTable AS StyleData "base",$50000001,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ToolBarEventTable AS EventData "%",0,0,0ENDTABLETABLE StatusBarPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgForeColor,psForeColor,LONGVAR,TRUE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "setparts",pfSetParts,pfSetParts,LONGVAR,FALSE "settext",pfSetSBText,pfSetSBText,LONGVAR,FALSE "seticon",pfSetSBIcon,pfSetSBIcon,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE StatusBarStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000810,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "sizegrip",$00000010,STYLE,TRUE "tooltips",$00000800,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE StatusBarEventTable AS EventData "%",0,0,0ENDTABLETABLE CheckBoxPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psBad,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "checked",pgChecked,psChecked,BOOLVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE CheckBoxStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000003,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "autocheckbox"$00000003,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE CheckBoxEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE RadioButtonPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "checked",pgChecked,psChecked,BOOLVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE RadioButtonStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000009,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "autoradiobutton",$00000009,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE RadioButtonEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE TimerPropTable AS PropData "interval",pgBad,psInterval,LONGVAR,FALSE "stop",pfStop,pfStop,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE TimerStyleTable AS StyleData "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE TimerEventTable AS EventData "timer",0,0,0 "%",0,0,0ENDTABLETABLE RichEditPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,FALSE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psRichEditBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "line",pgLine,psBad,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE RichEditStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50300104,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "multiline",$00000004,STYLE,TRUE "vscroll",$00200000,STYLE,TRUE "hscroll",$00100000,STYLE,TRUE "nohidesel",$00000100,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE RichEditEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE RAEditPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBad,psRAEditBCKCOLOR,LONGVAR,TRUE "FORCOLOR",pgBad,psBad,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "FONT",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "seltext",pgSelText,psBad,STRINGVAR,FALSE "line",pgLine,psBad,STRINGVAR,FALSE "loadfile",pfRAEditLoadFile,pfRAEditLoadFile,LONGVAR,FALSE "savefile",pfRAEditSaveFile,pfRAEditSaveFile,LONGVAR,FALSE "goto",pfRAEditGoto,pfRAEditGoto,LONGVAR,FALSE "cursorpos",pgGetCursorPos,psSetCursorPos,LONGVAR,FALSE "selectall",pfSelectAll,pfSelectAll,LONGVAR,FALSE "setsel",pfSetSel,pfSetSel,LONGVAR,FALSE "getsel",pfGetSel,pfGetSel,LONGVAR,FALSE "inserttext",pfInsertText,pfInsertText,LONGVAR,FALSE "replacesel",pfReplaceSel,pfReplaceSel,LONGVAR,FALSE "appendtext",pfAppendText,pfAppendText,LONGVAR,FALSE "replacetext",pfReplaceText,pfReplaceText,LONGVAR,FALSE "textcolor",pgBad,psRAEditTXTCOLOR,LONGVAR,TRUE "selbackcolor",pgBad,psRAEditSELBCKCOLOR,LONGVAR,FALSE "seltextcolor",pgBad,psRAEditSELTXTCOLOR,LONGVAR,FALSE "commentcolor",pgBad,psRAEditCMNTCOLOR,LONGVAR,FALSE "stringcolor",pgBad,psRAEditSTRCOLOR,LONGVAR,FALSE "operatorcolor",pgBad,psRAEditOPRCOLOR,LONGVAR,FALSE "hilite1color",pgBad,psRAEditHILITE1,LONGVAR,FALSE "hilite2color",pgBad,psRAEditHILITE2,LONGVAR,FALSE "hilite3color",pgBad,psRAEditHILITE3,LONGVAR,FALSE "hiliteline",pgHiLiteLine,psBad,LONGVAR,FALSE "sethiliteline",pfSetHiLiteLine,pfSetHiLiteLine,LONGVAR,FALSE "selbarpencolor",pgBad,psRAEditSELBARPEN,LONGVAR,FALSE "linenumcolor",pgBad,psRAEditLNRCOLOR,LONGVAR,FALSE "sethilitewords",pfSetHiliteWords,pfSetHiliteWords,LONGVAR,FALSE "setdividerline",pfSetDividerLine,pfSetDividerLine,LONGVAR,FALSE "setfont",pfSetRAFont,pfSetRAFont,LONGVAR,FALSE "find",pfFind,pfFind,LONGVAR,FALSE "textlength",pgGetTextLength,psBad,LONGVAR,FALSE "canundo",pgCanUndo,psBad,BOOLVAR,FALSE "undo",pfUnDo,pfUnDo,LONGVAR,FALSE "canredo",pgCanReDo,psBad,BOOLVAR,FALSE "redo",pfReDo,pfReDo,LONGVAR,FALSE "canpaste",pgCanPaste,psBad,BOOLVAR,FALSE "paste",pfPaste,pfPaste,LONGVAR,FALSE "emptyundobuffer",pfEmptyUndoBuffer,pfEmptyUndoBuffer,LONGVAR,FALSE "cut",pfCut,pfCut,LONGVAR,FALSE "copy",pfCopy,pfCopy,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE RAEditStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000044,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE RAEditEventTable AS EventData "change",evNotify1Used,0,$702 "contextmenu",evContextMenuUsed,evContextMenuOffs,0 "%",0,0,0ENDTABLETABLE RAGridPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psGridBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psGridForeColor,LONGVAR,TRUE "text",pgGridText,psGridText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "gridcolor",pgBad,psGridGridColor,LONGVAR,FALSE "text",pgGridText,psGridText,STRINGVAR,FALSE "headertext",pgHeaderText,psHeaderText,STRINGVAR,FALSE "value",pgBad,psGridValue,LONGVAR,FALSE "selitem",pgBad,psGridComboIndex,LONGVAR,FALSE "addrow",pfGridAddRow,pfGridAddRow,LONGVAR,FALSE "addcol",pfGridAddCol,pfGridAddCol,LONGVAR,FALSE "deleterow",pfGridDeleteRow,pfGridDeleteRow,LONGVAR,FALSE "insertrow",pfGridInsertRow,pfGridInsertRow,LONGVAR,FALSE "moverow",pfGridMoveRow,pfGridMoveRow,LONGVAR,FALSE "additem",pfGridComboAddIttem,pfGridComboAddIttem,LONGVAR,FALSE "headerheight",pgBad,psSetHeaderHeight,LONGVAR,FALSE "rowheight",pgBad,psSetRowHeight,LONGVAR,FALSE "gridclear",pfGridClear,pfGridClear,LONGVAR,FALSE "comboclear",pfGridComboClear,pfGridComboClear,LONGVAR,FALSE "sort",pfGridSort,pfGridSort,LONGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE RAGridStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$5000000c,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "hgridlines",$40000004,STYLE,TRUE "vgridlines",$40000008,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE RAGridEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "headerclick",evNotify1Used,0,1 "buttonclick",evNotify2Used,0,2 "checkclick",evNotify3Used,0,3 "imageclick",evNotify4Used,0,4 "beforeselchange",evNotify5Used,0,5 "afterselchange",evNotify6Used,0,6 "beforeedit",evNotify7Used,0,7 "afteredit",evNotify8Used,0,8 "beforeupdate",evNotify9Used,0,9 "afterupdate",evNotify10Used,0,10 "userconvert",evNotify11Used,0,11 "%",0,0,0ENDTABLETABLE ListViewPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor"pgForeColor,psForeColor,LONGVAR,TRUE "TEXT",pgBad,psBad,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "additem",pfListBoxAddItem,pfListBoxAddItem,LONGVAR,FALSE "clear",pfListBoxClear,pfListBoxClear,LONGVAR,FALSE "selitem",pgListBoxSelItem,psListBoxSelItem,LONGVAR,FALSE "topitem",pgListBoxTopItem,psListBoxTopItem,LONGVAR,FALSE "seltext",pgListBoxSelText,psBad,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE ListViewStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000001,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify",$00000001,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE ListViewEventTable AS EventData "select",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE StaticTextPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "text",pgText,psText,STRINGVAR,TRUE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE StaticTextStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000101,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify"$00000100,STYLE,TRUE "left",$00000000,STYLE,FALSE "center",$00000001,STYLE,TRUE "right",$00000002,STYLE,FALSE "sunken",$00001000,STYLE,FALSE "etchedframe",$00000012,STYLE,FALSE "icon",$00000003,STYLE,FALSE "bitmap",$0000000e,STYLE,FALSE "centerimage",$00000200,STYLE,FALSE "blackframe",$00000007,STYLE,FALSE "whiterame",$00000008,STYLE,FALSE "blackframe",$00001000,STYLE,FALSE "sunken",$00000007,STYLE,FALSE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE StaticTextEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETABLE RectanglePropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "backcolor",pgBackColor,psBackColor,LONGVAR,TRUE "forecolor",pgForeColor,psForeColor,LONGVAR,TRUE "text",pgText,psText,STRINGVAR,FALSE "font",pgBad,psFont,LONGVAR,FALSE "ICON",pgBad,psIcon,LONGVAR,FALSE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE RectangleStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000000,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "notify"$00000100,STYLE,FALSE "left",$00000000,STYLE,FALSE "center",$00000001,STYLE,FALSE "Right",$00000000,STYLE,FALSE "sunken",$00001000,STYLE,FALSE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE RectangleEventTable AS EventData "%",0,0,0ENDTABLETABLE IconButtonPropTable AS PropData "OWNER",pgBad,psBad,LONGVAR,TRUE "ARRAYINDEX",pgBad,psBad,LONGVAR,TRUE "visible",pgVisible,psVisible,BOOLVAR,TRUE "enabled",pgEnabled,psEnabled,BOOLVAR,TRUE "left",pgLeft,psLeft,LONGVAR,TRUE "top",pgTop,psTop,LONGVAR,TRUE "width",pgWidth,psWidth,LONGVAR,TRUE "height",pgHeight,psHeight,LONGVAR,TRUE "BACKCOLOR",pgBad,psBad,LONGVAR,FALSE "FORECOLOR",pgBad,psBad,LONGVAR,FALSE "TEXT",pgText,psText,STRINGVAR,FALSE "FONT",pgBad,psFont,LONGVAR,FALSE "icon",pgBad,psButtonIcon,LONGVAR,TRUE "tooltip",pgBad,psBad,LONGVAR,TRUE "status",pgStatus,psBad,LONGVAR,FALSE "address",pgAddress,psBad,LONGVAR,FALSE "intercepton",pgBad,psInterceptOn,LONGVAR,FALSE "interceptoff",pgBad,psInterceptOff,LONGVAR,FALSE "id",pgID,psBad,LONGVAR,FALSE "handle",pgHandle,psBad,LONGVAR,FALSE "setfocus",pfSetFocus,pfSetFocus,BOOLVAR,FALSE "style",pgBad,psStyle,LONGVAR,FALSE "right",pgRight,psRight,LONGVAR,FALSE "bottom",pgBottom,psBottom,LONGVAR,FALSE "front",pgBad,pfFront,LONGVAR,FALSE "zrank",pgZRank,psZRank,LONGVAR,FALSE "font",pgBad,psFont,LONGVAR,TRUE "%",MainLoop,MainLoop,0,FALSEENDTABLETABLE IconButtonStyleTable AS StyleData "base",$50000000,STYLE,FALSE "default",$50000040,STYLE,FALSE "visible",$10000000,STYLE,TRUE "child",$40000000,STYLE,TRUE "pushbutton"$00000000,STYLE,TRUE "icon"$00000040,STYLE,TRUE "flat",0,EXSTYLE,FALSE "3d",$200,EXSTYLE,FALSE "%",0,0,FALSEENDTABLETABLE IconButtonEventTable AS EventData "command",evCommandUsed,evCommandOffs,0 "%",0,0,0ENDTABLETYPE PropMap PropMapPropTable AS LABEL PropMapStyleTable AS LABEL PropMapEventTable AS LABEL PropMapCount AS LONG PropMapName AS STRING*16END TYPETABLE ToolPropMap AS PropMap FormPropTable,FormStyleTable,FormEventTable,1,"FORM" ToolWindowPropTable,ToolWindowStyleTable,ToolWindowEventTable,0,"TOOLWINDOW" ButtonPropTable,ButtonStyleTable,ButtonEventTable,0,"BUTTON" StaticTextPropTable,StaticTextStyleTable,StaticTextEventTable,0,"STATICTEXT" FramePropTable,FrameStyleTable,FrameEventTable,0,"FRAME" SliderPropTable,SliderStyleTable,SliderEventTable,0,"SLIDER" TextBoxPropTable,TextBoxStyleTable,TextBoxEventTable,0,"TEXTBOX" ComboBoxPropTable,ComboBoxStyleTable,ComboBoxEventTable,0,"COMBOBOX" ListBoxPropTable,ListBoxStyleTable,ListBoxEventTable,0,"LISTBOX" RadioButtonPropTable,RadioButtonStyleTable,RadioButtonEventTable,0,"RADIOBUTTON" CheckBoxPropTable,CheckBoxStyleTable,CheckBoxEventTable,0,"CHECKBOX" ProgressBarPropTable,ProgressBarStyleTable,ProgressBarEventTable,0,"PROGRESBAR" CalendarPropTable,CalendarStyleTable,CalendarEventTable,0,"CALENDAR" TabFolderPropTable,TabFolderStyleTable,TabFolderEventTable,0,"TABFOLDER" SpinnerPropTable,SpinnerStyleTable,SpinnerEventTable,0,"SPINNER" StatusBarPropTable,StatusBarStyleTable,StatusBarEventTable,0,"STATUSBAR" HeaderPropTable,HeaderStyleTable,HeaderEventTable,0,"HEADER" ButtonListBoxPropTable,ButtonListBoxStyleTable,ButtonListBoxEventTable,0,"BUTTONLISTBOX" RichEditPropTable,RichEditStyleTable,RichEditEventTable,0,"RICHEDIT" RAEditPropTable,RAEditStyleTable,RAEditEventTable,0,"RAEDIT" RAGridPropTable,RAGridStyleTable,RAGridEventTable,0,"RAGRID" ListViewPropTable,ListViewStyleTable,ListViewEventTable,0,"LISTVIEW" ToolBarPropTable,ToolBarStyleTable,ToolBarEventTable,0,"TOOLBAR"END TABLETEXTBLOCK PreCodeSeg1section '.code' code readable executable; Main Code Sectionalign 4!Start:call _Initinvoke GetModuleHandle, NULLmov dword [!hinstance], eaxinvoke GetCommandLinemov dword [_ArgList],eaxmov dword edi,ProgramNamecall __MovArginvoke GetStdHandle, STD_INPUT_HANDLEmov dword [_InHandle], eaxinvoke GetStdHandle, STD_OUTPUT_HANDLEmov dword [_OutHandle], eaxmov byte [_CRLF+12],13mov byte [_CRLF+13],10mov byte [_CRLF+14],0mov byte [_Prompt+12],63mov byte [_Prompt+13],0mov byte [_NullStr+12],0mov dword [_ErrVec],_ErrExitENDTEXTTEXTBLOCK GUIEquates HandleOffs equ 0 IDOffs equ 4 OwnerOffs equ 8 ArrayOffs equ 12 LeftOffs equ 16 TopOffs equ 20 RightOffs equ 24 BottomOffs equ 28 BackColorOffs equ 32 ForeColorOffs equ 36 TypeOffs equ 40 StatusOffs equ 44 evActivateOffs equ 48 evCommandOffs equ 52 evMouseActivateOffs equ 56 evMouseHoverOffs equ 60 evMouseLeaveOffs equ 64 evMouseMoveOffs equ 68 evMouseWheelOffs equ 72 evScrollOffs equ 76 evCreateOffs equ 80 evDestroy equ 84 evKeyDownOffs equ 88 evKeyUpOffs equ 92 evDblClickOffs equ 96 cdDblClickOffs equ 100 evClickOffs equ 104 cdClickOffs equ 108 evChangeOffs equ 112 cdChangeOffs equ 116 evSelectOffs equ 120 cdSelectOffs equ 124 evNotify1Offs equ 128 cdNotify1Offs equ 132 evNotify2Offs equ 136 cdNotify2Offs equ 140 evNotify3Offs equ 144 cdNotify3Offs equ 148 evNotify4Offs equ 152 cdNotify4Offs equ 156 evNotify5Offs equ 160 cdNotify5Offs equ 164 evNotify6Offs equ 168 cdNotify6Offs equ 172 evNotify7Offs equ 176 cdNotify7Offs equ 180 evNotify8Offs equ 184 cdNotify8Offs equ 188 evNotify9Offs equ 192 cdNotify9Offs equ 196 evNotify10Offs equ 200 cdNotify10Offs equ 204 evNotify11Offs equ 208 cdNotify11Offs equ 212 evNotify12Offs equ 216 cdNotify12Offs equ 220 evNotify13Offs equ 224 cdNotify13Offs equ 228 evNotify14Offs equ 232 cdNotify14Offs equ 236 evNotify15Offs equ 240 cdNotify15Offs equ 244 evNotify16Offs equ 248 cdNotify16Offs equ 252 evNotify17Offs equ 256 cdNotify17Offs equ 260 evNotify18Offs equ 264 cdNotify18Offs equ 268 evNotify19Offs equ 272 cdNotify19Offs equ 276 evNotify20Offs equ 280 cdNotify20Offs equ 284 evNotify21Offs equ 288 cdNotify21Offs equ 292 evNotify22Offs equ 296 cdNotify22Offs equ 300 evNotify23Offs equ 304 cdNotify23Offs equ 308 evNotify24Offs equ 312 cdNotify24Offs equ 316 evNotify25Offs equ 320 cdNotify25Offs equ 324 evNotify26Offs equ 328 cdNotify26Offs equ 332 evNotify27Offs equ 336 cdNotify27Offs equ 340 evNotify28Offs equ 344 cdNotify28Offs equ 348 evNotify29Offs equ 352 cdNotify29Offs equ 356 evNotify30Offs equ 360 cdNotify30Offs equ 364 evNotify31Offs equ 368 cdNotify31Offs equ 372 evNotify32Offs equ 376 cdNotify32Offs equ 380 evSysCommandOffs equ 384 evResizeOffs equ 388 evMoveOffs equ 392 evLButtonDownOffs equ 396 evLButtonUpOffs equ 400 evRButtonDownOffs equ 404 evRButtonUpOffs equ 408 ToolTipHandleOffs equ 412 evContextMenuOffs equ 416 evReserved2Offs equ 420 evReserved3Offs equ 424 evReserved4Offs equ 428 evReserved5Offs equ 432 evReserved6Offs equ 436 evReserved7Offs equ 440 Reserved1Offs equ 444 Reserved2Offs equ 448 Reserved3Offs equ 452 Reserved4Offs equ 456 Reserved5Offs equ 460 Reserved6Offs equ 464 Reserved7Offs equ 468 Reserved8Offs equ 472 ZRankOffs equ 476; Sequential update number WidthOffs equ 480 HeightOffs equ 484 ControlBrushOffs equ 488 InterceptSafeOffs equ 492 InterceptProcOffs equ 496 Extra1Offs equ 500 Extra2Offs equ 504 DoNoUseOffs equ 508ENDTEXTTEXTBLOCK PreCodeSeg2invoke InitCommonControlsEx,!iccinvoke LoadLibrary,!!RichEdinvoke LoadLibrary,!!RAEditinvoke LoadLibrary,!!RAGridinvoke LoadLibrary,!!Csmdllinvoke LoadIcon,0,IDI_APPLICATIONmov [!OBMainWindowClass.hIcon],eaxinvoke LoadCursor,0,IDC_ARROWmov [!OBMainWindowClass.hCursor],eaxmov [!OBMainWindowClass.style],0mov [!OBMainWindowClass.lpfnWndProc],!WindowProcmov [!OBMainWindowClass.cbClsExtra],0mov [!OBMainWindowClass.cbWndExtra],0mov eax,[!hinstance]mov [!OBMainWindowClass.hInstance],eaxmov [!OBMainWindowClass.hbrBackground],COLOR_BTNFACE+1mov [!OBMainWindowClass.lpszMenuName],0mov [!OBMainWindowClass.lpszClassName],!OBMainClassinvoke RegisterClass,!OBMainWindowClassmov dword [!OBMain+StatusOffs],0mov dword [!OBMain+IDOffs],1mov dword [!OBMain+ArrayOffs],0mov dword [!OBMain+LeftOffs],0mov dword [!OBMain+TopOffs],0mov dword [!OBMain+WidthOffs],400mov dword [!OBMain+HeightOffs],300mov dword [!OBMain+BackColorOffs],$ffffffmov dword [!OBMain+ForeColorOffs],$000000mov dword [!OBMain+TypeOffs],!CT_FORMmov dword [!OBMain+ControlBrushOffs],0invoke CreateWindowEx,0,!OBMainClass,!title,WS_VISIBLE+WS_OVERLAPPEDWINDOW,0,0,400,300,NULL,NULL,[!hinstance],!OBMaininvoke SetWindowLong,[!OBMain],GWL_USERDATA,!OBMain!MsgLoop:invoke GetMessage,msg,NULL,0,0or eax,eaxjz !EndMsgLoopinvoke TranslateMessage,msginvoke DispatchMessage,msgjmp !MsgLoop!EndMsgLoop:invoke ExitProcess,[msg.wParam]proc !WindowProc,!hwnd,wmsg,wparam,lparamenterpush ebx esi edicmp [wmsg],WM_GETMINMAXINFOjne NotwmGetMaxInfomov dword edi,[!hwnd]mov dword [!OBMain+HandleOffs],edimov dword [!OBMain+OwnerOffs],0mov dword [!OBMain+InterceptSafeOffs],!WindowProcjmp !DefWndProcNotwmGetMaxInfo:mov esi,!OBMaincmp [wmsg],WM_DESTROYje !wmDestroy!WinProcCommon:cmp [wmsg],WM_SYSCOMMANDje !wmSysCommandcmp [wmsg],WM_SIZEje !wmSizecmp [wmsg],WM_MOVEje !wmMovecmp [wmsg],WM_TIMERje !wmTimercmp [wmsg],WM_CREATEje !wmCreatemov eax,[wparam]mov [EventID],axshr eax,16mov [EventNotify],axcmp [wmsg],WM_CONTEXTMENUje !wmContextMenuinvoke GetWindowLong,[lparam],GWL_USERDATAmov [!Desc],eaxcmp [wmsg],WM_CTLCOLORSTATICje !CtlColorChangecmp [wmsg],WM_CTLCOLOREDITje !CtlColorChangecmp [wmsg],WM_CTLCOLORBTNje !CtlColorChangecmp [wmsg],WM_CTLCOLORSCROLLBARje !CtlColorChangecmp [wmsg],WM_CTLCOLORLISTBOXje !CtlColorChangecmp [wmsg],WM_CTLCOLORDLGje !CtlColorChangecmp [wmsg],WM_CTLCOLORMSGBOXje !CtlColorChangecmp [wmsg],WM_COMMANDje !wmCommandcmp [wmsg],WM_NOTIFYje !wmNotifycmp [wmsg],WM_HSCROLLje !wmScrollcmp [wmsg],WM_VSCROLLje !wmScrollcmp [wmsg],WM_MOUSEMOVEje !wmMouseMovecmp [wmsg],WM_LBUTTONDOWNje !wmLButtonDowncmp [wmsg],WM_LBUTTONUPje !wmLButtonUpcmp [wmsg],WM_RBUTTONDOWNje !wmRButtonDowncmp [wmsg],WM_RBUTTONUPje !wmRButtonUpmov eax,[wmsg]cmp [FindMsgID],eaxje !FindMsg!DefWndProc:invoke DefWindowProc,[!hwnd],[wmsg],[wparam],[lparam]jmp !Finish!wmSysCommand:mov [!PassSystemEvent],0mov eax,[esi+evSysCommandOffs]or eax,eaxje !DefWndProcmov edx,[wparam]cmp edx,$f020je !DoSysCmdcmp edx,$f030je !DoSysCmdcmp edx,$f060je !DoSysCmdcmp edx,$f120je !DoSysCmdjmp !DefWndProc!DoSysCmd:mov [STATUS],edxcall dword eaxcmp [!PassSystemEvent],0jne !DefWndProcxor eax,eaxjmp !Finish!wmSize:mov ecx,[lparam]mov edx,ecxand ecx,$ffffshr edx,16mov [esi+WidthOffs],ecxmov [esi+HeightOffs],edxmov eax,[esi+evResizeOffs]or eax,eaxje !DefWndProcmov edx,[wparam]mov [STATUS],edxcall dword eaxxor eax,eaxjmp !Finish!wmMove:mov ecx,[lparam]mov edx,ecxand ecx,$ffffshr edx,16mov [esi+LeftOffs],ecxmov [esi+TopOffs],edxmov eax,[esi+evMoveOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!FindMsg:mov edx,[FindEVPtr]or edx,edxje !DefWndProcmov eax,[fr_Flags]mov [FLAGS],eaxcall dword edxje !DefWndProc!wmTimer:mov edx,[wparam]shl edx,2add edx,!Timermov eax,[edx]cmp eax,0je !Finishcall dword eaxxor eax,eaxjmp !Finish!wmNotify:mov edi,[lparam]; Address of NMHDRmov [NMHDR],edi; Save NMHDR for event processingmov esi,[edi]; Handleinvoke GetWindowLong,esi,GWL_USERDATAcmp eax,0je !DefWndProcmov esi,eax; Address of Descmov ebx,[edi+8]; Codemov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+TypeOffs]mov [!dsControlType],eaxmov ecx,cdNotify32Offs+4; Points past last Notify Offsadd ecx,esi; Add Offs to baseadd esi,evNotify1Offs; Points to first Notify Offs!NotifyLoop:cmp ebx,[esi+4]jne !NotNotifyCodemov eax,[esi]cmp eax,0jne !ProcNotifyjmp !DefWndProc!NotNotifyCode:add esi,8; Point to next Notifycmp esi,ecx; Past last Notify?jne !NotifyLoop; No, Try nextjmp !DefWndProc; Give up, no Notify match!ProcNotify:mov edi,[NMHDR]add edi,12cmp [!dsControlType],!CT_RAGridjne !RAEditCheckmov ebx,[edi]add ebx,[!ArrayBase]mov [GridCol],ebxmov ebx,[edi+4]add ebx,[!ArrayBase]mov [GridRow],ebxjmp !NotifyDispatch!RAEditCheck:cmp [!dsControlType],!CT_RAEditjne !NotifyDispatchmov ebx,[edi]add ebx,[!ArrayBase]mov [EditcpMin],ebxsub ebx,[edi+14]mov [EditcpLine],ebxmov ebx,[edi+4]add ebx,[!ArrayBase]mov [EditcpMax],ebxmov bx,[edi+8]mov [EditSelType],bxmov ebx,[edi+10]add ebx,[!ArrayBase]mov [EditLine],ebxmov ebx,[edi+18]add ebx,[!ArrayBase]mov [EditlpLine],ebxmov ebx,[edi+22]add ebx,[!ArrayBase]mov [EditnLines],ebxmov ebx,[edi+26]mov [EditnHidden],ebxmov ebx,[edi+30]mov [EditfChanged],ebxmov ebx,[edi+34]add ebx,[!ArrayBase]mov [EditnPage],ebxmov ebx,[edi+38]add ebx,[!ArrayBase]mov [EditnWordGroup],ebx!NotifyDispatch:jmp !CommandDispatch!wmMouseMove:call !GetMousePosmov eax,[esi+evMouseMoveOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmLButtonDown:call !GetMousePosmov eax,[esi+evLButtonDownOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmLButtonUp:call !GetMousePosmov eax,[esi+evLButtonUpOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmRButtonDown:call !GetMousePos mov eax,[esi+evRButtonDownOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmRButtonUp:call !GetMousePos mov eax,[esi+evRButtonUpOffs]or eax,eaxje !DefWndProccall dword eaxxor eax,eaxjmp !Finish!GetMousePos:mov ebx,[lparam]and ebx,$ffffmov [CursorPosX],ebxmov ebx,[lparam]shr ebx,16mov [CursorPosY],ebxret!wmCreate:mov esi,[lparam]mov esi,[esi]mov eax,[esi+evCreateOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!CtlColorChange:invoke GetWindowLong,[lparam],GWL_USERDATAcmp [!Desc],0je !DefWndProcmov esi,[!Desc]call !GetDescbt [!dsStatus],WinChangeBackColorjc !CtlBackcolorChangebt [!dsStatus],WinChangeForeColorjc !CtlForecolorChangejmp !DefWndProc!CtlBackcolorChange:bt [!dsStatus],WinChangeForeColorjc !CtlBothColorChangecmp [!dsBackColor],$ffffffffjne !NotTransparentinvoke SetBkMode,[wparam],TRANSPARENTinvoke GetStockObject,NULL_BRUSHjmp !Finish!NotTransparent:invoke DeleteObject,[!Brush]invoke CreateSolidBrush,[!dsBackColor]mov [!Brush],eaxinvoke SetBkColor,[wparam],[!dsBackColor]mov eax,[!Brush]jmp !Finish!CtlBothColorChange:invoke DeleteObject,[!Brush]invoke CreateSolidBrush,[!dsBackColor]mov [!Brush],eaxinvoke SetBkColor,[wparam],[!dsBackColor]invoke SetTextColor,[wparam],[!dsForeColor]mov eax,[!Brush]jmp !Finish!CtlForecolorChange:invoke DeleteObject,[!Brush]invoke GetBkColor,[wparam]cmp [!dsControlType],!CT_TEXTBOXje !ListOrTextOrCombocmp [!dsControlType],!CT_LISTBOXje !ListOrTextOrCombocmp [!dsControlType],!CT_COMBOBOXje !ListOrTextOrComboinvoke GetPixel,[wparam],0,0!ListOrTextOrCombo:mov esi,[!Desc]bts dword [esi+StatusOffs],WinChangeBackColormov [esi+BackColorOffs],eaxinvoke CreateSolidBrush,eaxmov [!Brush],eaxinvoke SetTextColor,[wparam],[!dsForeColor]invoke SetBkMode,[wparam],TRANSPARENTmov eax,[!Brush]jmp !Finish!wmCommand:mov ax,[EventID]cmp ax,999jg !wmMenucmp [!Desc],0je !DefWndProcmov esi,[!Desc]mov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+evCommandOffs]cmp eax,0jne !CommandDispatchxor ebx,ebxmov bx,[EventNotify]; Clickcmp ebx,[esi+cdClickOffs]jne !evChangemov eax,[esi+evClickOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evChange:cmp ebx,[esi+cdChangeOffs]jne !evSelectmov eax,[esi+evChangeOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evSelect:cmp ebx,[esi+cdSelectOffs]jne !evDblClickmov eax,[esi+evSelectOffs]cmp eax,0jne !CommandDispatchjmp !DefWndProc!evDblClick:cmp ebx,[esi+cdDblClickOffs]jne !DefWndProcmov eax,[esi+evDblClickOffs]cmp eax,0je !DefWndProc!CommandDispatch:call dword eaxxor eax,eaxjmp !Finish!wmMenu:mov edx,[MenuEVPtr]or edx,edxje !DefWndProcand eax,$ffffmov [MenuID],eaxcall dword edxjmp !Finish!wmScroll:cmp [!Desc],0je !DefWndProcmov esi,[!Desc]mov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxmov eax,[esi+evScrollOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!wmContextMenu:invoke GetWindowLong,[wparam],GWL_USERDATAor eax,eaxje !DefWndProcmov esi,eaxmov eax,[esi+ArrayOffs]mov [ArrayIndex],eaxcall !GetMousePosmov eax,[esi+evContextMenuOffs]cmp eax,0je !DefWndProccall dword eaxxor eax,eaxjmp !Finish!GetDesc:mov eax,[esi+StatusOffs]mov [!dsStatus],eaxmov eax,[esi+BackColorOffs]mov [!dsBackColor],eaxmov eax,[esi+ForeColorOffs]mov [!dsForeColor],eaxmov eax,[esi+TypeOffs]mov [!dsControlType],eaxret!wmDestroy:invoke DeleteObject,[!Brush]invoke PostQuitMessage,0xor eax,eax!Finish:pop edi esi ebxreturn ENDTEXTTEXTBLOCK Includesinclude 'include\kernel.inc'include 'include\user.inc'include 'include\gdi.inc'include 'include\comctl.inc'include 'include\comdlg.inc'include 'include\shell.inc'include 'include\cproc.inc'include 'include\riched.inc'include 'include\raedit.inc'include 'include\ragrid.inc'include 'include\macro\import.inc'include 'include\macro\stdcall.inc'include 'include\macro\resource.inc'ENDTEXTTEXTBLOCK SubClassProcenterpush ebx esi edimov eax,[wparam]mov [EventID],axshr eax,16mov [EventNotify],axinvoke GetWindowLong,[lparam],GWL_USERDATAmov [!Desc],eaxcmp [wmsg],WM_CTLCOLORSTATICje !CtlColorChangecmp [wmsg],WM_CTLCOLOREDITje !CtlColorChangecmp [wmsg],WM_CTLCOLORBTNje !CtlColorChangecmp [wmsg],WM_CTLCOLORSCROLLBARje !CtlColorChangecmp [wmsg],WM_CTLCOLORLISTBOXje !CtlColorChangecmp [wmsg],WM_COMMANDje !wmCommandENDTEXTTEXTBLOCK ReadFileLib__ReadFile:mov [_ArgSafe0],esiinvoke ReadFile,[_IOPthNum],[_IOBuffer],1,XferCount,0mov [STATUS],eaxcmp eax,0je __ReadFile2cmp [XferCount],0je __ReadFile1cmp byte [_IOBuffer+12],13je __ReadFile1cmp byte [_IOBuffer+12],10je __ReadFilecmp [__ByteCounter],0je __ReadFilemov al, byte [_IOBuffer+12]mov esi,[_ArgSafe0]mov [esi],alinc esimov [_ArgSafe0],esidec [__ByteCounter]jmp __ReadFile__ReadFile1:cmp [__ByteCounter],0je __ReadOKmov esi,[_ArgSafe0]mov byte [esi],0jmp __ReadOK__ReadFile2:cmp eax,0jne __ReadOKinvoke GetLastErrormov [ERR],eaxjmp [_ErrVec]__ReadOK:retENDTEXTTEXTBLOCK WriteFileLib__WriteFile:mov [XferCount],0__WriteStrLen:cmp byte [esi],0je __WriteStrLenDoneinc esiinc [XferCount]dec [__ByteCounter]jne __WriteStrLen__WriteStrLenDone:invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0mov [STATUS],eaxcmp eax,0jne __WriteOKinvoke GetLastErrormov [ERR],eaxjmp [_ErrVec]__WriteOK:mov edx,[XferCount]mov [_ArgSafe0],edxmov eax,[_CRLF]mov [_XferAddr],eaxmov [XferCount],2invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0mov edx,[_ArgSafe0]add edx,[XferCount]mov [XferCount],edxretENDTEXTTEXTBLOCK TailStrLib__TailStr:push ebxmov edi,[esi]mov ecx,[esi+4]xor edx,edxdec eaxadd eax,edi__TailStrLen:mov bl,[edi]or bl,blje __TailStr2dec ecxje __TailStr1inc ediinc edxjmp __TailStrLen__TailStr1:inc edi__TailStr2:mov [esi],eaxmov [esi+4],edxpop ebxretENDTEXTTEXTBLOCK LCaseLib__LCase:mov ecx,[esi+4]mov esi,[esi]__LCaseLoop:mov al,[esi]or al,alje __LCaseDonecmp al,$41jb __NotUppercmp al, $5aja __NotUpperor al,$20__NotUpper:mov [esi],alinc esidec ecxjne __LCaseLoop__LCaseDone:retENDTEXTTEXTBLOCK UCaseLib__UCase:mov ecx,[esi+4]mov esi,[esi]__UCaseLoop:mov al,[esi]or al,alje __UCaseDone cmp al,$61jb __NotLowercmp al, $7aja __NotLowerand al,$df__NotLower:mov [esi],alinc esidec ecxjne __UCaseLoop__UCaseDone:retENDTEXTTEXTBLOCK SetStrConstLib__SetStrConst:mov ecx,[esi+4]mov al,[esi]mov [edi],alor al,alje __SetStrConstDonedec ecxje __SetStrConstDoneinc esiinc edijmp __SetStrConst__SetStrConstDone:retENDTEXTTEXTBLOCK DataLib__ReadBool:mov edi,[_DataPtr]mov al,[edi]cmp al,$30jne __ReadBoolTruexor al,aljmp __ReadBoolDone__ReadBoolTrue:mov al,1__ReadBoolDone:mov [esi],aladd edi,2mov [_DataPtr],ediret__ReadByte:push esicinvoke atol,[_DataPtr]pop esimov [esi],alcall __UpDateDataPtrret__ReadShort:push esicinvoke atol,[_DataPtr]pop esimov [esi],axcall __UpDateDataPtrret__ReadLong:push esicinvoke atol,[_DataPtr]pop esimov [esi],eaxcall __UpDateDataPtrret__ReadFlt:ret__ReadStr:mov edi,[_DataPtr]__ReadStrLoop:mov al,[edi]mov [esi],alinc ediinc esicmp al,0jne __ReadStrLoopmov [_DataPtr],ediret__UpDateDataPtr:mov esi,[_DataPtr]__UpDateDataPtrLoop:mov al,[esi]cmp al,0je __UpDateDataPtrDoneinc esijmp __UpDateDataPtrLoop__UpDateDataPtrDone:inc esimov [_DataPtr],esiretENDTEXTTEXTBLOCK InpDataLib__InpData:invoke ReadConsole,[_InHandle],[_IOBuffer],_BufSize,XferCount,0push eaxcmp [_ArgSafe1],6je __InpDataStringcmp [_ArgSafe1],1je __InpDataBoolcmp [_ArgSafe1],2je __InpDataBytecmp [_ArgSafe1],3je __InpDataShortcmp [_ArgSafe1],5je __InpDataFloatcall __GetNumValmov [esi],eaxjmp __InpDataDone__InpDataString:mov edi,[_ArgSafe0]mov edx,ediadd edx,4mov edx,[edx]mov edi,[edi]mov ecx,[XferCount]mov esi,[_IOBuffer]__InpDataStringLp:mov al,[esi]cmp al,$0djne __NotCRmov byte [edi],0jmp __InpDataDone__NotCR:mov [edi],aldec edxje __InpDataDoneinc esiinc edijne __InpDataStringLpjmp __InpDataDone__InpDataBool:jmp __InpDataDone__InpDataByte:call __GetNumValmov [esi],aljmp __InpDataDone__InpDataShort:call __GetNumValmov [esi],axjmp __InpDataDone__InpDataFloat:__InpDataDone:pop eaxret__GetNumVal:mov esi,[_IOBuffer]cinvoke atol,[_IOBuffer]mov esi,[_ArgSafe0]mov esi,[esi]retENDTEXTTEXTBLOCK BtoALib__BtoA:mov edi,[_ConvBuf1]or al,alje __BoolFalsemov esi,_TrueStrjmp __BldBool__BoolFalse:mov esi,_FalseStr__BldBool:mov al,[esi]mov [edi],alcmp al,0je __BtoADoneinc esiinc edijmp __BldBool__BtoADone:mov [edi],alretENDTEXTTEXTBLOCK MidStrLib__MidStr:dec eaxmov edi,[esi]add edi,eaxmov [esi],edimov [esi+4],edxretENDTEXTTEXTBLOCK MovArgLib__MovArg:mov esi,[_ArgList]mov edx,[edi+4]mov edi,[edi]__MovArg1:mov al,[esi]cmp al,32je __MovArgSpacemov [edi],alor al,alje __MovArgDoneinc esiinc edidec edxje __MovArgDonejmp __MovArg1__MovArgSpace:xor al,almov [edi],alinc esi__MovArgDone:mov [_ArgList],esiretENDTEXTTEXTBLOCK CmpStrLib__CmpStr:mov edx,[edi+4]mov edi,[edi]mov ecx,[esi+4]mov esi,[esi]__CmpStrLoop:mov al,[edi]mov ah,[esi]cmp al,0je __CmpStrDonecmp ah,0je __CmpStrDonecmp al,ahjne __CmpStrDiffinc ediinc esidec edxje __CmpStrDonedec ecxjne __CmpStrLoop__CmpStrDone:cmp al,ah__CmpStrDiff:retENDTEXTTEXTBLOCK MovStrLib__MovStr:push ebxmov edx,[edi+4]mov edi,[edi]__MovStr1:mov ecx,[esi+4]or ecx,ecxje __MovStrDone1mov ebx,[esi]__MovStr2:mov al,[ebx]mov [edi],alinc ediinc ebxdec edxje __MovStrDone2or al,alje __MovStr3dec ecxjne __MovStr2jmp __MovStr4__MovStr3:dec edi__MovStr4:mov ecx,[esi+8]or ecx,ecxje __MovStrDone1mov esi,ecxjmp __MovStr1__MovStrDone1:mov byte [edi],0__MovStrDone2:pop ebxretENDTEXTTEXTBLOCK AtoLLib__AtoL:mov dl,[esi]cmp dl,'$'jne __NotHexcall __NumScan__HexLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'$'je __AtoLDonecmp dl,$39jg __HexLetterand dl,$0fjmp __HexAcc__HexLetter:and dl,$0fadd dl,9__HexAcc:imul edx,ecxadd eax,edximul ecx,16 jmp __HexLoop__NotHex:cmp dl,'%'jne __NotOctalcall __NumScan__OctalLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'%'je __AtoLDoneand dl,$07imul edx,ecxadd eax,edximul ecx,8jmp __OctalLoop__NotOctal:cmp dl,'&'jne __NotBinarycall __NumScan__BinaryLoop:dec esixor edx,edxmov dl,[esi]cmp dl,'&'je __AtoLDoneand dl,$01imul edx,ecxadd eax,edximul ecx,2jmp __OctalLoop__NotBinary:cinvoke atol,esi__AtoLDone:ret__NumScan:inc esimov dl,[esi]cmp dl,0jne __NumScanxor eax,eaxmov ecx,1retENDTEXTTEXTBLOCK StrLenLib__StrLen:xor eax,eax__StrLenGetVec:mov edi,[esi]mov edx,[esi+4]__StrLenLp:mov cl,[edi]cmp cl,0je __StrLenChkLnkinc eaxdec edxje __StrLenChkLnkinc edijmp __StrLenLp__StrLenChkLnk:mov esi,[esi+8]or esi,esijne __StrLenGetVecretENDTEXTTEXTBLOCK RightStrLib__RightStr:mov edi,[esi]mov ecx,[esi+4]__RightStrLen:mov dl,[edi]or dl,dlje __RightStr2dec ecxje __RightStr1inc edijmp __RightStrLen__RightStr1:inc edi__RightStr2:sub edi,eaxmov [esi],edimov [esi+4],eaxretENDTEXTTEXTBLOCK IncZRankLib__IncZRank:inc [!ZRank]mov edx,[!ZRank]mov dword [edi+476],edxretENDTEXTTEXTBLOCK SetRightBottomLib__SetRightBottom:mov edi,[!TargetGUIDesc]mov dword eax,[edi+LeftOffs]add dword eax,[edi+WidthOffs]mov dword [edi+RightOffs],eaxmov dword eax,[edi+TopOffs]add dword eax,[edi+HeightOffs]mov dword [edi+BottomOffs],eaxretENDTEXTTABLE KeyTable AS KeyData 0,"data",DataX 0,"restore",RestoreX 0,"poke",PokeX 0,"return",ReturnX 0,"seek",SeekX 0,"type",TypeX 0,"dim",DimX 0,"let",LetX 0,"for",ForX 0,"if",IfX 0,"construct",ConstructX 0,"gosub",GosubX 0,"on",OnX 0,"print",PrintX 0,"input",InputX 0,"read",ReadX 0,"write",WriteX 0,"get",GetX 0,"put",PutX 0,"end",EndX 0,"create",CreateX 0,"open",OpenX 0,"close",CloseX 0,"while",WhileX 0,"endwhile",EndWhileX 0,"next",NextX 0,"rem",RemX 0,"else",ElseX 0,"endif",ENDIFX 0,"delete",DeleteX 0,"buffer",BufferX 0,"endloop",EndLoopX 0,"repeat",RepeatX 0,"until",UntilX 0,"exitif",ExitIfX 0,"shell",ShellX 0,"fprint",FPrintX 0,"finput",FInputX 0,"base",BaseX 0,"incr",IncrX 0,"decr",DecrX 0,"bufread",BufReadX 0,"bufwrite",BufWriteX 0,"decimals",DecimalsX 0,"exchange",ExchangeX 0,"beep",BeepX 0,"endexit",EndExitX 0,"redim",ReDimX 0,"playwave",PlayWaveX 0,"setvec",SetVecX 0,"digits",DigitsX 0,"macro",MacroX 0,"endmacro",EndMacroX 0,"table",TableX 0,"endtable",EndTableX 0,"include",IncludeX 0,"freeze",FreezeX 0,"call",CallX 0,"chdir",ChDirX 0,"mkdir",MkDirX 0,"rmdir",RmDirX 0,"endfunction",EndFunctionX 0,"endprocedure",EndProcedureX 0,"randomize",RandomizeX 0,"declare",DeclareX 0,"function",FunctionX 0,"procedure",ProcedureX 0,"wend",WendX 0,"continue",ContinueX 0,"select",SelectX 0,"endselect",EndSelectX 0,"case",CaseX 0,"endcase",EndCaseX 0,"const",ConstX 0,"swap",SwapX 0,"program",ProgramX 0,"gencode",GenCodeX 0,"endgencode",EndGenCodeX 0,"makelower",MakeLowerX 0,"makeupper",MakeUpperX 0,"find",FindX 0,"endtext",EndTextX 0,"endtype",EndTypeX 0,"setposition",SetPositionX 0,"goto",GotoX 0,"getcursorposition",GetCursorPositionX 0,"screentoclient",ScreenToClientX 0,"getwindowrect",GetWindowRectX 0,"setcapture",SetCaptureX 0,"releasecapture",ReleaseCaptureX 0,"msgbox",MsgBoxX 0,"warningbox",WarningBoxX 0,"infobox",InfoBoxX 0,"questionbox",QuestionBoxX 0,"errorbox",ErrorBoxX 0,"setstyle",SetStyleX 0,"textblock",TextBlockX 0,"destroy",DestroyX 0,"show",ShowX 0,"endevent",EndEventX 0,"finddialog",FindDialogX 0,"replacedialog",ReplaceDialogX 0,"colordialog",ColorDialogX 0,"fontdialog",FontDialogX 0,"opendialog",OpenDialogX 0,"savedialog",SaveDialogX 0,"printdialog",PrintDialogX 0,"pagedialog",PageDialogX 0,"showpopup",ShowPopupX 0,"popupmenu",PopupMenuX 0,"menu",MenuX 0,"endmenu",EndMenuX 0,"checkmenuitem",CheckMenuitemX 0,"uncheckmenuitem",UncheckMenuitemX 0,"enablemenuitem",EnableMenuitemX 0,"disablemenuitem",DisableMenuitemX 0,"enum",EnumX 0,"endenum",EndEnumX 0,"beginloop",BeginLoopX 0,"begin",BeginX 0,"createfont",CreateFontX 0,"createicon",CreateIconX 0,"createcursor",CreateCursorX 0,"createbitmap",CreateBitMapX 0,"passsystemevent",PassSystemEventX 0,"passinterceptevent",PassInterceptEventX 0,"readcard",ReadCardX 0,"writecard",WriteCardX 0,"useimport",UseImportX 0,"importfunction",ImportFunctionX 0,"exportfunction",ExportFunctionX 0,"finditem",FindItemX 0,"finditemexact",FindItemExactX 0,"object",ObjectX 0,"endobject",EndObjectX 0,"db",DBX 0,"dw",DWX 0,"dd",DDX 0,"rb",RBX 0,"rw",RWX 0,"rd",RDX 0,"set",SETDx 0,"add",AssemblyX 0,"aad",AssemblyX 0,"aam",AssemblyX 0,"aas",AssemblyX 0,"adc",AssemblyX 0,"and",AssemblyX 0,"arpl",AssemblyX 0,"bound",AssemblyX 0,"bsf",AssemblyX 0,"bsr",AssemblyX 0,"bswap",AssemblyX 0,"bt",AssemblyX 0,"btc",AssemblyX 0,"btr",AssemblyX 0,"bts",AssemblyX 0,"call",AssemblyX 0,"cbw",AssemblyX 0,"cdq",AssemblyX 0,"clc",AssemblyX 0,"cld",AssemblyX 0,"cli",AssemblyX 0,"clts",AssemblyX 0,"cmc",AssemblyX 0,"cmp",AssemblyX 0,"cpms",AssemblyX 0,"cmpxchg",AssemblyX 0,"cwd",AssemblyX 0,"cwde",AssemblyX 0,"daa",AssemblyX 0,"das",AssemblyX 0,"dec",AssemblyX 0,"div",AssemblyX 0,"enter",AssemblyX 0,"esc",AssemblyX 0,"hlt",AssemblyX 0,"idiv",AssemblyX 0,"imul",AssemblyX 0,"in",AssemblyX 0,"inc",AssemblyX 0,"ins",AssemblyX 0,"int",AssemblyX 0,"into",AssemblyX 0,"invd",AssemblyX 0,"iret",AssemblyX 0,"iretd",AssemblyX 0,"invlpg",AssemblyX 0,"invoke",AssemblyX 0,"ja",AssemblyX 0,"jae",AssemblyX 0,"jb",AssemblyX 0,"jbe",AssemblyX 0,"jc",AssemblyX 0,"jcxz",AssemblyX 0,"je",AssemblyX 0,"jecxz",AssemblyX 0,"jg",AssemblyX 0,"jge",AssemblyX 0,"jl",AssemblyX 0,"jle",AssemblyX 0,"jmp",AssemblyX 0,"jna",AssemblyX 0,"jnae,",AssemblyX 0,"jnb",AssemblyX 0,"jnbe",AssemblyX 0,"jnc",AssemblyX 0,"jne",AssemblyX 0,"jng",AssemblyX 0,"jnge",AssemblyX 0,"jnl",AssemblyX 0,"jnle",AssemblyX 0,"jno",AssemblyX 0,"jnp",AssemblyX 0,"jns",AssemblyX 0,"jnz",AssemblyX 0,"jo",AssemblyX 0,"jp",AssemblyX 0,"jpe",AssemblyX 0,"jpo",AssemblyX 0,"js",AssemblyX 0,"jz",AssemblyX 0,"lahf",AssemblyX 0,"lar",AssemblyX 0,"lds",AssemblyX 0,"lea",AssemblyX 0,"leave",AssemblyX 0,"les",AssemblyX 0,"lfs",AssemblyX 0,"lgdt",AssemblyX 0,"lidt",AssemblyX 0,"lgs",AssemblyX 0,"lldt",AssemblyX 0,"lmsw",AssemblyX 0,"lock",AssemblyX 0,"lods",AssemblyX 0,"loop",AssemblyX 0,"loope",AssemblyX 0,"loopne",AssemblyX 0,"loopnz",AssemblyX 0,"loopz",AssemblyX 0,"mov",AssemblyX 0,"movs",AssemblyX 0,"movsx",AssemblyX 0,"movzx",AssemblyX 0,"mul",AssemblyX 0,"neg",AssemblyX 0,"nop",AssemblyX 0,"not",AssemblyX 0,"or",AssemblyX 0,"out",AssemblyX 0,"outs",AssemblyX 0,"pop",AssemblyX 0,"popa",AssemblyX 0,"popad",AssemblyX 0,"popf",AssemblyX 0,"popfd",AssemblyX 0,"push",AssemblyX 0,"pusha",AssemblyX 0,"pushad",AssemblyX 0,"pushf",AssemblyX 0,"pushfd",AssemblyX 0,"rcl",AssemblyX 0,"rcr",AssemblyX 0,"rep",AssemblyX 0,"repe",AssemblyX 0,"repne",AssemblyX 0,"repnz",AssemblyX 0,"repz",AssemblyX 0,"ret",AssemblyX 0,"retf",AssemblyX 0,"rol",AssemblyX 0,"ror",AssemblyX 0,"sahf",AssemblyX 0,"sal",AssemblyX 0,"shl",AssemblyX 0,"sar",AssemblyX 0,"sbb",AssemblyX 0,"scas",AssemblyX 0,"setae",AssemblyX 0,"setnb",AssemblyX 0,"setnae",AssemblyX 0,"setbe",AssemblyX 0,"setna",AssemblyX 0,"sete",AssemblyX 0,"setz",AssemblyX 0,"setne",AssemblyX 0,"setnz",AssemblyX 0,"setl",AssemblyX 0,"setnge",AssemblyX 0,"setge",AssemblyX 0,"setnl",AssemblyX 0,"setle",AssemblyX 0,"setng",AssemblyX 0,"setg",AssemblyX 0,"setnle",AssemblyX 0,"sets",AssemblyX 0,"setns",AssemblyX 0,"setc",AssemblyX 0,"setnc",AssemblyX 0,"seto",AssemblyX 0,"setno",AssemblyX 0,"setp",AssemblyX 0,"setpe",AssemblyX 0,"setnp",AssemblyX 0,"setpo",AssemblyX 0,"sgdt",AssemblyX 0,"sidt",AssemblyX 0,"shl",AssemblyX 0,"shr",AssemblyX 0,"shld",AssemblyX 0,"shrd",AssemblyX 0,"shld",AssemblyX 0,"smsw",AssemblyX 0,"stc",AssemblyX 0,"std",AssemblyX 0,"sti",AssemblyX 0,"stos",AssemblyX 0,"str",AssemblyX 0,"sub",AssemblyX 0,"test",AssemblyX 0,"verr",AssemblyX 0,"verw",AssemblyX 0,"wait",AssemblyX 0,"fwait",AssemblyX 0,"wbinvd",AssemblyX 0,"xchg",AssemblyX 0,"xlat",AssemblyX 0,"xlatb",AssemblyX 0,"xor",AssemblyXENDTABLEGenConst CT,FORM,100GenConst CT,BUTTON,101GenConst CT,STATICICON,102GenConst CT,COMBOBOX,103GenConst CT,TEXTBOX,104GenConst CT,FRAME,105GenConst CT,LISTBOX,106GenConst CT,SLIDER,107GenConst CT,SPINNER,108GenConst CT,PROGRESSBAR,109GenConst CT,CALENDAR,110GenConst CT,HEADER,111GenConst CT,TREEVIEW,112GenConst CT,TABFOLDER,113GenConst CT,BUTTONLISTBOX,114GenConst CT,TOOLBAR,115GenConst CT,STATUSBAR,116GenConst CT,CHECKBOX,117GenConst CT,RADIOBUTTON,118GenConst CT,TIMER,119GenConst CT,RICHEDIT,120GenConst CT,RAEdit,121GenConst CT,RAGrid,122GenConst CT,TOOLWINDOW,123GenConst CT,LISTVIEW,124GenConst CT,STATICTEXT,125GenConst CT,ICONBUTTON,126GenConst CT,RECTANGLE,127TABLE ObjTable AS ObjData 0,STDCTL,"form","Havis","0",FormPropTable,FormStyleTable,FormEventTable 0,STDCTL,"button","BUTTON","0",ButtonPropTable,ButtonStyleTable,ButtonEventTable 0,STDCTL,"staticicon","STATIC","0",StaticIconPropTable,StaticIconStyleTable,StaticIconEventTable 0,STDCTL,"combobox","COMBOBOX","0",ComboBoxPropTable,ComboBoxStyleTable,ComboBoxEventTable 0,STDCTL,"textbox","EDIT","WS_EX_CLIENTEDGE",TextBoxPropTable,TextBoxStyleTable,TextBoxEventTable 0,STDCTL,"frame","BUTTON","0",FramePropTable,FrameStyleTable,FrameEventTable 0,STDCTL,"listbox","LISTBOX","0",ListBoxPropTable,ListBoxStyleTable,ListBoxEventTable 0,COMCTL,"slider","msctls_trackbar32","0",SliderPropTable,SliderStyleTable,SliderEventTable 0,COMCTL,"spinner","msctls_updown32","0",SpinnerPropTable,SpinnerStyleTable,SpinnerEventTable 0,COMCTL,"progressbar","msctls_progress32","0",ProgressBarPropTable,ProgressBarStyleTable,ProgressBarEventTable 0,COMCTL,"calendar","SysMonthCal32","0",CalendarPropTable,CalendarStyleTable,CalendarEventTable 0,COMCTL,"header","SysHeader32","0",HeaderPropTable,HeaderStyleTable,HeaderEventTable 0,COMCTL,"treeview","SysTreeView32","0",TreeViewPropTable,TreeViewStyleTable,TreeViewEventTable 0,COMCTL,"tabfolder","SysTabControl32","WS_EX_CONTROLPARENT",TabFolderPropTable,TabFolderStyleTable,TabFolderEventTable 0,COMCTL,"buttonlistbox","ButtonListBox","0",ButtonListBoxPropTable,ButtonListBoxStyleTable,ButtonListBoxEventTable 0,COMCTL,"toolbar","ToolbarWindow32","0",ToolBarPropTable,ToolBarStyleTable,ToolBarEventTable 0,COMCTL,"statusbar","msctls_statusbar32","0",StatusBarPropTable,StatusBarStyleTable,StatusBarEventTable 0,STDCTL,"checkbox","BUTTON","0",CheckBoxPropTable,CheckBoxStyleTable,CheckBoxEventTable 0,STDCTL,"radiobutton","BUTTON","0",RadioButtonPropTable,RadioButtonStyleTable,CheckBoxEventTable 0,TIMCTL,"timer","TIMER","0",TimerPropTable,TimerStyleTable,TimerEventTable 0,COMCTL,"richedit","RICHEDIT20A","WS_EX_CLIENTEDGE",RichEditPropTable,RichEditStyleTable,RichEditEventTable 0,COMCTL,"raedit","RAEdit","WS_EX_CLIENTEDGE",RAEditPropTable,RAEditStyleTable,RAEditEventTable 0,COMCTL,"ragrid","RAGrid","WS_EX_CLIENTEDGE",RAGridPropTable,RAGridStyleTable,RAGridEventTable 0,STDCTL,"toolwindow","Havis","0",ToolWindowPropTable,ToolWindowStyleTable,ToolWindowEventTable 0,COMCTL,"listview","SysListView32","0",ListViewPropTable,ListViewStyleTable,ListViewEventTable 0,STDCTL,"statictext","STATIC","0",StaticTextPropTable,StaticTextStyleTable,StaticTextEventTable 0,STDCTL,"iconbutton","BUTTON","0",IconButtonPropTable,IconButtonStyleTable,IconButtonEventTable 0,STDCTL,"rectangle","STATIC","0",RectanglePropTable,RectangleStyleTable,RectangleEventTableENDTABLELastKey=TABLESIZE(KeyTable)FOR KeyNdx=1 TO LastKey	KeyTable(KeyNdx).KeyCheckWord=CHKWORD(KeyTable(KeyNdx).KeyName)NEXT KeyNdxLastImportFcn=TABLESIZE(ImportFcnTable)LastImportLib=TABLESIZE(ImportLibTable)Preamble:;*** Win95/NT ****NewLine=$0dOutBuf=";Compiler Declaration Section";;; Temp fix for init problem;GOSUB OutDeclareOutBuf=";Compiler Declaration Section"GOSUB OutDeclareOutBuf=""GOSUB OutDeclareOutBuf="format PE "IF GUIFlag=0 THEN	OutBuf=OutBuf+"console"ELSE	OutBuf=OutBuf+"GUI 4.0"ENDIFIF DLLFlag=TRUE THEN	OutBuf=OutBuf+" DLL"ENDIFGOSUB OutDeclareOutBuf="section '.data' data readable writeable"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataOutBuf="align 4"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataOutBuf="ERR dd 0"GOSUB OutInitDataOutBuf="!ArrayBase dd 1"GOSUB OutInitDataOutBuf="_ErrVec dd 0"GOSUB OutInitDataOutBuf="STATUS dd 0"GOSUB OutInitDataOutBuf="POS dd 0"GOSUB OutInitDataOutBuf="Ticks dd 0"GOSUB OutInitDataOutBuf="XferCount dd 0"GOSUB OutInitDataOutBuf="ArrNdx dd 0"GOSUB OutInitDataOutBuf="EventNotify dw 0"GOSUB OutInitDataOutBuf="EventID dw 0"GOSUB OutInitDataOutBuf="_TrueStr db "+CHR(OBQUOTE)+"TRUE"+CHR(OBQUOTE)+",0"GOSUB OutInitDataOutBuf="_FalseStr db "+CHR(OBQUOTE)+"FALSE"+CHR(OBQUOTE)+",0"GOSUB OutInitDataIF GUIFlag<>0 THEN	LastObj=TABLESIZE(ObjTable)	FOR ObjNdx=1 TO LastObj		ObjTable(ObjNdx).ObjCheckWord=CHKWORD(ObjTable(ObjNdx).ObjName)		OutBuf="!ControlType"+STR(ObjNdx)+" db '"+ObjTable(ObjNdx).ObjTypeName+"',0"		GOSUB OutInitData	NEXT ObjNdxENDIFOutBuf=""GOSUB OutDeclareOutBuf="entry !Start"GOSUB OutDeclareOutBuf=""GOSUB OutDeclareOutBuf="macro align value { rb (value-1) - (rva $ + value-1) mod value }"GOSUB OutDeclareOutBuf=""GOSUB OutDeclareOutBuf="_BufSize="+STR(_BufSize)GOSUB OutDeclareRESTORE RunVarTblOutBuf="align 4"GOSUB OutUninitDataRunVarLoop:READ OutBufIF OutBuf="%" THEN RunVarDoneGOSUB OutUninitDataGOTO RunVarLoopRunVarDone:RESTORE PreCodeSeg1GOSUB OutPreCodeTextImportFcnTable(ptrGetStdHandle).ImportFcnUse=TRUEImportFcnTable(ptrGetCommandLine).ImportFcnUse=TRUEImportFcnTable(ptrGetModuleHandle).ImportFcnUse=TRUEIF GUIFlag<>0 THEN	OutBuf="!OBMainWindowClass WNDCLASS"	GOSUB OutInitData	OutBuf="msg MSG"	GOSUB OutInitData	OutBuf="!OBMainClass db 'OBMain',0"	GOSUB OutInitData	OutBuf="!icc dd $00000008,$00003FFF"	GOSUB OutInitData	OutBuf="!!RichEd db 'RichEd20.dll',0"	GOSUB OutInitData	OutBuf="!!RAEdit db 'RAEdit.dll',0"	GOSUB OutInitData	OutBuf="!!RAGrid db 'RAGrid.dll',0"	GOSUB OutInitData	OutBuf="!!Csmdll db 'Csmdll.dll',0"	GOSUB OutInitData	OutBuf="!title db 'OmniBasic',0"	GOSUB OutInitData	OutBuf="align 4"	GOSUB OutUninitData	OutBuf="align 4"	GOSUB OutInitData	OutBuf="!Timer dd 0"	GOSUB OutInitData	OutBuf="Timer1 dd 0"	GOSUB OutInitData	OutBuf="Timer2 dd 0"	GOSUB OutInitData	OutBuf="Timer3 dd 0"	GOSUB OutInitData	OutBuf="Timer4 dd 0"	GOSUB OutInitData	OutBuf="Timer5 dd 0"	GOSUB OutInitData	OutBuf="Timer6 dd 0"	GOSUB OutInitData	OutBuf="Timer7 dd 0"	GOSUB OutInitData	OutBuf="Timer8 dd 0"	GOSUB OutInitData	OutBuf="Timer9 dd 0"	GOSUB OutInitData	OutBuf="Timer10 dd 0"	GOSUB OutInitData	OutBuf="Timer11 dd 0"	GOSUB OutInitData	OutBuf="Timer12 dd 0"	GOSUB OutInitData	OutBuf="Timer13 dd 0"	GOSUB OutInitData	OutBuf="Timer14 dd 0"	GOSUB OutInitData	OutBuf="Timer15 dd 0"	GOSUB OutInitData	OutBuf="Timer16 dd 0"	GOSUB OutInitData	OutBuf="Timer17 dd 0"	GOSUB OutInitData	OutBuf="Timer18 dd 0"	GOSUB OutInitData	OutBuf="Timer19 dd 0"	GOSUB OutInitData	OutBuf="Timer20 dd 0"	GOSUB OutInitData	OutBuf="Timer21 dd 0"	GOSUB OutInitData	OutBuf="Timer22 dd 0"	GOSUB OutInitData	OutBuf="Timer23 dd 0"	GOSUB OutInitData	OutBuf="Timer24 dd 0"	GOSUB OutInitData	OutBuf="Timer25 dd 0"	GOSUB OutInitData	OutBuf="Timer26 dd 0"	GOSUB OutInitData	OutBuf="Timer27 dd 0"	GOSUB OutInitData	OutBuf="Timer28 dd 0"	GOSUB OutInitData	OutBuf="Timer29 dd 0"	GOSUB OutInitData	OutBuf="Timer30 dd 0"	GOSUB OutInitData	OutBuf="Timer31 dd 0"	GOSUB OutInitData	OutBuf="Timer32 dd 0"	GOSUB OutInitData	OutBuf="gc_colwt dd 0"	GOSUB OutInitData	OutBuf="gc_lpszhdrtext dd 0"	GOSUB OutInitData	OutBuf="gc_halign dd 0"	GOSUB OutInitData	OutBuf="gc_calign dd 0"	GOSUB OutInitData	OutBuf="gc_ctype dd 0"	GOSUB OutInitData	OutBuf="gc_ctextmax dd 0"	GOSUB OutInitData	OutBuf="gc_lpszformat dd 0"	GOSUB OutInitData	OutBuf="gc_himl dd 0"	GOSUB OutInitData	OutBuf="gc_hdrflag dd 0"	GOSUB OutInitData	OutBuf="gc_colxp dd 0"	GOSUB OutInitData	OutBuf="gc_edthwnd dd 0"	GOSUB OutInitData		OutBuf="MenuEVPtr dd 0"	GOSUB OutInitData	OutBuf="MenuID dd 0"	GOSUB OutInitData	OutBuf="FindEVPtr dd 0"	GOSUB OutInitData	OutBuf="FindMsgID dd 0"	GOSUB OutInitData	OutBuf="FINDMSGSTRING db 'commdlg_FindReplace',0"	GOSUB OutInitData	OutBuf="FLAGS dd 0"	GOSUB OutInitData	OutBuf="nmhdr_hwndFrom dd 0"	GOSUB OutInitData	OutBuf="nmhdr_idFrom dd 0"	GOSUB OutInitData	OutBuf="nmhdr_code dd 0"	GOSUB OutInitData	OutBuf="cr_cpMin dd 0"	GOSUB OutInitData	OutBuf="cr_cpMax dd 0"	GOSUB OutInitData	OutBuf="ofn_lStructSize dd 76"	GOSUB OutInitData	OutBuf="ofn_hwndOwner dd 0"	GOSUB OutInitData	OutBuf="ofn_hInstance dd 0"	GOSUB OutInitData	OutBuf="ofn_lpstrFilter dd 0"	GOSUB OutInitData	OutBuf="ofn_lpstrCustomFilter dd 0"	GOSUB OutInitData	OutBuf="ofn_nMaxCustFilter dd 0"	GOSUB OutInitData	OutBuf="ofn_nFilterIndex dd 1"	GOSUB OutInitData	OutBuf="ofn_lpstrFile dd 0"	GOSUB OutInitData	OutBuf="ofn_nMaxFile dd 0"	GOSUB OutInitData	OutBuf="ofn_lpstrFileTitle dd 0"	GOSUB OutInitData	OutBuf="ofn_nMaxFileTitle dd 0"	GOSUB OutInitData	OutBuf="ofn_lpstrInitialDir dd 0"	GOSUB OutInitData	OutBuf="ofn_lpstrTitle dd 0"	GOSUB OutInitData	OutBuf="ofn_Flags dd 0"	GOSUB OutInitData	OutBuf="ofn_nFileOffset dw 0"	GOSUB OutInitData	OutBuf="ofn_nFileExtension dw 0"	GOSUB OutInitData	OutBuf="ofn_lpstrDefExt dd 0"	GOSUB OutInitData	OutBuf="ofn_lCustData dd 0"	GOSUB OutInitData	OutBuf="ofn_lpfnHook dd 0"	GOSUB OutInitData	OutBuf="ofn_lpTemplateName dd 0"	GOSUB OutInitData	OutBuf="cc_lStructSize dd 36"	GOSUB OutInitData	OutBuf="cc_hwndOwner dd 0"	GOSUB OutInitData	OutBuf="cc_hInstance dd 0"	GOSUB OutInitData	OutBuf="cc_rgbResult dd 0"	GOSUB OutInitData	OutBuf="cc_lpCustColors dd _CustColors"	GOSUB OutInitData	OutBuf="cc_Flags dd 0"	GOSUB OutInitData	OutBuf="cc_lCustData dd 0"	GOSUB OutInitData	OutBuf="cc_lpfnHook dd 0"	GOSUB OutInitData	OutBuf="cc_lpTemplateName dd 0"	GOSUB OutInitData	OutBuf="_CustColors rd 16"	GOSUB OutInitData	OutBuf="fr_lStructSize dd 40"	GOSUB OutInitData	OutBuf="fr_hwndOwner dd 0"	GOSUB OutInitData	OutBuf="fr_hInstance dd 0"	GOSUB OutInitData	OutBuf="fr_Flags dd 0"	GOSUB OutInitData	OutBuf="fr_lpstrFindWhat dd 0"	GOSUB OutInitData	OutBuf="fr_lpstrReplaceWith dd _PrintBuf+12"	GOSUB OutInitData	OutBuf="fr_wFindWhatLen dw 0"	GOSUB OutInitData	OutBuf="fr_wReplaceWithLen dw 0"	GOSUB OutInitData	OutBuf="fr_lCustData dd 0"	GOSUB OutInitData	OutBuf="fr_lpfnHook dd 0"	GOSUB OutInitData	OutBuf="fr_lpTemplateName dd 0"	GOSUB OutInitData	OutBuf="ft_SearchMin rd 1"	GOSUB OutUninitData	OutBuf="ft_SearchMax rd 1"	GOSUB OutUninitData	OutBuf="ft_SearchTextPtr rd 1"	GOSUB OutUninitData	OutBuf="ft_FoundMin rd 1"	GOSUB OutUninitData	OutBuf="ft_FoundMax rd 1"	GOSUB OutUninitData	OutBuf="cf_lStructSize dd 58"	GOSUB OutInitData	OutBuf="cf_hwndOwner dd 0"	GOSUB OutInitData	OutBuf="cf_hDC dd 0"	GOSUB OutInitData	OutBuf="cf_lpLogFont dd 0"	GOSUB OutInitData	OutBuf="cf_iPointSize dd 0"	GOSUB OutInitData	OutBuf="cf_Flags dd 0"	GOSUB OutInitData	OutBuf="cf_rgbColors dd 0"	GOSUB OutInitData	OutBuf="cf_lCustData dd 0"	GOSUB OutInitData	OutBuf="cf_lpfnHook dd 0"	GOSUB OutInitData	OutBuf="cf_lpTemplateName dd 0"	GOSUB OutInitData	OutBuf="cf_hInstance dd 0"	GOSUB OutInitData	OutBuf="cf_lpszStyle dd 0"	GOSUB OutInitData	OutBuf="cf_nFontType dw 0"	GOSUB OutInitData	OutBuf="cf_nSizeMin dd 0"	GOSUB OutInitData	OutBuf="cf_nSizeMax dd 0"	GOSUB OutInitData	OutBuf="pr_lStructSize dd 66"	GOSUB OutInitData	OutBuf="pr_hwndOwner dd 0"	GOSUB OutInitData	OutBuf="pr_hDevMode dd 0"	GOSUB OutInitData	OutBuf="pr_hDevNames dd 0"	GOSUB OutInitData	OutBuf="pr_hDC dd 0"	GOSUB OutInitData	OutBuf="pr_Flags dd 0"	GOSUB OutInitData	OutBuf="pr_nFromPage dw 0"	GOSUB OutInitData	OutBuf="pr_nToPage dw 0"	GOSUB OutInitData	OutBuf="pr_nMinPage dw 0"	GOSUB OutInitData	OutBuf="pr_nMaxPage dw 0"	GOSUB OutInitData	OutBuf="pr_nCopies dw 0"	GOSUB OutInitData	OutBuf="pr_hInstance dd 0"	GOSUB OutInitData	OutBuf="pr_lCustData dd 0"	GOSUB OutInitData	OutBuf="pr_lpfnPrintHook dd 0"	GOSUB OutInitData	OutBuf="pr_lpfnSetupHook dd 0"	GOSUB OutInitData	OutBuf="pr_lpPrintTemplateName dd 0"	GOSUB OutInitData	OutBuf="pr_lpSetupTemplateName dd 0"	GOSUB OutInitData	OutBuf="pr_hPrintTemplate dd 0"	GOSUB OutInitData	OutBuf="pr_hSetupTemplate dd 0"	GOSUB OutInitData		OutBuf="!OBMain rd 256"	GOSUB OutDesc	ObjectCtr=1	OutBuf="CursorPosX rd 1"	GOSUB OutUninitData	OutBuf="CursorPosY rd 1"	GOSUB OutUninitData	; The next 4 constitute a Rect structure	OutBuf="RectLeft rd 1"	GOSUB OutUninitData	OutBuf="RectTop rd 1"	GOSUB OutUninitData	OutBuf="RectRight rd 1"	GOSUB OutUninitData	OutBuf="RectBottom rd 1"	GOSUB OutUninitData	OutBuf="!ZRank dd 0"	GOSUB OutInitData	OutBuf="!TargetGUIDesc rd 1"	GOSUB OutUninitData	OutBuf="!SourceGUIDesc rd 1"	GOSUB OutUninitData	OutBuf="GridRow rd 1"	GOSUB OutUninitData	OutBuf="GridCol rd 1"	GOSUB OutUninitData	OutBuf="!RA_BCKCOLOR dd $C0F0F0"	GOSUB OutInitData	OutBuf="!RA_TXTCOLOR dd $000000"	GOSUB OutInitData	OutBuf="!RA_SELBCKCOLOR dd $800000"	GOSUB OutInitData	OutBuf="!RA_SELTXTCOLOR dd $ffffff"	GOSUB OutInitData	OutBuf="!RA_CMNTCOLOR dd $008000"	GOSUB OutInitData	OutBuf="!RA_STRCOLOR dd $ff0000"	GOSUB OutInitData	OutBuf="!RA_OPRCOLOR dd $0000a0"	GOSUB OutInitData	OutBuf="!RA_HILITE1 dd $F0C0C0"	GOSUB OutInitData	OutBuf="!RA_HILITE2 dd $C0F0C0"	GOSUB OutInitData	OutBuf="!RA_HILITE3 dd $C0C0F0"	GOSUB OutInitData	OutBuf="!RA_SELBARCOLOR dd $c0c0c0"	GOSUB OutInitData	OutBuf="!RA_SELBARPEN dd $808080"	GOSUB OutInitData	OutBuf="!RA_LNRCOLOR dd $800000"	GOSUB OutInitData	OutBuf="EditcpMin rd 1"	GOSUB OutUninitData	OutBuf="EditcpMax rd 1"	GOSUB OutUninitData	OutBuf="EditSelType rw 1"	GOSUB OutUninitData	OutBuf="EditLine rd 1"	GOSUB OutUninitData	OutBuf="EditcpLine rd 1"	GOSUB OutUninitData	OutBuf="EditlpLine rd 1"	GOSUB OutUninitData	OutBuf="EditnLines rd 1"	GOSUB OutUninitData	OutBuf="EditnHidden rd 1"	GOSUB OutUninitData	OutBuf="EditfChanged rd 1"	GOSUB OutUninitData	OutBuf="EditnPage rd 1"	GOSUB OutUninitData	OutBuf="EditnWordGroup rd 1"	GOSUB OutUninitData	OutBuf="OldFrameProc rd 1"	GOSUB OutUninitData	OutBuf="!Brush rd 1"	GOSUB OutUninitData	OutBuf="!Desc rd 1"	GOSUB OutUninitData	OutBuf="NMHDR rd 1"	GOSUB OutUninitData	OutBuf="!cbSize dd 52"	GOSUB OutInitData	OutBuf="!rcItem dd 0,0,0,0"	GOSUB OutInitData	OutBuf="!rcButton dd 0,0,0,0"	GOSUB OutInitData	OutBuf="!stateButton dd 0"	GOSUB OutInitData	OutBuf="!hwndCombo dd 0"	GOSUB OutInitData	OutBuf="!hwndItem dd 0"	GOSUB OutInitData	OutBuf="!hwndList dd 0"	GOSUB OutInitData	OutBuf="!dsStatus rd 1"	GOSUB OutUninitData	OutBuf="ArrayIndex rd 1"	GOSUB OutUninitData	OutBuf="!dsBackColor rd 1"	GOSUB OutUninitData	OutBuf="!dsForeColor rd 1"	GOSUB OutUninitData	OutBuf="!dsControlType rd 1"	GOSUB OutUninitData	RESTORE PreCodeSeg2	GOSUB OutPreCodeText	ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	ImportFcnTable(ptrRegisterClass).ImportFcnUse=TRUE	ImportFcnTable(ptrLoadCursor).ImportFcnUse=TRUE	ImportFcnTable(ptrLoadIcon).ImportFcnUse=TRUE	ImportFcnTable(ptrLoadLibrary).ImportFcnUse=TRUE	ImportFcnTable(ptrInitCommonControlsEx).ImportFcnUse=TRUE	ImportFcnTable(ptrGetMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrTranslateMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrDispatchMessage).ImportFcnUse=TRUE	ImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUE	ImportFcnTable(ptrSetBkColor).ImportFcnUse=TRUE	ImportFcnTable(ptrSetTextColor).ImportFcnUse=TRUE	ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE	ImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUE	ImportFcnTable(ptrDefWindowProc).ImportFcnUse=TRUE	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	ImportFcnTable(ptrGetBkColor).ImportFcnUse=TRUE	ImportFcnTable(ptrGetPixel).ImportFcnUse=TRUE	ImportFcnTable(ptrSetBkMode).ImportFcnUse=TRUE	ImportFcnTable(ptrGetStockObject).ImportFcnUse=TRUE	ImportFcnTable(ptrGetModuleHandle).ImportFcnUse=TRUE	ImportFcnTable(ptrPostQuitMessage).ImportFcnUse=TRUE	RESTORE GUIEquates	OutBuf=""	GOSUB OutDeclare	OutBuf="; GUI Equates"	GOSUB OutDeclare	OutBuf=""	GOSUB OutDeclare	BEGIN LOOP		READ OutBuf		EXITIF OutBuf="ENDTEXT"		GOSUB OutDeclare		INCR AsmLineCtr	END LOOPENDIFGenEquate WinConstructed,0GenEquate WinEnabled,1GenEquate WinVisible,2GenEquate WinChangeBackColor,3GenEquate WinChangeForeColor,4GenEquate WinArray,5GenEquate WinSubClassed,6GenEquate WinLoaded,7GenEquate WinPlaced,8OutBuf="_ErrExitMsg db 'Error exit',0"GOSUB OutInitDataRESTORE RunStringTblRunStringLoop:READ VarNameIF VarName="%" THEN RunStringDoneREAD ArraySizeTempInt=ArraySize/4IF Mod(ArraySize,4)<>0 THEN	TempInt=TempInt+1ENDIFOutBuf="align 4"GOSUB OutInitDataOutBuf=VarName+" dd "+VarName+"+12"GOSUB OutInitDataOutBuf=" dd "+STR(ArraySize)GOSUB OutInitDataOutBuf=" dd 0"GOSUB OutInitDataOutBuf=" rb "+STR(ArraySize)GOSUB OutInitDataGOTO RunStringLoopRunStringDone:OutBuf=""GOSUB OutInitCodeOutBuf="; Init Section"GOSUB OutInitCodeOutBuf="_Init:"GOSUB OutInitCodeOutBuf=""GOSUB OutInitCodeOutBuf=""GOSUB OutFunctionOutBuf="; Function Code Section"GOSUB OutFunctionOutBuf=""GOSUB OutFunctionOutBuf=""GenExportOutBuf="section '.edata' export data readable"GenExportOutBuf=""GenExportOutBuf=""GenResourceOutBuf="section '.rsrc' resource data readable"GenResourceOutBuf=""GenResourceOutBuf="; End of Resource Section"GenResourceOutBuf=""GenResourceOutBuf="section '.reloc' fixups data readable discardable"GenResourceMainLoop:IF ErrNo<>0 THEN	IF ErrNo=ErrMacArg THEN		TempStr="Fatal Error... MACRO argument error in line "+STR(BasicLineCtr)		GOSUB ShowError		RETURN	ENDIF	IF ErrNo=$ff THEN		GOSUB ShowError		RETURN	ENDIF		RESTORE ErrorTbl	FOR Ctr1=1 to ErrNo		READ TempStr	NEXT Ctr1	TempStr=TempStr+" in line "+STR(BasicLineCtr)	GOSUB ShowError	RETURNENDIFIF DimFlag=0 THEN	BEGIN LOOP		IF SymTable(LastSym).DataType<>STRINGVAR OR LAND(SymTable(LastSym).DataMod,ConstBit)<>ConstBit THEN NotString		DECR LastSym	END LOOPENDIFNotString:GOSUB MainLoopInitIF MacExFlag=0 THEN	GOSUB ReadSource	IF TempInt=0 THEN FinishELSE	SrcLine=""	SrcNdx=0	MacExLp: AsciiByte=MacBuf(MacExNdx)	INCR MacExNdx	IF AsciiByte=0 THEN;  end of MACRO		MacExFlag=0		GOTO MainLoop	ENDIF	IF AsciiByte=NewLine THEN ProcLine	IF LAND($80,AsciiByte)=$80 THEN		AsciiByte=LAND($7f,AsciiByte)		IF AsciiByte=0 THEN			SrcLine=SrcLine+STR(SymTable(MacTblPtr).Detail)			GOTO MacExLp		ENDIF		IF AsciiByte>MaxArgNum THEN			ErrNo=ErrMacArg			GOTO MainLoop		ENDIF		MacArgPtr=AsciiByte		SrcLine=SrcLine+MacArgBuf(MacArgPtr)		GOTO MacExLp	ENDIF	SrcLine=SrcLine+CHR(AsciiByte)	GOTO MacExLpENDIFProcLine:SrcNdx=0IF GenFlag(GFNdx)=0 THEN	IF LEFT(SrcLine,1)<>"$" THEN MainLoop	INCR SrcNdx	GOSUB NexToken	IF TokenBuf<>"if" AND TokenBuf<>"else" AND TokenBuf<>"endif" THEN MainLoop	IF TokenBuf="if" THEN IFDx	IF TokenBuf="else" THEN ELSEDx	GOTO ENDIFDxENDIF	IF LEN(SrcLine)=0 THEN MainLoopTempByte=LEFT(SrcLine,1)IF TempByte="'" THEN	GOSUB Remark	GOSUB OutCodeData	GOTO MainLoopENDIFIF TempByte=";" THEN	GOSUB Remark	GOSUB OutCodeData	GOTO MainLoopENDIFIF TempByte="$" THEN	; Process Directive	GOSUB Remark	GOSUB OutCodeData	INCR SrcNdx	GOSUB NexToken	IF TokenBuf="if" THEN IFDx	IF TokenBuf="else" THEN ELSEDx	IF TokenBuf="endif" THEN ENDIFDx	IF TokenBuf="exok" THEN		ExclamationOK=TRUE		GOTO MainLoop	ENDIF	ErrNo=ErrSyntax	GOTO MainLoopENDIF GOSUB NexTokenSrcNdx=0IF NextByte<>":" THEN ProcStmt ;ProcLabelStartFlag=TRUEIF DataFlag=TRUE THEN	DataFlag=FALSEENDIFLNFlag=$ffGOSUB TokenSymErrMainLabelFlag=$ffTDataType=SymTable(SymNdx).DataTypeTDetail=SymTable(SymNdx).DetailTDataSize=SymTable(SymNdx).DataSizeTempStr=SymbolSafSymbolSaf=TempStrIF SymFound=TRUE THEN; Label Found	IF TDataType<>LABELVAR THEN		ErrNo=ErrDupSym		GOTO MainLoop	ENDIF	IF TDetail=LabelUnresolved THEN		SymTable(SymNdx).Detail=LabelResolved	ELSE		ErrNo=ErrDupSym		GOTO MainLoop	ENDIFELSE	GOSUB ClrDatTyp	TDataType=LABELVAR	SymTemp.DataType=LABELVAR	GOSUB ClrSym	SymTemp.DataMod=0	SymTemp.Detail=LabelResolved	GOSUB SymInsert	ErrMainENDIFGOSUB NexToken; Eat the ':'GOSUB NexTokenIF TokenBuf="data" THEN	SymTable(SymNdx).DataMod=DataBit	GOTO DataX;  DATA statement processingENDIFGOSUB UnDoTokenSymbolSaf=SymbolSaf+":"ProcStmt:GOSUB NexTokenIF TokenSaf="STATUS" THEN	EqualMain	GOSUB NexToken	StatFlag=$ffENDIFIF LEN(TokenBuf)>0 THEN	LastStmt=TokenBufENDIFIF TokenLen=0 THEN	GOSUB OutLabel	GOTO MainLoopENDIFGOSUB KeyLookIF KeyNdx=0 THEN	REM maybe a macro	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=TRUE AND SymTable(SymNdx).DataType=MACROVAR THEN		GOSUB Remark		GOSUB OutCodeData		MacTblPtr=SymNdx		MacExNdx=SymTable(SymNdx).DataAddr		SymTable(SymNdx).Detail=SymTable(SymNdx).Detail+1; inc macro occurrance		NeedComma=0		MaxArgNum=0		MacExFlag=$ff		GOSUB OutLabel		IF MID(SrcLine,SrcNdx+1,1)=" " THEN			INCR SrcNdx		ENDIF		MacExLoop:		GOSUB MacToken		IF TokenLen=0 THEN			GOTO MainLoop		ENDIF		IF NeedComma=0 AND TokenSaf="," THEN			INCR MaxArgNum			MacArgBuf(MaxArgNum)=""			GOTO MacExLoop		ENDIF		IF NeedComma=$ff AND TokenSaf<>"," THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		IF NeedComma=$ff AND TokenSaf="," THEN			NeedComma=0			GOTO MacExLoop		ENDIF		INCR MaxArgNum		MacArgBuf(MaxArgNum)=TokenSaf		NeedComma=$ff		GOTO MacExLoop	ENDIF	IF SymFound=TRUE AND SymTable(SymNdx).DataType>99 THEN		KeyNdx=999; Pseudo code for GUI Target		ObjectType=SymTable(SymNdx).DataType		ObjectName=SymTable(SymNdx).SymName	ELSE		KeyNdx=8; Assume LET	ENDIF	GOSUB UnDoTokenENDIFIF KeyNdx<>1 THEN	DataFlag=FALSEENDIFGOSUB RemarkSELECT CASE KeyNdx	CASE 1		GOSUB OutInitData		GOTO DataX	CASE 6		GOSUB OutUninitData		GOTO TypeX	CASE 7		GOTO DimX	CASE 67		GOSUB OutFunction		GOTO FunctionX	CASE 68		GOSUB OutFunction		GOTO ProcedureX	CASE 999		ErrGUI		GOSUB NexToken		ObjectName=TokenSaf		StartFlag=TRUE		GOSUB OutCodeData; put out OmniBasic source as comment		GUITargetSymNdx=SymNdx		GUITargetFlag=$ff		GOSUB ProcessObject		ErrMain		GOTO GUITarget	CASE ELSE		StartFlag=TRUE		GOSUB OutCodeData; put out OmniBasic source as comment		OutBuf=""		GOSUB OutLabel		GOTO [KeyTable(KeyNdx).KeyLabel]END SELECTProcCmd:IF Op1Class<>STRClass THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFOutBuf="mov dword edi,"+Op1NameGOSUB OutCodeDataOutBuf="call __MovArg"GOSUB OutCodeDataRETURNSETDx:SetMask=0GOSUB SETDx1GOTO MainLoopSETDx1:; Changed into a subroutine because is called by; inline code OR CmdLine, so cannot "jump" to MainLoop as before.UMFlag=0GOSUB TokenSymErrRetIF SymFound=FALSE THEN	SymTemp.DataType=COMPVAR	GOSUB ClrSym	GOSUB SymInsert	ErrRetELSE	IF SymTable(SymNdx).DataType<>COMPVAR AND SymTable(SymNdx).DataType<> MACROVAR THEN		ErrNo=ErrTypMis		RETURN	ENDIF	IF LAND(SymTable(SymNdx).DataMod,SetMask)<>0 THEN		RETURN	ENDIFENDIFSymNdxSaf=SymNdxEqualRetGOSUB NexTokenIF TokenBuf="-" THEN	UMFlag=$ff	GOSUB NexTokenENDIFSELECT CASE TokenType	CASE TTypInt		GOSUB ChkInt		ErrRet		GOTO SetOp1	CASE TTypHex		GOSUB ChkHex		ErrRet		GOTO SetOp1	CASE TTypSym		GOSUB ChkSym		ErrRet		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO SetOp1	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTSetOp1:IF UMFlag=$ff THEN	TempStr="-"ELSE	TempStr=""ENDIFTempStr=TempStr+TokenSafIF MID(TempStr,1,2)="--" THEN	TempStr=MID(TempStr,2,LEN(TempStr)-2)ENDIFCVTemp=VAL(TempStr)GOSUB NexTokenIF TokenLen=0 THEN SetFinishIF TokenBuf="<" THEN	GOSUB NexToken	IF TokenBuf<>"<" THEN		ErrNo=ErrIVExp		RETURN	ENDIF	TokenType=TTypMathENDIFIF TokenBuf=">>" THEN	TokenType=TTypMathENDIFIF TokenType<>TTypMath THEN	ErrNo=ErrIVExp	RETURNENDIFCVOp=TokenBufGOSUB NexTokenSELECT CASE TokenType	CASE TTypInt		GOSUB ChkInt		ErrRet		GOTO SetOperator	CASE TTypHex		GOSUB ChkHex		ErrRet		GOTO SetOperator	CASE TTypSym		GOSUB ChkSym		ErrRet		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO SetOperator	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTSetOperator:SymNdx=SymNdxSafSymTable(SymNdx).Detail=CVTempIF CVOp="+" THEN	CVTemp=SymTable(SymNdx).Detail+VAL(TokenSaf)ENDIFSELECT CASE CVOp	CASE "-"		CVTemp=SymTable(SymNdx).Detail-VAL(TokenSaf)	CASE "*"		CVTemp=SymTable(SymNdx).Detail*VAL(TokenSaf)	CASE "/"		CVTemp=SymTable(SymNdx).Detail/VAL(TokenSaf)	CASE "&"		CVTemp=LAND(SymTable(SymNdx).Detail,VAL(TokenSaf))	CASE "|"		CVTemp=LOR(SymTable(SymNdx).Detail,VAL(TokenSaf))END SELECTIF CVOp="<" OR CVOp=">>" THEN	CVTemp=SymTable(SymNdx).Detail	TempInt=VAL(TokenSaf);;if (CVOp[0] == '>') CVTemp=CVTemp>>TempInt;;;else CVTemp=CVTemp<<TempInt;ENDIFSetFinish:SymNdx=SymNdxSafSymTable(SymNdx).Detail=CVTempSymTable(SymNdx).DataMod=SetMaskOutBuf=SymTable(SymNdx).SymName+" equ "+STR(CVTemp)GOSUB OutCodeDataRETURNMACRODx:GOSUB NexTokenIF TokenType<>TTypSym THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=TRUE THEN	ErrNo=ErrDupSym;  symbol already defined	GOTO MainLoopENDIFSymTemp.DataType=MACROVARGOSUB ClrSymSymTemp.DataAddr=MacDefNdx;  address of macro in macro bufferGOSUB SymInsertErrMainMacLp:GOSUB ReadSourceIF TempInt=0 THEN	TempStr="FATAL ERROR.. EOF in MACRO"	ErrNo=$ff	GOTO MainLoopENDIFMacLpExit:GOSUB NexTokenSELECT CASE TokenBuf	CASE "macro"		ErrNo=ErrMacNst;  nested macro		GOTO MainLoop	CASE "endmacro"		MacBuf(MacDefNdx)=0		GOSUB MacDefInc		GOTO MainLoop	CASE "end"		GOSUB NexToken		IF TokenBuf="macro" THEN			MacBuf(MacDefNdx)=0			GOSUB MacDefInc			GOTO MainLoop		ENDIFEND SELECT	SrcNdx=0lbl7027:INCR SrcNdxIF SrcNdx>LEN(SrcLine) THEN	MacBuf(MacDefNdx)=NewLine	GOSUB MacDefInc	ErrMain	GOTO MacLpENDIFIF MID(SrcLine,SrcNdx,1)="~" THEN	INCR SrcNdx	TempByte=MID(SrcLine,SrcNdx,1)	AsciiByte=ASC(TempByte)	IF TempByte>="0" AND TempByte<="9" THEN		AsciiByte=LAND($0f,AsciiByte)		AsciiByte=LOR($80,AsciiByte)		MacBuf(MacDefNdx)=AsciiByte		GOSUB MacDefInc		ErrMain		GOTO lbl7027	ENDIF	AsciiByte=LAND(AsciiByte,$4f); make upper case	TempByte=CHR(AsciiByte)	IF TempByte>="A" AND TempByte<="F" THEN		AsciiByte=LAND($0f,AsciiByte)		AsciiByte=LOR($80,AsciiByte)		AsciiByte=AsciiByte+9		MacBuf(MacDefNdx)=AsciiByte		GOSUB MacDefInc		ErrMain		GOTO lbl7027	ENDIF	ErrNo=ErrIVMac	GOTO MainLoopENDIFTempByte=MID(SrcLine,SrcNdx,1)AsciiByte=ASC(TempByte)MacBuf(MacDefNdx)=AsciiByteGOSUB MacDefIncErrMainGOTO lbl7027ENDMDx:ErrNo=ErrEndmGOTO MainLoopIFDx:CondValid=GenFlag(GFNdx)INCR GFNdxIF GFNdx>20 THEN	TempStr="FATAL Error Conditional stack overflow"	ErrNo=$ff	GOTO MainLoopENDIFUMFlag=0GOSUB TokenSymErrMainIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).DataType<>COMPVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFCondOp1=SymTable(SymNdx).DetailEqualMainGOSUB NexTokenIF TokenBuf="-" THEN	UMFlag=$ff	GOSUB NexTokenENDIFSELECT CASE TokenType	CASE TTypInt		GOSUB ChkInt		ErrMain		GOTO IFDx1	CASE TTypHex		GOSUB ChkHex		ErrMain		GOTO IFDx1	CASE TTypSym		GOSUB TokenSym1		ErrMain		TokenSaf=STR(SymTable(SymNdx).Detail)		GOTO IFDx1	CASE ELSE		ErrNo=ErrIVExp		GOTO MainLoopEND SELECTIFDx1:IF UMFlag=$ff THEN	TempStr="-"ELSE	TempStr=""ENDIFTempStr=TempStr+TokenSafIF MID(TempStr,1,2)="--" THEN	TempStr=MID(TempStr,2,LEN(TempStr)-2)ENDIFCondOp2=VAL(TempStr)IF CondOp1=CondOp2 AND CondValid=$ff THEN	GenFlag(GFNdx)=$ffELSE	GenFlag(GFNdx)=0ENDIFGOTO MainLoopELSEDx:IF GFNdx<2 THEN	TempStr="FATAL ERROR Conditional stack error (#ELSE)"	ErrNo=$ff	GOTO MainLoopENDIFIF GenFlag(GFNdx-1)=$ff THEN	GenFlag(GFNdx)=LNOT(GenFlag(GFNdx))ENDIFGOTO MainLoopENDIFDx:DECR GFNdxIF GFNdx=0 THEN	TempStr="FATAL ERROR Conditional stack error (#ENDIF)"	ErrNo=$ff	GOTO MainLoopENDIFCondValid=GenFlag(GFNdx)GOTO MainLoopFIXDx:SetMask=$80GOSUB SETDx1GOTO MainLoopDataX:UseData=TRUEIF DataFlag=FALSE THEN	DataFlag=TRUE	IF LabelFlag=0 OR SymTable(SymNdx).DataMod<>DataBit THEN		TempStr="FATAL ERROR... DATA block with no label in line "';BasicLineCtr		ErrNo=$ff		GOTO MainLoop	ENDIF	LastStmt="data"; needed for first 'DATA' in block	GOSUB Remark	GOSUB OutInitData	OutBuf=SymbolSaf+":"	GOSUB OutInitDataENDIFNeedComma=0DATALoop:GOSUB NexTokenIF TokenLen=0 THEN	GOTO MainLoopENDIFIF NeedComma=0 AND TokenBuf="," THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF NeedComma=$ff AND TokenBuf="," THEN	NeedComma=0	GOTO DATALoopENDIFIF TokenType=TTypQuote THEN	TempStr=MID(TokenSaf,2,LEN(TokenSaf)-2)	GOTO NextDataENDIFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrMain		TempStr=TokenSaf	CASE TTypInt		GOSUB ChkInt		ErrMain		TempStr=TokenSaf	CASE TTypFloat		GOSUB ChkFlt		ErrMain		TempStr=TokenSaf	CASE TTypSym		IF TokenBuf="true" OR TokenBuf="false" THEN			IF TokenBuf="true" THEN				TempStr="1"			ELSE				TempStr="0"			ENDIF			GOTO NextData		ENDIF		GOSUB TokenSym1		ErrMain		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			GOTO MainLoop		ENDIF		Konstant=SymTable(SymNdx).Detail		TempStr=STR(Konstant)	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECTNextData:IF TempStr="" THEN	TempStr=CHR($80)ENDIFOutBuf="db "+CHR(OBQUOTE)+TempStr+CHR(OBQUOTE)+",0"GOSUB OutInitDataNeedComma=$ffGOTO DATALoopRestoreX:GOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR OR SymTable(SymNdx).DataMod<>DataBit THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFOutBuf="mov dword [_DataPtr],"+SymbolSafGOSUB OutCodeDataGOTO MainLoopPokeX:GOSUB GetIntOp get addrErrMainOutBuf="mov ecx,eax"GOSUB OutCodeDataCommaMainGOSUB GetIntOp; get dataErrMainOutBuf="mov byte [ecx],al"GOSUB OutCodeDataGOTO MainLoopReturnX:IF FcnFlag<>0 THEN	GOSUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	GOSUB UnDoToken	GOSUB Expr	ErrMain	SELECT CASE TFcnDataType		CASE BOOLVAR			IF TDataType<>BOOLVAR THEN				ErrNo=ErrTypMis				GOTO MainLoop			ENDIF			OutBuf="mov byte al,["+TSymName+"]"		CASE LONGVAR			IF TDataType<>LONGVAR THEN				ErrNo=ErrTypMis				GOTO MainLoop			ENDIF			IF TSymName<>"~" THEN				OutBuf="mov eax,["+TSymName+"]"				GOSUB OutFunction			ENDIF			OutBuf="mov [_LongRet],eax"					CASE STRINGVAR			IF TDataType<>STRINGVAR THEN				ErrNo=ErrTypMis				GOTO MainLoop			ENDIF			OutBuf="mov edi,["+TSymName+"]"			GOSUB OutFunction			OutBuf="mov [_StringRet],edi"			GOSUB OutFunction			OutBuf="mov edi,["+TSymName+"+4]"			GOSUB OutFunction			OutBuf="mov [_StringRet+4],edi"			GOSUB OutFunction			OutBuf="mov edi,["+TSymName+"+8]"			GOSUB OutFunction			OutBuf="mov [_StringRet+8],edi"		CASE FLOATVAR			IF TDataType<>FLOATVAR THEN				ErrNo=ErrTypMis				GOTO MainLoop			ENDIF	END SELECT	GOSUB OutFunctionENDIFOutBuf="ret"GOSUB OutCodeDataGOTO MainLoopSeekX:DiskIO=$ffGOSUB GetPthNumErrMainGOSUB ExprErrMainIF OpClass<>INTClass AND OpClass<>FLTClass THEN       ErrNo=ErrTypMis       ErrMainENDIFGOSUB LoadNumericValueImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],eax,0,FILE_BEGIN"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrGOTO MainLoopTypeX:IF ProcFcnFlag<>0 THEN	ErrNo=ErrTypeFcn	GOTO MainLoopENDIFGOSUB ClrDatTypGOSUB TokenSymErrMainIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopENDIFTypeFlag=$ffTypePtr=SymNdxTypeVars=0TypeBytes=0SymTemp.DataType=TYPEGOSUB ClrSymGOSUB SymInsertErrMainTypeLp:GOSUB ReadSourceIF TempInt=0 THEN	ErrNo=$ff	GOTO MainLoop	RETURNENDIFTypeLp2:GOSUB NexTokenIF TokenBuf="end" THEN	GOSUB NexToken	IF TokenBuf="type" THEN TypeEnd	ErrNo=ErrSyntaxENDIFIF TokenBuf="endtype" THEN TypeEndGOSUB UnDoToken		IF LEFT(SrcLine,1)="*" THEN TypeLpGOSUB DimVarIF DimOK=0 THEN MainLoopINCR TypeVarsSymTemp.DataAddr=TypeBytesGOSUB SymInsertErrMain TypeBytes=TypeBytes+SymTemp.DataSizeIF MultiFlag=$ff THEN	;GOSUB AddMulti	ErrMainENDIFGOTO TypeLpTypeEnd:SymTable(TypePtr).DataSize=TypeBytesSymTable(TypePtr).Detail=TypeVarsGOTO MainLoopDimX:GOSUB DimVarIF DimOK=0 THEN MainLoopGOSUB SymInsertErrMainIF TDataType<>TEXT THEN	GOSUB DecVarENDIFIF MultiFlag=$ff THEN	;GOSUB AddMultiENDIFGOTO MainLoopLetX:Target=$ffGOSUB GetExpIF ErrNo<>0 THEN	IF ErrNo<>ErrUDSym THEN MainLoop	ErrNo=0	DataLabel=TRUE	GOSUB NexToken	SELECT CASE TokenBuf		CASE "db"			GOTO DBX		CASE "dw"			GOTO DWX		CASE "dd"			GOTO DDX		CASE "rb"			GOTO RBX		CASE "rw"			GOTO RWX		CASE "rd"			GOTO RDX		CASE "equ"			GOTO EquX		CASE "ds"			GOTO DSX		CASE ELSE			DataLabel=FALSE			ErrNo=ErrUDSym			SrcNdx=0; Fixes error caret			GOTO MainLoop	END SELECTENDIFIF TextFlag<>0 THEN	IF LAND(SymTemp.DataMod,TextDefinedBit)<>0 THEN		ErrNo=ErrTextDefined		GOTO MainLoop	ENDIF	SymTable(SymNdx).DataMod=TextDefinedBit	EqualMain	TempInt=SrcNdx+1	BEGIN LOOP		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		IF TokenSaf="," THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		GOSUB NexToken		IF TokenLen=0 THEN			GOTO TextDone		ELSE			IF TokenSaf<>"," THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF		ENDIF	END LOOP	TextDone:	OutBuf=SymTemp.SymName+" db "+TAIL(SrcLine,TempInt)	GOSUB OutInitData	GOTO MainLoopENDIFGOSUB ProcExpErrMainGOSUB ClassOpErrMainIF DMConst<>0 THEN	GOSUB NexToken	SrcNdx=2	IF TokenBuf="equ" THEN		ErrNo=ErrDupSym			ELSE		ErrNo=ErrIVTarg	ENDIF	GOTO MainLoopENDIFOp1Name=TSymNameOp1Mod=TDataModOp1Detail=TDetailOp1DataSize=TDataSizeOp1Type=TDataTypeOp1Class=OpClassSELECT CASE Op1Type	CASE 1		OpSizeStr=" byte "	CASE 2		OpSizeStr=" byte "	CASE 3		OpSizeStr=" word "	CASE 4		OpSizeStr=" dword "	CASE ELSE		OpSizeStr=" "END SELECTIF Op1Name="NextArg" THEN	ErrNo=ErrIVTarg	GOTO MainLoopENDIFIF LAND(TempBit,Op1Mod)<>0 AND LAND(VectorBit,Op1Mod)=0 THEN	ErrNo=ErrIVTarg	GOTO MainLoopENDIF GOSUB NexTokenIF TokenBuf<>"=" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF Op1Mod=VectorBit AND Op1Type=STRINGVAR AND NextByte=CHR($22) THEN	GOSUB NexToken	IF RIGHT(TokenSaf,1)<>CHR(OBQUOTE) THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	IF LEN(TokenBuf)=2 THEN		OutBuf="mov ["+Op1Name+"+12],0"		GOSUB OutCode		GOTO MainLoop	ELSE		IF NextByte<>"+" AND Op1Detail>LEN(TokenSaf) THEN			ediUsed=TRUE			OutBuf="mov edi,["+Op1Name+"]"			GOSUB OutCode			GOSUB MakeStrConst			OutBuf="mov esi,_StrConst"+STR(PoolCtr)			GOSUB OutCode			UseSetStrConst=TRUE			OutBuf="call __SetStrConst"			GOSUB OutCode			GOTO MainLoop		ENDIF	ENDIF	GOSUB UnDoTokenENDIFIF Op1Type=LABELPTR THEN	GOSUB NexToken	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		;print "make label here",SrcLine	ELSE 		IF  SymTable(SymNdx).DataType<>LABELVAR AND SymTable(SymNdx).DataType<>LABELPTR THEN			ErrNo=ErrTypMis			GOTO MainLoop		ENDIF		ENDIF	IF LAND(VectorBit,Op1Mod)=0 THEN		OutBuf="mov dword ["+Op1Name+"],"+SymTemp.SymName	ELSE		OutBuf="mov dword esi,["+Op1Name+"]"		GOSUB OutCode		OutBuf="mov dword [esi], dword "+SymTemp.SymName	ENDIF	GOSUB OutCode	GOTO MainLoopENDIFGOSUB GetExpErrMainTarget=0GOSUB ProcOp2GOSUB NexTokenIF TokenLen<>0 THEN; check for junk on end	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF Op2Name="NextArg" THEN	GOSUB ProcCmd	GOTO MainLoopENDIFIF Op1Class<>Op2Class THEN;  int=float for example	EXITIF Op1Class=INTClass AND Op2Class=FLTClass	EXITIF Op1Class=FLTClass AND Op2Class=INTClass	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF Op1Class=INTClass OR Op1Class=FLTClass OR Op1Class=BOOLClass THEN	IF TSymName<>"~" THEN		TDataType=Op1Type		GOSUB GetDtaTyp		IF Op1Mod=0 AND Op2Mod=ConstBit THEN			Op2Name=STR(Op2Detail)			IF Op1Type=BOOLVAR OR Op1Type=BYTEVAR THEN				IF Op2Detail>255 THEN					ErrNo=ErrOpRange					GOTO MainLoop				ENDIF			ENDIF			IF Op1Type=WORDVAR THEN				IF Op2Detail>65535 THEN					ErrNo=ErrOpRange					GOTO MainLoop				ENDIF			ENDIF			IF Op1Type=LONGVAR THEN				IF Op2Detail>$7fffffff THEN					ErrNo=ErrOpRange					GOTO MainLoop				ENDIF			ENDIF			OutBuf="mov"+OpSizeStr+"["+Op1Name+"],"+Op2Name			GOSUB OutCodeData			GOTO MainLoop		ENDIF		IF Op1Mod=0 AND Op2Mod=0 THEN			IF Op1Type>Op2Type AND Op2Type<>BOOLVAR THEN				OutBuf="xor eax,eax"				GOSUB OutCodeData			ENDIF 			IF Op2Type=BOOLVAR OR Op2Type=BYTEVAR THEN				OutBuf="mov al, byte ["+Op2Name+"]"							GOSUB OutCodeData				GOSUB StoreInt				GOTO MainLoop			ENDIF			IF Op2Type=WORDVAR THEN				OutBuf="mov ax, word ["+Op2Name+"]"							GOSUB OutCodeData				GOSUB StoreInt				GOTO MainLoop			ENDIF			IF Op2Type=LONGVAR THEN				OutBuf="mov eax, dword ["+Op2Name+"]"							GOSUB OutCodeData				GOSUB StoreInt				GOTO MainLoop			ENDIF		ENDIF		D0Loaded=0		GOSUB LoadReg		ErrMain	ENDIF	GOSUB StoreD0	GOTO MainLoopENDIFIF Op1Class=STRClass THEN	ediUsed=TRUE	OutBuf="mov edi,"+Op1Name	GOSUB OutCodeData	OutBuf="mov esi,"+Op2Name	GOSUB OutCodeData	UseMovStr=TRUE	OutBuf="call __MovStr"	GOSUB OutCodeData	GOTO MainLoopENDIFIF Op1Class=CPXClass OR Op1Class=ARRClass THEN	ediUsed=TRUE	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov edi,"+Op1Name	ELSE		OutBuf="mov edi,["+Op1Name+"]"	ENDIF	GOSUB OutCodeData	IF LAND(Op2Mod,VectorBit)=0 THEN		OutBuf="mov esi,"+Op2Name	ELSE		OutBuf="mov esi,["+Op2Name+"]; Get src addr"	ENDIF	GOSUB OutCodeData	IF Op1Class=ARRClass THEN		TempInt=Op1DataSize	ELSE		TempInt=SymTable(Op1Detail).DataSize	ENDIF	OutBuf="mov ecx,"+STR(TempInt)		GOSUB OutCodeData	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	GOSUB OutCodeData	OutBuf="mov al,byte [esi]"	GOSUB OutCodeData	OutBuf="mov byte [edi],al"	GOSUB OutCodeData	OutBuf="inc esi"	GOSUB OutCodeData	OutBuf="inc edi"	GOSUB OutCodeData	OutBuf="dec ecx"	GOSUB OutCodeData	OutBuf="jne "+"_Lbl"+STR(LabelNum)	GOSUB OutCodeData	GOTO MainLoopENDIFSELECT CASE Op1Class	CASE BOOLClass		D0Loaded=0		GOSUB LoadReg		ErrMain		GOSUB StoreD0		GOTO MainLoop	CASE OBJClass		ErrNo=ErrIVType		GOTO MainLoop	CASE FRMClass		ErrNo=ErrIVType		GOTO MainLoop	CASE ELSE 		TempStr="Internal Error"		GOSUB ShowError		RETURNEND SELECTProcOp2:IF GUIObjFlag<>0 THEN;//	GOSUB UnDoToken;//	GUITargetFlag=0;//	GOSUB ValidateObject;//	ErrRet;//	GOSUB GUISource	Op2Name=GUITempName	Op2Type=GUIDataType	SELECT CASE Op2Type		CASE BOOLVAR			Op2Class=BOOLClass		CASE LONGVAR			Op2Class=INTClass		CASE STRINGVAR			Op2Class=STRClass	END SELECT	OpClass=Op2Class	TSymName=Op2Name	TDataType=Op2Type	Op2Mod=0	TDataMod=0	Op2Detail=0	TDetail=0	SymTemp.SymName="~"ELSE	GOSUB ProcExp	ErrRet	GOSUB ClassOp	Op2Name=TSymName	Op2Class=OpClass	Op2Type=TDataType	Op2Mod=TDataMod	Op2Detail=TDetailENDIFRETURNStoreInt:IF Op1Type=BOOLVAR OR Op1Type=BYTEVAR THEN	OutBuf="mov ["+Op1Name+"],al"ENDIFIF Op1Type=WORDVAR THEN	OutBuf="mov ["+Op1Name+"],ax"ENDIFIF Op1Type=LONGVAR THEN	OutBuf="mov ["+Op1Name+"],eax"ENDIFGOSUB OutCodeDataRETURNDBX:IF DataLabel=TRUE THEN	GOSUB ProcDataLabel	ErrMain	SymTemp.DataType=BYTEVAR	SymTemp.DataSize=1	SymTemp.DataAddr=1	GOSUB SymInsert	GOSUB NexToken	OutBuf=SymTemp.SymName+" db "ELSE	OutBuf=" db "ENDIFGOSUB DefineDataErrMainGOTO DefineDataCommonDWX:IF DataLabel=TRUE THEN	GOSUB ProcDataLabel	ErrMain	SymTemp.DataType=WORDVAR	SymTemp.DataSize=2	SymTemp.DataAddr=2	GOSUB SymInsert	GOSUB NexToken	OutBuf=SymTemp.SymName+" dw "ELSE	OutBuf=" dw "ENDIFGOSUB DefineDataErrMainGOTO DefineDataCommonDDX:IF DataLabel=TRUE THEN	GOSUB ProcDataLabel	ErrMain	SymTemp.DataType=LONGVAR	SymTemp.DataSize=4	SymTemp.DataAddr=4	GOSUB SymInsert	GOSUB NexToken	OutBuf=SymTemp.SymName+" dd "ELSE	OutBuf=" dd "ENDIFGOSUB DefineDataErrMainGOTO DefineDataCommonDSX:GOSUB ProcDataLabelErrMainSymTemp.DataType=STRINGVARSymTemp.DataMod=ConstBitGOSUB SymInsertGOSUB NexTokenGOSUB NexTokenOutBuf=SymTemp.SymName+" db "+TokenSaf+",0"GOSUB OutInitDataTempStr=MID(TokenSaf,2,LEN(TokenSaf)-2)TempInt=LEN(TempStr)+1SymTable(DataSymNdx).Detail=TempIntSymTable(DataSymNdx).DataSize=TempIntSymTable(DataSymNdx).DataAddr=TempIntGOTO MainLoopDefineDataCommon:IF RIGHT$(OutBuf,1)="," OR RIGHT$(OutBuf,1)=" " THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB OutInitDataIF DMArray<>0 AND DataLabel=TRUE THEN	SymTable(DataSymNdx).DataMod=LOR(ArrayBit,TDataMod)	TempInt=ArraySize*SymTemp.DataSize	SymTable(DataSymNdx).DataSize=TempIntENDIFGOTO MainLoopRBX:IF DataLabel=TRUE THEN	GOSUB ProcDataLabel	ErrMain	SymTemp.DataType=BYTEVAR	SymTemp.DataSize=1	SymTemp.DataAddr=1	GOSUB SymInsert	GOSUB NexToken	OutBuf=SymTemp.SymName+" rb "ELSE	OutBuf=" rb "ENDIFGOTO ReserveDataCommonRWX:IF DataLabel=TRUE THEN	GOSUB ProcDataLabel	ErrMain	SymTemp.DataType=WORDVAR	SymTemp.DataSize=2	SymTemp.DataAddr=2	GOSUB SymInsert	GOSUB NexToken	OutBuf=SymTemp.SymName+" rw "ELSE	OutBuf=" rw "ENDIFGOTO ReserveDataCommonRDX:IF DataLabel=TRUE THEN	GOSUB ProcDataLabel	ErrMain	SymTemp.DataType=LONGVAR	SymTemp.DataSize=4	SymTemp.DataAddr=4	GOSUB SymInsert	GOSUB NexToken	OutBuf=SymTemp.SymName+" rd "ELSE	OutBuf=" rd "ENDIFReserveDataCommon:DMArray=0ArraySize=0DimFlag=0GOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrMain		TempStr=TokenSaf		TempInt=VAL(TempStr)	CASE TTypInt		GOSUB ChkInt		ErrMain		TempStr=TokenSaf		TempInt=VAL(TempStr)	CASE TTypSym		GOSUB TokenSym1		ErrMain		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		TempInt=SymTable(SymNdx).Detail		TempStr=STR(TempInt)	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECTOutBuf=OutBuf+TempStrGOSUB OutUninitDataIF TempInt>1 AND DataLabel=TRUE THEN	SymTable(DataSymNdx).DataMod=LOR(ArrayBit,TDataMod)	TempInt=TempInt*SymTemp.DataSize	SymTable(DataSymNdx).DataSize=TempIntENDIFIF TempInt<1 THEN	ErrNo=ErrSyntaxENDIFGOTO MainLoopProcDataLabel:SrcNdx=0GOSUB PrepVarErrRetIF SymFound=TRUE THEN	ErrNo=ErrDupSym	RETURNENDIFRETURNEquX:GOSUB ProcDataLabelErrMainSymTemp.DataType=COMPVARSymTemp.DataMod=SetMaskGOSUB SymInsertGOSUB NexTokenEquX1:OutBuf=SymTemp.SymName+" equ "DMArray=0ArraySize=0DimFlag=0GOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrMain		TempStr=TokenSaf		TempInt=VAL(TempStr)	CASE TTypInt		GOSUB ChkInt		ErrMain		TempStr=TokenSaf		TempInt=VAL(TempStr)	CASE TTypSym		GOSUB TokenSym1		ErrMain		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		TempInt=SymTable(SymNdx).Detail		TempStr=STR(TempInt)	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECTSymTable(DataSymNdx).Detail=TempIntOutBuf=OutBuf+TempStrGOSUB OutUninitDataGOTO MainLoopDefineData:DMArray=0ArraySize=0DimFlag=0NeedComma=0DefineDataLoop:GOSUB NexTokenIF TokenLen=0 THEN	RETURNENDIFIF NeedComma=0 AND TokenBuf="," THEN	ErrNo=ErrSyntax	RETURNENDIFIF NeedComma=$ff AND TokenBuf="," THEN	NeedComma=0	TempStr=", "	DMArray=$ff	GOTO DefineNextDataENDIFIF TokenType=TTypQuote THEN	IF SymTemp.DataAddr<>1 THEN		ErrNo=ErrSyntax		RETURN	ENDIF	ArraySize=ArraySize+LEN(TokenSaf)-3	TempStr="'"+MID(TokenSaf,2,LEN(TokenSaf)-2)+"'"	GOTO DefineNextDataENDIFSELECT CASE TokenType	CASE TTypHex		GOSUB ChkHex		ErrRet		TempStr=TokenSaf	CASE TTypInt		GOSUB ChkInt		ErrRet		TempStr=TokenSaf	CASE TTypFloat		GOSUB ChkFlt		ErrRet		TempStr=TokenSaf	CASE TTypSym		GOSUB TokenSym1		ErrRet		TDataType=SymTable(SymNdx).DataType		IF TDataType<>COMPVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		Konstant=SymTable(SymNdx).Detail		TempStr=STR(Konstant)	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTDefineNextData:IF NeedComma=0 THEN	INCR ArraySizeENDIFNeedComma=$ffOutBuf=OutBuf+TempStrGOTO DefineDataLoopRETURNForX:GOSUB TokenSymErrMainIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFForDataType=SymTable(SymNdx).DataTypeGOSUB IncConStkErrMainConStk(ConStkPtr).LoopName=SymTemp.SymNameGOSUB GetSymTempGOSUB ClassOp1IF OpClass<>INTClass OR DMVector<>0 OR DMArray<>0 THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFGOSUB GetLopVecErrMainConStk(ConStkPtr).LoopVec=LopVarNdxConStk(ConStkPtr).ConType=5ConStk(ConStkPtr).ConLine=BasicLineCtrEqualMainGOSUB ExprErrMainIF TSymName="~" THEN	TSymName="eax"ENDIF; set initial value into loop varIF DMConst<>0 THEN	GOSUB ChkForIMM	ErrMain	OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],"+TSymNameELSE	IF DMVector<>0 THEN		ediUsed=TRUE		OutBuf="mov edi,["+TSymName+"]"		GOSUB OutCodeData		OutBuf="mov eax,[edi]"		GOSUB OutCodeData	ELSE		OutBuf="mov eax,["+TSymName+"]"		GOSUB OutCodeData	ENDIF	OutBuf="mov ["+ConStk(ConStkPtr).LoopName+"],eax"ENDIFGOSUB OutCodeDataGOSUB NexTokenIF TokenBuf<>"to" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB ExprErrMainIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF TSymName<>"~" AND DMConst<>0 THEN	GOSUB ChkForIMM	ErrMain	ConStk(ConStkPtr).ImmTo=$ff	ConStk(ConStkPtr).ImmToVal=TSymNameELSE	ConStk(ConStkPtr).ImmTo=0ENDIFIF ConStk(ConStkPtr).ImmTo=0 THEN	IF DMVector<>0 THEN		ediUsed=TRUE		OutBuf="mov edi,["+TSymName+"]"		GOSUB OutCodeData		OutBuf="mov eax,[edi]"		GOSUB OutCodeData	ELSE		IF TSymName<>"~" THEN			OutBuf="mov eax,["+TempStr+"]"			GOSUB OutCodeData		ENDIF	ENDIF	OutBuf="mov [_LopVec"+STR(LopVarNdx)+"],eax"	GOSUB OutCodeDataENDIFGOSUB NexTokenIF TokenLen=0 THEN	ConStk(ConStkPtr).NoStep=$ffELSE	IF TokenBuf<>"step" THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	ConStk(ConStkPtr).NoStep=0	GOSUB Expr	IF OpClass<>INTClass THEN		ErrNo=ErrTypMis		GOTO MainLoop	ENDIF	ErrMain	ConStk(ConStkPtr).NegImmStep=0	IF TSymName<>"~" AND DMConst<>0 THEN		GOSUB ChkForIMM		ErrMain		ConStk(ConStkPtr).ImmStep=$ff		ConStk(ConStkPtr).ImmStepVal=TSymName		IF LEN(TSymName)=10 THEN;???			IF Mid(TSymName,3,1)>"7" THEN;???				ConStk(ConStkPtr).NegImmStep=$ff			ENDIF		ENDIF	ELSE		ConStk(ConStkPtr).ImmStep=0		IF TSymName="~" THEN			TSymName="eax"		ENDIF		IF DMVector<>0 THEN			ediUsed=TRUE			OutBuf="mov edi,["+TSymName+"]"			GOSUB OutCodeData			OutBuf="mov eax,[edi]"			GOSUB OutCodeData		ELSE			OutBuf="mov eax,["+TSymName+"]"			GOSUB OutCodeData		ENDIF		OutBuf="mov [_LopVec"+Str(LopVarNdx)+"+4],eax"		GOSUB OutCodeData	ENDIFENDIFINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataConStk(ConStkPtr).LoopLabel=LabelNumINCR LabelNumConStk(ConStkPtr).ContLabel=LabelNumINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNum; compare loopvar to "to" valueIF ConStk(ConStkPtr).ImmStep=$ff AND ConStk(ConStkPtr).NegImmStep=0 OR ConStk(ConStkPtr).NoStep=$ff THEN	SymTemp.SymName=ConStk(ConStkPtr).LoopName	IF ForDataType<LONGVAR THEN		OutBuf="xor eax,eax"		GOSUB OutCodeData	ENDIF		IF ConStk(ConStkPtr).ImmTo=$ff THEN		OutBuf="cmp ["+ConStk(ConStkPtr).LoopName+"],"+ConStk(ConStkPtr).ImmToVal		GOSUB OutCodeData	ELSE		OutBuf="mov eax,["+ConStk(ConStkPtr).LoopName+"]"		GOSUB OutCodeData		OutBuf="cmp eax,[_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"]"		GOSUB OutCodeData	ENDIF	If ForDataType=LONGVAR THEN		OutBuf="jg "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	ELSE		OutBuf="ja "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	ENDIF	GOSUB OutCodeDataENDIFIF ConStk(ConStkPtr).ImmStep=$ff AND ConStk(ConStkPtr).NegImmStep=$ff THEN	IF ConStk(ConStkPtr).ImmTo=$ff THEN		OutBuf=";if ("+ConStk(ConStkPtr).LoopName+"<"+ConStk(ConStkPtr).ImmToVal+") goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	ELSE		OutBuf=";if ("+ConStk(ConStkPtr).LoopName+"<_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Limit) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	ENDIFENDIFIF ConStk(ConStkPtr).ImmStep=0 AND ConStk(ConStkPtr).NoStep=0 THEN	IF ConStk(ConStkPtr).ImmTo=0 THEN		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step>=0) && ("+ConStk(ConStkPtr).LoopName+">_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Limit)) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step<0) && ("+ConStk(ConStkPtr).LoopName+"<_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Limit)) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	ELSE		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step>=0) && ("+ConStk(ConStkPtr).LoopName+">"+ConStk(ConStkPtr).ImmToVal+")) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData		OutBuf=";if ((_LopVec"+STR(LopVarNdx)+"._Step<0) && ("+ConStk(ConStkPtr).LoopName+"<"+ConStk(ConStkPtr).ImmToVal+")) goto _Lbl"+STR(ConStk(ConStkPtr).TermLabel)+";"		GOSUB OutCodeData	ENDIFENDIFGOTO MainLoopIfX:GOSUB CmpOps ErrMainINCR LabelNumIF TokenBuf<>"then" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB NexTokenIF TokenLen=0 THEN StructIFGOSUB UnDoTokenGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF SimpleCmp=0 THEN	OutBuf="jne "+SymTemp.SymNameELSE	OutBuf=SimpleOp+SymTemp.SymNameENDIFGOSUB OutCodeDataGOTO MainLoopStructIF:GOSUB IncConStkErrMainConStk(ConStkPtr).TermLabel=LabelNumConStk(ConStkPtr).ConType=0ConStk(ConStkPtr).ConLine=BasicLineCtrIF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(LabelNum)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)ENDIFGOSUB OutCodeData GOTO MainLoopGotoX:ToSub="jmp "GotoX1:LNFlag=$ffGOSUB NexTokenIF TokenBuf="[" THEN	GOSUB RightBracket	ErrMain	GOSUB Expr	IF TDataType<>LABELPTR THEN		ErrNo=ErrTypMis		GOTO MainLoop	ENDIF	IF DMVector<>0 THEN		OutBuf="mov esi,["+TSymName+"]"		GOSUB OutCode		OutBuf=ToSub+"dword [esi]"			ELSE		OutBuf=ToSub+"["+TSymName+"]"	ENDIF	GOSUB OutCode	GOTO MainLoopENDIFGOSUB UnDoTokenGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFOutBuf=ToSub+SymbolSafGOSUB OutCodeDataGOTO MainLoopGosubX:ToSub="call "GOTO GotoX1OnX:LNFlag=$ffNeedComma=$00JmpArgs=0GOSUB NexTokenIF TokenBuf="error" THEN ON_ERRORGOSUB UnDoTokenINCR LabelNumINCR TableNumOutBuf="align 4"GOSUB OutInitDataOutBuf="_Table"+STR(TableNum)+":"GOSUB OutInitDataGOSUB GetIntOp; get test integerErrMainGOSUB NexTokenIF TokenBuf="goto" OR TokenBuf="gosub" THEN	IF TokenBuf="goto" THEN		ToSubFlag=0	ELSE		ToSubFlag=$ff	ENDIFELSE	ErrNo=ErrSyntax	GOTO MainLoopENDIFChkArgs:GOSUB NexTokenIF TokenLen=0 THEN MakSwitchIF TokenBuf="," AND NeedComma=$ff THEN	NeedComma=0	GOTO ChkArgsENDIFIF TokenBuf="," AND NeedComma=0 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF TokenBuf<>"," AND NeedComma=$ff THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB UnDoTokenGOSUB ChkLabelErrMainTempInt=SymTable(SymNdx).DetailTDataType=SymTable(SymNdx).DataTypeIF TDataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFOutBuf="dd "+SymTable(SymNdx).SymNameGOSUB OutInitDataINCR JmpArgsNeedComma=$ffGOTO ChkArgsMakSwitch:IF JmpArgs<1 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFCtr1=0OutBuf="cmp eax,1"GOSUB OutCodeDataOutBuf="jl "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="cmp eax,"+STR(JmpArgs)GOSUB OutCodeDataOutBuf="jg "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="dec eax"GOSUB OutCodeDataOutBuf="shl eax,2"GOSUB OutCodeDataOutBuf="add eax,_Table"+STR(TableNum)GOSUB OutCodeDataOutBuf="mov eax,[eax]"GOSUB OutCodeDataIF ToSubFlag=0 THEN	OutBuf="jmp dword eax"ELSE	OutBuf="call dword eax"ENDIFGOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOTO MainLoopON_ERROR:GOSUB NexTokenIF TokenLen=0 THEN; Turn off ON ERROR	OutBuf="mov [_ErrVec],_ErrExit"	GOSUB OutCode	GOTO MainLoopENDIFIF TokenBuf<>"goto" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB ChkLabelErrMainIF SymTable(SymNdx).DataType<>LABELVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFOutBuf="mov [_ErrVec],"+SymTemp.SymNameGOSUB OutCodeGOTO MainLoopPrintX:UseStrLen=TRUEGOSUB DevChkPrintFlag=$ffIF DevFlag=$ff THEN	PrintPathFlag=$ff	GOSUB GetPthNum1	ErrMain	PrintPathFlag=0ENDIFGOSUB NexTokenIF TokenBuf="using" THEN PrtUsingGOSUB UnDoTokenPrintLp:GOSUB NexTokenIF TokenLen=0 THEN PrintExGOSUB UnDoTokenGOSUB ExprErrMainIF TDataType=VOIDX THEN PrtArgSepIF TabFlag=$ff THEN	TabFlag=0	GOTO PrtArgSepENDIFIF TDataType<>STRINGVAR OR DMAddr<>0 THEN	GOSUB MakString	ErrMainENDIFGOSUB ClassOpOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataediUsed=TRUEOutBuf="mov edi,_PrintBuf"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataOutBuf="mov esi,_PrintBuf"GOSUB OutCodeDataOutBuf="call __StrLen"GOSUB OutCodeDataOutBuf="mov edx,eax"GOSUB OutCodeDataOutBuf="add edx,[POS]"GOSUB OutCodeDataOutBuf="mov [POS],edx"GOSUB OutCodeDataImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUEOutBuf="invoke WriteConsole,[_OutHandle],[_PrintBuf],eax,XferCount,NULL"GOSUB OutCodeDataGOSUB CallErrZPrtArgSep:GOSUB NexTokenIF FileIO<>0 THEN	GOSUB OutCRLF	IF TokenBuf="," OR TokenBuf=";" THEN		IF NextByte<>"" THEN PrintLp	ENDIF	GOTO PrintExENDIFIF TokenBuf="," THEN	OutBuf="xor eax,eax"	GOSUB OutCodeData	OutBuf="";call __PrintTab	GOSUB OutCodeData	GOSUB CallErr	IF NextByte="" THEN PrintEx	GOTO PrintLpENDIFIF TokenBuf=";" THEN	IF NextByte="" THEN PrintEx	GOTO PrintLpENDIFPrintEx:IF TokenBuf<>"," AND TokenBuf<>";" THEN	ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE	OutBuf="invoke WriteConsole,[_OutHandle],[_CRLF],2,XferCount,NULL"	GOSUB OutCodeData	OutBuf="mov [POS],0"	GOSUB OutCodeDataENDIFGOTO MainLoopPrtUsing:GOSUB UnDoTokenGOSUB ExprGOTO MainLoopInputX:GOSUB DevChkIF DevFlag=$ff THEN	GOSUB GetPthNum1	ErrMainENDIFIF FileIO=0 THEN	GOSUB NexToken	GOSUB UnDoToken	IF TokenType=TTypQuote THEN		GOSUB Expr		ErrMain		ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE		OutBuf="invoke WriteConsole,[_OutHandle],["+TSymName+"],["+TSymName+"+4],XferCount,NULL"		GOSUB OutCodeData		CommaMain	ELSE		ImportFcnTable(ptrWriteConsole).ImportFcnUse=TRUE		OutBuf="invoke WriteConsole,[_OutHandle],[_Prompt],1,XferCount,NULL"		GOSUB OutCodeData	ENDIF	GOSUB CallErrZENDIFTarget=$ffBEGIN LOOP	GOSUB Expr	ErrMain	IF DMVector=0 THEN		GOSUB Vectorize		ErrMain		GOSUB ClassOp	ENDIF	IF DMVector<>0 AND DMTemp=0 THEN		GOSUB SetTmpVec		ErrMain	ENDIF	OutBuf="mov esi,"+TSymName	GOSUB OutCodeData	OutBuf="mov [_ArgSafe0],esi"	GOSUB OutCodeData	OutBuf="mov [_ArgSafe1],"+STR(TDataType)	GOSUB OutCodeData	UseInpData=TRUE	OutBuf="call __InpData"	GOSUB OutCodeData	GOSUB CallErrZ	GOSUB NexToken	EXITIF TokenBuf<>","END LOOPIF FileIO=0 AND NewLine=$0d THEN	GOSUB OutCRLFENDIFGOTO MainLoopReadX:NeedComma=0GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).SubType=FILE OR SymTable(SymNdx).SubType=DEVICE THEN FileReadGOSUB GetSymTempGOSUB UnDoTokenTarget=$ffReadFlag=$ffBEGIN LOOP	IF NeedComma=$ff THEN		GOSUB NexToken		IF TokenLen=0 THEN MainLoop		IF TokenBuf<>"," THEN			ErrNo=ErrSyntax			GOTO MainLoop		ELSE			NeedComma=0		ENDIF	ENDIF	GOSUB GetExp	ErrMain	IF TokenLen=0 THEN MainLoop	GOSUB ProcExp	ErrMain	GOSUB ClassOp	GOSUB GetBase	IF TDataType=COMPVAR OR TDataType>6 THEN		ErrNo=ErrTypMis		GOTO MainLoop	ENDIF	IF DMAddr<>0 THEN		TDataType=LONGVAR	ENDIF	SELECT CASE TDataType		CASE BOOLVAR			OutBuf="call __ReadBool"		CASE BYTEVAR			OutBuf="call __ReadByte";		CASE WORDVAR			OutBuf="call __ReadShort"		CASE LONGVAR			OutBuf="call __ReadLong"		CASE FLOATVAR			OutBuf="call __ReadFlt"		CASE STRINGVAR			OutBuf="mov eax,"+STR(TDetail)			GOSUB OutCodeData			OutBuf="call __ReadStr"	END SELECT	GOSUB OutCodeData	NeedComma=$ffEND LOOPFileRead:UseReadFile=TRUEGOSUB UnDoTokenGOSUB ReadWriteErrMainOutBuf="call __ReadFile"GOSUB OutCodeDataGOTO MainLoopWriteX:UseWriteFile=TRUEGOSUB ReadWriteErrMainOutBuf="call __WriteFile"GOSUB OutCodeDataGOTO MainLoopGetX:GOSUB GetPutErrMainGOSUB OutReadGOTO MainLoopPutX:GOSUB GetPutErrMainGOSUB OutWriteGOTO MainLoopEndX:GOSUB NexTokenIF TokenLen<>0 THEN	LastStmt=LastStmt+TokenBuf; prevents bug involving false 'end'	SELECT CASE TokenBuf		CASE "if"			GOTO ENDIFX		CASE "loop"			GOTO EndLoopX		CASE "while"			GOTO EndWhileX		CASE "exit"			GOTO EndExitX		CASE "select"			GOTO EndSelectX		CASE "case"			GOTO EndCaseX		CASE "function"			GOTO EndFunctionX		CASE "procedure"			GOTO EndProcedureX		CASE "table"			GOTO EndTableX		CASE "text"			GOTO EndTextX		CASE "type"			GOTO EndTypeX		CASE "event"			GOTO EndEventX		CASE "menu"			GOTO EndMenuX		CASE "enum"			GOTO EndEnumX		CASE "object"			GOTO EndObjectX		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECTENDIFIF GUIFlag=0 THEN	OutBuf="xor eax,eax"	GOSUB OutCodeData	ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE	OutBuf="invoke ExitProcess, eax"	GOSUB OutCodeDataELSE	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	OutBuf="invoke DeleteObject,[!Brush]"	GOSUB OutCodeData	ImportFcnTable(ptrPostMessage).ImportFcnUse=TRUE	OutBuf="invoke PostMessage,[!OBMain],WM_CLOSE,0,0"	GOSUB OutCodeDataENDIFGOTO MainLoopCreateX:CrOpFlag=$ffTarget=$ffGOSUB GetPthNumErrMainTarget=0GOSUB GetPthNamErrMainColonMainGOSUB GetAccModImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,[_IOBuffer],GENERIC_WRITE+GENERIC_READ,0,0,CREATE_NEW,FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataGOSUB SetStatusOutBuf="mov ["+PathVar+"],eax"GOSUB OutCodeDataGOSUB CallErrGOTO MainLoopOpenX:CrOpFlag=0Target=$ffGOSUB GetPthNumErrMainTarget=0GOSUB GetPthNamErrMainColonMainGOSUB GetAccModErrMainIF DirFlag=$ff THEN	AccMode=AccMode+"|A_DIR"ENDIFImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,[_IOBuffer],GENERIC_WRITE+GENERIC_READ,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataGOSUB SetStatusIF PathIsVector=0 THEN	OutBuf="mov ["+PathVar+"],eax"ELSE	OutBuf="mov edi,["+PathVar+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"ENDIFGOSUB OutCodeDataGOSUB CallErrGOTO MainLoopCloseX:DiskIO=$ffCloseLp:GOSUB GetPthNumErrMainImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUEOutBuf="invoke CloseHandle,[_IOPthNum]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOSUB NexTokenIF TokenLen=0 THEN MainLoopIF TokenBuf<>"," THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOTO CloseLpWhileX:INCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOSUB CmpOpsErrMainIF TokenBuf<>"do" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB IncConStkErrMainConStk(ConStkPtr).LoopLabel=LabelNumConStk(ConStkPtr).ContLabel=LabelNum; For consistancy with CONTINUE statementINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumConStk(ConStkPtr).ConType=1ConStk(ConStkPtr).ConLine=BasicLineCtrIF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(LabelNum)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)ENDIFGOSUB OutCodeDataGOTO MainLoopEndWhileX:TempInt=1GOSUB ConStkChkErrMainOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopNextX:IF ConStkPtr=0 THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFGOSUB NexTokenIF TokenLen=0 THEN	TokenSaf=ConStk(ConStkPtr).LoopNameENDIFIF TokenSaf<>ConStk(ConStkPtr).LoopName THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFTempInt=5OutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"GOSUB OutCodeDataGOSUB ConStkChkErrMain; add "step" to loop varIF ConStk(ConStkPtr).NoStep=$ff THEN	OutBuf="inc ["+ConStk(ConStkPtr).LoopName+"]"	GOSUB OutCodeDataELSE	IF ConStk(ConStkPtr).ImmStep=0 THEN		OutBuf=";"+ConStk(ConStkPtr).LoopName+"="+ConStk(ConStkPtr).LoopName+"+_LopVec"+STR(ConStk(ConStkPtr).LoopVec)+"._Step;"		GOSUB OutCodeData	ELSE		OutBuf=";"+ConStk(ConStkPtr).LoopName+"="+ConStk(ConStkPtr).LoopName+"+"+ConStk(ConStkPtr).ImmStepVal+";"		GOSUB OutCodeData	ENDIFENDIF; branch back to loop beginningOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)GOSUB OutCodeData; generate done labelOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopRemX:GOTO MainLoopElseX:GOSUB NexToken;  make sure nothing followsIF TokenLen<>0 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFTempInt=0GOSUB ConStkChkErrMainINCR LabelNumOutBuf="jmp "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataConStk(ConStkPtr).TermLabel=LabelNumGOTO MainLoopENDIFX:TempInt=0GOSUB ConStkChkErrMainOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopDeleteX:GOSUB GetPthNamErrMainImportFcnTable(ptrDeleteFile).ImportFcnUse=TRUEOutBuf="invoke DeleteFile,[_IOBuffer]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopBufferX:GOSUB TokenSymErrMainBufName=SymTemp.SymNameIF SymFound=FALSE THEN	GOSUB MakeBuffer	GOSUB ClrSym	SymTemp.DataMod=0	SymTemp.DataType=BUFFER	SymTemp.DataSize=8	GOSUB SymInsert	ErrMainENDIFTDataType=SymTable(SymNdx).DataTypeIF TDataType<>BUFFER THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFEqualMainGOSUB ExprErrMainIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainENDIFIF DMConst<>0 AND TSymName="0" THEN	GOSUB ReleaseBufferELSE	GOSUB GetBufferENDIFGOTO MainLoopBeginX:GOSUB NexTokenIF TokenBuf="loop" THEN BeginLoopXErrNo=ErrSyntaxGOTO MainLoopBeginLoopX:GOSUB IncConStkErrMainGOSUB NexTokenIF TokenLen=0 THEN	ConStk(ConStkPtr).ConType=3ELSE	INCR LopCtrNum	IF LopCtrNum>9 THEN		ErrNo=ErrTmpUse		GOTO MainLoop	ENDIF	IF TokenBuf<>"count" THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	EqualMain	GOSUB GetIntOp	ErrMain	OutBuf="mov [_LoopCtr+"+STR(LopCtrNum*4)+"],"+LdRegName	GOSUB OutCodeData	ConStk(ConStkPtr).ConType=4ENDIFConStk(ConStkPtr).ConLine=BasicLineCtrINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataConStk(ConStkPtr).LoopLabel=LabelNumConStk(ConStkPtr).ContLabel=LabelNum; For consistancy with CONTINUE statementINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumGOTO MainLoopEndLoopX:TempInt=3GOSUB ConStkChkIF ErrNo<>0 THEN	ErrNo=0	TempInt=4	GOSUB ConStkChk	ErrMainENDIFIF TempInt=3 THEN	OutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ELSE	OutBuf="dec [_LoopCtr"+"+"+STR(LopCtrNum*4)+"];"	GOSUB OutCodeData	OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)	DECR LopCtrNumENDIFGOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopRepeatX:GOSUB IncConStkErrMainINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataConStk(ConStkPtr).LoopLabel=LabelNumConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=2INCR LabelNumConStk(ConStkPtr).ContLabel=LabelNumINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumGOTO MainLoopUntilX:TempInt=2GOSUB ConStkChkErrMainOutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"GOSUB OutCodeDataGOSUB CmpOpsErrMainIF TokenLen<>0 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ENDIFGOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopExitIfX:GOSUB CmpOpsErrMainIF ConStkPtr<1 THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFIF TokenLen=0 THEN	IF SimpleCmp=0 THEN		OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	ELSE		OutBuf=SimpleOp+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)	ENDIF	GOSUB OutCodeData	GOTO MainLoopENDIFIF TokenBuf<>"then" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB NexTokenIF TokenLen<>0 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB IncConStkErrMainINCR LabelNumConStk(ConStkPtr).TermLabel=LabelNumConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=6IF SimpleCmp=0 THEN	OutBuf="je "+"_Lbl"+STR(LabelNum)ELSE	OutBuf=SimpleStructOp+"_Lbl"+STR(LabelNum)ENDIFGOSUB OutCodeDataGOTO MainLoopShellX:GOSUB ExprIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymName+"; Get src"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataImportFcnTable(ptrsystem).ImportFcnUse=TRUEOutBuf="cinvoke system,[_IOBuffer]"GOSUB OutCodeDataGOTO MainLoopFPrintX:FileIO=$ffGOTO PrintXFInputX:FileIO=$ffGOTO InputXBaseX:GOSUB NexTokenIF TokenBuf<>"0" AND TokenBuf<>"1" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF TokenBuf="0" THEN	ArrayBase=0	OutBuf="mov [!ArrayBase],0"ELSE	ArrayBase=1	OutBuf="mov [!ArrayBase],1"ENDIFGOSUB OutCodeDataGOTO MainLoopIncrX:DecInc="inc"INCx1:Target=$ffGOSUB ExprErrMainFcnOp1Nam=TSymNameIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopENDIFIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF DMAddr=0 THEN	IF LAND(VectorBit,TDataMod)=VectorBit THEN		OutBuf="mov esi,["+SymTemp.SymName+"]"		GOSUB OutCodeData		OutBuf=DecInc+_DataType+"[esi]; INC/DEC operand"	ELSE		OutBuf=DecInc+" ["+SymTemp.SymName+"]"	ENDIFELSE	GOSUB GetVarSiz	IF LAND(VectorBit,TDataMod)=VectorBit THEN		OutBuf="mov esi,["+SymTemp.SymName+"]"		GOSUB OutCodeData		OutBuf="add [esi],"+STR(VarSize)	ELSE		OutBuf="add ["+SymTemp.SymName+"],"+STR(VarSize)	ENDIFENDIFGOSUB OutCodeDataGOTO MainLoopDecrX:DecInc="dec"GOTO INCx1BufReadX:GOSUB BufRWErrMainGOSUB OutReadGOTO MainLoopBufWriteX:GOSUB BufRWErrMainGOSUB OutWriteGOTO MainLoopDecimalsX:DigDec=0Decimals1:GOSUB GetIntOpErrMainIF DigDec=0 THEN	OutBuf="mov [_Decimals],eax"ELSE	OutBuf="mov [_Digits],eax"ENDIFGOSUB OutCodeDataGOTO MainLoopExchangeX:Target=$ffGOSUB ExprErrMainIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopENDIFOp1Name=TSymNameOp1Class=OpClassOp1Type=TDataTypeOp1Mod=TDataModOp1Detail=TDetailOp1DataSize=TDataSizeIF Op1Name="NextArg" THEN	ErrNo=ErrIVTarg	GOTO MainLoopENDIFCommaMainGOSUB ExprErrMainIF DMConst<>0 THEN	ErrNo=ErrIVExp	GOTO MainLoopENDIFOp2Name=TSymNameOp2Class=OpClassOp2Type=TDataTypeOp2Mod=TDataModOp2Detail=TDetailOp2DataSize=TDataSizeIF Op2Name="NextArg" THEN	ErrNo=ErrIVTarg	GOTO MainLoopENDIFIF Op1Type<>Op2Type THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF Op1Class<>CPXClass AND Op1DataSize<>Op2DataSize THEN	IF Op1Type<>STRINGVAR THEN		ErrNo=ErrTypMis		GOTO MainLoop	ELSE		IF Op1Detail<>Op2Detail THEN			ErrNo=ErrTypMis			GOTO MainLoop		ENDIF	ENDIFENDIFIF Op1Class=CPXClass AND SymTable(Op1Detail).DataSize<>SymTable(Op2Detail).DataSize THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF Op1Class=FLTClass OR Op1Class=INTClass OR Op1Class=BOOLClass THEN	Promote=$ff	SymTemp.SymName=Op1Name	GOSUB LoadReg	ErrMain	SymTemp.SymName=Op2Name	GOSUB LoadReg	ErrMain	TempStr=Op1Name	Op1Name=Op2Name	Op2Name=TempStr	GOSUB StoreD0	ErrMain	OutBuf="mov eax,edx"	GOSUB OutCodeData	Op1Name=Op2Name	GOSUB StoreD0	GOTO MainLoopENDIFIF Op1Class=CPXClass OR Op1Class=ARRClass OR Op1Type=STRINGVAR THEN	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov esi,"+Op1Name	ELSE		OutBuf="mov esi,["+Op1Name+"]"		GOSUB OutCodeData		OutBuf="mov esi,[esi]"	ENDIF	GOSUB OutCodeData	IF LAND(Op1Mod,VectorBit)=0 THEN		OutBuf="mov esi,"+Op2Name	ELSE		OutBuf="mov esi,["+Op2Name+"]"		GOSUB OutCodeData		OutBuf="mov esi,[esi]"	ENDIF	GOSUB OutCodeData	IF Op1Class=ARRClass THEN		TempInt=Op1DataSize	ELSE		IF Op1Type=STRINGVAR THEN			TempInt=Op1Detail		ELSE			TempInt=SymTable(Op1Detail).DataSize		ENDIF	ENDIF	INCR LabelNum			OutBuf="mov edx,"+STR(TempInt)		GOSUB OutCodeData	OutBuf="_Lbl"+STR(LabelNum)+":"	GOSUB OutCodeData	OutBuf="mov al,[esi]"	GOSUB OutCodeData	OutBuf="mov ah,[edi]"	GOSUB OutCodeData	OutBuf="mov [esi],ah"	GOSUB OutCodeData	OutBuf="mov [edi],al"	GOSUB OutCodeData	OutBuf="inc esi"	GOSUB OutCodeData	OutBuf="inc edi"	GOSUB OutCodeData		OutBuf="dec edx"	GOSUB OutCodeData	OutBuf="jne "+"_Lbl"+STR(LabelNum)	GOSUB OutCodeData	GOTO MainLoop	ENDIFErrNo=ErrIVTypeGOTO MainLoopBeepX:GOTO MainLoopEndExitX:TempInt=6GOSUB ConStkChkErrMainOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr-1).TermLabel)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoopReDimX:IgnoreRightParen=$ffGOSUB TokenSymErrMainBufName=SymTemp.SymNameBufDataSize=SymTable(SymNdx).DataAddrIF LAND(SymTable(SymNdx).DataMod,ReDimBit)<>ReDimBit THEN	ErrNo=ErrTypMisENDIFGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFTempInt=0Ctr1=0FOR I=SrcNdx TO EndNdx	IF MID(SrcLine,I,1)="," THEN		INCR Ctr1	ENDIFNEXT IIF Ctr1>2 THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB ExprErrMainIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainENDIFOutBuf="imul eax,"+STR(BufDataSize)GOSUB OutCodeDataIF DMConst<>0 AND TSymName="0" THEN	GOSUB ReleaseBufferELSE	GOSUB GetBufferENDIFGOTO MainLoopPlayWaveX:GOSUB ExprErrMainIF OpClass<>STRClass THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataOutBuf="mov eax,[esi]"GOSUB OutCodeDataOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataOutBuf="mov [_ArgSafe1],0"GOSUB OutCodeDataGOSUB NexTokenIF TokenLen=0 THEN PlayWave1GOSUB ExprIF OpClass<>INTClass THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainENDIFOutBuf="mov _ArgSafe1,eax"GOSUB OutCodeDataPlayWave1:ImportFcnTable(ptrsndPlaySound).ImportFcnUse=TRUEOutBuf="invoke sndPlaySound,[_ArgSafe0],[_ArgSafe1]"GOSUB OutCodeDataGOTO MainLoopSetVecX:GOSUB TokenSymErrMainIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFVectorName=SymTemp.SymNameVDataMod=SymTable(SymNdx).DataModVDataAddr=SymTable(SymNdx).DataAddrIF SymTable(SymNdx).DataType=STRINGVAR THEN	VDetail=SymTable(SymNdx).DetailELSE	VDetail=0ENDIFIF LAND(VDataMod,VectorBit)=0 THEN; Not a vector	ErrNo=ErrTypMis	GOTO MainLoopENDIFEqualMainGOSUB NexTokenIF TokenBuf="[" THEN	GOSUB RightBracket	ErrMain	GOSUB Expr	MID(SrcLine,SrcLineMod,1)="]"	ErrMain	IF TDataType<>LABELPTR THEN		ErrNo=ErrTypMis		GOTO MainLoop	ENDIF	OutBuf="mov eax,[esi]"	GOSUB OutCodeData	SymTemp.SymName=VectorName	GOSUB SymSrch	SymNdx=SymTable(SymNdx).Detail	TempInt=SymTable(SymNdx).DataSize	OutBuf="sub eax,"+STR(TempInt)	GOSUB OutCodeData	OutBuf="mov ["+VectorName+"],eax"	GOSUB OutCodeData	GOTO MainLoopELSE	GOSUB UnDoToken	GOSUB GetIntOp	ErrMain	IF LAND(VDataMod,ArrayBit)=ArrayBit THEN		TempInt=ArrayBase*VDataAddr		OutBuf="sub eax,"+STR(TempInt)		GOSUB OutCodeData	ENDIF	OutBuf="mov ["+VectorName+"],eax"	GOSUB OutCodeData	IF VDetail<>0 THEN;  must be STRING.. do rest of vector		GOSUB NexToken		IF TokenLen=0 THEN			OutBuf="mov ["+VectorName+"+4],"+STR(VDetail)		ELSE			IF TokenBuf<>"," THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOSUB GetIntOp			ErrMain			OutBuf="mov ["+VectorName+"+4],eax"		ENDIF		GOSUB OutCodeData		OutBuf="mov ["+VectorName+"+8],0"		GOSUB OutCodeData	ENDIFENDIFGOTO MainLoopDigitsX:DigDec=$ffGOTO Decimals1MacroX:GOTO MACRODxEndMacroX:ErrNo=ErrEndmGOTO MainLoopTableX:ArraySize=0GOSUB ClrDatTypGOSUB TokenSymSymNdxSaf=SymNdxErrMainIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopENDIFGOSUB NexTokenIF TokenBuf<>"as" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFOutBuf=""GOSUB OutInitDataOutBuf="align 4"GOSUB OutInitDataOutBuf=SymTemp.SymName+":"GOSUB OutInitDataGOSUB ClrSymGOSUB NexTokenSELECT CASE TokenBuf	CASE "boolean"		SymTemp.DataType=BOOLVAR		SymTemp.DataAddr=1		SymTemp.SubType=NONE	CASE "byte"		SymTemp.DataType=BYTEVAR		SymTemp.DataAddr=1		SymTemp.SubType=NONE	CASE "integer"		SymTemp.DataType=WORDVAR		SymTemp.DataAddr=2		SymTemp.SubType=NONE	CASE "long"		SymTemp.DataType=LONGVAR		SymTemp.DataAddr=4		SymTemp.SubType=NONE	CASE "float"		SymTemp.DataType=FLOATVAR		SymTemp.DataAddr=8		SymTemp.SubType=NONE	CASE "label"		SymTemp.DataType=LABELPTR		SymTemp.DataAddr=4		SymTemp.SubType=NONE	CASE "string"		SymTemp.DataType=STRINGVAR		IF NextByte<>"*" THEN			TempInt=255; Default string size		ELSE			GOSUB NexToken; Eat '*'			GOSUB NexToken			TempStr=TokenSaf			GOSUB StrSiz			ErrMain		ENDIF		SymTemp.Detail=TempInt		SymTemp.DataAddr=TempInt		StringLength=TempInt		SymTemp.SubType=NONE	CASE "file"		SymTemp.DataType=LONGVAR		SymTemp.DataAddr=4		SymTemp.SubType=FILE	CASE "device"		SymTemp.DataType=LONGVAR		SymTemp.DataAddr=4		SymTemp.SubType=DEVICE	CASE ELSE		TableName=SymTemp.SymName		SymTemp.SymName=TokenSaf		GOSUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO MainLoop		ENDIF		IF SymTable(SymNdx).DataType<>TYPE THEN			ErrNo=ErrTypMis			GOTO MainLoop		ENDIF		TypeNdx=SymNdx		TypeVars=SymTable(SymNdx).Detail		SymTemp.DataType=COMPLEX		SymTemp.Detail=TypeNdx		SymTemp.DataAddr=SymTable(SymNdx).DataSize		SymTemp.SymName=TableNameEND SELECTSymTemp.DataMod=ArrayBitSymNdx=SymNdxSafTDataAddr=SymTemp.DataAddrGOSUB SymInsertErrMainTblDataType=SymTemp.DataTypeTDataType=TblDataType; Useful only if NOT COMPLEX data typeRepeatFlag=0TblLoop:BEGIN LOOP	INCR ArraySize	IF RepeatFlag<>0 THEN		DECR RepeatCnt		IF RepeatCnt=0 THEN			RepeatFlag=0			GOTO TblLoop		ENDIF		SrcNdx=0		GOSUB NexToken	ELSE		GOSUB ReadSource		GOSUB NexToken		IF TokenBuf="repeat" THEN			RepeatFlag=$ff			GOSUB NexToken			IF TokenBuf="until" THEN				GOSUB NexToken				RepeatCnt=VAL(TokenSaf)				RepeatCnt=RepeatCnt-ArraySize+1			ELSE				RepeatCnt=VAL(TokenSaf)+1			ENDIF			SrcLine=SrcLineSaf			GOTO TblLoop		ELSE			SrcLineSaf=SrcLine		ENDIF	ENDIF	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in TABLE"		ErrNo=$ff		GOTO MainLoop	ENDIF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"			IF TokenBuf="end" OR TokenBuf="endtable" THEN		IF TokenBuf="end" THEN			GOSUB  NexToken			IF TokenBuf<>"table" THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF		ENDIF		SymTable(SymNdxSaf).DataSize=(ArraySize-1)*TDataAddr		OutBuf="; End of table"		GOSUB OutInitData		OutBuf=""		GOSUB OutInitData		GOTO MainLoop	ENDIF	IF TblDataType=COMPLEX THEN		GOSUB UnDoToken		FOR I=1 TO TypeVars			GOSUB NexToken			IF TokenBuf="," THEN				GOSUB NexToken				IF TokenBuf="," THEN					ErrNo=ErrSyntax					GOTO MainLoop				ENDIF			ENDIF			TDataType=SymTable(TypeNdx+I).DataType			IF TDataType=STRINGVAR THEN				StringLength=SymTable(TypeNdx+I).Detail			ENDIF			GOSUB MakeTableEntry			ErrMain			NEXT I	ELSE		GOSUB MakeTableEntry		ErrMain	ENDIFEND LOOPMakeTableEntry:SELECT CASE TDataType	CASE BOOLVAR		IF TokenBuf="true" THEN			OutBuf="db 1"		ELSE			IF TokenBuf="false" THEN				OutBuf="db 0"			ELSE				ErrNo=ErrTypMis				RETURN			ENDIF		ENDIF		CASE BYTEVAR		GOSUB ChkConst		ErrRet		IF IVAL(TokenSaf)>255 THEN			ErrNo=ErrOpRange			RETURN		ENDIF		GOSUB TblInt		ErrRet		OutBuf="db "+TempStr	CASE WORDVAR		GOSUB ChkConst		ErrRet		IF IVAL(TokenSaf)>65535 THEN			ErrNo=ErrOpRange			RETURN		ENDIF		GOSUB TblInt		ErrRet		OutBuf="dw "+TempStr	CASE LABELPTR		GOSUB UnDoToken		GOSUB ChkLabel		ErrRet		OutBuf="dd "+TempStr	CASE LONGVAR		GOSUB ChkConst		ErrRet		IF IVAL(TokenSaf)>$7fffffff THEN			ErrNo=ErrOpRange			RETURN		ENDIF		GOSUB TblInt		ErrRet		OutBuf="dd "+TempStr	CASE FLOATVAR		;	CASE STRINGVAR		IF TokenType<>TTypQuote THEN			ErrNo=ErrTypMis			RETURN			ENDIF		IF LEN(TokenSaf)-1>StringLength THEN;			TempStr=SrcLine;			GOSUB OutPrint			TempStr="Fatal Error: Oversize string in table"			ErrNo=$ff			RETURN		ENDIF		IF LEN(TokenSaf)>2 THEN			OutBuf="db "+TokenSaf+",0"		ELSE			OutBuf="db 0"		ENDIF		FOR Ctr1=1 TO StringLength-LEN(TokenSaf)+1			OutBuf=OutBuf+",0"		NEXT Ctr1END SELECTGOSUB OutInitDataRETURNChkConst:IF TokenType=TTypInt THEN	RETURNENDIFIF TokenType=TTypHex THEN	RETURNENDIFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	RETURNENDIFTokenSaf=STR(SymTable(SymNdx).Detail)TokenBuf=TokenSafTokenType=TTypIntRETURNTblInt:IF TokenType=TTypInt THEN	GOSUB ValidInt	IF IntOK=0 THEN		ErrNo=ErrIVExp		RETURN	ENDIFENDIFIF TokenType=TTypHex THEN	GOSUB ValidHex	IF HexOK=0 THEN		ErrNo=ErrIVExp		RETURN	ENDIFENDIFTempStr=TokenSafRETURNEndTableX:TempStr="Fatal Error: EndTable while not in table"ErrNo=$ffGOTO MainLoopIncludeX:UseFilNam=""UseLoop:GOSUB NexTokenIF TokenLen=0 THEN Include1UseFilNam=UseFilNam+TokenSafGOTO UseLoopInclude1:ON ERROR GOTO NoUseFileINCR InpFilPtrIF InpFilPtr>20 THEN	TempStr="FATAL ERROR Include Stack OverFlow"	ErrNo=$ff	GOTO MainLoopENDIFOPEN InpFile(InpFilPtr),UseFilNam:READON ERRORGOTO MainLoopNoUseFile:TempStr="Cannot Open Include File: "';UseFilNamGOSUB ShowErrorRETURNNoImportFile:TempStr="Cannot Open Import File"GOSUB ShowErrorRETURNFreezeX:GOTO FIXDxCallX:GOSUB NexTokenSymTemp.SymName=TokenSafFcnName=TokenSafGOSUB SymSrchGOSUB GetSymTempIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTemp.DataType<>PROC THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFFcnDataMod=SymTable(SymNdx).DataModFcnSymNdx=SymNdxIF SymTemp.FcnArgs<>0 THEN	GOSUB PushArgs	ErrMainENDIFTempInt=FcnDataModTempInt=LOR(TempInt,CalledBit)SymTable(FcnSymNdx).DataMod=TempIntOutBuf="call "+FcnNameGOSUB OutCodeDataGOTO MainLoop ChDirX:GOSUB GetPthNamErrMainImportFcnTable(ptrSetCurrentDirectory).ImportFcnUse=TRUEOutBuf="invoke SetCurrentDirectory,[_IOBuffer]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZ GOTO MainLoopMkDirX:GOSUB GetPthNamErrMainImportFcnTable(ptrCreateDirectory).ImportFcnUse=TRUEOutBuf="invoke CreateDirectory,[_IOBuffer],0"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopRmDirX:GOSUB GetPthNamErrMainImportFcnTable(ptrRemoveDirectory).ImportFcnUse=TRUEOutBuf="invoke RemoveDirectory,[_IOBuffer]"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZGOTO MainLoopEndFunctionX:IF FcnFlag=0 THEN	ErrNo=ErrEndFcn	GOTO MainLoopENDIF; Put default return data hereSELECT CASE TFcnDataType	CASE BOOLVAR		OutBuf="mov [_BoolRet],0"	CASE LONGVAR		OutBuf="mov [_LongRet],0"	CASE STRINGVAR		ediUsed=TRUE		OutBuf="mov edi,_NullStr"		GOSUB OutFunction		OutBuf="mov [_StringRet],edi"		GOSUB OutFunction		OutBuf="mov [_StringRet+4],0"		GOSUB OutFunction		OutBuf="mov [_StringRet+8],0"	CASE FLOATVAR		;END SELECTGOSUB OutFunctionOutBuf="ret"GOSUB OutFunctionFcnFlag=0ProcFcnFlag=0GOTO MainLoopEndProcedureX:IF ProcFlag=0 THEN	ErrNo=ErrEndProc	GOTO MainLoopENDIFOutBuf="ret"GOSUB OutFunctionProcFlag=0ProcFcnFlag=0GOTO MainLoopRandomizeX:GOSUB NexTokenIF TokenLen<>0 THEN	GOSUB UnDoToken	GOSUB GetIntOp	ErrMain	OutBuf=";srand(eax);"ELSE	OutBuf=";srand(time(NULL)/2);"ENDIFGOSUB OutCodeDataGOTO MainLoopDeclareX:GOSUB NexTokenSymTemp.DataMod=UsrFcnBitIF TokenBuf="procedure" THEN	ProcFcn=0	SymTemp.DataType=PROCELSE	IF TokenBuf="function" THEN		ProcFcn=$ff		SymTemp.DataType=FCN	ELSE		ErrNo=ErrSyntax		GOTO MainLoop	ENDIFENDIFGOSUB NexTokenIF TokenBuf="public" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopENDIFCtr3=0GOSUB NexTokenIF TokenSaf<>"(" THEN	IF ProcFcn=0 THEN		GOTO ProcFcnDone	ELSE		ErrNo=ErrSyntax		GOTO MainLoop	ENDIFENDIFNeedComma=0DeclareLoop:GOSUB NexTokenIF TokenBuf=")" THEN	IF ProcFcn=0 THEN		GOTO ProcFcnDone	ELSE		GOSUB NexToken		IF TokenBuf<>"as" THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		SELECT CASE TokenBuf			CASE "boolean"				SymTemp.FcnDataType=BOOLVAR			CASE "integer"				SymTemp.FcnDataType=LONGVAR			CASE "string"				SymTemp.FcnDataType=STRINGVAR			CASE "float"				SymTemp.FcnDataType=FLOATVAR			CASE ELSE				ErrNo=ErrSyntax				GOTO MainLoop		END SELECT		GOTO ProcFcnDone	ENDIFELSE	IF NeedComma<>0 THEN		IF TokenSaf<>"," THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		NeedComma=0		GOTO DeclareLoop	ELSE		IF TokenSaf="," THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF	ENDIF	INCR Ctr3	IF Ctr3>7 THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	SELECT CASE TokenBuf		CASE "boolean"			TempInt=BOOLVAR		CASE "integer"			TempInt=LONGVAR		CASE "string"			TempInt=STRINGVAR		CASE "float"			TempInt=FLOATVAR		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECT	SELECT CASE Ctr3		CASE 1			SymTemp.DataAddr=TempInt		CASE 2			SymTemp.DataSize=TempInt		CASE 3			SymTemp.ArrayDim1=TempInt		CASE 4			SymTemp.ArrayDim2=TempInt		CASE 5			SymTemp.ArrayDim3=TempInt		CASE 6			SymTemp.ArrayDims=TempInt		CASE 7			SymTemp.Misc=TempInt	END SELECT	NeedComma=$ff	GOTO DeclareLoopENDIFProcFcnDone:IF ProcFcn=$ff THEN	IF Ctr3=0 THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIFENDIFSymTemp.FcnArgs=Ctr3SymTemp.Detail=LabelUnresolvedGOSUB SymInsertGOTO MainLoopFunctionX:GOSUB FcnFlagChkErrMainFcnFlag=$ffProcFcnFlag=$ffGOSUB ProcFcnPrepGOSUB PopArgsErrMainGOTO MainLoopProcedureX:GOSUB FcnFlagChkErrMainProcFlag=$ffProcFcnFlag=$ffGOSUB ProcFcnPrepIF SymTemp.FcnArgs<>0 THEN	GOSUB PopArgs	ErrMainENDIFErrMainGOTO MainLoopFcnFlagChk:IF ProcFlag+FcnFlag+EventFlag<>0 THEN	ErrNo=ErrFSNest	RETURNENDIFRETURNExitX:GOSUB NexTokenIF TokenBuf="if" THEN ExitIfXErrNo=ErrSyntaxGOTO MainLoopWendX:GOTO EndWhileX; Turn into ENDWHILEContinueX:GOSUB NexTokenIF TokenBuf<>"if" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFIF ConStkPtr<1 THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFTempInt=ConStk(ConStkPtr).ConTypeIF TempInt<0 OR TempInt>5 THEN; Only for FOR/NEXT, BEGINLOOP/ENDLOOP, REPEAT/UNTIL/, WHILE/ENDWHILE	ErrNo=ErrUBCon	GOTO MainLoopENDIFGOSUB CmpOpsErrMainIF SimpleCmp=0 THEN	OutBuf="jne "+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ELSE	OutBuf=SimpleOp+"_Lbl"+STR(ConStk(ConStkPtr).LoopLabel)ENDIFGOSUB OutCodeDataGOTO MainLoopSelectX:IF SelectFlag=TRUE THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFSelectFlag=TRUEGOSUB NexTokenIF TokenBuf<>"case" THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB ExprErrMainIF OpClass<>STRClass AND OpClass<>INTClass THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFIF OpClass=INTClass AND TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainENDIFSwitchClass=OpClassIF OpClass=INTClass THEN	OutBuf="mov [_SwitchInt],eax"ELSE	ediUsed=TRUE	OutBuf="mov edi,["+TSymName+"]"	GOSUB OutCodeData	OutBuf="mov [_SwitchStr],edi"	GOSUB OutCodeData	OutBuf="mov edi,["+TSymName+"+4]"	GOSUB OutCodeData	OutBuf="mov [_SwitchStr+4],edi"	GOSUB OutCodeData	OutBuf="mov edi,["+TSymName+"+8]"	GOSUB OutCodeData	OutBuf="mov [_SwitchStr+8],edi"ENDIFGOSUB OutCodeDataGOSUB IncConStkErrMainConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=7INCR LabelNumConStk(ConStkPtr).TermLabel=LabelNum	GOTO MainLoopEndSelectX:IF SelectFlag=FALSE THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFIF CaseFlag=TRUE THEN	GOSUB EndCasex	CaseFlag=FALSEENDIFSelectFlag=FALSECaseElseFlag=FALSETempInt=7GOSUB ConStkChkErrMainOutBuf="_Lbl"+STR(ConStk(ConStkPtr).TermLabel)+":"GOSUB OutCodeDataDECR ConStkPtrGOTO MainLoop CaseX:IF SelectFlag=FALSE OR CaseElseFlag=TRUE THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFIF CaseFlag=TRUE THEN	GOSUB EndCasexENDIFCaseFlag=TRUEINCR LabelNumConStk(ConStkPtr).ConLine=BasicLineCtrConStk(ConStkPtr).ConType=7ConStk(ConStkPtr).ContLabel=LabelNumGOSUB NexTokenIF TokenBuf="else" THEN	CaseElseFlag=TRUEELSE	GOSUB UnDoToken	GOSUB Expr	ErrMain	IF OpClass<>STRClass AND OpClass<>INTClass THEN		ErrNo=ErrIVType		GOTO MainLoop	ENDIF	IF OpClass=INTClass AND TSymName<>"~" THEN		D0Loaded=0		GOSUB LoadReg		ErrMain	ENDIF	IF OpClass<>SwitchClass THEN		ErrNo=ErrTypMis		GOTO MainLoop	ENDIF	CaseToFlag=FALSE	GOSUB NexToken	IF TokenLen<>0 THEN		IF TokenBuf="to" THEN			CaseToFlag=TRUE		ELSE			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF	ENDIF	IF CaseToFlag=FALSE THEN		SymType="jne "		GOSUB GenCase	ELSE		SymType="<"		GOSUB GenCase		REM Get second arg here		D0Loaded=0		GOSUB Expr		ErrMain		IF OpClass<>STRClass AND OpClass<>INTClass THEN			ErrNo=ErrIVType			GOTO MainLoop		ENDIF		IF OpClass=INTClass AND TSymName<>"~" THEN			D0Loaded=0			GOSUB LoadReg			ErrMain		ENDIF		IF OpClass<>SwitchClass THEN			ErrNo=ErrTypMis			GOTO MainLoop		ENDIF		SymType=">"		GOSUB GenCase 		ENDIFENDIF	GOTO MainLoopEndCaseX:IF SelectFlag=FALSE OR CaseFlag=FALSE THEN	ErrNo=ErrUBCon	GOTO MainLoopENDIFCaseFlag=FALSEGOSUB EndCasexGOTO MainLoopConstX:GOTO SETDxSwapX:GOTO ExchangeXProgramX:StartFlag=TRUEGOTO MainLoopGenCodeX:GOSUB ReadSourceIF TempInt=0 THEN	TempStr="FATAL ERROR.. EOF in Text"	ErrNo=$ff	GOTO MainLoopENDIFIF SrcLine="ENDGENCODE" THEN MainLoop;;;;;;;; fix thisGOTO MainLoopEndGenCodeX:TempStr="Fatal Error: EndGenCode while not in GenCode"ErrNo=$ffGOTO MainLoopMakeLowerX:GOSUB GetStringOpErrMainOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseLCase=TRUEOutBuf="call __LCase"GOSUB OutCodeDataGOTO MainLoopMakeUpperX:GOSUB GetStringOpErrMainOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseUCase=TRUEOutBuf="call __UCase"GOSUB OutCodeDataGOTO MainLoopTextBlockX:UseData=TRUEGOSUB TokenSymErrMainIF SymFound=TRUE THEN	ErrNo=ErrDupSym	GOTO MainLoopENDIFGOSUB ClrDatTypTDataType=LABELVARSymTemp.DataType=LABELVARGOSUB ClrSymSymTemp.DataMod=DataBitSymTemp.Detail=LabelResolvedGOSUB SymInsertErrMainOutBuf=SymTemp.SymName+":"GOSUB OutInitDataTextLoop:GOSUB ReadSourceIF TempInt=0 THEN	TempStr="FATAL ERROR.. EOF in Text"	ErrNo=$ff	GOTO MainLoopENDIFOutBuf=" db "+CHR(OBQUOTE)+SrcLine+CHR(OBQUOTE)+",0"GOSUB OutInitDataGOSUB NexTokenIF TokenBuf="end" THEN	GOSUB NexToken	IF TokenBuf="text" THEN		GOTO MainLoop	ELSE		GOTO TextLoop	ENDIFENDIFIF TokenBuf<>"endtext" THEN TextLoopGOTO MainLoopEndTextX:TempStr="Fatal Error: EndText while not in Text"ErrNo=$ffGOTO MainLoopEndTypeX:TempStr="Fatal Error: ENDTYPE while not in TYPE or Empty TYPE Declaration"ErrNo=$ffGOTO MainLoopSetPositionX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainGOSUB SetPosErrMainGOSUB SetPosFromTableGOTO MainLoopGetCursorPositionX:ErrGUIImportFcnTable(ptrGetCursorPos).ImportFcnUse=TRUEOutBuf="invoke GetCursorPos,CursorPosX"GOSUB OutCodeDataGOTO MainLoopScreenToClientX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrScreenToClient).ImportFcnUse=TRUEOutBuf="invoke ScreenToClient, dword ["+HandleName+"],CursorPosX"GOSUB OutCodeDataGOTO MainLoopGetWindowRectX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrGetWindowRect).ImportFcnUse=TRUEOutBuf="invoke GetWindowRect, dword ["+HandleName+"],RectLeft"GOSUB OutCodeDataGOTO MainLoopSetCaptureX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainImportFcnTable(ptrSetCapture).ImportFcnUse=TRUEOutBuf="invoke SetCapture, dword ["+HandleName+"]"GOSUB OutCodeDataGOTO MainLoopReleaseCaptureX:ErrGUIImportFcnTable(ptrReleaseCapture).ImportFcnUse=TRUEOutBuf="invoke ReleaseCapture"GOSUB OutCodeDataGOTO MainLoopConstructX:ErrGUIGUITargetFlag=$ffInFlag=FalseChildFlag=FALSEGOSUB ValidateObjectErrMainGOSUB SetPosErrMainObjectTypeSafe=ObjectType-99ObjectNameSafe=ObjectNameTempExStyle=ObjTable(ObjectTypeSafe).ObjExStyleSETVEC StyleArray=[ObjTable(ObjectTypeSafe).ObjStyleTable]TempStr="default"GOSUB FindStyleErrMainStyleCode=StyleArray(I).StyleValueIF NextByte="," THEN; Style Arg	StyleCode=0	GOSUB NexToken; Eat the comma	BEGIN LOOP		EXITIF NextByte=" " OR NextByte=","		GOSUB NexToken		EXITIF TokenLen=0		IF TokenBuf<>"+" THEN			TempStr=TokenBuf			GOSUB FindStyle			ErrMain			StyleCode=StyleCode+StyleArray(I).StyleValue		ENDIF	END LOOPENDIFTempStyle="$"+HEX(StyleCode)ObjectParent="!OBMain"INCR ObjectIDBEGIN LOOP	GOSUB NexToken	EXITIF TokenLen=0	SELECT CASE TokenBuf		CASE "child"			IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			ChildFlag=TRUE		CASE "in"			IF ObjectTypeSafe=ptrFORM OR ObjectTypeSafe=ptrTOOLWINDOW THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOSUB ValidateParentObject			InFlag=TRUE		CASE "topmost"			IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN							ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			FormExStyle=FormExStyle+"+WS_EX_TOPMOST"		CASE "appwindow"			IF ObjectTypeSafe<>ptrFORM AND ObjectTypeSafe<>ptrTOOLWINDOW THEN							ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			FormExStyle=FormExStyle+"+WS_EX_APPWINDOW"					CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECTEND LOOPINCR LabelNumOutBuf="bt dword [edi+StatusOffs],WinConstructed"GOSUB OutCodeDataOutBuf="jc _Lbl"+STR(LabelNum)GOSUB OutCodeDataTempStr="!ControlType"+STR(ObjectTypeSafe)IF ObjectTypeSafe=ptrFORM OR ObjectTypeSafe=ptrTOOLWINDOW THEN; FORM	OutBuf="!"+ObjectName+"WindowClass WNDCLASS"	GOSUB OutInitData	OutBuf="!"+ObjectName+"Class db '"+ObjectName+"',0"	GOSUB OutInitData	ImportFcnTable(ptrLoadIcon).ImportFcnUse=TRUE	OutBuf="invoke LoadIcon,0,IDI_APPLICATION"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.hIcon],eax"	GOSUB OutCodeData	ImportFcnTable(ptrLoadCursor).ImportFcnUse=TRUE	OutBuf="invoke LoadCursor,0,IDC_ARROW"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.hCursor],eax"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.style],0"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.lpfnWndProc],!"+ObjectName+"Proc"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.cbClsExtra],0"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.cbWndExtra],0"	GOSUB OutCodeData	OutBuf="mov eax,[!hinstance]"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.hbrBackground],COLOR_BTNFACE+1"	GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.lpszMenuName],0"		GOSUB OutCodeData	OutBuf="mov [!"+ObjectName+"WindowClass.lpszClassName],!"+ObjectName+"Class"	GOSUB OutCodeData	ImportFcnTable(ptrRegisterClass).ImportFcnUse=TRUE	OutBuf="invoke RegisterClass,!"+ObjectName+"WindowClass"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+HandleOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+IDOffs],1"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+ArrayOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+BackColorOffs],$ffffff"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+ForeColorOffs],$000000"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+TypeOffs],!CT_FORM"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+ControlBrushOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [!"+ObjectName+"+InterceptSafeOffs],!"+ObjectName+"Proc"	GOSUB OutCodeData	IF ChildFlag=TRUE THEN		ObjectParent="[!OBMain]"	ELSE		ObjectParent="NULL"	ENDIF	UseSetRightBottom=TRUE	OutBuf="call __SetRightBottom"	GOSUB OutCodeData	ImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUE	OutBuf="invoke CreateWindowEx,"+FormExStyle+",!"+ObjectName+"Class,!title,WS_VISIBLE+WS_OVERLAPPEDWINDOW,dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs], dword "+ObjectParent+",NULL,[!hinstance],!"+ObjectName	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,[!"+ObjectName+"+HandleOffs],GWL_USERDATA,!"+ObjectName	GOSUB OutCodeData	OutBuf="mov dword [edi+StatusOffs],$07"	GOSUB OutCodeData	OutBuf="proc !"+ObjectName+"Proc"+",!hwnd,wmsg,wparam,lparam"	GOSUB OutFunction	OutBuf="enter"	GOSUB OutFunction	OutBuf="push ebx esi edi"	GOSUB OutFunction	OutBuf="mov [!PassSystemEvent],0"	GOSUB OutFunction	OutBuf="cmp [wmsg],WM_GETMINMAXINFO"	GOSUB OutFunction	OutBuf="jne "+ObjectName+"NotwmGetMaxInfo"	GOSUB OutFunction	OutBuf="mov dword edi,[!hwnd]"	GOSUB OutFunction	OutBuf="mov dword [!"+ObjectName+"+HandleOffs],edi"	GOSUB OutFunction	OutBuf="mov dword [!"+ObjectName+"+OwnerOffs],0"	GOSUB OutFunction	OutBuf="jmp !DefWndProc"	GOSUB OutFunction	OutBuf=ObjectName+"NotwmGetMaxInfo:"	GOSUB OutFunction	OutBuf="mov esi,!"+ObjectName	GOSUB OutFunction	OutBuf="cmp [wmsg],WM_DESTROY"	GOSUB OutFunction	OutBuf="jne !WinProcCommon"	GOSUB OutFunction	ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE	OutBuf="invoke DeleteObject,dword [esi+ControlBrushOffs]"	GOSUB OutFunction	OutBuf="jmp !DefWndProc"	GOSUB OutFunction	GOTO ConstructDoneENDIFUseSetRightBottom=TRUEOutBuf="call __SetRightBottom"GOSUB OutCodeDataImportFcnTable(ptrCreateWindowEx).ImportFcnUse=TRUEOutBuf="invoke CreateWindowEx,"+TempExStyle+","+TempStr+",NULL,"+TempStyle+", dword [edi+LeftOffs], dword [edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs], dword ["+ObjectParent+"],"+STR(ObjectID)+",[!hinstance],!"+ObjectNameGOSUB OutCodeDataOutBuf="mov dword edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+HandleOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword eax,GWL_USERDATA,edi"GOSUB OutCodeDataUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataIF ObjectTypeSafe=ptrCOMBOBOX THEN	OutBuf="mov dword edi,[!TargetGUIDesc]"	GOSUB OutCodeData	ImportFcnTable(ptrGetComboBoxInfo).ImportFcnUse=TRUE		OutBuf="invoke GetComboBoxInfo, dword ["+HandleName+"],!cbSize"	GOSUB OutCodeData	OutBuf="mov dword edi,[!TargetGUIDesc]"	GOSUB OutCodeData	OutBuf="mov eax,[!hwndCombo]"	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"	GOSUB OutCodeData	OutBuf="mov eax,[!hwndItem]"	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"	GOSUB OutCodeData	OutBuf="mov eax,[!hwndList]"	GOSUB OutCodeData	ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE	OutBuf="invoke SetWindowLong,eax,GWL_USERDATA,edi"	GOSUB OutCodeDataENDIF	ObjectName=ObjectNameSafeObjectNameSafe="!"+ObjectNameIF InFlag=TRUE THEN	IF LAND(SymTable(SymNdx).DataMod,SubClassedBit)=0 THEN		INCR ProcNum		OutBuf="!OldProc"+STR(ProcNum)+" rd 1"		GOSUB OutUninitData		TDataMod=SymTable(SymNdx).DataMod		TDataMod=LOR(TDataMod,SubClassedBit)		SymTable(SymNdx).DataMod=TDataMod		INCR SCLabelNum		OutBuf="bts dword ["+ObjectParentName+"+StatusOffs],WinSubClassed"		GOSUB OutCodeData		OutBuf="jc _SCLbl"+STR(SCLabelNum)		GOSUB OutCodeData		ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUE		OutBuf="invoke SetWindowLong, dword ["+ObjectParent+"],GWL_WNDPROC,!SubClassProc"+STR(ProcNum)		GOSUB OutCodeData		OutBuf="mov [!OldProc"+STR(ProcNum)+"],eax"		GOSUB OutCodeData		OutBuf="_SCLbl"+STR(SCLabelNum)+":"		GOSUB OutCodeData			OutBuf="proc !SubClassProc"+STR(ProcNum)+",!OBMain,wmsg,wparam,lparam"		GOSUB OutFunction		RESTORE SubClassProc		GOSUB OutLibCodeText		ImportFcnTable(ptrCallWindowProc).ImportFcnUse=TRUE		OutBuf="invoke CallWindowProc,[!OldProc"+STR(ProcNum)+"],[!hwnd],[wmsg],[wparam],[lparam]"		GOSUB OutFunction		OutBuf="jmp !Finish"		GOSUB OutFunction		OutBuf=""		GOSUB OutFunction			ENDIFENDIFOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+TypeOffs],"+STR(ObjectTypeSafe+99)GOSUB OutCodeDataOutBuf="mov dword [edi+IDOffs],"+STR(ObjectID)GOSUB OutCodeDataOutBuf="mov eax,["+ObjectParent+"]"GOSUB OutCodeDataOutBuf="mov dword [edi+OwnerOffs],eax"GOSUB OutCodeDataIF GUIArrayFlag=0 THEN	OutBuf="mov dword [edi+ArrayOffs],0"	GOSUB OutCodeData	OutBuf="mov dword [edi+StatusOffs],$07"ELSE	OutBuf="mov eax,[ArrayIndex]"	GOSUB OutCodeData	OutBuf="mov dword [edi+ArrayOffs],eax"	GOSUB OutCodeData	OutBuf="mov dword [edi+StatusOffs],$27"ENDIFGOSUB OutCodeDataOutBuf="mov dword [edi+BackColorOffs],0"GOSUB OutCodeDataOutBuf="mov dword [edi+ForeColorOffs],0"GOSUB OutCodeDataOutBuf="mov dword [edi+ControlBrushOffs],0"GOSUB OutCodeDataImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUEOutBuf="invoke GetWindowLong,dword [edi+HandleOffs],GWL_WNDPROC"GOSUB OutCodeDataOutBuf="mov dword edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="mov dword [edi+InterceptSafeOffs],eax"GOSUB OutCodeDataConstructDone:OutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOTO MainLoopMsgBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSafGOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopWarningBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONWARNING"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopInfoBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONINFORMATION"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopQuestionBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONQUESTION"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopErrorBoxX:ErrGUIGOSUB GetStringOpErrMainVSymName=TSymNameCommaMainGOSUB GetStringOpErrMainCommaMainGOSUB NexTokenSELECT CASE TokenSaf	CASE "MB_OK"	CASE "MB_OKCANCEL"	CASE "MB_ABORTRETRYIGNORE" 	CASE "MB_YESNOCANCEL"	CASE "MB_YESNO"	CASE ELSE		ErrNo=ErrSyntaxEND SELECTImportFcnTable(ptrMessageBox).ImportFcnUse=TRUEOutBuf="invoke MessageBox,[!OBMain],["+TSymName+"],["+VSymName+"],"+TokenSaf+"+MB_ICONERROR"GOSUB OutCodeDataGOSUB SetStatusGOTO MainLoopSetStyleX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainCommaMainGOSUB NexTokenTempStr=TokenSafCommaMainGOSUB NexTokenIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrGetWindowLong).ImportFcnUse=TRUEOutBuf="invoke GetWindowLong, dword ["+HandleName+"],GWL_STYLE"GOSUB OutCodeDataSELECT CASE TokenBuf	CASE "true"		OutBuf="or eax,"+TempStr	CASE "false"		OutBuf="not eax"		GOSUB OutCodeData		OutBuf="or eax,"+TempStr		GOSUB OutCodeData		OutBuf="not eax"	CASE ELSE		ErrNo=ErrIVType		GOTO MainLoopEND SELECTGOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_STYLE,eax"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataGOTO MainLoopFindX:ErrGUIGOSUB NexTokenIF TokenBuf="." THEN	GOSUB NexToken	IF TokenBuf<>"notify" THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	TempStr="Find_notify"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	OutBuf="mov [FindEVPtr],"+TempStr	GOSUB OutInitCode	GOTO MainLoopELSE	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOTO MainLoopDestroyX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainINCR LabelNumOutBuf="bt dword [edi+StatusOffs],WinConstructed"GOSUB OutCodeDataOutBuf="jnc _Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="btr dword [edi+StatusOffs],WinConstructed"GOSUB OutCodeDataImportFcnTable(ptrDestroyWindow).ImportFcnUse=TRUEOutBuf="invoke DestroyWindow, dword ["+HandleName+"]"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOTO MainLoopShowX:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMain; finish thisGOTO MainLoopEndEventX:IF EventFlag=0 THEN	ErrNo=ErrEndEvent	GOTO MainLoopENDIFEventFlag=0ProcFcnFlag=0OutBuf="ret"GOSUB OutCodeDataGOTO MainLoopFindDialogX:ErrGUIFindReplace=0FindReplaceDialog:ErrGUIGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [fr_lpstrFindWhat],eax"GOSUB OutCodeDataOutBuf="mov eax,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="mov [fr_wFindWhatLen],ax"GOSUB OutCodeDataOutBuf="mov eax,[!hinstance]"GOSUB OutCodeDataOutBuf="mov [fr_hInstance],eax"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain]"GOSUB OutCodeDataOutBuf="mov [fr_hwndOwner],eax"GOSUB OutCodeDataIF FindReplace=0 THEN	OutBuf="mov [fr_Flags],FR_DOWN"	GOSUB OutCodeData	ImportFcnTable(ptrFindText).ImportFcnUse=TRUE	OutBuf="invoke FindText,fr_lStructSize"	GOSUB OutCodeDataELSE	CommaMain	GOSUB GetStringOp	ErrMain	OutBuf="mov eax,["+TSymName+"]"	GOSUB OutCodeData	OutBuf="mov [fr_lpstrReplaceWith],eax"	GOSUB OutCodeData	OutBuf="mov eax,["+TSymName+"+4]"	GOSUB OutCodeData	OutBuf="mov [fr_wReplaceWithLen],ax"	GOSUB OutCodeData	OutBuf="mov [fr_Flags],FR_DOWN"	GOSUB OutCodeData	ImportFcnTable(ptrReplaceText).ImportFcnUse=TRUE	OutBuf="invoke ReplaceText,fr_lStructSize"	GOSUB OutCodeDataENDIFGOSUB SetStatusIF FindReplaceFlag=0 THEN; How about the REPLACE case?	FindReplaceFlag=$ff	ImportFcnTable(ptrRegisterWindowMessage).ImportFcnUse=TRUE	OutBuf="invoke RegisterWindowMessage,FINDMSGSTRING"	GOSUB OutCodeData	OutBuf="mov [FindMsgID],eax"	GOSUB OutCodeData	ENDIFGOTO MainLoopReplaceDialogX:ErrGUIFindReplace=$ffGOTO FindReplaceDialogGOTO MainLoopColorDialogX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).DataType<>LONGVAR THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFImportFcnTable(ptrChooseColor).ImportFcnUse=TRUE	OutBuf="invoke ChooseColor,cc_lStructSize"GOSUB OutCodeDataINCR LabelNumOutBuf="or eax,eax"GOSUB OutCodeDataOutBuf="jne _Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="mov [cc_rgbResult],$ffffffff"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="mov eax,[cc_rgbResult]"GOSUB OutCodeDataOutBuf="mov ["+TokenSaf+"],eax"GOSUB OutCodeDataGOTO MainLoopFontDialogX:ErrGUIGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [cf_lpszStyle],eax"GOSUB OutCodeDataOutBuf="mov [cf_Flags],CF_SCREENFONTS"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain]"GOSUB OutCodeDataOutBuf="mov [cf_hwndOwner],eax"GOSUB OutCodeDataImportFcnTable(ptrChooseFont).ImportFcnUse=TRUEOutBuf="invoke ChooseFont,cf_lStructSize"GOSUB OutCodeDataGOTO MainLoopOpenDialogX:ErrGUIOpenSave=0OpenSaveDialog:ErrGUIGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [ofn_lpstrFile],eax"GOSUB OutCodeDataOutBuf="mov eax,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="mov [ofn_nMaxFile],eax"GOSUB OutCodeDataCommaMainGOSUB GetTextOpErrMainOutBuf="mov eax,"+TSymNameGOSUB OutCodeDataOutBuf="mov [ofn_lpstrFilter],eax"GOSUB OutCodeDataCommaMainGOSUB GetStringOpErrMainOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [ofn_lpstrInitialDir],eax"GOSUB OutCodeDataOutBuf="mov eax,[!hinstance]"GOSUB OutCodeDataOutBuf="mov [ofn_hInstance],eax"GOSUB OutCodeDataOutBuf="mov eax,[!OBMain]"GOSUB OutCodeDataOutBuf="mov [ofn_hwndOwner],eax"GOSUB OutCodeDataIF OpenSave=0 THEN	OutBuf="mov [ofn_Flags],OFN_FILEMUSTEXIST+OFN_PATHMUSTEXIST+OFN_HIDEREADONLY"	GOSUB OutCodeData	ImportFcnTable(ptrGetOpenFileName).ImportFcnUse=TRUE	OutBuf="invoke GetOpenFileName,ofn_lStructSize"	GOSUB OutCodeDataELSE	OutBuf="mov [ofn_Flags],OFN_OVERWRITEPROMPT"	GOSUB OutCodeData	ImportFcnTable(ptrGetSaveFileName).ImportFcnUse=TRUE	OutBuf="invoke GetSaveFileName,ofn_lStructSize"	GOSUB OutCodeDataENDIFGOSUB SetStatusGOTO MainLoopSaveDialogX:ErrGUIOpenSave=$ffGOTO OpenSaveDialogGOTO MainLoopPrintDialogX:ErrGUIGOTO MainLoopPageDialogX:ErrGUIGOTO MainLoopShowPopupX:ErrGUIGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFMenuTitleName=TokenSafCommaRetGOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetImportFcnTable(ptrTrackPopupMenuEx).ImportFcnUse=TRUEOutBuf="invoke TrackPopupMenuEx,["+MenuTitleName+"],TPM_LEFTALIGN+TPM_TOPALIGN,[_ArgSafe0],eax,[!OBMain],0"GOSUB OutCodeDataGOTO MainLoopPopupMenuX:ErrGUIGOSUB NexTokenIF TokenBuf="." THEN	GOSUB NexToken	IF TokenBuf<>"command" THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	TempStr="Menu_command"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	OutBuf="mov [MenuEVPtr],"+TempStr	GOSUB OutInitCode	GOTO MainLoopENDIFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).SubType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFMenuTitleName=TokenSafImportFcnTable(ptrCreatePopupMenu).ImportFcnUse=TRUEOutBuf="invoke CreatePopupMenu"GOSUB OutCodeDataOutBuf="mov ["+TokenSaf+"],eax"GOSUB OutCodeDataBEGIN LOOP	GOSUB MainLoopInit	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in MENU"		ErrNo=$ff		GOTO MainLoop	ENDIF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"	GOSUB Remark	GOSUB OutCodeData	GOSUB NexToken	SELECT CASE TokenBuf		CASE "menuitem"			GOSUB NexToken			GOSUB SymChk			IF SymbolOK=0 THEN				ErrNo=ErrIVSNam				GOTO MainLoop			ENDIF							SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				INCR MenuIDNum				GOSUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.DataSize=4				SymTemp.DataMod=ConstBit				SymTemp.Detail=MenuIDNum				GOSUB SymInsert				ErrMain				OutBuf=TokenSaf+" equ "+STR(MenuIDNum)				GOSUB OutDeclare			ELSE				ErrNo=ErrDupSym				GOTO MainLoop			ENDIF			CommaMain			GOSUB GetStringOp			ErrMain			MenuItemName=TSymName			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,"+STR(MenuIDNum)+",["+MenuItemName+"]"			GOSUB OutCodeData							CASE "cascade"			GOSUB NexToken		CASE "menuseparator"			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke AppendMenu,["+MenuTitleName+"],MF_SEPARATOR,0,0"			GOSUB OutCodeData		CASE "endmenu"			GOTO PopupMenuDone		CASE "end"			GOSUB NexToken			IF TokenBuf<>"menu" THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOTO PopupMenuDone		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop							END SELECTEND LOOPPopupMenuDone:GOTO MainLoopMenuX:ErrGUIMenuBarName=""MenuTitleName=""GOSUB NexTokenIF TokenBuf="." THEN	GOSUB NexToken	IF TokenBuf<>"command" THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	TempStr="Menu_command"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	OutBuf="mov [MenuEVPtr],"+TempStr	GOSUB OutInitCode	GOTO MainLoopENDIFSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFGOSUB GetSymTempIF SymTemp.DataType<>FORM AND SymTemp.DataType<>TOOLWINDOW THEN	ErrNo=ErrIVType	GOTO MainLoopENDIF	MenuWindowName="!"+SymTemp.SymNameBEGIN LOOP	GOSUB MainLoopInit	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in MENU"		ErrNo=$ff		GOTO MainLoop	ENDIF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"	GOSUB Remark	GOSUB OutCodeData	GOSUB NexToken	SELECT CASE TokenBuf		CASE "menubar"			GOSUB NexToken			MenuBarName=TokenSaf			SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=TRUE THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOSUB ClrDatTyp			SymTemp.DataType=MENU			GOSUB ClrSym			SymTemp.DataMod=0			SymTemp.Detail=0			GOSUB SymInsert			ErrMain			OutBuf=MenuBarName+" rd 1"			GOSUB OutUninitData			ImportFcnTable(ptrCreateMenu).ImportFcnUse=TRUE			OutBuf="invoke CreateMenu"			GOSUB OutCodeData			OutBuf="mov ["+MenuBarName+"],eax"			GOSUB OutCodeData		CASE "menutitle"			IF LEN(MenuBarName)=0 THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOSUB NexToken			MenuTitleName=TokenSaf			SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=TRUE THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOSUB ClrDatTyp			SymTemp.DataType=MENU			GOSUB ClrSym			SymTemp.DataMod=0			SymTemp.Detail=0			GOSUB SymInsert			ErrMain			OutBuf=MenuTitleName+" rd 1"			GOSUB OutUninitData			ImportFcnTable(ptrCreatePopupMenu).ImportFcnUse=TRUE			OutBuf="invoke CreatePopupMenu"			GOSUB OutCodeData			OutBuf="mov ["+MenuTitleName+"],eax"			GOSUB OutCodeData			CommaMain			GOSUB GetStringOp			ErrMain			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke AppendMenu,["+MenuBarName+"],MF_POPUP,["+MenuTitleName+"],["+TSymName+"]"			GOSUB OutCodeData		CASE "menuitem"			IF LEN(MenuTitleName)=0 THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOSUB NexToken			GOSUB SymChk			IF SymbolOK=0 THEN				ErrNo=ErrIVSNam				GOTO MainLoop			ENDIF							SymTemp.SymName=TokenSaf			GOSUB SymSrch			IF SymFound=FALSE THEN				INCR MenuIDNum				GOSUB ClrSym				SymTemp.DataType=LONGVAR				SymTemp.DataSize=4				SymTemp.DataMod=ConstBit				SymTemp.Detail=MenuIDNum				GOSUB SymInsert				ErrMain				OutBuf=TokenSaf+" equ "+STR(MenuIDNum)				GOSUB OutDeclare			ELSE				ErrNo=ErrDupSym				GOTO MainLoop			ENDIF			CommaMain			GOSUB GetStringOp			ErrMain			MenuItemName=TSymName			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke  AppendMenu,["+MenuTitleName+"],MF_STRING,"+STR(MenuIDNum)+",["+MenuItemName+"]"			GOSUB OutCodeData							CASE "cascade"			GOSUB NexToken		CASE "menuseparator"			ImportFcnTable(ptrAppendMenu).ImportFcnUse=TRUE			OutBuf="invoke AppendMenu,["+MenuTitleName+"],MF_SEPARATOR,0,0"			GOSUB OutCodeData		CASE "endmenu"			GOTO MenuDone		CASE "end"			GOSUB NexToken			IF TokenBuf<>"menu" THEN				ErrNo=ErrSyntax				GOTO MainLoop			ENDIF			GOTO MenuDone		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop							END SELECTEND LOOPMenuDone:ImportFcnTable(ptrSetMenu).ImportFcnUse=TRUEOutBuf="invoke SetMenu,["+MenuWindowName+"],["+MenuBarName+"]"GOSUB OutCodeDataGOTO MainLoopEndMenuX:TempStr="Fatal Error: EndMenu while not in menu"ErrNo=$ffGOTO MainLoopCheckMenuitemX:MenuOp=1MenuCommon:GOSUB NexTokenObjectName=TokenSafSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFGOSUB GetSymTempIF SymTemp.DataType<>MENU THEN	ErrNo=ErrIVType	GOTO MainLoopENDIFCommaMainGOSUB GetIntOpErrMainSELECT CASE MenuOp	CASE 1		ImportFcnTable(ptrCheckMenuItem).ImportFcnUse=TRUE		OutBuf="invoke CheckMenuItem,["+ObjectName+"],eax,MF_CHECKED+MF_BYCOMMAND"	CASE 2		ImportFcnTable(ptrCheckMenuItem).ImportFcnUse=TRUE		OutBuf="invoke CheckMenuItem,["+ObjectName+"],eax,MF_UNCHECKED+MF_BYCOMMAND"	CASE 3		ImportFcnTable(ptrEnableMenuItem).ImportFcnUse=TRUE		OutBuf="invoke EnableMenuItem,["+ObjectName+"],eax,MF_ENABLED+MF_BYCOMMAND"	CASE 4		ImportFcnTable(ptrEnableMenuItem).ImportFcnUse=TRUE		OutBuf="invoke EnableMenuItem,["+ObjectName+"],eax,MF_GRAYED+MF_BYCOMMAND"END SELECTGOSUB OutCodeDataGOTO MainLoopUncheckMenuitemX:ErrGUIMenuOp=2GOTO MenuCommonEnableMenuitemX:ErrGUIMenuOp=3GOTO MenuCommonDisableMenuitemX:ErrGUIMenuOp=4GOTO MenuCommonEnumX:GOSUB NexTokenEnumStep=1IF TokenLen<>0 THEN	EnumVal=VAL(TokenSaf)	GOSUB NexToken	IF TokenLen<>0 THEN		IF TokenBuf<>"step" THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO MainLoop		ENDIF		EnumStep=VAL(TokenSaf)	ENDIF	ENDIFBEGIN LOOP	GOSUB ReadSource	IF TempInt=0 THEN		TempStr="Fatal Error: EOF in Enum"		ErrNo=$ff		GOTO MainLoop	ENDIF	CONTINUE IF LEN(SrcLine)=0	CONTINUE IF LCASE(LEFT(SrcLine,1))="'"	CONTINUE IF LCASE(LEFT(SrcLine,3))="rem"	GOSUB NexToken	IF TokenBuf="endenum" THEN		GOTO MainLoop	ENDIF	IF TokenBuf="end" THEN		GOSUB NexToken		IF TokenBuf<>"enum" THEN			ErrNo=ErrSyntax		ENDIF		GOTO MainLoop	ENDIF	GOSUB SymChk	IF SymbolOK=0 THEN		ErrNo=ErrIVSNam		GOTO MainLoop	ENDIF					SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		GOSUB ClrSym		SymTemp.DataType=COMPVAR		SymTemp.DataSize=4		SymTemp.Detail=EnumVal		SymTemp.DataMod=0		GOSUB SymInsert		ErrMain		OutBuf=TokenSaf+" equ "+STR(EnumVal)		GOSUB OutDeclare	ELSE		ErrNo=ErrDupSym		GOTO MainLoop	ENDIF	EnumVal=EnumVal+EnumStepEND LOOPGOTO MainLoopEndEnumX:TempStr="Fatal Error: EndEnum while not in enum"ErrNo=$ffGOTO MainLoopCreateFontX:ErrGUIGOSUB ExprOp1Name=TSymNameOp1Mod=TDataModIF TSubType<>FONT THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFCommaMainGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF LAND(SymTable(SymNdx).DataMod,LogFontBit)=0 THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFImportFcnTable(ptrCreateFontIndirect).ImportFcnUse=TRUEOutBuf="invoke CreateFontIndirect,"+TokenSafGOSUB OutCodeDataIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"ENDIFGOSUB OutCodeDataGOTO MainLoopCreateCursorX:IconCursorFlag=FALSEGOTO CreateIconCursorCreateIconX:IconCursorFlag=TRUECreateIconCursor:ErrGUIGOSUB ExprOp1Name=TSymNameOp1Mod=TDataModIF TSubType<>ICON THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFCommaMainGOSUB NexTokenIF IconCursorFlag=TRUE THEN	TempStr=TokenSaf+".ico"	Opt="1"ELSE	TempStr=TokenSaf+".cur"	Opt="0"ENDIFON ERROR GOTO BadResourceFileOPEN BitMapFile,TempStr:READON ERROROutBuf="!"+Op1Name+":"GOSUB OutInitDataOutBuf=""GET BitMapFile,IconDirTempInt=IconDir.dwBytesInResTempStr=str(TempInt)I=0SEEK BitMapFile,IconDir.dwImageOffsetBEGIN LOOP	FOR J=1 TO 32		INCR I		IF I>TempInt THEN			IF OutBuf<>"" THEN				GOSUB OutInitData			ENDIF			GOTO CreateIcon1		ENDIF		GET BitMapFile,AsciiByte		TempName=HEX(AsciiByte)		IF LEN(TempName)=1 THEN			TempStr="$0"+TempName		ELSE			TempStr="$"+TempName		ENDIF		IF J=1 THEN			OutBuf=OutBuf+" db "+TempStr		ELSE			OutBuf=OutBuf+","+TempStr		ENDIF						NEXT J	GOSUB OutInitData	OutBuf=""END LOOPCreateIcon1:CLOSE BitMapFileImportFcnTable(ptrCreateIconFromResource).ImportFcnUse=TRUEOutBuf="invoke CreateIconFromResource,!"+Op1Name+","+STR(TempInt)+","+Opt+",$30000"GOSUB OutCodeDataIF LAND(Op1Mod,VectorBit)=0 THEN	OutBuf="mov ["+Op1Name+"],eax"ELSE	OutBuf="mov edi,["+Op1Name+"]"	GOSUB OutCodeData	OutBuf="mov [edi],eax"ENDIFGOSUB OutCodeDataGOTO MainLoopBadResourceFile:TempStr="Fatal Error: Icon File does not exist"ErrNo=$ffGOTO MainLoopCreateBitMapX:ErrGUIGOTO MainLoopPassSystemEventX:ErrGUIOutBuf="mov [!PassSystemEvent],1"GOSUB OutCodeDataGOTO MainLoopPassInterceptEventX:ErrGUIOutBuf="mov [!PassInterceptEvent],1"GOSUB OutCodeDataGOTO MainLoopReadCardX:' READCARD Buffer,NumBytesImportFcnTable(ptrCSMGetDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMGetDriveHandle, [DriverName], DriverHandle, 1"GOSUB OutCodeData' Get and test status, set STATUS to -1 if badImportFcnTable(ptrCSMReadBlock).ImportFcnUse=TRUEOutBuf="invoke CSMReadBlock,[DriverHandle],0,2,0,CardBuf,262144"GOSUB OutCodeDataGOSUB SetStatusImportFcnTable(ptrCSMReleaseDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMReleaseDriveHandle,[DriverHandle]"GOSUB OutCodeDataGOTO MainLoopWriteCardX:' WRITECARD Buffer,NumBytesImportFcnTable(ptrCSMGetDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMGetDriveHandle, [DriverName], DriverHandle, 1"GOSUB OutCodeData' Get and test status, set STATUS to -1 if badImportFcnTable(ptrCSMWriteBlock).ImportFcnUse=TRUEOutBuf="invoke CSMWriteBlock,[DriverHandle],0,2,96,0,CardBuf,0,262144"GOSUB OutCodeDataGOSUB SetStatusImportFcnTable(ptrCSMReleaseDriveHandle).ImportFcnUse=TRUEOutBuf="invoke CSMReleaseDriveHandle,[DriverHandle]"GOSUB OutCodeDataGOTO MainLoopUseImportX:GOSUB NexTokenFOR I=1 TO LastImportFcn	IF ImportFcnTable(I).ImportFcnAlias=TokenSaf THEN		ImportFcnTable(I).ImportFcnUse=TRUE		GOTO MainLoop	ENDIFNEXT IErrNo=ErrUDSymGOTO MainLoopImportFunctionX:GOTO MainLoopExportFunctionX:GOTO MainLoopFindItemX:MsgName=""FindItem1:ErrGUIGUITargetFlag=$ffGOSUB ValidateObjectErrMainSELECT CASE ObjectType	CASE LISTBOX		FcnName="LB"	CASE COMBOBOX		FcnName="CB"	CASE ELSE		ErrNo=ErrIVType		GOTO MainLoopEND SELECTCommaMainGOSUB GetIntOpErrMainCommaMainGOSUB GetStringOpErrMainOutBuf="invoke SendMessage, dword ["+HandleName+"],"+FcnName+"_FINDSTRING"+MsgName+",eax,["+TSymName+"]"GOSUB OutCodeDataIncArrayNdxGOSUB SetStatusCommaMainGOSUB NexTokenSELECT CASE TokenBuf	CASE "yes"		DecArrayNdx		OutBuf="invoke SendMessage, dword ["+HandleName+"],"+FcnName+"_SETCURSEL,eax,0"		GOSUB OutCodeData	CASE "no"	CASE ELSE		ErrNo=ErrSyntax		GOTO MainLoopEND SELECTGOTO MainLoopFindItemExactX:MsgName="EXACT"GOTO FindItem1GOTO MainLoop; OBJECT ObjectName AS ObjectType IN ParentObject;	EXSTYLE=ExStyle;	STYLE=Style;	LEFT=LeftPos;	TOP=TopPos;	WIDTH=Width;	HEIGHT=Height;	ZORDER=ZOrder;	ENABLED=Enabled;	VISIBLE=Visible;	BACKCOLOR=BackColor;	FORECOLOR=ForeColor;	TEXT="Text";	VALUE=Value;	TOOLTIP="ToolTip"	; END OBJECT; OBJECT ObjectName(ArraySize) AS ObjectType IN ParentObject;	EXSTYLE(n)=ExStyle;	STYLE(n)=Style;	LEFT(n)=LeftPos;	TOP(n)=TopPos;	WIDTH(n)=Width;	HEIGHT(n)=Height;	ZORDER(n)=ZOrder;	ENABLED(n)=Enabled;	VISIBLE(n)=Visible;	BACKCOLOR(n)=BackColor;	FORECOLOR(n)=ForeColor;	TEXT(n)="Text";	VALUE(n)=Value;	TOOLTIP(n)="ToolTip"; END OBJECTObjectX:GOSUB NexTokenGOTO MainLoopEndObjectX:TempStr="Fatal Error: ENDOBJECT while not in OBJECT"ErrNo=$ffGOTO MainLoopAssemblyX:StartFlag=TRUEOutBuf=SrcLineGOSUB OutCodeDataGOTO MainLoopErrorTbl: DATA "Undefined symbol"; ErrUDSymDATA "Invalid symbol name"; ErrIVSNamDATA "Type mismatch or wrong type"; ErrTypMisDATA "Invalid Expression"; ErrIVExpDATA "Syntax Error"; ErrSyntaxDATA "Symbol already defined"; ErrDupSymDATA "Symbol table full"; ErrSymFulDATA "Undefined Function"; ErrUDFcnDATA "Invalid data type"; ErrIVTypeDATA "Invalid data type modifier"; ErrIVModDATA "Macro argument error"; ErrMacArgDATA "Invalid directive"; ErrIVDirDATA "Macro already defined"; ErrDupMacDATA "Undefined Error"; ErrEndStrDATA "Nested macro"; ErrMacNstDATA "Macro buffer full"; ErrMacBufDATA "Invalid macro"; ErrIVMacDATA "ENDMACRO without MACRO";  ErrEndmDATA "Unbalanced control structure"; ErrUBConDATA "Nested too deep"; ErrNDeepDATA "Illegal Declaration inside Function or Subroutine"; ErrDecFcnDATA "Invalid parameter"; ErrIVParmDATA "Parameter Statement out of Place"; ErrErrParmDATA "Expression too complex"; ErrCpxExpDATA "Invalid function";  ErrIVFuncDATA "No more temps available"; ErrTmpUseDATA "Unbalanced parens"; ErrParenDATA "Function error"; ErrFcnDATA "Invalid target"; ErrIVTargDATA "Function/Subroutine/Procedure/Event nested"; ErrFSNestDATA "Undefined Error"; ErrTblArrDATA "ENDFUNCTION statement not in function"; ErrEndFcnDATA "Array subscript error"; ErrArrSubDATA "ENDPROCEDURE statement not in procedure"; ErrEndProcDATA "ENDTABLE without TABLE"; ErrEndTblDATA "Undefined Error"; ErrTblArgsDATA "Wrong number of args in procedure or function"; ErrFcnArgsDATA "TYPE statement inside procedure or function"; ErrTypeFcnDATA "Duplicate event"; ErrDupEventDATA "Invalid property, event, or style"; ErrIVPropDATA "ENDEVENT statement not in procedure"; ErrEndEventDATA "Operand value is out of range for data type specified"; ErrOpRangeDATA "Text arrays not allowed"; ErrTextArrayDATA "Text already defined"; ErrTextDefinedDATA "Text not defined"; ErrTextNotDefinedRunStringTbl: DATA "_IOBuffer",_BufSizeDATA "_PrintBuf",_BufSizeDATA "_NullStr",1DATA "_CRLF",2DATA "_Prompt",1DATA "_ConvBuf",32DATA "_ConvBuf1",32DATA "ProgramName",28DATA "_SwitchStr",_BufSizeDATA "%",0RunVarTbl: DATA "_FltArgSafe0 rf 1"DATA "_FltArgSafe1 rf 1"DATA "_FloatRet rf 1"DATA "_LoopCtr rd 10"DATA "!hinstance rd 1"DATA "!dc rd 1"DATA "_InHandle rd 1"DATA "_OutHandle rd 1"DATA "_IOPthNum rd 1"DATA "_XferAddr rd 1"DATA "_PUArgs rd 15"DATA "_ArgList rd 1"DATA "_ArgNum rd 1"DATA "_Poker rd 1"DATA "_DummyArg rd 1"DATA "_FcnArg1 rd 1"DATA "_FcnArg2 rd 1"DATA "_FcnArg3 rd 1"DATA "_FcnArg4 rd 1"DATA "_FcnArg5 rd 1"DATA "_FcnArg6 rd 1"DATA "_FcnArg7 rd 1"DATA "_LongRet rd 1"DATA "_StringRet rd 3"DATA "_ArgSafe0 rd 1"DATA "_ArgSafe1 rd 1"DATA "_ArgSafe2 rd 1"DATA "_ArgSafe3 rd 1"DATA "!FileHandle rd 1"DATA "!FilBufAdr rd 1"DATA "!FilBufSiz rd 1"DATA "_SwitchInt rd 1"DATA "__ByteCounter rd 1"DATA "_PrtPthNum rd 1"DATA "_DataPtr rd 1"DATA "_Decimals rw 1"DATA "_Digits rw 1"DATA "_BoolRet rb 1"DATA "!PassSystemEvent rb 1"DATA "!PassInterceptEvent rb 1"DATA "%"PreDefTbl: DATA "{",OPER,0,0,0,0DATA "}",OPER,0,0,0,0DATA "[",OPER,0,0,0,0DATA "]",OPER,0,0,0,0DATA "(",OPER,0,0,0,0DATA ")",OPER,0,0,0,0DATA "=",OPER,0,0,0,0DATA "<",OPER,0,0,0,0DATA ">",OPER,0,0,0,0DATA "<=",OPER,0,0,0,0DATA ">=",OPER,0,0,0,0DATA "<>",OPER,0,0,0,0DATA ".",OPER,0,0,0,0DATA ",",OPER,0,0,0,0DATA "+",OPER,0,0,0,0DATA "-",OPER,0,0,0,0DATA "*",OPER,0,0,0,0DATA "/",OPER,0,0,0,0DATA "~",OPER,4,0,0,0DATA "_NullStr",STRINGVAR,VectorBit,0,0,0DATA "0x0",LONGVAR,ConstBit,0,0,4DATA "<",OPER,0,0,0,0DATA ">",OPER,0,0,0,0DATA "(",OPER,0,0,0,0DATA ")",OPER,0,0,0,0DATA "*",OPER,0,0,0,0DATA "",OPER,0,0,0,0DATA "true",BOOLVAR,4,1,0,1DATA "false",BOOLVAR,4,0,0,1DATA "eof",FCN,0,1,0,0DATA "len",FCN,0,2,0,0DATA "str$",FCN,0,3,0,0DATA "val",FCN,0,4,0,0DATA "land",FCN,0,5,0,0DATA "mid$",FCN,0,6,0,0DATA "lor",FCN,0,7,0,0DATA "left$",FCN,0,8,0,0DATA "mod",FCN,0,9,0,0DATA "chr$",FCN,0,10,0,0DATA "right$",FCN,0,11,0,0DATA "asc",FCN,0,12,0,0DATA "not",FCN,0,13,0,0DATA "bufadr",FCN,0,14,0,0DATA "bufsiz",FCN,0,15,0,0DATA "tab",FCN,0,16,0,0DATA "peek",FCN,0,17,0,0DATA "addr",FCN,0,18,0,0DATA "lxor",FCN,0,19,0,0DATA "lnot",FCN,0,20,0,0DATA "index",FCN,0,21,0,0DATA "size",FCN,0,22,0,0DATA "ival",FCN,0,23,0,0DATA "fval",FCN,0,24,0,0DATA "trim$",FCN,0,25,0,0DATA "filsiz",FCN,0,26,0,0DATA "filpos",FCN,0,27,0,0DATA "sqr",FCN,0,28,0,0DATA "int",FCN,0,29,0,0DATA "abs",FCN,0,30,0,0DATA "sin",FCN,0,31,0,0DATA "cos",FCN,0,32,0,0DATA "tan",FCN,0,33,0,0DATA "asn",FCN,0,34,0,0DATA "acs",FCN,0,35,0,0DATA "atn",FCN,0,36,0,0DATA "log",FCN,0,37,0,0DATA "log10",FCN,0,38,0,0DATA "!Vacant",FCN,0,39,0,0DATA "!Vacant",FCN,0,40,0,0DATA "thour",FCN,0,41,0,0DATA "tmin",FCN,0,42,0,0DATA "tsec",FCN,0,43,0,0DATA "tyear",FCN,0,44,0,0DATA "tmon",FCN,0,45,0,0DATA "tdat",FCN,0,46,0,0DATA "tday",FCN,0,47,0,0DATA "chkword",FCN,0,48,0,0DATA "hex$",FCN,0,49,0,0DATA "bittst",FCN,0,50,0,0DATA "shl",FCN,0,51,0,0DATA "shr",FCN,0,52,0,0DATA "rol",FCN,0,53,0,0DATA "ror",FCN,0,54,0,0DATA "bitchg",FCN,0,55,0,0DATA "bitclr",FCN,0,56,0,0DATA "bitset",FCN,0,57,0,0DATA "substr",FCN,0,56,0,0DATA "zstr$",FCN,0,59,0,0DATA "zhex$",FCN,0,60,0,0DATA "using",FCN,0,61,0,0DATA "ERR",LONGVAR,0,0,0,4DATA "_BufSize",0,0,0,0,0DATA "POS",LONGVAR,0,0,0,4DATA "_DummyArg",LONGVAR,0,0,0,4DATA "OBMain",FORM,0,0,0,0DATA "_IOBuffer",STRINGVAR,VectorBit,_BufSize,_BufSize,_BufSizeDATA "_PrintBuf",STRINGVAR,VectorBit,_BufSize,_BufSize,_BufSizeDATA "NMHDR",LONGVAR,0,0,0,4DATA "_Digits",WORDVAR,0,0,0,2DATA "_Decimals",WORDVAR,0,0,0,2DATA "STATUS",LONGVAR,0,0,0,4DATA "_ArgSafe0",LONGVAR,0,0,0,4DATA "_ArgSafe1",LONGVAR,0,0,0,4DATA "_IOPthNum",LONGVAR,0,0,0,4DATA "EventNotify",WORDVAR,0,0,0,2DATA "EventID",WORDVAR,0,0,0,2DATA "_IOBufPtr",LONGVAR,0,0,0,4DATA "MenuID",LONGVAR,0,0,0,4DATA "Menu",LONGVAR,0,0,0,4DATA "_DataPtr",LONGVAR,0,0,0,4DATA "ProgramName",STRINGVAR,VectorBit,28,28,28DATA "ArrNdx",LONGVAR,0,0,0,4DATA "_ConvBuf",STRINGVAR,VectorBit,32,32,32DATA "FLAGS",LONGVAR,0,0,0,4DATA "_ConvBuf1",STRINGVAR,VectorBit,32,32,32DATA "!Vacant",VOIDX,0,0,0,0DATA "_Tmp1",LONGVAR,TempBit,0,0,4DATA "_Tmp2",LONGVAR,TempBit,0,0,4DATA "_Tmp3",LONGVAR,TempBit,0,0,4DATA "_Tmp4",LONGVAR,TempBit,0,0,4DATA "_Tmp5",LONGVAR,TempBit,0,0,4DATA "_Tmp6",LONGVAR,TempBit,0,0,4DATA "_Tmp7",LONGVAR,TempBit,0,0,4DATA "_Tmp8",LONGVAR,TempBit,0,0,4DATA "_Tmp9",LONGVAR,TempBit,0,0,4DATA "_Tmp10",LONGVAR,TempBit,0,0,4DATA "_Tmp11",LONGVAR,TempBit,0,0,4DATA "_Tmp12",LONGVAR,TempBit,0,0,4DATA "_Tmp13",LONGVAR,TempBit,0,0,4DATA "_Tmp14",LONGVAR,TempBit,0,0,4DATA "_Tmp15",LONGVAR,TempBit,0,0,4DATA "_TmpVec1",VOIDX,TmpVec,0,0,12DATA "_TmpVec2",VOIDX,TmpVec,0,0,12DATA "_TmpVec3",VOIDX,TmpVec,0,0,12DATA "_TmpVec4",VOIDX,TmpVec,0,0,12DATA "_TmpVec5",VOIDX,TmpVec,0,0,12DATA "_TmpVec6",VOIDX,TmpVec,0,0,12DATA "_TmpVec7",VOIDX,TmpVec,0,0,12DATA "_TmpVec8",VOIDX,TmpVec,0,0,12DATA "_TmpVec9",VOIDX,TmpVec,0,0,12DATA "_TmpVec10",VOIDX,TmpVec,0,0,12DATA "_TmpVec11",VOIDX,TmpVec,0,0,12DATA "_TmpVec12",VOIDX,TmpVec,0,0,12DATA "_TmpVec13",VOIDX,TmpVec,0,0,12DATA "_TmpVec14",VOIDX,TmpVec,0,0,12DATA "_TmpVec15",VOIDX,TmpVec,0,0,12DATA "&",9,0,0,0,0DATA "|",9,0,0,0,0DATA "0BUGBUG",FLOATVAR,ConstBit,0,0,8DATA "NextArg",6,TmpVec,0,0,0DATA "XferCount",4,0,0,0,0DATA "_FTmp1",FLOATVAR,0,0,0,8DATA "_FTmp2",FLOATVAR,0,0,0,8DATA "_FTmp3",FLOATVAR,0,0,0,8DATA "_FTmp4",FLOATVAR,0,0,0,8DATA "_FTmp5",FLOATVAR,0,0,0,8DATA "_FTmp6",FLOATVAR,0,0,0,8DATA "_FTmp7",FLOATVAR,0,0,0,8DATA "_FTmp8",FLOATVAR,0,0,0,8DATA "_FTmp9",FLOATVAR,0,0,0,8DATA "_FTmp10",FLOATVAR,0,0,0,8DATA "_FTmp11",FLOATVAR,0,0,0,8DATA "_FTmp12",FLOATVAR,0,0,0,8DATA "_FTmp13",FLOATVAR,0,0,0,8DATA "_FTmp14",FLOATVAR,0,0,0,8DATA "_FTmp15",FLOATVAR,0,0,0,8DATA "TRUE",BOOLVAR,ConstBit,1,0,1DATA "True",BOOLVAR,ConstBit,1,0,1DATA "FALSE",BOOLVAR,ConstBit,0,0,1DATA "False",BOOLVAR,ConstBit,0,0,1DATA "sal",FCN,0,62,0,0DATA "sar",FCN,0,63,0,0DATA "rcl",FCN,0,64,0,0DATA "rcr",FCN,0,65,0,0DATA "tablesize",FCN,0,66,0,0DATA "filtyp",FCN,0,67,0,0DATA "curdir",FCN,0,68,0,0DATA "bin$",FCN,0,69,0,0DATA "oct$",FCN,0,70,0,0DATA "!Vacant",FCN,0,71,0,0DATA "rnd",FCN,0,72,0,0DATA "gettickcount",FCN,0,73,0,0DATA "!Vacant",FCN,0,74,0,0DATA "!Vacant",FCN,0,75,0,0DATA "!Vacant",FCN,0,76,0,0DATA "!Vacant",FCN,0,77,0,0DATA "lcase$",FCN,0,78,0,0DATA "ucase$",FCN,0,79,0,0DATA "tail$",FCN,0,80,0,0DATA "findaddr",FCN,0,81,0,0DATA "findoffs",FCN,0,82,0,0DATA "ArrayIndex",LONGVAR,0,0,0,4DATA "_BoolRet",BOOLVAR,0,0,0,1DATA "_LongRet",LONGVAR,0,0,0,4DATA "_StringRet",STRINGVAR,VectorBit,0,0,0DATA "_FloatRet",FLOATVAR,0,0,0,8DATA "!Timer",TIMER,0,0,0,4DATA "Timer1",TIMER,0,0,0,4DATA "Timer2",TIMER,0,0,0,4DATA "Timer3",TIMER,0,0,0,4DATA "Timer4",TIMER,0,0,0,4DATA "Timer5",TIMER,0,0,0,4DATA "Timer6",TIMER,0,0,0,4DATA "Timer7",TIMER,0,0,0,4DATA "Timer8",TIMER,0,0,0,4DATA "Timer9",TIMER,0,0,0,4DATA "Timer10",TIMER,0,0,0,4DATA "Timer11",TIMER,0,0,0,4DATA "Timer12",TIMER,0,0,0,4DATA "Timer13",TIMER,0,0,0,4DATA "Timer14",TIMER,0,0,0,4DATA "Timer15",TIMER,0,0,0,4DATA "Timer16",TIMER,0,0,0,4DATA "Timer17",TIMER,0,0,0,4DATA "Timer18",TIMER,0,0,0,4DATA "Timer19",TIMER,0,0,0,4DATA "Timer20",TIMER,0,0,0,4DATA "Timer21",TIMER,0,0,0,4DATA "Timer22",TIMER,0,0,0,4DATA "Timer23",TIMER,0,0,0,4DATA "Timer24",TIMER,0,0,0,4DATA "Timer25",TIMER,0,0,0,4DATA "Timer26",TIMER,0,0,0,4DATA "Timer27",TIMER,0,0,0,4DATA "Timer28",TIMER,0,0,0,4DATA "Timer29",TIMER,0,0,0,4DATA "Timer30",TIMER,0,0,0,4DATA "Timer31",TIMER,0,0,0,4DATA "Timer32",TIMER,0,0,0,4DATA "str",FCN,0,3,0,0DATA "mid",FCN,0,6,0,0DATA "left",FCN,0,8,0,0DATA "chr",FCN,0,10,0,0DATA "right",FCN,0,11,0,0DATA "trim",FCN,0,25,0,0DATA "hex",FCN,0,49,0,0DATA "zstr",FCN,0,59,0,0DATA "zhex",FCN,0,60,0,0DATA "bin",FCN,0,69,0,0DATA "oct",FCN,0,70,0,0DATA "lcase",FCN,0,78,0,0DATA "ucase",FCN,0,79,0,0DATA "tail",FCN,0,80,0,0DATA "LOGFONT",TYPE,0,14,0,60DATA "lfHeight",LONGVAR,0,0,0,4DATA "lfWidth",LONGVAR,0,0,0,4DATA "lfEscapement",LONGVAR,0,0,8,4DATA "lfOrientation",LONGVAR,0,0,12,4DATA "lfWeight",LONGVAR,0,0,16,4DATA "lfItalic",BYTEVAR,0,0,20,1DATA "lfUnderline",BYTEVAR,0,21,0,1DATA "lfStrikeOut",BYTEVAR,0,22,0,1DATA "lfCharSet",BYTEVAR,0,0,23,1DATA "lfOutPrecision",BYTEVAR,0,0,24,1DATA "lfClipPrecision",BYTEVAR,0,0,25,1DATA "lfQuality",BYTEVAR,0,0,26,1DATA "lfPitchAndFamily",BYTEVAR,0,0,27,1DATA "lfFaceName",STRINGVAR,0,32,28,32DATA "GridRow",LONGVAR,0,0,0,4DATA "GridCol",LONGVAR,0,0,0,4DATA "EditcpMin",LONGVAR,0,0,0,4DATA "EditcpMax",LONGVAR,0,0,0,4DATA "EditSelType",WORDVAR,0,0,0,4DATA "EditLine",LONGVAR,0,0,0,4DATA "EditcpLine",LONGVAR,0,0,0,4DATA "EditlpLine",LONGVAR,0,0,0,4DATA "EditnLines",LONGVAR,0,0,0,4DATA "EditnHidden",LONGVAR,0,0,0,4DATA "EditfChanged",LONGVAR,0,0,0,4DATA "EditnPage",LONGVAR,0,0,0,4DATA "EditnWordGroup",LONGVAR,0,0,0,4DATA "ft_SearchMin",LONGVAR,0,0,0,4DATA "ft_SearchMax",LONGVAR,0,0,0,4DATA "ft_SearchTextPtr",LONGVAR,0,0,0,4DATA "fr_lpstrFindWhat",LONGVAR,0,0,0,4DATA "ft_FoundMin",LONGVAR,0,0,0,4DATA "ft_FoundMax",LONGVAR,0,0,0,4DATA "cr_cpMin",LONGVAR,0,0,0,4DATA "cr_cpMax",LONGVAR,0,0,0,4DATA "SC_CLOSE",LONGVAR,ConstBit,61536,0,4DATA "SC_MINIMIZE",LONGVAR,ConstBit,61472,0,4DATA "SC_MAXIMIZE",LONGVAR,ConstBit,61488,0,4DATA "SC_RESTORE",LONGVAR,ConstBit,61728,0,4DATA "wmsg",LONGVAR,0,0,0,4DATA "wparam",LONGVAR,0,0,0,4DATA "lparam",LONGVAR,0,0,0,4DATA "ncode",LONGVAR,0,0,0,4DATA "WM_MOUSEMOVE",LONGVAR,ConstBit,512,0,4DATA "WM_LBUTTONDOWN",LONGVAR,ConstBit,513,0,4DATA "WM_LBUTTONUP",LONGVAR,ConstBit,514,0,4DATA "WM_RBUTTONDOWN",LONGVAR,ConstBit,516,0,4DATA "WM_RBUTTONUP",LONGVAR,ConstBit,517,0,4DATA "MK_LBUTTON",LONGVAR,ConstBit,1,0,4DATA "MK_RBUTTON",LONGVAR,ConstBit,2,0,4DATA "MK_SHIFT",LONGVAR,ConstBit,4,0,4DATA "MK_CONTROL",LONGVAR,ConstBit,8,0,4DATA "MK_MBUTTON",LONGVAR,ConstBit,16,0,4DATA "CursorPosX",LONGVAR,0,0,0,4DATA "CursorPosY",LONGVAR,0,0,0,4DATA "RectLeft",LONGVAR,0,0,0,4DATA "RectTop",LONGVAR,0,0,0,4DATA "RectRight",LONGVAR,0,0,0,4DATA "RectBottom",LONGVAR,0,0,0,4DATA "IDOK",LONGVAR,ConstBit,1,0,4DATA "IDCANCEL",LONGVAR,ConstBit,2,0,4DATA "IDABORT",LONGVAR,ConstBit,3,0,4DATA "IDRETRY",LONGVAR,ConstBit,4,0,4DATA "IDIGNORE",LONGVAR,ConstBit,5,0,4DATA "IDYES",LONGVAR,ConstBit,6,0,4DATA "IDNO",LONGVAR,ConstBit,7,0,4DATA "IDCLOSE",LONGVAR,ConstBit,8,0,4DATA "IDHELP",LONGVAR,ConstBit,9,0,4DATA "ZTOP",LONGVAR,ConstBit,0,0,4DATA "ZBOTTOM",LONGVAR,ConstBit,1,0,4DATA "ZTOPMOST",LONGVAR,ConstBit,4294967295,0,4DATA "ZNOTOPMOST",LONGVAR,ConstBit,4294967294,0,4DATA "%"Finish:IF InpFilPtr>1 THEN	CLOSE InpFile(InpFilPtr)	DECR InpFilPtr	GOTO MainLoopENDIFGOSUB ChkUseCLOSE InpFile(InpFilPtr)IF LastStmt="data" THEN	DataFlag=FALSEENDIFIF LastStmt<>"end" THEN	OutBuf=""	GOSUB OutCodeData	OutBuf="; Automatic END statement"	GOSUB OutCodeData	IF GUIFlag=0 THEN		OutBuf="xor eax,eax"		GOSUB OutCodeData		ImportFcnTable(ptrExitProcess).ImportFcnUse=TRUE		OutBuf="invoke ExitProcess, eax"		GOSUB OutCodeData	ELSE		ImportFcnTable(ptrDeleteObject).ImportFcnUse=TRUE		OutBuf="invoke DeleteObject,[!Brush]"		GOSUB OutCodeData		ImportFcnTable(ptrPostMessage).ImportFcnUse=TRUE		OutBuf="invoke PostMessage,[!OBMain],WM_CLOSE,0,0"		GOSUB OutCodeData	ENDIFENDIFOutBuf="_ErrExit:"GOSUB OutCodeImportFcnTable(ptrputs).ImportFcnUse=TRUEOutBuf="cinvoke puts,_ErrExitMsg"GOSUB OutCode	OutBuf="mov eax,[ERR]"GOSUB OutCodeDataImportFcnTable(ptrExitProcess).ImportFcnUse=TRUEOutBuf="invoke ExitProcess, eax"GOSUB OutCodeDataOutBuf="; End of Declaration Section"GOSUB OutDeclareCLOSE DeclareFileOutBuf="!ObjectCount dd "+STR(ObjectCtr)GOSUB OutInitDataOutBuf="; End of Initialized Data Section"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataOutBuf="; Start of Uninitialized Data Section"GOSUB OutInitDataOutBuf=""GOSUB OutInitDataCLOSE DataFileOutBuf="; End of Uninitialized Data Section"GOSUB OutUninitDataOutBuf=""GOSUB OutUninitDataOutBuf="; Start of Control Descriptor Section"GOSUB OutUninitDataCLOSE DimFileCLOSE DescFileCLOSE PreCodeFileOutBuf="; End of Code Section"GOSUB OutCodeCLOSE CodeFileOutBuf="ret"GOSUB OutInitCodeOutBuf="; End of Init Section"GOSUB OutInitCodeCLOSE InitFileOutBuf="; End of Function Section"GOSUB OutFunctionCLOSE FunctionFileOutBuf="; End of Export Section"GenExportCLOSE ExportFileCLOSE ResourceFileON ERROR GOTO NoCFileDELETE BareFileName+".asm"NoCFile:ON ERROR;******;TempStr=STR(BasicLineCtr)+" OmniBasic lines compiled to "+STR(AsmLineCtr)+" Assembler lines";GOSUB OutPrint;TempStr="";GOSUB OutPrint AsmFileName=BareFileName+".asm"CREATE OutFile,AsmFileName:WRITE+BINARYOPEN DeclareFile,"_DeclareFile":READ+BINARYFilBufSiz=FILSIZ(DeclareFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DeclareFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DeclareFileDELETE "_DeclareFile"RESTORE IncludesOutBuf=""WRITE OutFile,OutBufOutBuf="; Library Section"WRITE OutFile,OutBufOutBuf=""WRITE OutFile,OutBufBEGIN LOOP	READ OutBuf	EXITIF OutBuf="ENDTEXT"	WRITE OutFile,OutBuf	INCR AsmLineCtrEND LOOPOutBuf=""WRITE OutFile,OutBufOutBuf="section '.idata' import data readable writeable"WRITE OutFile,OutBufOutBuf=""WRITE OutFile,OutBufFOR I=1 TO LastImportLib; Find last fcn for each Lib	TempInt=0	FOR J=1 TO LastImportFcn		IF ImportFcnTable(J).ImportFcnUse=TRUE AND ImportFcnTable(J).ImportLibUseNdx=I THEN			TempInt=J		ENDIF			NEXT J	IF TempInt<>0 THEN		ImportFcnTable(TempInt).ImportFcnLastUsed=TRUE	ENDIFNEXT IFOR I=1 TO LastImportFcn; Mark each Lib used as used	IF ImportFcnTable(I).ImportFcnUse=TRUE THEN		TempInt=ImportFcnTable(I).ImportLibUseNdx		ImportLibTable(TempInt).ImportLibUse=TRUE	ENDIFNEXT ITempInt=0; Find last Lib usedFOR I=1 TO LastImportLib	IF ImportLibTable(I).ImportLibUse=TRUE THEN		TempInt=I	ENDIF		NEXT IImportLibTable(TempInt).ImportLibLastUsed=TRUEOutBuf="library "; Output the Lib SectionFOR I=1 TO LastImportLib	IF ImportLibTable(I).ImportLibUse=TRUE THEN		OutBuf=OutBuf+ImportLibTable(I).ImportLibAlias+","+CHR(OBQUOTE)+ImportLibTable(I).ImportLibName+CHR(OBQUOTE)		IF ImportLibTable(I).ImportLibLastUsed=FALSE THEN			OutBuf=OutBuf+CHR$($2c)+CHR$($5c)		ENDIF		WRITE OutFile,OutBuf		OutBuf="        "	ENDIFNEXT IOutBuf=""WRITE OutFile,OutBufFOR I=1 TO LastImportLib; Output the Fcn lists	TempStr="import"	IF ImportLibTable(I).ImportLibUse=TRUE THEN		OutBuf=ImportLibTable(I).ImportLibAlias+":"		WRITE OutFile,OutBuf		FOR J=1 TO LastImportFcn			OutBuf=CHR$($09)+TempStr+CHR$($09)			IF ImportFcnTable(J).ImportLibUseNdx=I AND ImportFcnTable(J).ImportFcnUse=TRUE THEN				OutBuf=OutBuf+ImportFcnTable(J).ImportFcnAlias+CHR$($2c)+CHR(OBQUOTE)+ImportFcnTable(J).ImportFcnName+CHR(OBQUOTE)				IF ImportFcnTable(J).ImportFcnLastUsed=FALSE THEN					OutBuf=OutBuf+CHR$($2c)+CHR$($5c)				ENDIF				WRITE OutFile,OutBuf				TempStr=""			ENDIF		NEXT J	ENDIFNEXT IOutBuf=""WRITE OutFile,OutBufOutBuf="; End of Library Section"WRITE OutFile,OutBufOutBuf=""WRITE OutFile,OutBufOPEN DataFile,"_DataFile":READ+BINARYFilBufSiz=FILSIZ(DataFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DataFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DataFileDELETE "_DataFile"OPEN DimFile,"_DimFile":READ+BINARYFilBufSiz=FILSIZ(DimFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DimFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DimFileDELETE "_DimFile"OPEN DescFile,"_DescFile":READ+BINARYFilBufSiz=FILSIZ(DescFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD DescFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE DescFileDELETE "_DescFile"OPEN PreCodeFile,"_PreCodeFile":READ+BINARYFilBufSiz=FILSIZ(PreCodeFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD PreCodeFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizCLOSE PreCodeFileDELETE "_PreCodeFile"OPEN CodeFile,"_CodeFile":READ+BINARYFilBufSiz=FILSIZ(CodeFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD CodeFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE CodeFileDELETE "_CodeFile"OPEN InitFile,"_InitFile":READ+BINARYFilBufSiz=FILSIZ(InitFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD InitFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE InitFileDELETE "_InitFile"OPEN FunctionFile,"_FunctionFile":READ+BINARYFilBufSiz=FILSIZ(FunctionFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD FunctionFile,FilBufAdr,FilBufSizBUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE FunctionFileDELETE "_FunctionFile"OPEN ExportFile,"_ExportFile":READ+BINARYFilBufSiz=FILSIZ(ExportFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD ExportFile,FilBufAdr,FilBufSiz;BUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE ExportFileDELETE "_ExportFile"OPEN ResourceFile,"_ResourceFile":READ+BINARYFilBufSiz=FILSIZ(ResourceFile)BUFFER FileBuf=FilBufSizFilBufAdr=BUFADR(FileBuf)BUFREAD ResourceFile,FilBufAdr,FilBufSiz;BUFWRITE OutFile,FilBufAdr,FilBufSizBUFFER FileBuf=0CLOSE ResourceFileDELETE "_ResourceFile"CLOSE OutFile;'end;******FOR Ctr1=1 TO LastSym	TDataType=SymTable(Ctr1).DataType	IF TDataType=LABELVAR OR TDataType=FCN OR TDataType=PROC THEN		TDetail=SymTable(Ctr1).Detail		TDataMod=SymTable(Ctr1).DataMod		IF TDetail=LabelUnresolved THEN			IF TDataType=LABELVAR THEN				INCR ErrCnt				TempStr="Label unresolved: "+SymTable(Ctr1).SymName				WARNINGBOX "Error",TempStr,MB_OK				RETURN			ELSE				IF TDataType=FCN OR TDataType=PROC THEN					IF LAND(TDataMod,UsrFcnBit)=UsrFcnBit THEN						IF LAND(TDataMod,CalledBit)=CalledBit THEN							INCR ErrCnt							TempStr="Function or procedure unresolved: "+SymTable(Ctr1).SymName							WARNINGBOX "Error",TempStr,MB_OK							RETURN						ENDIF					ENDIF				ENDIF			ENDIF								ENDIF	ENDIFNEXT Ctr1lbl9999:IF ConStkPtr<>0 THEN	TempStr="Unbalanced control structure in line "+STR(ConStk(ConStkPtr).ConLine)	WARNINGBOX "Error",TempStr,MB_OK	RETURN	DECR ConStkPtr; ???	INCR ErrCnt	GOTO lbl9999ENDIFIF GFNdx<>1 THEN	TempStr="Unbalanced conditional stack"	WARNINGBOX "Error",TempStr,MB_OK	RETURN	INCR ErrCntENDIFIF ProcFcnFlag<>0 THEN	TempStr="Procedure, function, or event not complete"	WARNINGBOX "Error",TempStr,MB_OK	RETURN	INCR ErrCntENDIFIF ErrCnt<>0 THEN	TempStr=STR(ErrCnt)+" error(s)"	WARNINGBOX "Error",TempStr,MB_OK	RETURNELSE	REM Do assembly here;	PRINT (GETTICKCOUNT()-StartTime)	IF AsmOutFlag=FALSE AND NoGen=FALSE THEN;		TempStr="Assemble:";		GOSUB OutPrint		GOSUB Assemble;		PRINT (GETTICKCOUNT()-StartTime)	ENDIFENDIFIF AsmOutFlag=FALSE OR NoGen=TRUE THEN	DELETE BareFileName+".asm"ENDIFIF AsmOutFlag=TRUE OR NoGen=TRUE THEN	GOSUB FormatCompileTime	MSGBOX "Success",TempName,MB_OK	GOSUB ShowMode	IF AsmOutFlag=TRUE THEN		FileName=BareFileName+".asm"		Edit.LOADFILE FileName		SaveFileName=FileName		BareFileName=LEFT(FileName,LEN(FileName)-4)		Extension=RIGHT(FileName,4)		TempStr=ProgramName+"     ["+FileName+"]"		OBMain.TEXT=TempStr		Timer1.INTERVAL=50		StatusBar.SETTEXT 5,"Not Changed"		StatusBarSafe5="Edit Objects"		StatusBar.SETTEXT 5,StatusBarSafe5		Changed=FALSE		Edit.SETFOCUS	ENDIF	ENDIFRETURNNoInpFile:TempStr="Cannot open file: "+FileNameWARNINGBOX "Error",TempStr,MB_OKRETURN;***** Subroutine Section ******DimVar:GOSUB PrepVarErrRetIF SymFound=TRUE THEN	ErrNo=ErrDupSym	RETURNENDIFIF SubCtr<>0 THEN	DMArray=$ff	ArraySize=SubValue(1)*SubValue(2)*SubValue(3)	SymTemp.ArrayDim1=SubValue(1)	SymTemp.ArrayDim2=SubValue(2)	SymTemp.ArrayDim3=SubValue(3)	SymTemp.ArrayDims=SubCtr	IF SubCtr>1 THEN		MultiFlag=$ff		TDataMod=LOR(TDataMod,MultiBit)	ENDIF	IF ArraySize=0 THEN		DMReDim=$ff		TDataMod=LOR(TDataMod,ReDimBit)	ENDIFENDIFGOSUB NexTokenIF TokenBuf<>"as" THEN	ErrNo=ErrSyntax	RETURNENDIFGOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	RETURNENDIFSymTemp.SubType=NONESELECT CASE TokenBuf	CASE "boolean"		TDataType=BOOLVAR		SymType=" rb "		TDataSize=1		TDataAddr=1		GOTO DimVar1	CASE "byte"		TDataType=BYTEVAR		SymType=" rb "		TDataSize=1		TDataAddr=1		GOTO DimVar1	CASE "integer"		TDataType=WORDVAR		SymType=" rw "		TDataSize=2		TDataAddr=2		GOTO DimVar1	CASE "long"		TDataType=LONGVAR		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "label"		TDataType=LABELPTR		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "float"		TDataType=FLOATVAR		SymType=" rf "		TDataSize=8		TDataAddr=8		GOTO DimVar1	CASE "string"		TDataType=STRINGVAR		SymType=" rb "		IF NextByte<>"*" THEN			TempInt=255; Default string size		ELSE			GOSUB NexToken; Eat '*'			GOSUB NexToken			TempStr=TokenSaf			GOSUB StrSiz			ErrRet		ENDIF		SymTemp.Detail=TempInt		IF TypeFlag=0 AND DMArray=0 THEN			VectorFlag=$ff			TDataMod=LOR(TDataMod,VectorBit)		ENDIF		TDataSize=TempInt		TDataAddr=TempInt		GOTO DimVar1	CASE "text"		IF DMArray<>0 THEN			ErrNo=ErrTextArray			RETURN		ENDIF		TDataType=TEXT		TDataSize=0		TDataAddr=0		GOTO DimVar1	CASE "file"		TDataType=LONGVAR		SymTemp.SubType=FILE		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "device"		TDataType=LONGVAR		SymTemp.SubType=DEVICE		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "font"		TDataType=LONGVAR		SymTemp.SubType=FONT		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "icon"		TDataType=LONGVAR		SymTemp.SubType=ICON		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "cursor"		TDataType=LONGVAR		SymTemp.SubType=CURSOR		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "bitmap"		TDataType=LONGVAR		SymTemp.SubType=BITMAP		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "handle"		TDataType=LONGVAR		SymTemp.SubType=HANDLE		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "menu"		TDataType=LONGVAR		SymTemp.SubType=MENU		SymType=" rd "		TDataSize=4		TDataAddr=4		GOTO DimVar1	CASE "puppet"		TDataType=PUPPET		SymType=" rd "		TDataSize=38		TDataAddr=38		IF SubCtr>1 THEN; 1 Dim arrays only for puppets			ErrNo=ErrSyntax			RETURN		ENDIF		GOTO DimVar1	CASE ELSE		GOSUB ObjLook		IF ObjNdx<>0 THEN			ObjectCtr=ObjectCtr+SubValue(1)			TDataType=ObjNdx+99			SymType=" rd "			TDataSize=256			TDataAddr=256			IF SubCtr>1 THEN; 1 Dim arrays only for controls				ErrNo=ErrSyntax				RETURN			ENDIF			IF TDataType=FORM OR TDataType=FRAME  OR TDataType=TABFOLDER OR TDataType=TOOLBAR OR TDataType=STATUSBAR OR TDataType=TOOLWINDOW THEN				IF SubCtr>0 THEN; 'Holder' Array not allowed					ErrNo=ErrSyntax					RETURN				ENDIF			ENDIF		ELSE			IF TokenBuf="logfont" THEN				TDataMod=LogFontBit			ENDIF			TSymName=SymTemp.SymName			TypePtr=SymNdx			SubCtrSaf=SubCtr			SubValSaf=SubValue			GOSUB TokenSym1			ErrRet			IF SymFound=FALSE OR SymTable(SymNdx).DataType<>TYPE THEN				ErrNo=ErrIVType				RETURN			ENDIF			TDataSize=SymTable(SymNdx).DataSize			TDataAddr=SymTable(SymNdx).DataSize			SymType=" rb "			SymTemp.Detail=SymNdx			SymNdx=TypePtr			SymTemp.SymName=TSymName			SubCtr=SubCtrSaf			SubValue=SubValSaf			TDataType=COMPLEX		ENDIFEND SELECTDimVar1:GOSUB NexTokenIF TokenLen=0 OR TokenBuf=";" THEN DimVar2IF TDataType=TEXT THEN	ErrNo=ErrSyntax	RETURNENDIFIF TokenBuf="=" THEN	IF TDataType<1 OR TDataType>6 OR SymTemp.SubType<>NONE THEN		ErrNo=ErrSyntax		RETURN	ENDIF	TDataMod=LOR(TDataMod,InitDataBit)	GOTO DimVar2; Temporary Bypass;;;ENDIFIF TokenBuf="pointer" THEN	IF TypeFlag<>0 OR DMArray<>0 THEN		ErrNo=ErrIVParm		RETURN	ENDIF	DMAddr=$ff	VectorFlag=0	SymType=" rd "	TDataSize=4	TDataAddr=4	TDataMod=LOR(TDataMod,PointerBit)	GOTO DimVar2ENDIFIF TokenBuf="alias" THEN	IF TypeFlag<>0 THEN		ErrNo=ErrIVParm		RETURN	ENDIF	IF TDataType=STRINGVAR THEN		ErrNo=ErrSyntax		RETURN	ENDIF	AliasFlag=$ff	GOSUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrSyntax		RETURN	ENDIF	SymNdxSaf=SymNdx	HandleName=SymTemp.SymName	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		RETURN	ENDIF	AliasDataType=SymTable(SymNdx).DataType	TempInt=SymTable(SymNdx).DataMod	IF LAND(TempInt,ArrayBit)=ArrayBit THEN		AliasDataType=BYTEVAR' (Anything but string)	ENDIF	SymNdx=SymNdxSaf	SymTemp.SymName=HandleName	GUITempName=TokenSaf	GOTO DimVar2ENDIFIF TokenBuf="vector" THEN	IF TypeFlag<>0 OR DMAddr<>0 THEN		ErrNo=ErrIVParm		RETURN	ENDIF	VectorFlag=$ff	TDataMod=LOR(TDataMod,VectorBit)	GOTO DimVar2ENDIFErrNo=ErrIVModRETURNDimVar2:SymTemp.DataType=TDataTypeIF DMArray<>0 THEN	TDataMod=LOR(ArrayBit,TDataMod)ENDIFDimOK=$ffSymTemp.DataMod=TDataModSymTemp.DataSize=ArraySize*TDataSizeSymTemp.DataAddr=TDataAddrIF TDataType=STRINGVAR OR TDataType=COMPLEX OR TDataType>99 OR TDataType=PUPPET THEN	ArraySize=SymTemp.DataSizeENDIFRETURNDecVar:TSymName=SymTemp.SymNameIF AliasFlag<>0 THEN	GOSUB OutUninitData; Basic line as comment	IF AliasDataType=STRINGVAR THEN		OutBuf=TSymName+" equ "+GUITempName+"+12"	ELSE		OutBuf=TSymName+" equ "+GUITempName	ENDIF	GOSUB OutUninitData	RETURNENDIFComment=OutBufIF DMAddr<>0 THEN	GOSUB OutUninitData; Basic line as comment	OutBuf=TSymName+" rd 1"	GOSUB OutUninitData	RETURNENDIFIF DMReDim<>0 THEN	GOSUB OutInitData; Basic line as comment	BufName=TSymName	GOSUB MakeBuffer	RETURNENDIFIF VectorFlag=$ff THEN	IF TDataType=STRINGVAR AND DMArray=0 THEN		GOSUB OutInitData; Basic line as comment		OutBuf="align 4"		GOSUB OutInitData		OutBuf=TSymName+" dd "+TempStr+"+12"		GOSUB OutInitData		OutBuf=" dd "+STR(TDataSize)		GOSUB OutInitData		OutBuf=" dd 0"		GOSUB OutInitData		OutBuf=" rb "+STR(ArraySize)		GOSUB OutInitData	ELSE		GOSUB OutUninitData; Basic line as comment		OutBuf="align 4"		GOSUB OutUninitData		OutBuf=TSymName+" rd 3"		GOSUB OutUninitData	ENDIF	RETURNENDIFIF TDataType=STRINGVAR THEN; String array case	GOSUB OutUninitData; Basic line as comment	OutBuf=TSymName+" rb "+STR(ArraySize)	GOSUB OutUninitData	RETURNENDIFIF DMArray<>0 OR TDataType=COMPLEX THEN	IF TDataType<100 THEN		GOSUB OutUninitData		OutBuf="align 4"		GOSUB OutUninitData		OutBuf=TSymName+SymType+STR(ArraySize)		GOSUB OutUninitData	ELSE		GOSUB OutDesc		OutBuf="!"+TSymName+SymType+STR(ArraySize)		GOSUB OutDesc	ENDIF	RETURNELSE	IF TDataSize=2 THEN		OutBuf="align 2"		GOSUB OutUninitData	ELSE		IF TDataSize>=4 AND TDataType<100 THEN			OutBuf="align 4"			GOSUB OutUninitData		ENDIF	ENDIF	IF TDataType<100 THEN		OutBuf=Comment		GOSUB OutUninitData		OutBuf=TSymName+SymType+"1"		GOSUB OutUninitData	ELSE		OutBuf=Comment		GOSUB OutDesc		OutBuf="!"+TSymName+SymType+"256"		GOSUB OutDesc	ENDIFENDIFRETURNPrepVar:TDataMod=LAND(MemberBit,TypeFlag)SymTemp.Detail=0GOSUB ClrDatTypVectorFlag=0MultiFlag=0DimOK=0DimFlag=$ffTDataType=COMPVARTDataSize=1ArraySize=1GOSUB ClrSymGOSUB TokenSymDataSymNdx=SymNdxRETURNVarBlank:OutBuf=""GOSUB OutUninitDataRETURNOutLabel:IF LabelFlag=$ff THEN	OutBuf=SymbolSaf	GOSUB OutCodeDataENDIFRETURNGetExp:FloatFlag=0TypePtr=0ExpEnd=0ExpNdx=1ExpLen=0ParenCnt=0FcnCtr=0AECtr=0ExpTable(ExpNdx)=1LastEntry=SymTable(ExpTable(ExpNdx))GetExp1:IF ExpEnd=$ff THEN ExpExitIF NextByte="," AND FcnCtr=0 AND AECtr=0 THEN ExpExitIF IgnoreRightParen<>0 AND SrcNdx+1=EndNdx THEN ExpExitIF IgnoreRightParen<>0 AND NextByte=")" AND ParenCnt<1 THEN ExpExitGetExp2:GOSUB NexTokenIF TokenLen=0 THEN ExpExitIF TokenBuf="," THEN	GOSUB AddRtGrp2	IncExpNdx	ExpTable(ExpNdx)=2	IncExpNdx	ExpTable(ExpNdx)=1	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1ENDIF;***********************; Start of Pointer Stuff HereIF TokenBuf="[" THEN	IncExpNdx	GOSUB NexToken	IF TokenLen=0 THEN		ErrNo=ErrIVExp		GOTO ExpExit	ENDIF	SymTemp.SymName=TokenSaf	GOSUB SymSrch	IF SymFound=FALSE THEN		ErrNo=ErrUDSym		GOTO ExpExit	ENDIF	GOSUB GetSymTemp	IF LAND(SymTemp.DataMod,PointerBit)<>PointerBit THEN		ErrNo=ErrTypMis		GOTO ExpExit	ENDIF	IF SymTemp.DataType=FLOATVAR THEN		INCR FloatFlag	ENDIF	IF SymTemp.DataType=COMPLEX THEN		ExpTable(ExpNdx)=24;  cpx begin		IncExpNdx	ENDIF	ExpTable(ExpNdx)=26;  "["	IncExpNdx	ExpTable(ExpNdx)=SymNdx	LastEntry=SymTemp	GOSUB NexToken	IF TokenBuf<>"]" OR TokenLen=0 THEN		ErrNo=ErrSyntax		GOTO ExpExit	ENDIF	IncExpNdx	ExpTable(ExpNdx)=27;  put "]" in table	IF SymTemp.DataType<>COMPLEX THEN GetExp1	IncExpNdx	IF NextByte="." THEN		GOSUB NexToken;  eat "."		ExpTable(ExpNdx)=13;  "."		GOSUB NexToken		IF TokenLen=0 THEN			ErrNo=ErrSyntax			GOTO ExpExit		ENDIF		SymTemp.SymName=TokenSaf		GOSUB SymSrch		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO ExpExit		ENDIF		GOSUB GetSymTemp		IF LAND(MemberBit,SymTemp.DataMod)<>MemberBit THEN			ErrNo=ErrTypMis			GOTO ExpExit		ENDIF		IF SymTemp.DataType=FLOATVAR THEN			INCR FloatFlag		ENDIF		IncExpNdx		ExpTable(ExpNdx)=SymNdx		IncExpNdx	ENDIF	ExpTable(ExpNdx)=25;  cpx end	GOTO GetExp1ENDIF; End of Pointer Stuff Here;***********************IF TokenType=TTypMath THEN	IncExpNdx	SELECT CASE TokenBuf		CASE "+"			GOSUB Unary			ExpTable(ExpNdx)=15		CASE"-"			GOSUB Unary			ExpTable(ExpNdx)=16		CASE "*"			ExpTable(ExpNdx)=17		CASE "/"			ExpTable(ExpNdx)=18		CASE "&"			ExpTable(ExpNdx)=147		CASE "|"			ExpTable(ExpNdx)=148	END SELECT	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1ENDIFIF TokenBuf="(" THEN	IncExpNdx	IF LAND(ArrayBit,LastEntry.DataMod)<>0 AND SymTemp.DataType<$10 THEN		ExpTable(ExpNdx)=3		INCR ParenCnt		ParenStk(ParenCnt)=3		INCR AECtr		IncExpNdx		ExpTable(ExpNdx)=1		GOTO GetExp3	ENDIF	IF LAND(ArrayBit,LastEntry.DataMod)<>0 AND SymTemp.DataType=LABELPTR THEN		ExpTable(ExpNdx)=3		INCR ParenCnt		ParenStk(ParenCnt)=3		INCR AECtr		IncExpNdx		ExpTable(ExpNdx)=1		GOTO GetExp3	ENDIF	IF LastEntry.DataType=FCN THEN		ExpTable(ExpNdx)=5		INCR ParenCnt		ParenStk(ParenCnt)=5		INCR FcnCtr		IncExpNdx		ExpTable(ExpNdx)=1		GOTO GetExp3	ENDIF	IF LastEntry.DataType<>9 AND ExpNdx<>1 THEN		ErrNo=ErrIVExp		GOTO ExpExit	ENDIF	LevelCnt=1	GOSUB PreScan1	GOSUB AddLftGrp	ExpTable(ExpNdx)=1	INCR ParenCnt	ParenStk(ParenCnt)=1GetExp3:	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1ENDIFIF TokenBuf=")" THEN	GOSUB AddRtGrp2	IncExpNdx	IF ParenCnt=0 THEN		ErrNo=ErrParen		GOTO ExpExit	ENDIF	IF ParenStk(ParenCnt)=3 OR ParenStk(ParenCnt)=5 THEN		ExpTable(ExpNdx)=2		IncExpNdx	ENDIF	ExpTable(ExpNdx)=ParenStk(ParenCnt)+1	IF ExpTable(ExpNdx)=4 THEN		DECR AECtr	ENDIF	IF ExpTable(ExpNdx)=6 THEN		DECR FcnCtr	ENDIF	DECR ParenCnt	LastEntry=SymTable(ExpTable(ExpNdx))	GOSUB AddRtGrp1	GOTO GetExp1ENDIFIF TokenBuf="." THEN	IncExpNdx	ExpTable(ExpNdx)=13	LastEntry=SymTable(ExpTable(ExpNdx))	GOTO GetExp1ENDIFSELECT CASE TokenType	CASE TTypSym		IncExpNdx		SymTemp.SymName=TokenBuf		GOSUB SymSearch		IF SymFound=TRUE THEN			GOSUB GetSymTemp			IF SymTemp.DataType=FCN THEN; Function found				IF MID(SrcLine,SrcNdx+1,2)="()" THEN					ExpTable(ExpNdx)=SymNdx					IncExpNdx					INCR SrcNdx					ExpTable(ExpNdx)=5					IncExpNdx					INCR SrcNdx					ExpTable(ExpNdx)=6					NextByte=MID(SrcLine,SrcNdx+1,1)					GOTO GetExp1				ENDIF				GOSUB PreScan				GOSUB AddLftGrp				LastEntry=SymTemp				ExpTable(ExpNdx)=SymNdx				GOTO GetExp1			ENDIF		ENDIF		SymTemp.SymName=TokenSaf		GOSUB SymSrch		IF ErrNo<>0 THEN ExpExit		IF SymFound=FALSE THEN			ErrNo=ErrUDSym			GOTO ExpExit		ENDIF		GOSUB GetSymTemp		IF SymTemp.DataType>=100 THEN;//			GUIObjFlag=$ff;//			RETURN;//		ENDIF;//		IF SymTemp.DataType=TEXT THEN;//			TextFlag=$ff;//			RETURN;//		ENDIF;//		IF LAND(SymTemp.DataMod,PointerBit)=0 AND SymTemp.DataType<$10 THEN;  special test for pointer			DataTemp=SymTemp.DataType			IF SymTemp.DataType=FLOATVAR THEN				INCR FloatFlag			ENDIF		ELSE			DataTemp=LONGVAR		ENDIF		IF DataTemp>=BOOLVAR AND DataTemp<=STRINGVAR OR DataTemp=COMPLEX OR DataTemp=BUFFER THEN			ExpTable(ExpNdx)=SymNdx			IF LAND(MemberBit,SymTemp.DataMod)<>0 AND LastEntry.SymName<>"." AND SymTemp.DataType<$10 THEN				ErrNo=ErrIVExp				GOTO ExpExit			ENDIF			IF TypePtr<>0 AND LastEntry.SymName="." THEN				IF SymNdx-TypePtr>SymTable(TypePtr).Detail OR TypePtr>SymNdx THEN					ErrNo=ErrUDSym					GOTO ExpExit				ELSE					TypePtr=0				ENDIF			ENDIF			IF DataTemp=COMPLEX THEN				TempStr=NextByte				GOSUB PreScan				GOSUB AddLftGrp				NextByte=TempStr				INCR ParenCnt				ParenStk(ParenCnt)=24				ExpTable(ExpNdx)=24				IncExpNdx				TypePtr=SymTemp.Detail			ENDIF			IF DataTemp<>COMPLEX AND LAND(ArrayBit,SymTemp.DataMod)=ArrayBit AND SymTemp.DataType<$10 THEN				TempStr=NextByte				GOSUB PreScan				GOSUB AddLftGrp				NextByte=TempStr			ENDIF			IF DataTemp<>COMPLEX THEN				GOSUB AddLftGrp			ENDIF			ExpTable(ExpNdx)=SymNdx			LastEntry=SymTemp			GOSUB AddRtGrp1			GOTO GetExp1		ENDIF		IF DataTemp=COMPVAR OR DataTemp=MACROVAR THEN			Konstant=SymTable(SymNdx).Detail			SymTemp.SymName=STR(Konstant)			GOSUB ProcKonst			IF ErrNo<>0 THEN ExpExit			GOSUB AddRtGrp1			GOTO GetExp1		ENDIF		GOTO ExpExit	CASE TTypFloat		INCR FloatFlag		IncExpNdx		GOSUB AddLftGrp		GOSUB ValidFlt		IF FloatOK=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		ENDIF		SymTemp.SymName=TokenBuf		GOSUB SymSrch		IF SymFound=FALSE THEN			GOSUB ClrSym			SymTemp.DataType=FLOATVAR			SymTemp.DataSize=8			SymTemp.DataMod=ConstBit			GOSUB SymInsert			ErrRet		ENDIF		GOSUB GetSymTemp		LastEntry=SymTemp		ExpTable(ExpNdx)=SymNdx		GOSUB AddRtGrp1	CASE TTypInt		IncExpNdx		GOSUB AddLftGrp		GOSUB ValidInt		IF IntOK=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		ENDIF		Konstant=VAL(TokenBuf)		SymTemp.SymName=Str(Konstant)		GOSUB ProcKonst		IF ErrNo<>0 THEN ExpExit		GOSUB AddRtGrp1	CASE TTypHex		IncExpNdx		GOSUB AddLftGrp		GOSUB ValidHex		IF HexOK=0 THEN			ErrNo=ErrIVExp			GOTO ExpExit		ENDIF		SymTemp.SymName=TokenBuf		GOSUB ProcKonst		IF ErrNo<>0 THEN ExpExit		GOSUB AddRtGrp1	CASE TTypQuote		IncExpNdx		IF LEN(TokenSaf)=2 THEN;  null string			LastEntry=SymTable(20)			ExpTable(ExpNdx)=20;  20 is table entry for null string			GOTO GetExp1		ENDIF		GOSUB MakeStrConst		TempStr="_StrConst"+STR(PoolCtr)		SymTemp.SymName=TempStr		;Skip SymSrch, just point to next vacancy in symbol table		SymNdx=LastSym+1		IF SymNdx>SymTabSiz THEN			SymFull=$ff		ENDIF		SymTemp.DataType=STRINGVAR		SymTemp.DataMod=ConstBit		GOSUB ClrSym		SymTemp.Detail=LEN(TokenSaf)-1		SymTemp.DataSize=SymTemp.Detail		GOSUB SymInsert		IF ErrNo<>0 THEN			GOTO ExpExit		ENDIF		LastEntry=SymTemp		ExpTable(ExpNdx)=SymNdx	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTGOTO GetExp1ExpExit:IF ExpLen=ExpTabSiz THEN	ErrNo=ErrCpxExpENDIFIF ExpLen=1 THEN	ErrNo=ErrIVExpENDIFIF ErrNo=0 THEN; Check this block of code	IF ParenCnt<>0 THEN		IF ParenStk(ParenCnt)=24 THEN			IncExpNdx			ExpTable(ExpNdx)=25			DECR ParenCnt		ENDIF	ENDIF	IF ParenCnt<>0 THEN		IF ParenStk(ParenCnt)=22 THEN			IncExpNdx			ExpTable(ExpNdx)=23			ParenCnt=0		ENDIF	ENDIF	IF ParenCnt<>0 THEN		ErrNo=ErrParen	ELSE		IncExpNdx		ExpTable(ExpNdx)=2	ENDIFENDIFRETURNPreScan:LevelCnt=0GOSUB PreScan1RETURNPreScan1:SrcNdxSaf=SrcNdxExpEndSaf=ExpEndPreScan2:GOSUB NexTokenIF TokenLen=0 THEN	NextByte="%"	SrcNdx=SrcNdxSaf	ExpEnd=ExpEndSaf	RETURNENDIFIF TokenType=TTypMath AND LevelCnt=0 THEN	NextByte=TokenBuf	SrcNdx=SrcNdxSaf	ExpEnd=ExpEndSaf	RETURNENDIFIF TokenBuf="(" THEN	INCR LevelCntENDIFIF TokenBuf=")" THEN	DECR LevelCntENDIFGOTO PreScan2Unary:LastExpression=ExpTable(ExpNdx-1)IF LastExpression=1 OR LastExpression=3 OR LastExpression=5 OR LastExpression=22 OR LastExpression=24 THEN	ExpTable(ExpNdx)=21; *********	IncExpNdxENDIFRETURNAddLftGrp:IF NextByte="*" OR NextByte="/" OR NextByte="&" THEN	IF LAND(MemberBit,SymTemp.DataMod)<>MemberBit THEN		IF ParenCnt<>0 THEN			IF ParenStk(ParenCnt)=22 THEN				RETURN			ENDIF		ENDIF		INCR ParenCnt		ParenStk(ParenCnt)=22		ExpTable(ExpNdx)=22		IncExpNdx	ENDIFENDIFRETURNAddRtGrp1:IF ParenCnt=0 THEN	RETURNENDIFIF NextByte="+" OR NextByte="-" OR NextByte="*" OR NextByte="/"  OR NextByte="&" OR NextByte="|" THEN	IF ParenStk(ParenCnt)=24 THEN		IncExpNdx		DECR ParenCnt		ExpTable(ExpNdx)=25	ENDIF	IF ParenCnt=0 THEN		RETURN	ENDIF	IF NextByte="+" OR NextByte="-"  OR NextByte="|" THEN		IF ParenStk(ParenCnt)=22 THEN			IncExpNdx			DECR ParenCnt			ExpTable(ExpNdx)=23			LastEntry=SymTable(ExpTable(ExpNdx))			RETURN		ELSE			RETURN		ENDIF	ENDIFENDIFRETURNAddRtGrp2:IF ParenStk(ParenCnt)=24 THEN	IncExpNdx	DECR ParenCnt	ExpTable(ExpNdx)=25ENDIFIF ParenStk(ParenCnt)=22 THEN	IncExpNdx	DECR ParenCnt	ExpTable(ExpNdx)=23ENDIFRETURNProcKonst:GOSUB SymSrchIF SymFound=FALSE THEN	GOSUB ClrSym	SymTemp.DataType=LONGVAR	SymTemp.DataSize=4	SymTemp.DataMod=ConstBit	SymTemp.Detail=IVAL(SymTemp.SymName)	GOSUB SymInsert	ErrRetENDIFGOSUB GetSymTempLastEntry=SymTempExpTable(ExpNdx)=SymNdxRETURNProcExp:IF ExpFlag=TRUE THEN	FOR Ctr1=1 to ExpLen		;PRINT SymTable(ExpTable(Ctr1)).SymName;	NEXT Ctr1	TempStr=""	;GOSUB OutPrintENDIFBEGIN LOOP	LastGroup=$00	TempInt=ExpNdx	GOSUB ParenScan	ExpNdx=TempInt	IF ParenCnt=0 THEN		RETURN	ENDIF	GOSUB SolveTerm	ErrRet	GOSUB SquishExpEND LOOPParenScan:ParenCnt=0ExpNdx=0PType=0ExpLeft=0ExpRight=0IF ExpNdx>ExpLen THEN;???	RETURNENDIFParenScn1:INCR ExpNdxPType=ExpTable(ExpNdx)IF PType=1 OR PType=PTArrOpn OR PType=PTFcnOpn OR PType=22 OR PType=PTCpxOpn OR PType=26 THEN	ExpLeft=ExpNdx	INCR ParenCntENDIFIF PType=2 OR PType=PTArrCls OR PType=PTFcnCls OR PType=23 OR PType=PTFCpxCls OR PType=27 THEN	ExpRight=ExpNdx	RETURNENDIFGOTO ParenScn1SquishExp:BEGIN LOOP	IF ExpRight+1>ExpLen THEN		ExpLen=ExpLeft-1		RETURN	ENDIF	ExpTable(ExpLeft)=ExpTable(ExpRight+1)	INCR ExpLeft	INCR ExpRightEND LOOPSolveTerm:D0Loaded=0IF ExpLeft=1 AND ExpRight=ExpLen THEN	LastGroup=$ffENDIFIF ExpLeft=2 AND ExpRight=ExpLen-1 AND ExpTable(1)=1 THEN	LastGroup=$ffENDIF;*******************************; Pointer Stuff Begins HereIF PType=27 THEN	ExpNdx=ExpLeft+1	GOSUB ClassOp	GOSUB GetTmpVec	ErrRet	SymTable(SymNdx).DataMod=LAND(SymTable(SymNdx).DataMod,$fd);  kill addr bit	ExpTable(ExpNdx)=SymNdx	OutBuf="mov esi,["+TSymName+"]"	GOSUB OutCodeData	IF SymTemp.DataType=COMPLEX THEN		OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+3)).DataAddr)		GOSUB OutCodeData	ENDIF	OutBuf="mov ["+SymTemp.SymName+"],esi"	GOSUB OutCodeData	IF TDataType=STRINGVAR THEN		OutBuf="mov ["+SymTemp.SymName+"+4],"+STR(TDetail)		GOSUB OutCodeData		OutBuf="mov ["+SymTemp.SymName+"+8],0"		GOSUB OutCodeData	ENDIF	GOTO GrpCpxEndENDIF; Pointer Stuff Ends Here;*******************************IF PType=PTArrCls THEN	ExpNdx=ExpLeft-1	GOSUB ClassOp	ArrayDataType=TDataType	ArrayDetail=TDetail	GOSUB GetTmpVec	ErrRet	GOSUB GetBase	ExpTable(ExpNdx)=SymNdx	TempStr=SymTemp.SymName	GOSUB GetOpSize	GOSUB BldOffset	ErrRet	OutBuf="mov ["+TempStr+"],esi"	GOSUB OutCodeData	IF ArrayDataType=STRINGVAR THEN		OutBuf="mov ["+TempStr+"+4],"+STR(ArrayDetail)		GOSUB OutCodeData		OutBuf="mov ["+TempStr+"+8],0"		GOSUB OutCodeData	ENDIF	GOTO ArrFcnEndENDIFIF PType=PTFcnCls THEN; Function	HasFcn=$ff	ExpNdx=ExpLeft-1	GOSUB GetSymTempExpNdx	FcnName=SymTemp.SymName	ExpNdx=ExpNdx+2	IF SymTemp.DataMod=UsrFcnBit THEN		TFcnDataType=SymTemp.FcnDataType		GOSUB GetFcnTypes		FOR Ctr3=1 TO TFcnArgs			GOSUB ClassOp			GOSUB ArgPush			ErrRet			INCR ExpNdx		NEXT Ctr3		OutBuf="call "+FcnName		GOSUB OutCodeData		SELECT CASE TFcnDataType			CASE BOOLVAR				ExpTable(ExpNdx)=193			CASE LONGVAR				ExpTable(ExpNdx)=194			CASE STRINGVAR				ExpTable(ExpNdx)=195			CASE FLOATVAR				ExpTable(ExpNdx)=196		END SELECT						ELSE		FcnCode=SymTemp.Detail		IF FcnCode<51 THEN			ON FcnCode GOSUB F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13,F14,F15,F16,F17,F18,F19,F20,F21,F22,F23,F24,F25,F26,F27,F28,F29,F30,F31,F32,F33,F34,F35,F36,F37,F38,F39,F40,F41,F42,F43,F44,F45,F46,F47,F48,F49,F50		ELSE			ON FcnCode-50 GOSUB F51,F52,F53,F54,F55,F56,F57,F58,F59,F60,F61,F62,F63,F64,F65,F66,F67,F68,F69,F70,F71,F72,F73,F74,F75,F76,F77,F78,F79,F80,F81,F82		ENDIF	ENDIF	ErrRet	GOTO ArrFcnEndENDIFIF PType=PTFCpxCls THEN	IF ExpRight-ExpLeft=2 THEN		ExpNdx=ExpLeft+1		GOSUB ClassOp		IF DMVector=0 THEN			GOSUB Vectorize			ErrRet		ENDIF		IF DMVector<>0 AND DMTemp=0 THEN			GOSUB SetTmpVec			ErrRet		ENDIF		GOTO GrpCpxEnd	ENDIF	ExpNdx=ExpLeft+3	GOSUB ClassOp	IF TDataType=STRINGVAR AND DMVector=0 THEN		;GOSUB VecString	ENDIF	IF DMVector<>0 AND DMTemp=0 THEN		GOSUB SetTmpVec		ErrRet	ENDIF	ExpNdx=ExpNdx-2	GOSUB ClassOp	IF DMVector=0 THEN		GOSUB Vectorize		ErrRet	ENDIF	IF DMVector<>0 AND DMTemp=0 THEN		GOSUB SetTmpVec		ErrRet	ENDIF	ExpNdx=ExpNdx+2	GOSUB ClassOp	ExpNdx=ExpNdx-2	SymNdx=ExpTable(ExpNdx)	SymTable(SymNdx).DataType=TDataType	SymTable(SymNdx).DataSize=TDataSize	SymTable(SymNdx).Detail=TDetail	IF DMVector<>0 THEN		OutBuf="mov eax,["+SymTable(SymNdx).SymName+"]"		GOSUB OutCodeData		OutBuf="add eax,["+TSymName+"]"		GOSUB OutCodeData		OutBuf="mov ["+SymTable(SymNdx).SymName+"],eax"		GOSUB OutCodeData	ENDIF	IF OpClass=STRClass AND ReadFlag=0 THEN		OutBuf="mov ["+SymTable(SymNdx).SymName+"+4],"+STR(SymTemp.Detail)		GOSUB OutCodeData		OutBuf="mov ["+SymTable(SymNdx).SymName+"+8],0"		GOSUB OutCodeData		ENDIF	GOTO GrpCpxEndENDIF; Get here if PType=2ExpNdx=ExpLeft+1GOSUB ClassOpMakeLongIF ExpRight-ExpLeft=2 AND DMArray<>0 THEN	IF CompFlag<>0 THEN		ErrNo=ErrIVExp	ENDIF	GOTO GrpCpxEndENDIFIF LastGroup=$ff AND ExpRight-ExpLeft<>2 AND Target=$ff THEN	ErrNo=ErrIVTarg	RETURNENDIFIF ExpRight-ExpLeft=2 THEN	IF TDataType=STRINGVAR AND DMVector=0 AND DMAddr=0 THEN		GOSUB VecString	ENDIF	IF TDataType=STRINGVAR AND DMVector<>0 AND DMTemp=0 AND DiskIO=$ff  AND BufRWFlg=0 THEN		GOSUB GetBase	ENDIF	GOTO GrpCpxEndENDIFScanStr:GOSUB ClassOpMakeLongIF TDataType=STRINGVAR AND DMVector=0 AND DMAddr=0 THEN	GOSUB VecStringENDIFIF DMVector<>0 AND DMTemp=0 THEN	REM need to make a temp vector	GOSUB SetTmpVec	ErrRetENDIFINCR ExpNdxIF ExpNdx<ExpRight THEN ScanStrExpNdx=ExpLeft+1GOSUB ClassOpMakeLongIF TDataType=STRINGVAR THEN	DataOp=0	Ctr1=0	Label6184:	IF DataOp=0 THEN		GOSUB ClassOp		IF TDataType<>STRINGVAR THEN			ErrNo=ErrIVExp			RETURN		ENDIF		INCR Ctr1		IF Ctr1>1 THEN			OutBuf="mov esi,"+TSymName			GOSUB OutCodeData			TSymName=SymTable(ExpTable(ExpNdx-2)).SymName			OutBuf="mov ["+TSymName+"+8],esi"			GOSUB OutCodeData		ENDIF		DataOp=$ff	ELSE		MathOp=ExpTable(ExpNdx)		IF MathOp<15 THEN			ErrNo=ErrIVExp			RETURN		ENDIF		DataOp=0	ENDIF	INCR ExpNdx	IF ExpNdx<ExpRight THEN Label6184	IF DataOp=0 THEN		ErrNo=ErrIVExp		RETURN	ENDIF	ExpNdx=ExpLeft+1	GOTO GrpCpxEndENDIFIF TDataType<2 OR TDataType>5 THEN	ErrNo=ErrIVExp	RETURNELSE	DataOp=0	Ctr1=0	Label6186:	IF DataOp=0 THEN		DataOp=$ff		GOSUB LoadReg		ErrRet		INCR Ctr1		IF Ctr1>1 THEN			SELECT CASE MathOp				CASE 15					GOSUB DoAdd				CASE 16					GOSUB DoSub				CASE 17					GOSUB DoMul				CASE 18					GOSUB DoDiv				CASE 146					GOSUB DoAnd				CASE 147					GOSUB DoOr			END SELECT		ENDIF	ELSE		MathOp=ExpTable(ExpNdx)		DataOp=0	ENDIF	INCR ExpNdx	IF ExpNdx<ExpRight THEN Label6186	IF DataOp=0 THEN		ErrNo=ErrIVExp	ENDIF	ExpNdx=ExpLeft+1	IF LastGroup=$ff AND CompFlag=0 THEN		ExpTable(ExpNdx)=19		IF TDataType=FLOATVAR THEN			SymTable(19).DataType=FLOATVAR		ELSE			SymTable(19).DataType=LONGVAR		ENDIF		GOTO GrpCpxEnd	ENDIF	IF FloatFlag=0 THEN		GOSUB GetTmp		ErrRet	ELSE		GOSUB GetFltTmp		ErrRet	ENDIF       	OutBuf="mov ["+SymTemp.SymName+"],"+Reg0Name	GOSUB OutCodeData	D1Cleared=0	ExpTable(ExpNdx)=SymNdx	GOTO GrpCpxEndENDIFArrFcnEnd:DECR ExpLeftGrpCpxEnd:ExpTable(ExpLeft)=ExpTable(ExpNdx)ExpNdx=ExpLeftINCR ExpLeftRETURNGetBase:IF DMMember<>0 THEN	IF DMArray=0 THEN		OutBuf="mov esi,"+STR(TDataAddr)	ELSE		GOSUB GetOpSize		OutBuf="mov esi,0-("+STR(ArrayBase)+"*"+STR(TempInt)+")"	ENDIF	GOSUB OutCodeData	RETURNENDIFIF DMVector<>0 THEN	OutBuf="mov esi,["+TSymName+"]"	GOSUB OutCodeData	IF TDataType=COMPLEX THEN		CpxArrayOffset=ArrayBase*TDataAddr		OutBuf="add esi,"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)		GOSUB OutCodeData	ENDIF	RETURNENDIFIF DMArray<>0 THEN	OutBuf="mov esi,"+TSymName+"-("+STR(ArrayBase)+"*"+STR(TDataAddr)+")"	IF TDataType=COMPLEX THEN		CpxArrayOffset=ArrayBase*TDataAddr		OutBuf=OutBuf+"+"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)	ENDIF	OutBuf=OutBuf	GOSUB OutCodeData	RETURNENDIFIF TDataType=COMPLEX THEN	OutBuf="mov esi,"+TSymName+"+"+STR(SymTable(ExpTable(ExpNdx+2)).DataAddr)	GOSUB OutCodeData	RETURNENDIFOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataRETURNBldOffset:SymTable(SymNdx).DataSize=TempIntSymTable(SymNdx).DataMod=LAND(ArrayMsk,SymTable(SymNdx).DataMod)GOSUB ClassOpExpNdx=ExpNdx+2NumArgs=ExpRight-ExpLeft-1IF NumArgs<>SubCtr THEN	ErrNo=ErrArrSub	RETURNENDIFGOSUB SubLoadIF NumArgs=1 THEN;  1 DIM array	IF TempInt<>1 THEN		SELECT CASE TempInt			CASE 2				OutBuf="shl eax,1"			CASE 4				OutBuf="shl eax,2"			CASE 8				OutBuf="shl eax,3"			CASE 16				OutBuf="shl eax,4"			CASE 32				OutBuf="shl eax,5"			CASE 64				OutBuf="shl eax,6"			CASE 128				OutBuf="shl eax,7"			CASE 256				OutBuf="shl eax,8"			CASE 512				OutBuf="shl eax,9"			CASE 1024				OutBuf="shl eax,10"			CASE ELSE				OutBuf="imul eax,"+STR(TempInt)		END SELECT				GOSUB OutCodeData	ENDIF	OutBuf="add esi,eax;"	GOSUB OutCodeData	ExpNdx=ExpNdx-2	RETURNENDIFOutBuf="mov edx,eax"GOSUB OutCodeDataINCR ExpNdxGOSUB SubLoadErrRetIF NumArgs=2 THEN;  2 DIM array	REM eax is (2), edx is (1)	OutBuf="eax=eax*"+STR(SubValue(1))+"*"+STR(TempInt)+"+"+STR(TempInt)+"*edx"	GOSUB OutCodeData	OutBuf="add esi,eax"	GOSUB OutCodeData	ExpNdx=ExpNdx-3	RETURNENDIFREM Get here if 3 DIM arrayediUsed=TRUEOutBuf="mov edi,eax"GOSUB OutCodeDataINCR ExpNdxGOSUB SubLoadErrRetREM eax is (3), edx is(1), edi is (2)OutBuf="eax=edi*"+STR(SubValue(1))+"*"+STR(TempInt)+"+eax*"+STR(SubValue(1))+"*"+STR(SubValue(2))+"*"+STR(TempInt)+";"GOSUB OutCodeDataOutBuf="eax=eax+"+STR(TempInt)+"*edx;"GOSUB OutCodeDataOutBuf="add esi,eax"GOSUB OutCodeDataExpNdx=ExpNdx-4RETURNVecString:IF BufRWFlg=$ff THEN;  for the case of BUFRW fn,ADDR(a$),size	RETURNENDIFGOSUB GetTmpVecErrRetGOSUB GetBaseExpTable(ExpNdx)=SymNdxTempStr=SymTemp.SymNameTempInt=TDetailIF PType=PTArrCls THEN	GOSUB BldOffsetENDIFOutBuf="mov ["+TempStr+"],esi"GOSUB OutCodeDataIF ReadFlag=0 THEN	OutBuf="mov ["+TempStr+"+4],"+STR(TempInt)	GOSUB OutCodeData	OutBuf="mov ["+TempStr+"+8],0"	GOSUB OutCodeDataENDIFRETURNClassOp:GOSUB GetSymTempExpNdxGOSUB ClassOp1RETURNClassOp1:GOSUB ClrDatTypTSymName=SymTemp.SymNameTDataType=SymTemp.DataTypeTSubType=SymTemp.SubTypeTDataMod=SymTemp.DataModTDetail=SymTemp.DetailTDataAddr=SymTemp.DataAddrTDataSize=SymTemp.DataSizeGOSUB GetDtaTyp DMTemp=LAND(TempBit,TDataMod)DMVector=LAND(VectorBit,TDataMod)DMMember=LAND(MemberBit,TDataMod)DMMulti=LAND(MultiBit,TDataMod)DMConst=LAND(ConstBit,TDataMod)DMAddr=LAND(PointerBit,TDataMod)IF LAND(ArrayBit,TDataMod)=ArrayBit THEN	DMArray=$ff	OpClass=ARRClass	IF DMMulti<>0 THEN		;MultiNdx=TMultiPtr		;SubCtr=SymTable(MultiNdx).DataMod		;SubValue(1)=SymTable(MultiNdx).Detail		;SubValue(2)=SymTable(MultiNdx).DataAddr		;SubValue(3)=SymTable(MultiNdx).DataSize	ELSE		SubCtr=1	ENDIF	RETURNENDIFIF TDataType>=2 AND TDataType<=4 OR LAND(TDataMod,PointerBit)=PointerBit THEN	OpClass=INTClass	RETURNENDIFIF TDataType=FCN AND LAND(TDataSize,$00000004)=4 THEN	OpClass=INTClassENDIFSELECT CASE TDataType	CASE BOOLVAR		OpClass=BOOLClass	CASE STRINGVAR		OpClass=STRClass	CASE FLOATVAR		OpClass=FLTClass	CASE COMPLEX		OpClass=CPXClass	CASE LABELPTR		OpClass=LBLClass	CASE ELSE		OpClass=0END SELECTRETURNExpr:GOSUB GetExpErrRetGOSUB ProcExpErrRetGOSUB ClassOpRETURNTokenSym:GOSUB NexTokenIF TokenLen=0 THEN	ErrNo=ErrSyntax	RETURNENDIFGOSUB TokenSym1RETURNTokenSym1:GOSUB GtRootSymGOSUB ValidSymIF SymbolOK=0 THEN	ErrNo=ErrIVSNam	RETURNENDIFSymTemp.SymName=SymbolSafGOSUB SymSrchRETURNClrSym:SymTemp.Detail=0SymTemp.DataAddr=0SymTemp.DataSize=0SymTemp.ArrayDim1=0SymTemp.ArrayDim2=0SymTemp.ArrayDim3=0SymTemp.GUIEvents=0SymTemp.GUINotifyEvents=0SymTemp.ArrayDims=0SymTemp.Misc=0SymTemp.FcnDataType=0SymTemp.FcnArgs=0RETURNCallErr:IF StatFlag=$ff THEN	RETURNENDIFINCR OELabelNumOutBuf="cmp eax,-1"GOSUB OutCodeOutBuf="jg _OELbl"+STR(OELabelNum)GOSUB OutCodeImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeOutBuf="mov [ERR],eax"GOSUB OutCodeOutBuf="jmp [_ErrVec]"GOSUB OutCodeOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeRETURNCallErrZ:IF StatFlag=$ff THEN	RETURNENDIFINCR OELabelNumOutBuf="cmp eax,0"GOSUB OutCodeOutBuf="jne _OELbl"+STR(OELabelNum)GOSUB OutCodeImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeOutBuf="mov [ERR],eax"GOSUB OutCodeOutBuf="jmp [_ErrVec]"GOSUB OutCodeOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeRETURNGetAccMod:GOSUB NexTokenIF TokenBuf="dir" THEN	DirFlag=$ff	GOSUB NexToken	IF TokenBuf="+" THEN		GOSUB NexToken;  eat optional "+"	ENDIFELSE	DirFlag=0ENDIFIF CrOpFlag=$ff THEN	AccMode="A_WRITE|A_CREAT|A_EXCL"ENDIFIF TokenLen<>0 THEN	SELECT CASE TokenBuf		CASE "update"			IF CrOpFlag=$ff THEN				;CreatMode="P_WRITE|P_READ"			ELSE				AccMode="A_UPDATE"			ENDIF		CASE "read"			IF CrOpFlag=$ff THEN				CreatMode="P_READ"			ELSE				AccMode="A_READ"			ENDIF		CASE "write"			IF CrOpFlag=$ff THEN				CreatMode="P_WRITE|P_READ"			ELSE				AccMode="A_WRITE"			ENDIF	END SELECTELSEAccModErr:	ErrNo=ErrSyntax	RETURNENDIFGOSUB NexTokenIF TokenLen<>0 THEN; Check this block of code	IF TokenBuf="+" THEN		GOSUB NexToken;  eat optional "+"		IF TokenBuf="dir" THEN			DirFlag=$ff		ELSE			IF TokenBuf="binary" THEN				AccMode=AccMode+"|A_BINARY"			ELSE				IF TokenBuf="text" THEN					;AccMode=AccMode+"|A_TEXT"				ELSE					ErrNo=ErrSyntax				ENDIF			ENDIF		ENDIF	ENDIFENDIFRETURNGetOpSize:SELECT CASE TDataType	CASE BOOLVAR		TempInt=1	CASE BYTEVAR		TempInt=1	CASE WORDVAR		TempInt=2	CASE LONGVAR		TempInt=4	CASE LABELPTR		TempInt=4	CASE FLOATVAR		TempInt=8	CASE COMPLEX		TempInt=SymTable(SymTable(SymNdx).Detail).DataSize	CASE STRINGVAR		TempInt=(SymTable(SymNdx).Detail)END SELECTIF LAND(TDataMod,PointerBit)=PointerBit THEN	TempInt=4ENDIFRETURNDevChk:GOSUB NexTokenIF TokenBuf="#" THEN	DevFlag=$ffELSE	GOSUB UnDoTokenENDIFRETURNGetPthNum:GOSUB GetPthNum1RETURNGetPthNum1:GOSUB GetExpErrRetIF SymTable(SymNdx).DataType>99 THEN	ErrNo=ErrSyntax	RETURNENDIFGOSUB ProcExpErrRetGOSUB GetPthNum2RETURNGetPthNum2:GOSUB ClassOpIF TSubType<>FILE AND TSubType<>DEVICE THEN	ErrNo=ErrTypMis	RETURNENDIFIF Target=0 THEN	IF TSymName<>"~" THEN		D0Loaded=0		GOSUB LoadReg		ErrRet	ENDIF	OutBuf="mov [_IOPthNum],eax"	GOSUB OutCodeDataELSE	IF DMConst<>0 THEN		ErrNo=ErrIVExp		RETURN	ENDIF	IF DMVector=0 THEN		PathIsVector=0		PathVar=TSymName	ELSE		PathIsVector=$ff		PathVar=TSymName	ENDIFENDIF; The following code makes the "," following the device name; acceptable but not mandatoryIF FileStat=0 AND KeyNdx<>23 THEN; Not fcn or close	GOSUB NexToken	IF TokenBuf<>"," THEN		GOSUB UnDoToken	ENDIFENDIFRETURNGetPthNam:GOSUB ExprErrRetIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	RETURNENDIFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataRETURNBufRW:BufRWFlg=$ffDiskIO=$ffGOSUB GetPthNumErrRetGOSUB GetIntOp; Get AddressErrRetOutBuf="mov [_XferAddr],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOp; Get # of bytesErrRetOutBuf="mov [XferCount],eax"GOSUB OutCodeDataRETURNGetPut:DiskIO=$ffGOSUB GetPthNumErrRetGOSUB ExprErrRetIF DMConst<>0 THEN	ErrNo=ErrTypMis	RETURNENDIFIF DMVector=0 THEN	IF DMArray<>0 AND TDataType=COMPLEX THEN		OutBuf="mov esi,"+TSymName+"-("+STR(ArrayBase)+"*"+STR(TDataAddr)+")"		CpxArrayOffset=ArrayBase*TDataAddr		OutBuf=OutBuf+"+"+STR(SymTable(ExpTable(ExpNdx+5)).DataAddr)	ELSE		OutBuf="mov esi,"+TSymName	ENDIF	GOSUB OutCodeDataENDIFOutBuf="mov [_XferAddr],esi"GOSUB OutCodeDataOutBuf="mov [XferCount],"+STR(SymTemp.DataSize)GOSUB OutCodeDataRETURNReadWrite:DiskIO=$ffGOSUB GetPthNumErrRetGOSUB ExprErrRetIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMisENDIFOutBuf="mov [_XferAddr],esi"GOSUB OutCodeDataOutBuf="mov [__ByteCounter],"+STR(SymTemp.Detail)GOSUB OutCodeDataRETURNGetRegPrm:GOSUB GetSymTempExpNdxGOSUB GetRP1RETURNGetRP1:TDataType=SymTemp.DataTypeTDataMod=SymTemp.DataModIF LAND(SymTemp.DataMod,PointerBit)<>PointerBit THEN	IF TDataType<1 OR TDataType>5 THEN		ErrNo=ErrIVExp		RETURN	ENDIFENDIFGOSUB GetDtaTypIF FloatFlag=0 THEN	Reg0Name="eax"	Reg1Name="edx"ELSE	Reg0Name="eaxf"	Reg1Name="edxf"ENDIFIF D0Loaded=0 THEN	LdRegName=Reg0NameELSE	LdRegName=Reg1NameENDIFRETURNLoadReg:IF Promote=$ff OR Demote=$ff THEN	GOSUB SymSrch	GOSUB GetSymTemp	GOSUB GetRP1ELSE	GOSUB GetRegPrmENDIFErrRetTDataType=SymTemp.DataTypeIF LAND(ConstBit,SymTemp.DataMod)=ConstBit THEN	TConst=$ff	TConstVal=SymTemp.DetailELSE	TConst=0ENDIFIF D0Loaded=0 THEN	D0Const=TConst	D0ConstVal=TConstVal	SELECT CASE TDataType		CASE BOOLVAR			LdRegName="al"		CASE BYTEVAR			LdRegName="al"		CASE WORDVAR			LdRegName="ax"		CASE LONGVAR			LdRegName="eax"	END SELECT	ELSE	D1Const=TConst	D0ConstVal=TConstVal	SELECT CASE TDataType		CASE BOOLVAR			LdRegName="dl"		CASE BYTEVAR			LdRegName="dl"		CASE WORDVAR			LdRegName="dx"		CASE LONGVAR			LdRegName="edx"	END SELECTENDIFIF TConst<>0 THEN	OutBuf="mov "+LdRegName+","+STR(TConstVal)ELSE	IF LAND(VectorBit,SymTemp.DataMod)=0 THEN		GOSUB ClrDataRegs		OutBuf="mov "+LdRegName+","+_DataType+"["+SymTemp.SymName+"]"	ELSE		ediUsed=TRUE		OutBuf="mov edi,["+SymTemp.SymName+"]"		GOSUB OutCodeData		GOSUB ClrDataRegs		OutBuf="mov "+LdRegName+","+_DataType+"[edi]"	ENDIFENDIFD0Loaded=$ffGOSUB OutCodeDataRETURNStoreD0:SymTemp.SymName=Op1NameGOSUB SymSrchTSymName=SymTable(SymNdx).SymNameTDataType=SymTable(SymNdx).DataTypeTDataMod=SymTable(SymNdx).DataModDMConst=0SELECT CASE TDataType	CASE BOOLVAR		Reg0Name="al"		OpSizeStr=" byte "	CASE BYTEVAR		Reg0Name="al"		OpSizeStr=" byte "	CASE WORDVAR		Reg0Name="ax"		OpSizeStr=" word "	CASE LONGVAR		Reg0Name="eax"		OpSizeStr=" dword "	CASE FLOATVAR		Reg0Name="floatreg"		OpSizeStr=" qword "END SELECTIF LAND(TDataMod,PointerBit)<>0 THEN		Reg0Name="eax"		OpSizeStr=" dword "ENDIFIF LAND(TDataMod,VectorBit)=0 THEN	OutBuf="mov"+OpSizeStr+"["+TSymName+"],"+Reg0NameELSE	IF LAND(TDataMod,PointerBit)<>0 THEN		Reg0Name="eax"		OutBuf="mov esi,"+SymTemp.SymName		GOSUB OutCodeData	ELSE		OutBuf="mov esi,["+SymTemp.SymName+"]"		GOSUB OutCodeData	ENDIF	OutBuf="mov"+OpSizeStr+"[esi],"+Reg0NameENDIFGOSUB OutCodeDataRETURNGetIntTmp:OpClass=INTClassGOSUB GetTmpRETURNGetTmp:IF TmpUse=NumTemps THEN	ErrNo=ErrTmpUse	RETURNENDIFINCR TmpUseIF TmpUse>TmpMax THEN	TmpMax=TmpUse	GOSUB VarBlank	Comment="Temporary Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf="_Tmp"+STR(TmpUse)+" rd 1"	GOSUB OutUninitDataENDIFSymTemp.SymName="_Tmp"+STR(TmpUse)GOSUB SymSrchIF OpClass=INTClass THEN	SymTable(SymNdx).DataType=LONGVARELSE	SymTable(SymNdx).DataType=TDataTypeENDIFSymTable(SymNdx).DataSize=TDataSizeRETURNGetFltTmp:IF FTmpUse=NumTemps THEN	ErrNo=ErrTmpUse	RETURNENDIFINCR FTmpUseIF FTmpUse>FTmpMax THEN	FTmpMax=FTmpUse	GOSUB VarBlank	Comment="Temporary Floating Point Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf=";static double _FTmp"+STR(FTmpUse)+";"	GOSUB OutUninitData	GOSUB VarBlankENDIFSymTemp.SymName="_FTmp"+STR(FTmpUse)GOSUB SymSrchRETURNGetStrVec:INCR StrTmpUseIF StrTmpUse>StrTmpMax THEN	StrTmpMax=StrTmpUse	GOSUB VarBlank	Comment="Temporary String Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf="_StrTmp"+STR(StrTmpUse)+" rb 32"	GOSUB OutUninitDataENDIFGOSUB ReqTmpVecErrRetSymTable(SymNdx).DataMod=TmpVecSymTable(SymNdx).DataType=STRINGVARSymTable(SymNdx).Detail=32TempInt=32SymTable(SymNdx).DataAddr=0SymTable(SymNdx).DataSize=32OutBuf="mov esi,_StrTmp"+STR(StrTmpUse)GOSUB OutCodeDataGOSUB SetStrVecRETURNGetChrVec:INCR ChrTmpUseIF ChrTmpUse>ChrTmpMax THEN	ChrTmpMax=ChrTmpUse	GOSUB VarBlank	Comment="Temporary Character Variable"	GOSUB BldComment	GOSUB OutUninitData	OutBuf="_ChrTmp"+STR(ChrTmpUse)+" rb 1"	GOSUB OutUninitData	GOSUB VarBlankENDIFGOSUB ReqTmpVecErrRetSymTable(SymNdx).DataMod=TmpVecSymTable(SymNdx).DataType=STRINGVARSymTable(SymNdx).Detail=1TempInt=1SymTable(SymNdx).DataAddr=0SymTable(SymNdx).DataSize=1OutBuf="mov esi,_ChrTmp"+STR(ChrTmpUse)GOSUB OutCodeDataGOSUB SetStrVecRETURNSetStrVec:OutBuf="mov ["+SymTemp.SymName+"],esi"GOSUB OutCodeDataOutBuf="mov ["+SymTemp.SymName+"+4],"+STR(TempInt)GOSUB OutCodeDataOutBuf="mov ["+SymTemp.SymName+"+8],0"GOSUB OutCodeDataRETURNReqTmpVec:IF TmpVecUse=NumTemps THEN	ErrNo=ErrTmpUse	RETURNENDIFINCR TmpVecUseIF TmpVecUse>TmpVecMax THEN	TmpVecMax=TmpVecUse	GOSUB MakTmpVecENDIFSymTemp.SymName="_TmpVec"+STR(TmpVecUse)GOSUB SymSrchSymNdxSaf=SymNdxRETURNGetTmpVec:GOSUB ReqTmpVecErrRetSymTable(SymNdx).DataMod=TmpVecSymTable(SymNdx).DataMod=LOR(TDataMod,SymTable(SymNdx).DataMod)SymTable(SymNdx).DataType=TDataTypeSymTable(SymNdx).SubType=TSubTypeSymTable(SymNdx).Detail=TDetailSymTable(SymNdx).DataAddr=TDataAddrSymTable(SymNdx).DataSize=TDataSizeRETURNMakTmpVec:GOSUB VarBlankComment="Temporary Vector"GOSUB BldCommentGOSUB OutUninitDataOutBuf="_TmpVec"+STR(TmpVecUse)+" rd 3"GOSUB OutUninitDataRETURNSetTmpVec:GOSUB GetTmpVecErrRetExpTable(ExpNdx)=SymNdxediUsed=TRUEOutBuf="mov edi,["+TSymName+"]"GOSUB OutCodeDataIF SymTemp.DataType=COMPLEX THEN	OutBuf="add edi,"+STR(SymTable(ExpTable(ExpNdx+2)).DataAddr)	GOSUB OutCodeDataENDIFOutBuf="mov ["+SymTable(SymNdx).SymName+"],edi"GOSUB OutCodeDataIF TDataType<>STRINGVAR THEN	RETURNENDIFOutBuf="mov edi,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="mov ["+SymTable(SymNdx).SymName+"+4],edi"GOSUB OutCodeDataOutBuf="mov edi,["+TSymName+"+8]"GOSUB OutCodeDataOutBuf="mov ["+SymTable(SymNdx).SymName+"+8],edi"GOSUB OutCodeDataGOSUB ClassOpRETURNVectorize:GOSUB GetTmpVecErrRetGOSUB GetBaseExpTable(ExpNdx)=SymNdxOutBuf="mov ["+SymTemp.SymName+"],esi"GOSUB OutCodeDataRETURNGetLopVec:LopVarNdx=0GetLV1:INCR LopVarNdxIF LopVarNdx=101 THEN	ErrNo=ErrTmpUse	RETURNENDIFIF LoopVars(LopVarNdx)=ConStk(ConStkPtr).LoopName THEN GetLV2IF LoopVars(LopVarNdx)<>"%" THEN GetLV1LoopVars(LopVarNdx)=ConStk(ConStkPtr).LoopNameGOSUB VarBlankComment="For Loop Vector"GOSUB BldCommentGOSUB OutUninitDataOutBuf="_LopVec"+STR(LopVarNdx)+" rd 2"GOSUB OutUninitDataGetLV2:RETURNDoAnd:IF TDataType=FLOATVAR THEN	ErrNo=ErrTypMisENDIFOutBuf="and eax,edx"GOSUB OutCodeDataRETURNDoOr:IF TDataType=FLOATVAR THEN	ErrNo=ErrTypMisENDIFOutBuf="or eax,edx"GOSUB OutCodeDataRETURNDoAdd:OutBuf="add "+Reg0Name+","+Reg1NameGOSUB OutCodeDataRETURNDoSub:OutBuf="sub "+Reg0Name+","+Reg1NameGOSUB OutCodeDataRETURNDoMul:;print SrcLine;print D0Const;print D1ConstOutBuf="imul "+Reg1NameGOSUB OutCodeDataRETURNDoDiv:;print SrcLine;print D0Const;print D1Const; The following is ONLY for integer divideOutBuf="mov ecx,edx"GOSUB OutCodeDataOutBuf="xor edx,edx"GOSUB OutCodeDataOutBuf="idiv ecx"GOSUB OutCodeDataRETURNCmpNum:D0Loaded=0Promote=$ffSymTemp.SymName=Op1NameGOSUB LoadRegSymTemp.SymName=Op2NameGOSUB LoadRegIF TDataType=BOOLVAR THEN	OutBuf="cmp al,dl"ELSE	OutBuf="cmp "+Reg0Name+","+Reg1NameENDIFGOSUB OutCodeDataIF SimpleCmp=0 THEN	OutBuf=SymType+"bl"	GOSUB OutCodeDataENDIFRETURNCmpString:ediUsed=TRUEOutBuf="mov edi,"+Op1NameGOSUB OutCodeDataOutBuf="mov esi,"+Op2NameGOSUB OutCodeDataUseCmpStr=TRUEOutBuf="call __CmpStr"GOSUB OutCodeDataIF SimpleCmp=0 THEN	OutBuf=SymType+"bl"	GOSUB OutCodeDataENDIFRETURNNexToken:ExpEnd=0TokenLen=0TokenType=0QuoteFlag=0EscSeq=0NextByte=""TokenBuf=""TokenSaf=""NexToken1:INCR SrcNdxIF SrcNdx>LEN(SrcLine) THEN NexToken5TempByte=MID(SrcLine,SrcNdx,1)NextByte=MID(SrcLine,SrcNdx+1,1)AsciiByte=ASC(TempByte)IF AsciiByte=OBQUOTE AND EscSeq=0 THEN	IF QuoteFlag=0 AND TokenLen<>0 THEN NexToken5	GOSUB NexToken3	IF QuoteFlag=1 THEN		TokenType=TTypQuote		GOTO NexToken6	ELSE		QuoteFlag=1		EscSeq=0		GOTO NexToken1	ENDIFENDIFIF QuoteFlag=1 THEN	IF EscSeq=$ff THEN		EscSeq=0	ELSE		IF AsciiByte=$5c THEN			EscSeq=$ff		ENDIF	ENDIF	GOSUB NexToken3	GOTO NexToken1ENDIFIF TempByte="." THEN	IF TokenType=TTypInt THEN		TokenType=TTypFloat		GOSUB NexToken3		GOTO NexToken1	ENDIF	IF TokenLen=0 THEN		IF NextByte>="0" AND NextByte<="9" THEN			TokenType=TTypFloat			GOSUB NexToken3			GOTO NexToken1		ENDIF	ENDIFENDIFIF TempByte="'" OR TempByte=";" THEN NexToken5; RemarkIF TempByte="<" OR TempByte=">" OR TempByte="=" THEN	IF TokenLen<>0 THEN NexToken5	TokenType=TTypRelOp	GOSUB NexToken3	IF TempByte="=" THEN		GOTO NexToken6	ENDIF	IF NextByte=">" OR NextByte="=" THEN		INCR SrcNdx		TempByte=MID(SrcLine,SrcNdx,1)		GOSUB NexToken3	ENDIF	GOTO NexToken6ENDIFIF AsciiByte=$20 OR AsciiByte=$09 THEN	IF TokenLen<>0 THEN		DECR SrcNdx		NextByte=" "		ExpEnd=$ff		GOTO NexTokDone	ENDIF	GOTO NexToken1ENDIFIF DimFlag=0 THEN	IF TempByte="(" OR TempByte=")" THEN		IF TokenLen<>0 THEN NexToken5		GOSUB NexToken3		TokenType=TTypParen		GOTO NexToken6	ENDIFENDIFIF DimFlag=0 OR TempByte<>"," THEN;  special cond for multi-dim array	IF TempByte="," OR TempByte=";" OR TempByte=":" OR TempByte="." THEN		IF TokenLen<>0 THEN NexToken5		GOSUB NexToken3		TokenType=TTypPunct		GOTO NexToken6	ENDIFENDIFIF TempByte="+" OR TempByte="-" OR TempByte="*" OR TempByte="/"  OR TempByte="&" OR TempByte="|" THEN	IF TokenLen<>0 THEN NexToken5	GOSUB NexToken3	TokenType=TTypMath	GOTO NexToken6ENDIFIF DimFlag=$ff THEN NexToken2IF TempByte="$" OR TempByte="_" OR TempByte="@" THEN NexToken2IF TempByte="!" AND ExclamationOK=TRUE THEN NexToken2IF TempByte>="0" AND TempByte<="9" THEN NexToken2IF TempByte>="A" AND TempByte<="Z" THEN NexToken2IF TempByte>="a" AND TempByte<="z" THEN NexToken2IF TokenLen<>0 THEN NexToken5GOSUB NexToken3TokenType=TTypMiscGOTO NexToken6NexToken2:GOSUB NexToken3GOTO NexToken1NexToken5:DECR SrcNdxNextByte=MID(SrcLine,SrcNdx+1,1)NexToken6:IF NextByte=" " OR ASC(NextByte)=9 OR NextByte=":" OR NextByte=";" THEN	ExpEnd=$ffENDIFIF NextByte="<" OR NextByte=">" OR NextByte="=" OR NextByte="" OR NextByte=";" THEN	ExpEnd=$ffENDIFNexTokDone:IF TokenType=TTypInt AND RIGHT(TokenBuf,1)="h" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="$"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="$"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	ENDIF	TokenBuf=TokenSaf	TokenType=TTypHexENDIFIF TokenType=TTypInt AND RIGHT(TokenBuf,1)="o" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="%"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="%"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	ENDIF	TokenBuf=TokenSaf	TokenType=TTypOctENDIFIF TokenType=TTypInt AND RIGHT(TokenBuf,1)="b" THEN; Intel hex->Motorola	IF LEFT(TokenBuf,1)<>"0" THEN		TokenSaf="&"+LEFT(TokenBuf,LEN(TokenBuf)-1)	ELSE		TokenSaf="&"+MID(TokenBuf,2,LEN(TokenBuf)-2); removes leading 0	ENDIF	TokenBuf=TokenSaf	TokenType=TTypBinENDIFIF TokenType=TTypInt AND MID(TokenBuf,2,1)="x" THEN; C hex->Motorala	TokenSaf="$"+MID(TokenBuf,3,LEN(TokenBuf)-2)	TokenBuf=TokenSaf	TokenType=TTypHexENDIFRETURNNexToken3:INCR TokenLenTokenSaf=TokenSaf+TempByteIF TempByte>="A" AND TempByte<="Z" THEN	AsciiByte=LOR(AsciiByte,$20)	TempByte=CHR(AsciiByte)ENDIFTokenBuf=TokenBuf+TempByteIF TokenLen=1 THEN	IF TokenBuf="$" THEN		TokenType=TTypHex	ENDIF	IF TokenBuf>="0" AND TokenBuf<="9" THEN		TokenType=TTypInt	ENDIF	IF TokenBuf>="a" AND TokenBuf<="z" OR TokenBuf="_" THEN		TokenType=TTypSym	ENDIF	IF TokenBuf="!" AND ExclamationOK=TRUE THEN		TokenType=TTypSym	ENDIFENDIFRETURNUnDoToken:SrcNdx=SrcNdx-TokenLenNextByte=""RETURNMacToken:TokenLen=0TokenSaf=""MacToken1:INCR SrcNdxTempByte=MID(SrcLine,SrcNdx,1)AsciiByte=ASC(TempByte)IF AsciiByte=NewLine OR AsciiByte=0 THEN	DECR SrcNdx	RETURNENDIFIF AsciiByte=$2c THEN;  comma	IF TokenLen=0 THEN		TokenSaf=TempByte		TokenLen=1	ELSE		DECR SrcNdx	ENDIF	RETURNENDIFTokenSaf=TokenSaf+TempByteINCR TokenLenGOTO MacToken1SymChk:SymbolOK=0IF ByteArray(1)<$61 OR ByteArray(1)>$7a THEN	IF ByteArray(1)<>$5f THEN		RETURN	ENDIFENDIFFOR I=2 TO TokenLen	IF ByteArray(I)<$61 OR ByteArray(I)>$7a THEN		IF ByteArray(I)<$30 OR ByteArray(I)>$39 THEN			IF ByteArray(I)<>$24 OR ByteArray(I)<>$5f THEN				RETURN			ENDIF		ENDIF	ENDIFNEXT ISymbolOK=$ffRETURN	ValidSym:SymbolOK=0IF LEN(RootSym)>28 THEN	RETURNENDIFIF LNFlag=0 THEN NotLineNumIF LEN(RootSym)>5 THEN NotLineNumTempByte=MID(RootSym,1,1)IF TempByte<"0" OR TempByte>"9" THEN NotLineNumLabNdx=1BldLineNumLbl:INCR LabNdxIF LabNdx>LEN(RootSym) THEN	SymbolSaf="_LN"	SymbolSaf=SymbolSaf+RootSym	SymbolOK=$ff	RETURNENDIFTempByte=MID(RootSym,LabNdx,1)IF TempByte<"0" OR TempByte>"9" THEN	RETURNENDIFGOTO BldLineNumLblNotLineNum:LabNdx=1TempByte=MID(RootSym,1,1)IF TempByte>="A" AND TempByte<="Z" THEN ValidSymLoopIF TempByte>="a" AND TempByte<="z" THEN ValidSymLoopIF TempByte="_" THEN ValidSymLoopIF TempByte="!" AND ExclamationOK=TRUE THEN ValidSymLoopRETURNValidSymLoop:INCR LabNdxIF LabNdx>LEN(RootSym) THEN	SymbolOK=$ff	SymbolSaf=RootSym	RETURNENDIFTempByte=MID(RootSym,LabNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidSymLoopIF TempByte>="A" AND TempByte<="Z" THEN ValidSymLoopIF TempByte>="a" AND TempByte<="z" THEN ValidSymLoopIF TempByte="_" THEN ValidSymLoopIF TempByte="$" AND LabNdx=LEN(RootSym) THEN ValidSymLoopRETURNValidInt:IntOK=0IF LEN(TokenBuf)>10 THEN	RETURNENDIFValidNdx=0ValidIntLoop:INCR ValidNdxIF ValidNdx>LEN(TokenBuf) THEN	IntOK=$ff	RETURNENDIFTempByte=MID(TokenBuf,ValidNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidIntLoopRETURNValidHex:HexOK=0IF LEN(TokenBuf)>9 THEN	RETURNENDIFValidNdx=1ValidHexLoop:INCR ValidNdxIF ValidNdx>LEN(TokenBuf) THEN	HexOK=$ff	RETURNENDIFTempByte=MID(TokenBuf,ValidNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidHexLoopIF TempByte>="a" AND TempByte<="f" THEN ValidHexLoopRETURNValidFlt:OneDot=0FloatOK=0IF LEN(TokenBuf)>21 THEN	RETURNENDIFValidNdx=0ValidFltLoop:INCR ValidNdxIF ValidNdx>LEN(TokenBuf) THEN	FloatOK=$ff	RETURNENDIFTempByte=MID(TokenBuf,ValidNdx,1)IF TempByte>="0" AND TempByte<="9" THEN ValidFltLoopIF TempByte="." THEN	IF OneDot=0 THEN		OneDot=$ff		GOTO ValidFltLoop	ENDIFENDIFRETURNSymSrch:SymFull=0SymFound=FALSESymNdx=0TempName=SymTemp.SymNameTempStr=TempNameTempInt=CHKWORD(TempStr)SymSrch1:INCR SymNdxIF SymNdx>LastSym THEN	IF SymNdx>SymTabSiz THEN		SymFull=$ff	ENDIF	RETURNENDIFIF SymTableKey(SymNdx)<>TempInt THEN SymSrch1IF SymTable(SymNdx).SymName<>TempName THEN SymSrch1SymFound=TRUERETURNSymSearch:GOSUB SymSrchIF SymFound=TRUE THEN	RETURNENDIFSymTemp.SymName=TokenSafGOSUB SymSrchRETURNSymInsert:IF SymFull=$ff THEN	ErrNo=ErrSymFul	RETURNENDIFSymTable(SymNdx)=SymTempLastSym=SymNdxTempStr=SymTemp.SymNameSymTableKey(SymNdx)=CHKWORD(TempStr)RETURNKeyLook:KeyNdx=0TempInt=CHKWORD(TokenBuf)BEGIN LOOP	INCR KeyNdx	IF KeyNdx>LastKey THEN		KeyNdx=0		RETURN	ENDIF	CONTINUE IF KeyTable(KeyNdx).KeyCheckWord<>TempInt	IF KeyTable(KeyNdx).KeyName=TokenBuf THEN		RETURN	ENDIFEND LOOPObjLook:ObjNdx=0TempInt=CHKWORD(TokenBuf)BEGIN LOOP	INCR ObjNdx	IF ObjNdx>LastObj THEN		ObjNdx=0		RETURN	ENDIF	CONTINUE IF ObjTable(ObjNdx).ObjCheckWord<>TempInt	IF ObjTable(ObjNdx).ObjName=TokenBuf THEN		RETURN	ENDIFEND LOOPCmpOps:Op1Class=0AndOrFlag=$ffCompFlag=$ffGUIObjFlag=0;//TextFlag=0;//CmpOps1:CmpOpFlag=FALSEPromote=0Demote=0TmpUse=0TmpVecUse=0FTmpUse=0ChrTmpUse=0StrTmpUse=0TypeFlag=0TDataMod=0FileStat=0GOSUB ClrDatTypGOSUB GetExpErrRetIF GUIObjFlag<>0 THEN;//	GOSUB UnDoToken;//	GUITargetFlag=0;//	GOSUB ValidateObject;//	ErrMain;//	GOSUB GUISource	Op1Name=GUITempName	Op1Type=GUIDataType	SELECT CASE Op1Type		CASE BOOLVAR			Op1Class=BOOLClass		CASE LONGVAR			Op1Class=INTClass		CASE STRINGVAR			Op1Class=STRClass	END SELECT	Op1Mod=0	Op1Detail=0ELSE	GOSUB ProcExp	ErrRet	GOSUB ClassOp	Op1Name=TSymName	Op1Class=OpClass	Op1Type=TDataType	Op1Mod=TDataMod	Op1Detail=TDetailENDIFIF TDataType=BOOLVAR THEN	IF NextByte="=" OR NextByte="<" THEN		GOSUB NexToken		IF TokenBuf="=" THEN			SymType="sete "			SimpleOp="je "			SimpleStructOp="jne "		ELSE			SymType="setne "			SimpleOp="jne "			SimpleStructOp="je "		ENDIF		IF TokenBuf<>"=" AND TokenBuf<>"<>" THEN			ErrNo=ErrIVExp			RETURN		ENDIF		GOTO CmpOps2	ELSE		Op2Name="true"		Op2Class=BOOLClass		Op2Type=1		Op2Mod=$04		Op2Detail=1		SymType="sete "		GOTO CmpOps3	ENDIFENDIFGOSUB NexTokenIF TokenType<>1 THEN	ErrNo=ErrIVExp	RETURNENDIFSymType=""SELECT CASE TokenBuf	CASE "="		SymType="sete "		SimpleOp="je "		SimpleStructOp="jne "	CASE "<"		SymType="setl "		SimpleOp="jl "		SimpleStructOp="jge "	CASE ">"		SymType="setg "		SimpleOp="jg "		SimpleStructOp="jle "	CASE "<="		SymType="setle "		SimpleOp="jle "		SimpleStructOp="jg "	CASE ">="		SymType="setge "		SimpleOp="jge "		SimpleStructOp="jl "	CASE "<>"		SymType="setne "		SimpleOp="jne "		SimpleStructOp="je "	CASE ELSE		ErrNo=ErrIVExp		RETURNEND SELECTCmpOps2:GUIObjFlag=0CmpOpFlag=TRUEGOSUB GetExpErrRetIF GUIObjFlag<>0 THEN;//	GOSUB UnDoToken;//	GUITargetFlag=0;//	GOSUB ValidateObject;//	ErrMain;//	GOSUB GUISource	Op2Name=GUITempName	Op2Type=GUIDataType	SELECT CASE Op2Type		CASE BOOLVAR			Op2Class=BOOLClass		CASE LONGVAR			Op2Class=INTClass		CASE STRINGVAR			Op2Class=STRClass	END SELECT	Op2Mod=0	Op2Detail=0ELSE	GOSUB ProcExp	ErrRet	GOSUB ClassOp	Op2Name=TSymName	Op2Class=OpClass	Op2Type=TDataType	Op2Mod=TDataMod	Op2Detail=TDetailENDIFTempInt=LOR(Op1Mod,TempBit)TempInt2=LOR(Op2Mod,TempBit)IF ComplexCmp=0 THEN	IF HasFcn=0 AND Op1Class=INTClass AND TempInt=TempBit AND Op2Class=INTClass AND Op2Mod=ConstBit THEN		GOSUB NexToken		IF TokenBuf<>"or" AND TokenBuf<>"and" THEN			SimpleCmp=$ff			IF Op1Type=BYTEVAR AND Op2Detail>255 THEN				ErrNo=ErrOpRange				RETURN			ENDIF			IF Op1Type=WORDVAR AND Op2Detail>65535 THEN				ErrNo=ErrOpRange				RETURN			ENDIF			IF Op1Type=LONGVAR AND Op2Detail>$7fffffff THEN				ErrNo=ErrOpRange				RETURN			ENDIF			OutBuf="cmp ["+Op1Name+"],"+STR(Op2Detail)			GOSUB OutCodeData			RETURN		ENDIF		GOSUB UnDoToken	ENDIF	IF HasFcn=0 AND Op1Class=BOOLClass AND TempInt=TempBit AND Op2Class=BOOLClass AND Op2Mod=ConstBit THEN		GOSUB NexToken		IF TokenBuf<>"or" AND TokenBuf<>"and" THEN			SimpleCmp=$ff			OutBuf="cmp ["+Op1Name+"],"+STR(Op2Detail)			GOSUB OutCodeData			RETURN		ENDIF		GOSUB UnDoToken	ENDIF	IF HasFcn=0 AND Op1Class=INTClass AND Op1Mod<>ConstBit AND TempInt=TempBit AND Op2Class=INTClass AND TempInt2=TempBit THEN		GOSUB NexToken		IF TokenBuf<>"or" AND TokenBuf<>"and" THEN			SimpleCmp=$ff			SELECT CASE Op1Type				CASE BYTEVAR					IF Op2Type=BYTEVAR THEN						OutBuf="mov al,["+Op2Name+"]"						GOSUB OutCodeData						OutBuf="cmp ["+Op1Name+"],al"						GOSUB OutCodeData						RETURN					ELSE						IF Op2Type=WORDVAR THEN							OutBuf="xor ax,ax"							GOSUB OutCodeData							OutBuf="mov al,["+Op1Name+"]"							GOSUB OutCodeData							OutBuf="mov dx,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp ax,dx"							GOSUB OutCodeData							RETURN						ELSE							OutBuf="xor eax,eax"							GOSUB OutCodeData							OutBuf="mov al,["+Op1Name+"]"							GOSUB OutCodeData							OutBuf="mov edx,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp eax,edx"							GOSUB OutCodeData							RETURN						ENDIF					ENDIF											CASE WORDVAR					IF Op2Type=WORDVAR THEN						OutBuf="mov ax,["+Op2Name+"]"						GOSUB OutCodeData						OutBuf="cmp ["+Op1Name+"],ax"						GOSUB OutCodeData						RETURN					ELSE						IF Op2Type=BYTEVAR THEN							OutBuf="xor ax,ax"							GOSUB OutCodeData							OutBuf="mov al,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp ["+Op1Name+"],ax"							GOSUB OutCodeData							RETURN						ELSE							OutBuf="xor eax,eax"							GOSUB OutCodeData							OutBuf="mov ax,["+Op1Name+"]"							GOSUB OutCodeData							OutBuf="mov edx,["+Op2Name+"]"							GOSUB OutCodeData							OutBuf="cmp eax,edx"							GOSUB OutCodeData							RETURN						ENDIF																			ENDIF				CASE LONGVAR					IF Op2Type=LONGVAR THEN						OutBuf="mov eax,["+Op2Name+"]"						GOSUB OutCodeData					ELSE						OutBuf="xor eax,eax"						GOSUB OutCodeData						IF Op2Type=WORDVAR THEN							OutBuf="mov ax,["+Op2Name+"]"							GOSUB OutCodeData						ELSE							OutBuf="mov al,["+Op2Name+"]"							GOSUB OutCodeData						ENDIF					ENDIF					OutBuf="cmp ["+Op1Name+"],eax"					GOSUB OutCodeData					RETURN			END SELECT			OutBuf="cmp ["+Op1Name+"],eax"			GOSUB OutCodeData			RETURN		ENDIF		GOSUB UnDoToken	ENDIFENDIFComplexCmp=$ffCmpOps3:GOSUB NexTokenIF TokenBuf<>"or" AND TokenBuf<>"and" AND InitTrue=0 THEN	SimpleCmp=$ffENDIFGOSUB UnDoTokenIF Op1Class=INTClass OR Op1Class=FLTClass OR Op1Class=BOOLClass THEN	GOSUB CmpNum	ErrRetENDIFIF Op1Class<>Op2Class THEN	EXITIF Op1Class=INTClass AND Op2Class=FLTClass	EXITIF Op1Class=FLTClass AND Op2Class=INTClass	ErrNo=ErrTypMis	RETURNENDIFIF Op1Class=STRClass THEN	GOSUB CmpStringENDIFIF Op1Class=0 OR Op1Class=ARRClass OR Op1Class=CPXClass THEN	ErrNo=ErrIVExp	RETURNENDIFIF InitTrue=0 AND SimpleCmp=0 THEN	OutBuf="xor bh,bh"	GOSUB OutCodeData	InitTrue=$ffENDIFIF SimpleCmp=0 THEN	IF AndOrFlag=0 THEN		OutBuf="and bh,bl"	ELSE		OutBuf="or bh,bl"	ENDIF	GOSUB OutCodeDataENDIFGOSUB NexTokenIF TokenBuf="and" THEN	AndOrFlag=0	GOTO CmpOps1ENDIFIF TokenBuf="or" THEN	AndOrFlag=$ff	GOTO CmpOps1ENDIFRETURNClrDatTyp:DMTemp=0DMVector=0DMMember=0DMMulti=0DMConst=0DMAddr=0DMArray=0RETURNGtRootSym:SubscrErr=0RootSym=""SubCtr=0Subscript(1)=""Subscript(2)=""Subscript(3)=""SubValue(1)=1SubValue(2)=1SubValue(3)=1LabNdx=0GtRtSym1:INCR LabNdxIF LabNdx>LEN(TokenSaf) THEN	RETURNENDIFTempByte=MID(TokenSaf,LabNdx,1)IF TempByte<>"(" THEN	RootSym=RootSym+TempByte	GOTO GtRtSym1ENDIFIF RIGHT(TokenSaf,1)<>")" THEN	SubscrErr=$ff	RETURNENDIFGtRtSym2:INCR SubCtrIF SubCtr>3 THEN	ErrNo=ErrSyntax	RETURNENDIFGtRtSym3:INCR LabNdxTempByte=MID(TokenSaf,LabNdx,1)IF TempByte=")" OR TempByte="," THEN	SymNdxSaf=SymNdx	TempStr=SymTemp.SymName	IF LEFT(Subscript(SubCtr),1)>="0" AND LEFT(Subscript(SubCtr),1)<="9" THEN		SubValue(SubCtr)=VAL(Subscript(SubCtr))	ELSE		SymTemp.SymName=Subscript(SubCtr)		GOSUB SymSrch		IF SymFound=TRUE AND SymTable(SymNdx).DataType=COMPVAR OR SymTable(SymNdx).DataType=MACROVAR THEN			SubValue(SubCtr)=SymTable(SymNdx).Detail		ELSE			ErrNo=ErrUDSym			RETURN		ENDIF	ENDIF	SymNdx=SymNdxSaf	SymTemp.SymName=TempStr	IF TempByte="," THEN GtRtSym2	RETURNENDIFSubscript(SubCtr)=Subscript(SubCtr)+TempByteGOTO GtRtSym3F1:; EOF(FileNum)FileStat=$ffGOSUB ClassOpGOSUB GetPthNum2ErrRetImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUEOutBuf="invoke GetFileSize,[_IOPthNum],0"GOSUB OutCodeDataOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataGOSUB CallErrImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],0,0,FILE_CURRENT"GOSUB OutCodeDataGOSUB CallErrOpClass=BOOLClassTDataType=BOOLVARGOSUB GetTmpErrRetOutBuf="cmp eax,[_ArgSafe0]"GOSUB OutCodeDataOutBuf="sete cl; Set result"GOSUB OutCodeDataOutBuf="mov byte ["+SymTemp.SymName+"],cl"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF2:; LEN(String)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis	RETURNENDIFOutBuf="mov esi,"+SymTemp.SymNameGOSUB OutCodeDataGOSUB GetIntTmpErrRetUseStrLen=TRUEOutBuf="call __StrLen"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF3:; STR(Number)GOSUB ClassOpGOSUB LoadRegErrRetIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF OpClass=INTClass THEN	IF FloatFlag<>0 THEN		OutBuf=";eax=eaxf;"		GOSUB OutCodeData		ENDIF	SELECT CASE FcnCode		CASE 69			TempInt=2		CASE 70			TempInt=8		CASE 3			TempInt=10		CASE 49			TempInt=16		CASE ELSE			ErrNo=ErrTypMis			RETURN	END SELECT	ImportFcnTable(ptrltoa).ImportFcnUse=TRUE				OutBuf="cinvoke ltoa,eax,[_ConvBuf1],"+STR(TempInt)ELSE	OutBuf=""ENDIFGOSUB OutCodeDataGOSUB NumToARETURNNumToA:GOSUB GetStrVecErrRetediUsed=TRUEOutBuf="mov edi,"+SymTemp.SymNameGOSUB OutCodeDataOutBuf="mov esi,_ConvBuf1"GOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF4:; VAL(String)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis;  wrong type	RETURNENDIFIF Op1Class=FLTClass AND FcnCode=4 THEN	FcnCode=24ENDIFIF FcnCode=24 THEN	OutBuf=";eaxf=_AtoD();"ELSE	OutBuf="mov esi,["+TSymName+"]"	GOSUB OutCodeData	UseAtoL=TRUE	OutBuf="call __AtoL"ENDIFGOSUB OutCodeDataIF FcnCode=24 THEN	INCR FloatFlag	OpClass=FLTClass	TDataType=FLOATVAR	GOSUB GetFltTmp	ErrRetELSE	OpClass=INTClass	GOSUB GetIntTmp	ErrRetENDIFIF FcnCode=24 THEN	OutBuf=";"+SymTemp.SymName+"=eaxf;"ELSE	OutBuf="mov ["+SymTemp.SymName+"],eax"ENDIFGOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF5:; LAND(Exp1,Exp2)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF TSymName<>"~" THEN	GOSUB LoadReg	ErrRetENDIFINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF TSymName<>"~" THEN	GOSUB LoadReg	ErrRetENDIFGOSUB GetIntTmpErrRetSELECT CASE FcnCode	CASE 5; LAND()		OutBuf="and eax,edx"	CASE 7; LOR()		OutBuf="or eax,edx"	CASE 9; MOD()		OutBuf="mov ecx,edx"		GOSUB OutCodeData		OutBuf="xor edx,edx"		GOSUB OutCodeData		OutBuf="idiv ecx"		GOSUB OutCodeData		OutBuf="mov eax,edx"	CASE 19; LXOR()		OutBuf="xor eax,edx"END SELECTGOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF6:; MID(String,Position,Quantity)IF FcnCode=6 THEN	IF ExpRight-ExpLeft<>4 THEN		ErrNo=ErrFcn		RETURN	ENDIFENDIFGOSUB MidLftRtRETURNMidLftRt:GOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	RETURNENDIFIF DMVector<>0 AND DMTemp=0 THEN	REM need to make a temp vector	GOSUB SetTmpVec	ErrRetENDIFOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB LoadReg; first argErrRetSELECT CASE FcnCode	CASE 6; Mid$		INCR ExpNdx		GOSUB ClassOp		IF OpClass<>INTClass THEN			ErrNo=ErrTypMis			RETURN		ENDIF		GOSUB LoadReg; second arg		ErrRet		UseMidStr=TRUE		OutBuf="call __MidStr"	CASE 8; Left$		OutBuf="mov edx,eax"		GOSUB OutCodeData		OutBuf="mov eax,1"		GOSUB OutCodeData		UseMidStr=TRUE		OutBuf="call __MidStr"	CASE 11; Right$		UseRightStr=TRUE		OutBuf="call __RightStr"	CASE 80; Tail$		UseTailStr=TRUE		OutBuf="call __TailStr"END SELECTGOSUB OutCodeDataExpNdx=ExpLeft+1RETURNF7:; LOR(Exp1,Exp2)GOSUB F5RETURNF8:; LEFT(String,Quantity)IF ExpRight-ExpLeft<>3 THEN	ErrNo=ErrFcn	RETURNENDIFGOSUB MidLftRtRETURNF9:; MOD(Exp1,Exp2)GOSUB F5RETURNF10:; CHR(Expr)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB LoadRegErrRetGOSUB GetChrVecErrRetOutBuf="mov [_ChrTmp"+STR(ChrTmpUse)+"],al"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF11:; RIGHT(String,Quantity)IF Target<>0 THEN	ErrNo=ErrIVTarg	RETURNENDIFGOSUB MidLftRtRETURNF12:; ASC(String)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrFcn	RETURNENDIFGOSUB GetIntTmpErrRetOutBuf="mov esi,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov al, byte [esi]"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF13:; NOT(Boolean)GOSUB ClassOpIF TDataType<>1 THEN	ErrNo=ErrTypMis	RETURNENDIFOpClass=BOOLClassTDataType=BOOLVARErrRetIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainENDIFGOSUB GetTmpOutBuf="btc eax,0"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF14:; BUFADR(Buffer)GOSUB ClassOpIF TDataType<>BUFFER THEN	ErrNo=ErrTypMisENDIFGOSUB GetIntTmpErrRetIF FcnCode=14 THEN	OutBuf="mov eax,["+TSymName+"]"ELSE	OutBuf="mov eax,["+TSymName+"+4]"ENDIFGOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF15:; BUFSIZ(Buffer)GOSUB F14RETURNF16:; TAB()IF PrintFlag=0 THEN	ErrNo=ErrFcn	RETURNENDIFTabFlag=$ffGOSUB ClassOpIF OpClass=INTClass THEN	GOSUB LoadReg	ErrRet	OutBuf="call __PrintTab"	GOSUB OutCodeData	GOSUB CallErrELSE	ErrNo=ErrTypMisENDIFRETURNF17:; PEEKGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadRegGOSUB GetIntTmpErrRetOutBuf="mov ecx,eax"GOSUB OutCodeDataOutBuf="mov byte al,[ecx]"GOSUB OutCodeDataOutBuf="mov byte ["+SymTemp.SymName+"],0"GOSUB OutCodeDataOutBuf="mov byte ["+SymTemp.SymName+"],al"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF18:; ADDR(Var)GOSUB ClassOpIF FloatFlag>0 THEN	DECR FloatFlagENDIFIF TDataType>STRINGVAR AND TDataType<COMPLEX OR DMConst<>0 THEN	ErrNo=ErrTypMis	RETURNENDIFIF DMArray=0 THEN	GOSUB GetBaseELSE	IF DMVector=0 THEN		OutBuf="mov esi,"+TSymName		GOSUB OutCodeData	ELSE		OutBuf="add esi,"+STR(CpxArrayOffset)		GOSUB OutCodeData	ENDIFENDIFOutBuf="mov eax,esi"GOSUB OutCodeDataGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF19:; LXOR(IntExpr)GOSUB F5RETURNF20:; LNOT(IntExpr)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrMainENDIFGOSUB GetIntTmpErrRetOutBuf="not "+Reg0NameGOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF21:; INDEX(Pointer,IntExpr)GOSUB ClassOpIF DMAddr=0 THEN	ErrNo=ErrTypMis	RETURNENDIFFcnOp1Nam=TSymNameIF DMVector<>0 THEN	FcnOp1Nam=FcnOp1Nam+"._Ptr"ENDIFGOSUB GetVarSizINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB GetIntTmpErrRetOutBuf="mov eax,"+TSymNameGOSUB OutCodeDataOutBuf="imul eax,"+STR(VarSize)GOSUB OutCodeDataOutBuf="add eax,["+FcnOp1Nam+"]"GOSUB OutCodeDataOutBuf="mov ["+SymTemp.SymName+"],eax"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNGetVarSiz:SELECT CASE TDataType	CASE COMPLEX		VarSize=SymTable(TDetail).DataSize	CASE STRINGVAR		VarSize=TDetail	CASE BOOLVAR		VarSize=1	CASE BYTEVAR		VarSize=1	CASE WORDVAR		VarSize=2	CASE LONGVAR		VarSize=4	CASE FLOATVAR		VarSize=8END SELECTRETURNF22:; SIZE(Var)GOSUB ClassOpIF FloatFlag>0 THEN	DECR FloatFlagENDIFIF TDataType<1 OR TDataType>6 THEN SIZE1VarSize=TDataSizeGOTO SIZE2SIZE1:IF TDataType=BUFFER THEN	VarSize=8	GOTO SIZE2ENDIFIF TDataType=COMPLEX THEN	VarSize=TDataSize	GOTO SIZE2ENDIFErrNo=ErrTypMisRETURNSIZE2:GOSUB GetIntTmpErrRetOutBuf="mov ["+SymTemp.SymName+"],"+STR(VarSize)GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF23:; IVAL(String)GOSUB F4RETURNF24:; FVAL(String)GOSUB F4RETURNF25:; TRIM$GOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrTypMis	RETURNENDIFIF DMVector<>0 AND DMTemp=0 THEN	GOSUB SetTmpVec	ErrRetENDIFOutBuf=""'call __TrmStrGOSUB OutCodeDataExpNdx=ExpLeft+1RETURNF26:; FILSIZ(FileNum)FileStat=$ffGOSUB ClassOpGOSUB GetPthNum2ErrRetImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUEOutBuf="invoke GetFileSize,[_IOPthNum],0"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF27:; FILPOS(FileNum)FileStat=$ffGOSUB ClassOpGOSUB GetPthNum2ErrRetImportFcnTable(ptrSetFilePointer).ImportFcnUse=TRUEOutBuf="invoke SetFilePointer,[_IOPthNum],0,0,FILE_CURRENT"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF28:; SQR(Expr)GOSUB ClassOpINCR FloatFlagIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNENDIFSELECT CASE FcnCode	CASE 28		TempStr="sqrt"	CASE 31		TempStr="sin"	CASE 32		TempStr="cos"	CASE 33		TempStr="tan"	CASE 34		TempStr="asin"	CASE 35		TempStr="acos"	CASE 36		TempStr="atan"	CASE 37		TempStr="log"	CASE 38		TempStr="log10"END SELECTGOSUB GetFltTmpErrRetIF DMVector=0 THEN	OutBuf=";"+SymTemp.SymName+"="+TempStr+"((double)"+TSymName+");"ELSE	OutBuf=";"+SymTemp.SymName+"="+TempStr+"(*((double*)"+TSymName+"._Ptr));"ENDIFGOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF29:; INT(FloatExpr)GOSUB ClassOpIF FloatFlag>0 THEN	DECR FloatFlagENDIFIF OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB GetIntTmpErrRetIF DMVector=0 THEN	OutBuf=";"+SymTemp.SymName+"=(long)"+TSymName+";"ELSE	OutBuf=";"+SymTemp.SymName+"=(long)*((double*)"+TSymName+"._Ptr);"ENDIFGOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF30:; ABS(Expr)GOSUB ClassOpIF OpClass<>INTClass AND OpClass<>FLTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF SymTemp.SymName<>"~" THEN	D0Loaded=0	GOSUB LoadRegENDIFIF OpClass=INTClass THEN	GOSUB GetIntTmp	ErrRet	ImportFcnTable(ptrabs).ImportFcnUse=TRUE	OutBuf="cinvoke abs,eax"	GOSUB OutCodeData	GOSUB StoreD0TmpELSE	GOSUB GetFltTmp	ErrRet	OutBuf=";"+SymTemp.SymName+"=fabs("+TSymName+");"	GOSUB OutCodeDataENDIFExpTable(ExpNdx)=SymNdxRETURNF31:; SIN(Expr)GOSUB F28RETURNF32:; COS(Expr)GOSUB F28RETURNF33:; TAN(Expr)GOSUB F28RETURNF34:; ASN(Expr)GOSUB F28RETURNF35:; ACS(Expr)GOSUB F28RETURNF36:; ATN(Expr)GOSUB F28RETURNF37:; LOG(Expr)GOSUB F28RETURNF38:; LOG10(Expr)RETURNF39:; VacantRETURNF40:; VacantRETURNF41:; THOUR()GOSUB DateTimeRETURNF42:; TMIN()GOSUB DateTimeRETURNF43:; TSEC()GOSUB DateTimeRETURNF44:; TYEAR()GOSUB DateTimeRETURNF45:; TMON()GOSUB DateTimeRETURNF46:; TDAT()GOSUB DateTimeRETURNF47:; TDAY()GOSUB DateTimeRETURNDateTime:OutBuf=";_t=time(0);"GOSUB OutCodeDataOutBuf=";_systime=localtime(&_t);"GOSUB OutCodeDataGOSUB GetIntTmpErrRetIF FcnCode=41 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_hour;"	GOSUB OutCodeDataENDIFIF FcnCode=42 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_min;"	GOSUB OutCodeDataENDIFIF FcnCode=43 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_sec;"	GOSUB OutCodeDataENDIFIF FcnCode=44 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_year;"	GOSUB OutCodeDataENDIFIF FcnCode=45 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_mon+1;"	GOSUB OutCodeDataENDIFIF FcnCode=46 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_mday;"	GOSUB OutCodeDataENDIFIF FcnCode=47 THEN	OutBuf=";"+SymTemp.SymName+"=_systime->tm_wday;"	GOSUB OutCodeDataENDIFExpTable(ExpNdx)=SymNdxRETURNF48:; CHKWORD(STRING);code template is for ASC(STRING)GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrFcn	RETURNENDIFGOSUB GetIntTmpErrRetOutBuf="xor eax,eax"GOSUB OutCodeDataOutBuf="mov esi,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov edx,["+TSymName+"+4]"GOSUB OutCodeDataOutBuf="xor ecx,ecx"GOSUB OutCodeDataINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="xor ebx,ebx"GOSUB OutCodeDataOutBuf="mov bl, byte [esi]"GOSUB OutCodeDataOutBuf="or bl,bl"GOSUB OutCodeDataOutBuf="je "+"_Lbl"+STR(LabelNum+1)GOSUB OutCodeDataOutBuf="sal ebx,cl"GOSUB OutCodeDataOutBuf="inc esi"GOSUB OutCodeDataOutBuf="add cl,4"GOSUB OutCodeDataOutBuf="add eax,ebx"GOSUB OutCodeDataOutBuf="dec edx"GOSUB OutCodeDataOutBuf="jne "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataINCR LabelNumOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF49:; HEX(INT)GOSUB F3RETURNF50:; BITTST(ByteVar,Bit#)GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB LoadRegErrRetINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB LoadRegErrRetOutBuf="bt eax,edx"GOSUB OutCodeDataOpClass=BOOLClassTDataType=BOOLVARGOSUB GetTmpErrRetOutBuf="setc cl; Set result"GOSUB OutCodeDataOutBuf="mov byte ["+SymTemp.SymName+"],cl"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF51:; SHLGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB LoadRegErrRetINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB LoadRegErrRetOutBuf="mov ecx,edx"GOSUB OutCodeDataOpSizeStr="cl"SELECT CASE FcnCode	CASE 51		TempStr="shl "	CASE 52		TempStr="shr "	CASE 53		TempStr="rol "	CASE 54		TempStr="ror "	CASE 55		TempStr="btc "		OpSizeStr="ecx"	CASE 56		TempStr="btr "		OpSizeStr="ecx"	CASE 57		TempStr="bts "		OpSizeStr="ecx"	CASE 62		TempStr="sal "	CASE 63		TempStr="sar "	CASE 64		TempStr="rcl "	CASE 65		TempStr="rcr "ENDSELECTOutBuf=TempStr+Reg0Name+","+OpSizeStrGOSUB OutCodeDataGOSUB GetIntTmpErrRetGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF52:; SHRGOSUB F51RETURNF53:; ROLGOSUB F51RETURNF54:; RORGOSUB F51RETURNF55:; BITCHGGOSUB F51RETURNF56:; BITCLRGOSUB F51RETURNF57:; BITSETGOSUB F51RETURNF58:; SUBSTR(Str1,Str2,[StartPos])GOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrIVType	RETURNENDIFIF DMVector<>0 AND DMTemp=0 THEN	GOSUB SetTmpVec	ErrRetENDIFFcnOp1Nam=TSymNameINCR ExpNdxGOSUB ClassOpIF TDataType<>STRINGVAR THEN	ErrNo=ErrIVType	RETURNENDIFIF DMVector<>0 AND DMTemp=0 THEN	GOSUB SetTmpVec	ErrRetENDIFTempStr=TSymNameIF ExpRight-ExpLeft=4 THEN	INCR ExpNdx	GOSUB ClassOp	IF OpClass<>INTClass THEN		ErrNo=ErrIVType		RETURN	ENDIFELSE	TSymName="1"ENDIFGOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=_SubStr(&"+FcnOp1Nam+",&"+TempStr+","+TSymName+");"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF59:; ZSTR(INT)GOSUB ClassOpGOSUB LoadRegErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFOutBuf=";_ZLtoA(eax);"GOSUB OutCodeDataGOSUB NumToARETURNF60:; ZHEX(INT)GOSUB ClassOpGOSUB LoadRegErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFOutBuf=";_ZLtoH(eax);"GOSUB OutCodeDataGOSUB NumToARETURNF61:; USING()RETURNF62:; SAL()GOSUB F51RETURNF63:; SAR()GOSUB F51RETURNF64:; RCL()GOSUB F51RETURNF65:; RCR()GOSUB F51RETURNF66:' TABLESIZE()GOSUB ClassOpIF LAND(TDataMod,ArrayBit)<>ArrayBit THEN	ErrNo=ErrTypMis	RETURNENDIFGOSUB GetIntTmpErrRetTempInt=TDataSize/TDataAddrOutBuf="mov ["+SymTemp.SymName+"],"+STR(TempInt)GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF67:' FilTyp()'GetFileTypeRETURNF68:' CurDir()'GetCurrentDirectoryRETURNF69:' BIN()GOSUB F3RETURNF70:' OCT()GOSUB F3RETURNF71:' Vacant()RETURNF72:' RND()GOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=rand();"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF73:' GETTICKCOUNT()GOSUB GetIntTmpErrRetImportFcnTable(ptrGetTickCount).ImportFcnUse=TRUEOutBuf="invoke GetTickCount"GOSUB OutCodeDataGOSUB StoreD0TmpExpTable(ExpNdx)=SymNdxRETURNF74:' Vacant()RETURNF75:' Vacant()RETURNF76:' Vacant()RETURNF77:' Vacant()RETURNF78:' LCASE()GOSUB ClassOpIF TDataType<>STRINGVAR OR DMArray<>0 THEN	ErrNo=ErrTypMis	RETURNENDIFediUsed=TRUEOutBuf="mov edi,_IOBuffer"GOSUB OutCodeDataOutBuf="mov esi,"+TSymNameGOSUB OutCodeDataUseMovStr=TRUEOutBuf="call __MovStr"GOSUB OutCodeDataOutBuf="mov esi,_IOBuffer"GOSUB OutCodeDataIF FcnCode=78 THEN	UseLCase=TRUE	OutBuf="call __LCase"ELSE	UseUCase=TRUE	OutBuf="call __UCase"ENDIFGOSUB OutCodeDataExpTable(ExpNdx)=96RETURNF79:' UCASE()GOTO F77F80:' Tail(String,Quantity)IF Target<>0 THEN	ErrNo=ErrIVTarg	RETURNENDIFGOSUB MidLftRtRETURNF81:' FINDADDR()GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadRegOutBuf="mov [_Poker],eax"GOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadRegOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadReg GOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=0;"GOSUB OutCodeDataOutBuf=";while (_ArgSafe0){"GOSUB OutCodeDataOutBuf=";if(*_Poker == eax){"GOSUB OutCodeDataOutBuf=";"+SymTemp.SymName+"=(long)_Poker;"GOSUB OutCodeDataOutBuf=";break;}"GOSUB OutCodeDataOutBuf=";_Poker++;"GOSUB OutCodeDataOutBuf=";_ArgSafe0--;}"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNF82:' FINDOFFS()GOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadReg' %%%%%%%%%%%############ bug followsOutBuf="mov [_Poker],eax"OutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataGOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadRegOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataINCR ExpNdxGOSUB ClassOpIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFD0Loaded=0GOSUB LoadReg GOSUB GetIntTmpErrRetOutBuf=";"+SymTemp.SymName+"=-1;"GOSUB OutCodeDataOutBuf=";while (_ArgSafe0){"GOSUB OutCodeDataOutBuf=";if(*_Poker == eax){"GOSUB OutCodeDataOutBuf=";"+SymTemp.SymName+"=(long)_Poker-_ArgSafe1;"GOSUB OutCodeDataOutBuf=";break;}"GOSUB OutCodeDataOutBuf=";_Poker++;"GOSUB OutCodeDataOutBuf=";_BlkCnt++;"GOSUB OutCodeDataOutBuf=";_ArgSafe0--;}"GOSUB OutCodeDataExpTable(ExpNdx)=SymNdxRETURNOutCodeData:INCR AsmLineCtrIF StartFlag=TRUE THEN	IF ProcFcnFlag=0 THEN		GOSUB OutCode	ELSE		IF EventFlag<>0 THEN			GOSUB OutCode		ELSE			GOSUB OutFunction		ENDIF	ENDIFELSE	WRITE DataFile,OutBufENDIFRETURNOutUninitData:WRITE DimFile,OutBufINCR AsmLineCtrRETURNOutDesc:WRITE DescFile,OutBufINCR AsmLineCtrRETURNOutDeclare:WRITE DeclareFile,OutBufINCR AsmLineCtrRETURNOutInitData:WRITE DataFile,OutBufINCR AsmLineCtrRETURNOutCode:IF DeferFlag=TRUE THEN	DeferFlag=FALSE	IF OutBuf="mov eax, dword [_Tmp1]" THEN		AsmLineCtr=AsmLineCtr-2		RETURN	ELSE		TempStr=OutBuf		OutBuf="mov [_Tmp1],eax"		WRITE CodeFile,OutBuf		OutBuf=TempStr		WRITE CodeFile,OutBuf		RETURN	ENDIF			ENDIFIF OutBuf="mov [_Tmp1],eax" THEN	DeferFlag=TRUE	RETURNENDIFWRITE CodeFile,OutBufINCR AsmLineCtrRETURNOutFunction:IF DeferFlag=TRUE THEN	DeferFlag=FALSE	IF OutBuf="mov eax, dword [_Tmp1]" THEN		AsmLineCtr=AsmLineCtr-2		RETURN	ELSE		TempStr=OutBuf		OutBuf="mov [_Tmp1],eax"		WRITE FunctionFile,OutBuf		OutBuf=TempStr		WRITE FunctionFile,OutBuf		RETURN	ENDIF			ENDIFIF OutBuf="mov [_Tmp1],eax" THEN	DeferFlag=TRUE	RETURNENDIFWRITE FunctionFile,OutBufINCR AsmLineCtrRETURNOutPreCode:WRITE PreCodeFile,OutBufINCR AsmLineCtrRETURNOutInitCode:WRITE InitFile,OutBufINCR AsmLineCtrRETURNStoreD0Tmp:OutBuf="mov ["+SymTemp.SymName+"],eax"GOSUB OutCodeDataD1Cleared=0RETURNOutWrite:IF PrintFlag=0 THEN	ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE	OutBuf="invoke WriteFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0"ELSE	OutBuf=";STATUS=write(_PrtPthNum,_XferAddr,XferCount);"ENDIFGOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZRETURNOutRead:ImportFcnTable(ptrReadFile).ImportFcnUse=TRUEOutBuf="invoke ReadFile,[_IOPthNum],[_XferAddr],[XferCount],XferCount,0"GOSUB OutCodeDataGOSUB SetStatusGOSUB CallErrZRETURNSetStatus:OutBuf="mov [STATUS],eax"GOSUB OutCodeDataRETURNOutCRLF:OutBuf="mov [_XferAddr],_CRLF"GOSUB OutCodeDataOutBuf="mov [XferCount],2"GOSUB OutCodeDataOutBuf=";STATUS=write(_PrtPthNum,_XferAddr,XferCount);"GOSUB OutCodeDataGOSUB CallErr RETURNMacDefInc:INCR MacDefNdxIF MacDefNdx>MacBufSiz THEN	DECR MacDefNdx	ErrNo=ErrMacBufENDIFRETURNIncConStk:INCR ConStkPtrIF ConStkPtr>40 THEN	ErrNo=ErrNDeepENDIFRETURNMakString:IF OpClass=BOOLClass THEN	IF TSymName<>"~" THEN		D0Loaded=0		GOSUB LoadReg		ErrRet	ENDIF	UseBtoA=TRUE	OutBuf="call __BtoA"	GOSUB OutCodeData	GOSUB NumToA	RETURNENDIFIF TSymName<>"~" THEN	D0Loaded=0	GOSUB LoadReg	ErrRetENDIFIF FloatFlag=0 THEN	ImportFcnTable(ptrltoa).ImportFcnUse=TRUE	OutBuf="cinvoke ltoa,eax,[_ConvBuf1],10"ELSE	OutBuf=";_DtoA(eaxf);"ENDIFGOSUB OutCodeDataGOSUB NumToARETURNConStkChk:IF ConStkPtr<1 THEN	ErrNo=ErrUBCon	RETURNENDIFIF ConStk(ConStkPtr).ConType<>TempInt THEN	ErrNo=ErrUBConENDIFRETURNStrSiz:SymNdxSaf=SymNdxTokenBuf=SymTemp.SymNameTempByte=LEFT(TempStr,1)IF TempByte>="0" AND TempByte<="9" THEN	TempInt=VAL(TempStr)ELSE	SymTemp.SymName=TempStr	GOSUB SymSrch	IF SymFound=TRUE AND SymTable(SymNdx).DataType=COMPVAR OR SymTable(SymNdx).DataType=MACROVAR THEN		TempInt=SymTable(SymNdx).Detail	ELSE		ErrNo=ErrUDSym		RETURN	ENDIFENDIFSymNdx=SymNdxSafSymTemp.SymName=TokenBufRETURNRemark:OutBuf="; LN:"+STR(BasicLineCtr)+" "+SrcLineRETURNBldComment:OutBuf=";"+CommentRETURNGetDtaTyp:SELECT CASE TDataType	CASE BOOLVAR		_DataType=" byte "	CASE BYTEVAR		_DataType=" byte "	CASE WORDVAR		_DataType=" word "	CASE LONGVAR		_DataType=" dword "	CASE FLOATVAR		_DataType=" double "END SELECTIF LAND(TDataMod,PointerBit)=PointerBit THEN	_DataType=" dword "ENDIFRETURNVecSymNam:'GOSUB GetDtaTypVSymName=TSymNameTSymName="["+VSymName+"]"RETURNGetIntOp:GOSUB GetExpErrRetGOSUB ProcOp2ErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF SymTemp.SymName<>"~" THEN	D0Loaded=0	GOSUB LoadRegENDIFRETURNGetGUINdx:GOSUB ExprErrRetIF OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF SymTemp.SymName<>"~" THEN	D0Loaded=0	GOSUB LoadRegENDIFRETURNGetFltOp:GOSUB ExprErrRetIF OpClass<>FLTClass AND OpClass<>INTClass THEN	ErrNo=ErrTypMis	RETURNENDIFIF TSymName="~" AND OpClass=INTClass THEN	TSymName="eax"ENDIFIF TSymName<>"~" OR OpClass=INTClass THEN	OutBuf=";eaxf="+TSymName+";"	GOSUB OutCodeDataENDIFRETURNGetComma:GOSUB NexTokenIF TokenBuf<>"," THEN	ErrNo=ErrSyntaxENDIFRETURNGetColon:GOSUB NexTokenIF TokenBuf<>":" THEN	ErrNo=ErrSyntaxENDIFRETURNGetEqual:GOSUB NexTokenIF TokenBuf<>"=" THEN	ErrNo=ErrSyntaxENDIFRETURNSubLoad:D0Loaded=0GOSUB LoadRegErrRetIF FloatFlag<>0 THEN	OutBuf=";eax=eaxf;"	GOSUB OutCodeDataENDIFRETURNReadSource:IF InpFilPtr=1 THEN	INCR BasicLineCtrENDIFSrcLine=""SrcNdx=0EndNdx=0EndFound=0QuoteFlag=0WhiteSpaceCtr=0FirstValidChar=FALSEBEGIN LOOP	STATUS=GET InpFile(InpFilPtr),RawData	TempInt=XferCount	IF TempInt=0 THEN		IF ASC(LastRawData)<>$0d THEN			RawData=CHR$($0d)			TempInt=1		ELSE				IF EndFound=0 THEN				EndNdx=EndNdx-WhiteSpaceCtr			ENDIF			RETURN		ENDIF	ENDIF	LastRawData=RawData	AsciiByte=ASC(RawData) 	IF AsciiByte=NewLine THEN		IF EndFound=0 THEN			EndNdx=EndNdx-WhiteSpaceCtr		ENDIF		RETURN	ENDIF	IF QuoteFlag=0 THEN		IF AsciiByte=OBQUOTE THEN			QuoteFlag=$ff		ENDIF	ELSE		IF AsciiByte=OBQUOTE THEN			QuoteFlag=0		ENDIF	ENDIF	IF AsciiByte=$27  OR AsciiByte=$3b THEN; Comment?		IF QuoteFlag=0 THEN			EndFound=$ff			EndNdx=EndNdx-WhiteSpaceCtr		ENDIF	ENDIF	IF AsciiByte=$09 OR AsciiByte=$20 THEN		INCR WhiteSpaceCtr	ELSE		IF AsciiByte<>$0d THEN			WhiteSpaceCtr=0		ENDIF	ENDIF	IF FirstValidChar=FALSE THEN		IF AsciiByte<>$0a AND AsciiByte<>$0d AND AsciiByte<>$09 AND AsciiByte<>$20 THEN			FirstValidChar=TRUE			SrcLine=SrcLine+RawData			IF EndFound=0 THEN				INCR EndNdx			ENDIF		ENDIF	ELSE		IF AsciiByte<>$0d THEN' Temporary code?			SrcLine=SrcLine+RawData			IF EndFound=0 THEN				INCR EndNdx			ENDIF		ENDIF	ENDIFEND LOOPRETURNGenCase:IF OpClass=INTClass THEN	OutBuf="mov edx,[_SwitchInt]"	GOSUB OutCodeData	OutBuf="cmp eax,edx"	GOSUB OutCodeData	OutBuf=SymType+"_Lbl"+STR(LabelNum)ELSE	ediUsed=TRUE	OutBuf="mov edi,_SwitchStr"	GOSUB OutCodeData	OutBuf="mov esi,"+TSymName	GOSUB OutCodeData	UseCmpStr=TRUE	OutBuf="call __CmpStr"	GOSUB OutCodeData		OutBuf=SymType+"_Lbl"+STR(LabelNum)ENDIFGOSUB OutCodeDataRETURNEndCasex:TempInt=7GOSUB ConStkChkErrRetOutBuf="jmp "+"_Lbl"+STR(ConStk(ConStkPtr).TermLabel)GOSUB OutCodeDataOutBuf="_Lbl"+STR(ConStk(ConStkPtr).ContLabel)+":"' get here if case not trueGOSUB OutCodeDataRETURNMainLoopInit:ediUsed=FALSEDataLabel=FALSEGOSUB ClrDatTypDMReDim=0CmpOpFlag=FALSEInitTrue=0IgnoreRightParen=0SimpleCmp=0ComplexCmp=0HasFcn=0Target=0GUIObjFlag=0'//TextFlag=0'//PrintFlag=0StatFlag=0TabFlag=0DevFlag=0FileIO=0DiskIO=0BufRWFlg=0D1Cleared=0FileStat=0LabelFlag=0Op1Class=0ReadFlag=0CompFlag=0Promote=0Demote=0LNFlag=0TmpUse=0TmpVecUse=0FTmpUse=0ChrTmpUse=0StrTmpUse=0DimFlag=0TypeFlag=0AliasFlag=0TDataMod=0RETURNClrDataRegs:IF TDataType<>LONGVAR AND TDataType<>BOOLVAR THEN' Check for pointer here also?	IF D1Cleared=0 THEN		IF D0Loaded=0 THEN			OutBuf="xor eax,eax"		ELSE			D1Cleared=$ff			OutBuf="xor edx,edx"		ENDIF		GOSUB OutCodeData	ENDIFENDIFRETURNGetSymTemp:SymTemp=SymTable(SymNdx)RETURNGetSymTempExpNdx:SymTemp=SymTable(ExpTable(ExpNdx))RETURNChkLabel:LNFlag=$ffGOSUB TokenSymErrRetIF SymFound=FALSE THEN	SymTemp.DataType=LABELVAR	GOSUB ClrSym	SymTemp.Detail=LabelUnresolved	IF KeyNdx=2 THEN' Restore		SymTemp.DataMod=DataBit	ENDIF	GOSUB SymInsert	ErrRetENDIFRETURNMakeStrConst:INCR PoolCtrOutBuf="_StrConst"+STR(PoolCtr)+" db "+TokenSaf+",0"GOSUB OutInitDataRETURNMakeBuffer:Comment="Memory Buffer"GOSUB BldCommentGOSUB OutInitDataOutBuf=BufName+" dd 0"GOSUB OutInitDataOutBuf=" dd 0"GOSUB OutInitDataRETURNReleaseBuffer:OutBuf="cmp ["+BufName+"+4],0"GOSUB OutCodeDataINCR LabelNumOutBuf="je "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,["+BufName+"],0,MEM_RELEASE"GOSUB OutCodeDataOutBuf="mov ["+BufName+"],0"GOSUB OutCodeDataOutBuf="mov ["+BufName+"+4],0"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataRETURNGetBuffer:OutBuf="push eax"GOSUB OutCodeDataOutBuf="cmp ["+BufName+"+4],0"GOSUB OutCodeDataINCR LabelNumOutBuf="je "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,["+BufName+"],0,MEM_RELEASE"GOSUB OutCodeDataOutBuf="mov ["+BufName+"],0"GOSUB OutCodeDataOutBuf="mov ["+BufName+"+4],0"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="pop eax"GOSUB OutCodeDataOutBuf="mov ["+BufName+"+4],eax"GOSUB OutCodeDataImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUEOutBuf="invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE"GOSUB OutCodeDataOutBuf="mov ["+BufName+"],eax"GOSUB OutCodeDataRETURNPushArgs:IgnoreRightParen=$ffSymTemp=SymTable(SymNdx)GOSUB GetFcnTypesGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNENDIFNeedComma=0Ctr3=0PushArgsLp:IF Ctr3>TFcnArgs THEN	ErrNo=ErrFcnArgs	RETURNENDIFGOSUB NexTokenIF TokenBuf=")" THEN	IF Ctr3<>TFcnArgs THEN		ErrNo=ErrFcnArgs	ENDIF	RETURN	ENDIFIF NeedComma<>0 THEN	IF TokenSaf<>"," THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	NeedComma=0	GOTO PushArgsLpELSE	IF TokenSaf="," THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIFENDIFGOSUB UnDoTokenGOSUB ExprErrRetINCR Ctr3GOSUB ArgPushErrRetNeedComma=$ffGOTO PushArgsLpRETURNPopArgs:SymTemp=SymTable(SymNdx)GOSUB GetFcnTypesGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNENDIFNeedComma=0Ctr3=0PopArgsLp:IF Ctr3>TFcnArgs THEN	ErrNo=ErrFcnArgs	RETURNENDIFGOSUB NexTokenIF TokenBuf=")" THEN	IF Ctr3<>TFcnArgs THEN		ErrNo=ErrFcnArgs	ENDIF	RETURN	ENDIFIF NeedComma<>0 THEN	IF TokenSaf<>"," THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIF	NeedComma=0	GOTO PopArgsLpELSE	IF TokenSaf="," THEN		ErrNo=ErrSyntax		GOTO MainLoop	ENDIFENDIFINCR Ctr3SymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=TRUE THEN	ErrNo=ErrDupSym	ErrRetENDIFSymTemp.Detail=0OutBuf="; Auto diminsion of argument"GOSUB OutUninitDataOutBuf="align 4"GOSUB OutUninitDataSELECT CASE FcnTypes(Ctr3)	CASE BOOLVAR		; Pop bool here	CASE LONGVAR		OutBuf=TokenSaf+" rd 1"		GOSUB OutUninitData		OutBuf="mov eax,[_FcnArg"+STR(Ctr3)+"]"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"],eax"		GOSUB OutCodeData		SymTemp.DataType=LONGVAR		SymTemp.DataMod=0		SymTemp.DataAddr=4	CASE FLOATVAR		; Pop float here	CASE STRINGVAR		OutBuf=TokenSaf+" rd 3"		GOSUB OutUninitData		OutBuf="mov esi,[_FcnArg"+STR(Ctr3)+"]"		GOSUB OutCodeData		OutBuf="mov eax,[esi]"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"],eax"		GOSUB OutCodeData		OutBuf="add esi,4"		GOSUB OutCodeData		OutBuf="mov eax,[esi]"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"+4],eax"		GOSUB OutCodeData		OutBuf="mov ["+TokenSaf+"+8],0"		GOSUB OutCodeData		SymTemp.DataType=STRINGVAR		SymTemp.DataMod=VectorBitEND SELECTGOSUB SymInsertNeedComma=$ffGOTO PopArgsLpRETURNGetFcnTypes:TFcnArgs=SymTemp.FcnArgsTFcnDataType=SymTemp.FcnDataTypeFcnTypes(1)=SymTemp.DataAddrFcnTypes(2)=SymTemp.DataSizeFcnTypes(3)=SymTemp.ArrayDim1FcnTypes(4)=SymTemp.ArrayDim2FcnTypes(5)=SymTemp.ArrayDim3FcnTypes(6)=SymTemp.ArrayDimsFcnTypes(7)=SymTemp.MiscRETURNChkInt:GOSUB ValidIntIF IntOK=0 THEN	ErrNo=ErrIVExpENDIFRETURNChkSym:GOSUB TokenSym1ErrRetIF SymFound=FALSE THEN	ErrNo=ErrUDSym	RETURNENDIFRETURNChkHex:GOSUB ValidHexIF HexOK=0 THEN	ErrNo=ErrIVExp	RETURNENDIFRETURNChkFlt:GOSUB ValidFltIF FloatOK=0 THEN	ErrNo=ErrIVExp	GOTO MainLoopENDIFRETURNLoadNumericValue:IF TSymName<>"~" THEN	IF OpClass=INTClass THEN		D0Loaded=0		GOSUB LoadReg	ELSE		;TSymName="eaxf"	ENDIFELSE	IF OpClass=INTClass THEN		TSymName="eax"	ELSE		;TSymName="eaxf"	ENDIFENDIFRETURNPushNumeric:GOSUB LoadNumericValueOutBuf="mov [_FcnArg"+STR(Ctr3)+"],eax"GOSUB OutCodeDataRETURNProcFcnPrep:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFSymTable(SymNdx).Detail=LabelResolvedGOSUB GetSymTempOutBuf=SymTemp.SymName+":"GOSUB OutFunctionGOSUB GetFcnTypesRETURNArgPush:SELECT CASE OpClass	CASE BOOLClass		IF FcnTypes(Ctr3)<>BOOLVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		; Push bool here	CASE INTClass		IF FcnTypes(Ctr3)<>LONGVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		GOSUB PushNumeric	CASE FLTClass		IF FcnTypes(Ctr3)<>FLOATVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		GOSUB PushNumeric	CASE STRClass		IF FcnTypes(Ctr3)<>STRINGVAR THEN			ErrNo=ErrTypMis			RETURN		ENDIF		OutBuf="mov [_FcnArg"+STR(Ctr3)+"],"+TSymName		GOSUB OutCodeDataEND SELECTRETURNChkUse:RESTORE MovArgLibGOSUB OutLibCodeTextIF UseReadFile=TRUE THEN	ImportFcnTable(ptrReadFile).ImportFcnUse=TRUE	RESTORE ReadFileLib	GOSUB OutLibCodeTextENDIFIF UseWriteFile=TRUE THEN	ImportFcnTable(ptrWriteFile).ImportFcnUse=TRUE	RESTORE WriteFileLib	GOSUB OutLibCodeTextENDIFIF UseInpData=TRUE THEN	ImportFcnTable(ptrReadConsole).ImportFcnUse=TRUE	ImportFcnTable(ptratol).ImportFcnUse=TRUE	RESTORE InpDataLib	GOSUB OutLibCodeTextENDIFIF UseData=TRUE THEN	ImportFcnTable(ptratol).ImportFcnUse=TRUE	RESTORE DataLib	GOSUB OutLibCodeTextENDIFIF UseCmpStr=TRUE THEN	RESTORE CmpStrLib	GOSUB OutLibCodeTextENDIFIF UseMovStr=TRUE THEN	RESTORE MovStrLib	GOSUB OutLibCodeTextENDIFIF UseStrLen=TRUE THEN	RESTORE StrLenLib	GOSUB OutLibCodeTextENDIFIF UseAtoL=TRUE THEN	ImportFcnTable(ptratol).ImportFcnUse=TRUE	RESTORE AtoLLib	GOSUB OutLibCodeTextENDIFIF UseBtoA=TRUE THEN	RESTORE BtoALib	GOSUB OutLibCodeTextENDIFIF UseSetStrConst=TRUE THEN	RESTORE SetStrConstLib	GOSUB OutLibCodeTextENDIFIF UseMidStr=TRUE THEN	RESTORE MidStrLib	GOSUB OutLibCodeTextENDIFIF UseIncZRank=TRUE THEN	RESTORE IncZRankLib	GOSUB OutLibCodeTextENDIFIF UseSetRightBottom=TRUE THEN	RESTORE SetRightBottomLib	GOSUB OutLibCodeTextENDIFIF UseRightStr=TRUE THEN	RESTORE RightStrLib	GOSUB OutLibCodeTextENDIFIF UseTailStr=TRUE THEN	RESTORE TailStrLib	GOSUB OutLibCodeTextENDIFIF UseLCase=TRUE THEN	RESTORE LCaseLib	GOSUB OutLibCodeTextENDIFIF UseUCase=TRUE THEN	RESTORE UCaseLib	GOSUB OutLibCodeTextENDIFRETURNOutLibCodeText:BEGIN LOOP	READ OutBuf	EXITIF OutBuf="ENDTEXT"	GOSUB OutFunction	INCR AsmLineCtrEND LOOPRETURNOutPreCodeText:BEGIN LOOP	READ OutBuf	EXITIF OutBuf="ENDTEXT"	WRITE PreCodeFile,OutBuf	INCR AsmLineCtr	END LOOPRETURNValidateParentObject:ParentFlag=$ffGOTO ValidateObject1ValidateObject:ParentFlag=0ValidateObject1:IF ParentFlag=0 THEN; ******??????	GUIArrayFlag=0ENDIFGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ObjectType=0ELSE	ObjectType=SymTable(SymNdx).DataTypeENDIFIF LAND(SymTable(SymNdx).DataMod,ArrayBit)<>0 AND ParentFlag<>0 THEN	ErrNo=ErrTypMis	RETURNENDIFIF ObjectType=FORM THEN	FormExStyle="0"ENDIFIF ObjectType=TOOLWINDOW THEN	FormExStyle="WS_EX_TOOLWINDOW"ENDIFObjectName=SymTable(SymNdx).SymNameIF ObjectType<100 THEN	ErrNo=ErrIVType	RETURNENDIFIF ParentFlag<>0 THEN	ObjectParent="!"+ObjectName+"+HandleOffs"	ObjectParentName="!"+ObjectName	RETURNENDIFGOSUB ProcessObjectRETURNProcessObject:HandleName="edi+HandleOffs"IF ObjectType=TIMER THEN	RETURNENDIFOutBuf="mov edi,!"+ObjectNameGOSUB OutCodeDataGUIArrayFlag=LAND(SymTable(SymNdx).DataMod,ArrayBit)IF GUIArrayFlag<>0 THEN	IF NextByte="." THEN; Must be event		RETURN	ENDIF	GOSUB NexToken	IF TokenBuf<>"(" THEN		ErrNo=ErrSyntax		RETURN	ENDIF	IF ParentFlag=0 THEN		TArrayDim1=SymTable(SymNdx).ArrayDim1	ENDIF	IgnoreRightParen=$ff	GUIObjFlag=0	GOSUB GetGUINdx	ErrRet	IF KeyNdx=11 THEN; Construct		OutBuf="mov [ArrayIndex],eax"		GOSUB OutCodeData	ENDIF	DecArrayNdx	OutBuf="imul eax,1024"	GOSUB OutCodeData	OutBuf="add edi,eax"	GOSUB OutCodeData	INCR SrcNdx; Point past ')'	IgnoreRightParen=0ENDIFIF GUITargetFlag<>0 THEN	OutBuf="mov [!TargetGUIDesc],edi"	GOSUB OutCodeDataENDIF	RETURNGetStringOp:GOSUB GetExpErrRetGOSUB ProcOp2ErrRetIF Op2Class<>STRClass THEN	ErrNo=ErrIVTypeENDIFRETURNGetTextOp:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	RETURNENDIFGOSUB GetSymTempIF SymTemp.DataType<>TEXT THEN	ErrNo=ErrIVType	RETURNENDIFIF SymTemp.DataMod=0 THEN	ErrNo=ErrTextNotDefined	RETURNENDIFTSymName=SymTemp.SymNameRETURNRightBracket:FOR I=SrcNdx TO LEN(SrcLine)	IF MID(SrcLine,I,1)="]" THEN BracketFoundNEXT IErrNo=ErrSyntaxRETURNBracketFound:SrcLineMod=IMID(SrcLine,SrcLineMod,1)=CHR(0)RETURNGUIFatal:;TempStr=SrcLine;GOSUB OutPrintTempStr="Fatal Error... GUI statement or declaration in Console program"ErrNo=$ffGOTO MainLoopGUITarget:GOSUB NexTokenIF TokenBuf<>"." THEN	ErrNo=ErrSyntax	GOTO MainLoopENDIFGOSUB NexTokenIF ObjectType=TIMER THEN	SELECT CASE TokenBuf		CASE "interval"			EqualMain			GOSUB GetIntOp			ErrMain			ImportFcnTable(ptrSetTimer).ImportFcnUse=TRUE			OutBuf="invoke SetTimer,[!OBMain],"+TAIL(ObjectName,6)+",eax,NULL"			GOSUB OutCodeData		CASE "stop"			ImportFcnTable(ptrKillTimer).ImportFcnUse=TRUE			OutBuf="invoke KillTimer,[!OBMain],"+TAIL(ObjectName,6)			GOSUB OutCodeData		CASE "timer"			TempStr=ObjectName+"_timer"			SymTemp.SymName=TempStr			GOSUB MakeEvent			ErrMain			OutBuf="mov ["+ObjectName+"],"+TempStr			GOSUB OutInitCode		CASE ELSE			ErrNo=ErrSyntax			GOTO MainLoop	END SELECT	GOTO MainLoopENDIFIF TokenBuf="intercept" THEN	TempStr=ObjectName+"_intercept"	SymTemp.SymName=TempStr	GOSUB MakeEvent	ErrMain	INCR InterceptProcNum	OutBuf="mov dword [!"+ObjectName+"+"+STR(InterceptProcOffs)+"],!InterceptProc"+STR(InterceptProcNum)	GOSUB OutInitCode		OutBuf="proc !InterceptProc"+STR(InterceptProcNum)+",!OBMain,wmsg,wparam,lparam"	GOSUB OutFunction	OutBuf="enter"	GOSUB OutFunction	OutBuf="push ebx esi edi"	GOSUB OutFunction	OutBuf="mov [!PassInterceptEvent],0"	GOSUB OutFunction	OutBuf="mov [!Desc],!"+ObjectName	GOSUB OutFunction	OutBuf="call "+ObjectName+"_intercept"	GOSUB OutFunction	OutBuf="cmp [!PassInterceptEvent],0"	GOSUB OutFunction	OutBuf="je !NoPass"+STR(InterceptProcNum)	GOSUB OutFunction	ImportFcnTable(ptrCallWindowProc).ImportFcnUse=TRUE	OutBuf="invoke CallWindowProc,[!"+ObjectName+"+492],[!hwnd],[wmsg],[wparam],[lparam]"	GOSUB OutFunction	OutBuf="!NoPass"+STR(InterceptProcNum)+":"	GOSUB OutFunction	OutBuf="jmp !Finish"	GOSUB OutFunction	OutBuf=""	GOSUB OutFunction	GOTO MainLoopENDIFObjectTypeSafe=ObjectType-99SETVEC EventArray=[ObjTable(ObjectTypeSafe).ObjEventTable]I=0BEGIN LOOP	INCR I	IF EventArray(I).EVType="%" THEN NotEvent	IF EventArray(I).EVType=TokenBuf THEN EventFoundEND LOOPEventFound:DescOffs=EventArray(I).EVDescOffsNotifyCode=EventArray(I).EVNotifyTempInt=EventArray(I).EVStatusBitIF TempInt>31 THEN; Notify Event	TempInt=LAND(TempInt,$0000001f)	TGUINotifyEvents=SymTable(GUITargetSymNdx).GUINotifyEvents	IF BITTST(TGUINotifyEvents,TempInt)=TRUE THEN		ErrNo=ErrDupEvent		GOTO MainLoop	ELSE		TGUINotifyEvents=BITSET(TGUINotifyEvents,TempInt)		SymTable(GUITargetSymNdx).GUINotifyEvents=TGUINotifyEvents	ENDIF	DescOffs=TempInt	DescOffs=SHL(DescOffs,3)	DescOffs=DescOffs+256; ??????????ELSE	TGUIEvents=SymTable(GUITargetSymNdx).GUIEvents	IF BITTST(TGUIEvents,TempInt)=TRUE THEN		ErrNo=ErrDupEvent		GOTO MainLoop	ELSE		TGUIEvents=BITSET(TGUIEvents,TempInt)		SymTable(GUITargetSymNdx).GUIEvents=TGUIEvents	ENDIFENDIFTempStr=ObjectName+"_"+TokenSafSymTemp.SymName=TempStrGOSUB MakeEventErrMainIF GUIArrayFlag=0 THEN	OutBuf="mov [!"+ObjectName+"+"+STR(DescOffs)+"],"+ObjectName+"_"+TokenSaf	GOSUB OutInitCode	IF DescOffs>=96 AND DescOffs<=380 THEN; Sub code for command event		OutBuf="mov [!"+ObjectName+"+"+STR(DescOffs)+"+4],"+STR(NotifyCode)		GOSUB OutInitCode	ENDIFELSE	OutBuf="mov ecx,"+STR(TArrayDim1)	GOSUB OutInitCode	OutBuf="mov esi,!"+ObjectName	GOSUB OutInitCode	INCR LabelNum	OutBuf="_Lbl"+STR(LabelNum)+":"	GOSUB OutInitCode	OutBuf="mov dword [esi+"+STR(DescOffs)+"],"+ObjectName+"_"+TokenSaf	GOSUB OutInitCode	IF DescOffs>=96 AND DescOffs<=380 THEN; Sub code for command event		OutBuf="mov dword [esi+"+STR(DescOffs)+"+4],"+STR(NotifyCode)		GOSUB OutInitCode	ENDIF	OutBuf="add esi,1024"	GOSUB OutInitCode	OutBuf="dec ecx"	GOSUB OutInitCode	OutBuf="jne _Lbl"+STR(LabelNum)	GOSUB OutInitCode	ENDIFGOTO MainLoopNotEvent:SETVEC PropArray=[ObjTable(ObjectTypeSafe).ObjPropTable]I=0BEGIN LOOP	INCR I	IF PropArray(I).PropName="%" THEN		ErrNo=ErrIVProp		GOTO MainLoop	ENDIF		IF PropArray(I).PropName=TokenBuf THEN		GOSUB [PropArray(I).PropSet]		GOTO MainLoop	ENDIFEND LOOPGUISource:GOSUB NexTokenIF TokenBuf<>"." THEN	ErrNo=ErrSyntax	RETURNENDIFGOSUB NexTokenObjectTypeSafe=ObjectType-99SETVEC PropArray=[ObjTable(ObjectTypeSafe).ObjPropTable]I=0BEGIN LOOP	INCR I	IF PropArray(I).PropName="%" THEN		ErrNo=ErrIVProp		RETURN	ENDIF		IF PropArray(I).PropName=TokenBuf THEN		GOSUB [PropArray(I).PropGet]		GUIDataType=PropArray(I).PropDataType		RETURN	ENDIFEND LOOPpgVisible:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrIsWindowVisible).ImportFcnUse=TRUEOutBuf="invoke IsWindowVisible, dword ["+HandleName+"]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsVisible:EqualRetGOSUB NexTokenTempStr=TokenSafSELECT CASE TokenBuf	CASE "true"		TempStr="SW_SHOW"		OutBuf="bts dword [edi+StatusOffs],WinVisible"	CASE "false"		TempStr="SW_HIDE"		OutBuf="btr dword [edi+StatusOffs],WinVisible"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTGOSUB OutCodeDataImportFcnTable(ptrShowWindow).ImportFcnUse=TRUEOutBuf="invoke ShowWindow, dword ["+HandleName+"],"+TempStrGOSUB OutCodeDataRETURN pgCanUndo:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANUNDO,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgCanReDo:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANREDO,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgCanPaste:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_CANPASTE,CF_TEXT,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgEnabled:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrIsWindowEnabled).ImportFcnUse=TRUEOutBuf="invoke IsWindowEnabled, dword ["+HandleName+"]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsEnabled:EqualRetGOSUB NexTokenTempStr=TokenSafSELECT CASE TokenBuf	CASE "true"		TempStr="TRUE"		OutBuf="bts dword [edi+StatusOffs],WinEnabled"	CASE "false"		TempStr="FALSE"		OutBuf="btr dword [edi+StatusOffs],WinEnabled"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTGOSUB OutCodeDataImportFcnTable(ptrEnableWindow).ImportFcnUse=TRUEOutBuf="invoke EnableWindow, dword ["+HandleName+"],"+TempStrGOSUB OutCodeDataRETURNpsFlashWindow:EqualRetGOSUB NexTokenTempStr=TokenSafSELECT CASE TokenBuf	CASE "true"		TempStr="TRUE"	CASE "false"		TempStr="FALSE"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTImportFcnTable(ptrFlashWindow).ImportFcnUse=TRUEOutBuf="invoke FlashWindow, dword ["+HandleName+"],"+TempStrGOSUB OutCodeDataRETURNpgBackColor:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+BackColorOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="bts dword [edi+StatusOffs],WinChangeBackColor"GOSUB OutCodeDataOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataRETURNpsFormBackColor:EqualRetOutBuf="invoke DeleteObject,dword [edi+ControlBrushOffs]"GOSUB OutCodeDataGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrCreateSolidBrush).ImportFcnUse=TRUEOutBuf="invoke CreateSolidBrush,eax"GOSUB OutCodeDataOutBuf="mov [edi+ControlBrushOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSetClassLong).ImportFcnUse=TRUEOutBuf="invoke SetClassLong, dword ["+HandleName+"],GCL_HBRBACKGROUND,eax"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataImportFcnTable(ptrUpdateWindow).ImportFcnUse=TRUEOutBuf="invoke UpdateWindow, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpsSBBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETBKCOLOR,0,eax"GOSUB OutCodeDataRETURNpgSBBackColor:ediUsed=TRUERETURNpfSetParts:GOSUB GetIntOpErrRetCommaRetGOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).DataType<>LONGVAR OR SymTable(SymNdx).DataMod<>ArrayBit THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETPARTS,eax,"+TokenSafGOSUB OutCodeDataRETURNpfSetSBText:GOSUB GetIntOpErrRetCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETTEXT,eax,["+Op2Name+"]"GOSUB OutCodeDataRETURNpsStyle:EqualRetStyleCode=0TempInt=0SETVEC StyleArray=[ObjTable(ObjectTypeSafe).ObjStyleTable]BEGIN LOOP	GOSUB NexToken	EXITIF TokenLen=0	IF TokenBuf<>"+" THEN		TempStr=TokenBuf		GOSUB FindStyle		ErrRet		StyleCode=StyleCode+StyleArray(I).StyleValue		INCR TempInt	ENDIFEND LOOPIF TempInt=0 THEN	ErrNo=ErrSyntax	RETURNENDIFOutBuf="mov eax,$"+HEX$(StyleCode)GOSUB OutCodeDataImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_STYLE,eax"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataRETURNpsGridBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETBACKCOLOR,eax,0"GOSUB OutCodeDataRETURNpsGridForeColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+ForeColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETTEXTCOLOR,eax,0"GOSUB OutCodeDataRETURNpsGridGridColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETGRIDCOLOR,eax,0"GOSUB OutCodeDataRETURNpsRichEditBackColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+BackColorOffs],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETBKGNDCOLOR,0,eax"GOSUB OutCodeDataRETURNpgForeColor:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+ForeColorOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsForeColor:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="bts dword [edi+StatusOffs],WinChangeForeColor"GOSUB OutCodeDataOutBuf="mov dword [edi+ForeColorOffs],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect, dword ["+HandleName+"],NULL,TRUE"GOSUB OutCodeDataRETURNpgStatus:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+StatusOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgAddress:GOSUB GetIntTmpErrRetOutBuf="mov eax,edi"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsInterceptOn:ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_WNDPROC,dword [edi+InterceptProcOffs]"GOSUB OutCodeDataRETURNpsInterceptOff:ImportFcnTable(ptrSetWindowLong).ImportFcnUse=TRUEOutBuf="invoke SetWindowLong, dword ["+HandleName+"],GWL_WNDPROC,dword [edi+InterceptSafeOffs]"GOSUB OutCodeDataRETURNpgID:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+IDOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgHandle:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+HandleOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgLeft:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+LeftOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgTop:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+TopOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgWidth:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+WidthOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgHeight:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+HeightOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgRight:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+RightOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgBottom:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+BottomOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsLeft:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+LeftOffs],eax"; LeftGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,dword [edi+16],dword [edi+20],0,0,5"GOSUB OutCodeDataRETURNpsTop:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+TopOffs],eax"; TopGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,dword [edi+LeftOffs],dword [edi+TopOffs],0,0,5"GOSUB OutCodeDataRETURNpsWidth:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+WidthOffs],eax"; WidthGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,0,0,dword [edi+WidthOffs],dword [edi+HeightOffs],6"GOSUB OutCodeDataRETURNpsHeight:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+HeightOffs],eax"; HeightGOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],0,0,0,dword [edi+WidthOffs],dword [edi+HeightOffs],6"GOSUB OutCodeDataRETURNpsRight:RETURNpsBottom:RETURNpfFront:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov eax,[edi+OwnerOffs]"GOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos,dword eax,dword ["+HandleName+"],-1,0,0,0,$03"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataImportFcnTable(ptrInvalidateRect).ImportFcnUse=TRUEOutBuf="invoke InvalidateRect,dword[edi+HandleOffs],NULL,TRUE"GOSUB OutCodeDataRETURNpgZRank:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameOutBuf="mov eax,[edi+ZRankOffs]"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsZRank:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+ZRankOffs],eax"GOSUB OutCodeDataRETURNpgChecked:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BM_GETCHECK,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsPushed:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="1"	CASE "false"		TempStr="0"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUE	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETSTATE,"+TempStr+",0"GOSUB OutCodeDataRETURNpsChecked:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="BST_CHECKED"	CASE "false"		TempStr="BST_UNCHECKED"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUE	OutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETCHECK,"+TempStr+",0"GOSUB OutCodeDataRETURNpfGridAddCol:GOSUB NexTokenSELECT CASE TokenBuf	CASE "text"		OutBuf="mov [gc_ctype],TYPE_EDITTEXT"		GOSUB OutCodeData		GOSUB AddColCommon		ErrRet		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "combo"		OutBuf="mov [gc_ctype],TYPE_COMBOBOX"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "check"		OutBuf="mov [gc_ctype],TYPE_CHECKBOX"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "long"		OutBuf="mov [gc_ctype],TYPE_EDITLONG"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "hotkey"		OutBuf="mov [gc_ctype],TYPE_HOTKEY"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "button"		OutBuf="mov [gc_ctype],TYPE_BUTTON"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "image"		OutBuf="mov [gc_ctype],TYPE_IMAGE"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "date"		OutBuf="mov [gc_ctype],TYPE_DATE"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE "time"		OutBuf="mov [gc_ctype],TYPE_TIME"		GOSUB OutCodeData		GOSUB AddColCommon		OutBuf="mov [gc_lpszformat],0"		GOSUB OutCodeData	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_ADDCOL,0,gc_colwt"GOSUB OutCodeDataRETURNAddColCommon:CommaRetGOSUB GetIntOpErrRetOutBuf="mov [gc_colwt],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetOutBuf="mov eax,["+TSymName+"]"GOSUB OutCodeDataOutBuf="mov [gc_lpszhdrtext],eax"GOSUB OutCodeDataGOSUB GetColAlignmentErrRetOutBuf="mov [gc_halign],"+TempStrGOSUB OutCodeDataGOSUB GetColAlignmentErrRetOutBuf="mov [gc_calign],"+TempStrGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetOutBuf="mov [gc_ctextmax],eax"GOSUB OutCodeDataRETURNGetColAlignment:CommaRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "left"		TempStr="ALIGN_LEFT"	CASE "center"		TempStr="ALIGN_CENTER"	CASE "right"		TempStr="ALIGN_RIGHT"	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTRETURNpfGridAddRow:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_ADDROW,0,0"GOSUB OutCodeDataRETURNpfUnDo:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],EM_UNDO,0,0"GOSUB OutCodeDataRETURNpfReDo:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],EM_REDO,0,0"GOSUB OutCodeDataRETURNpfPaste:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],WM_PASTE,0,0"GOSUB OutCodeDataRETURNpfEmptyUndoBuffer:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],EM_EMPTYUNDOBUFFER,0,0"GOSUB OutCodeDataRETURNpfCut:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],WM_CUT,0,0"GOSUB OutCodeDataRETURNpfCopy:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],WM_COPY,0,0"GOSUB OutCodeDataRETURNpsSetHeaderHeight:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_SETHDRHEIGHT,0,eax"GOSUB OutCodeDataRETURNpsSetRowHeight:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_SETROWHEIGHT,0,eax"GOSUB OutCodeDataRETURNpfGridComboClear:GOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_COMBOCLEAR,eax,0"GOSUB OutCodeDataRETURNpfGridClear:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage,dword ["+HandleName+"],GM_RESETCONTENT,0,0"GOSUB OutCodeDataRETURNpfGridSort:GOSUB GetIntOpErrRetDecArrayNdxCommaRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "ascending"		TempStr="0"	CASE "descending"		TempStr="1"	CASE "inverting"		TempStr="2"	CASE ELSE		ErrNo=ErrSyntax		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_COLUMNSORT,eax,"+TempStrGOSUB OutCodeDataRETURNpfGridDeleteRow:GOSUB GetIntOpErrRetOutBuf="push eax"GOSUB OutCodeDataDecArrayNdxOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_DELROW,eax,0"GOSUB OutCodeDataOutBuf="pop eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCURSEL,0,eax"GOSUB OutCodeDataRETURNpfGridInsertRow:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_INSROW,eax,0"GOSUB OutCodeDataRETURNpgHiLiteLine:RETURNpfSetHiLiteLine:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="pop ebx"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETHILITELINE,ebx,eax"GOSUB OutCodeDataRETURNpfRAEditGoto:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_LINEINDEX,eax,0"GOSUB OutCodeDataOutBuf="mov [EditcpMin],eax"GOSUB OutCodeDataIF NextByte<>"," THEN NoRangeArgCommaRetGOSUB GetIntOpErrRetOutBuf="add eax,[EditcpMin]"GOSUB OutCodeDataNoRangeArg:OutBuf="mov [EditcpMax],eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_EXSETSEL,0,EditcpMin"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpsRAEditBCKCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_BCKCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditTXTCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_TXTCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELBCKCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_SELBCKCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELTXTCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_SELTXTCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditCMNTCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_CMNTCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSTRCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_STRCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditOPRCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_OPRCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditHILITE1:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_HILITE1],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditHILITE2:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_HILITE2],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditHILITE3:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_HILITE3],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELBARCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_BARCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditSELBARPEN:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_SELBARPEN],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNpsRAEditLNRCOLOR:EqualRetGOSUB GetIntOpErrRetOutBuf="mov [!RA_LNRCOLOR],eax"GOSUB OutCodeDataGOSUB SetRAEditColorsRETURNSetRAEditColors:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETCOLOR,0,!RA_BCKCOLOR"GOSUB OutCodeDataRETURNpfSetHiliteWords:GOSUB GetStringOpErrRetVSymName=TSymNameCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETHILITEWORDS,eax,["+VSymName+"]"GOSUB OutCodeDataRETURNpfSetRAFont:GOSUB NexTokenSymTemp.SymName=TokenSafGOSUB SymSrchIF SymFound=FALSE THEN	ErrNo=ErrUDSym	GOTO MainLoopENDIFIF SymTable(SymNdx).SubType<>FONT THEN	ErrNo=ErrTypMis	GOTO MainLoopENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETFONT,0,"+TokenSafGOSUB OutCodeDataRETURNpfFind:OutBuf="mov [STATUS],0"GOSUB OutCodeDataOutBuf="bt [FLAGS],6"GOSUB OutCodeDataINCR LabelNumOutBuf="jc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="mov eax,[fr_lpstrFindWhat]"GOSUB OutCodeDataOutBuf="mov [ft_SearchTextPtr],eax"GOSUB OutCodeDataOutBuf="xor ebx,ebx"GOSUB OutCodeDataOutBuf="bt [FLAGS],0"GOSUB OutCodeDataINCR LabelNumOutBuf="jnc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="or ebx,FR_DOWN"GOSUB OutCodeDataOutBuf="mov ecx,[EditcpMax]"GOSUB OutCodeDataOutBuf="dec ecx"GOSUB OutCodeDataOutBuf="mov [ft_SearchMin],ecx"GOSUB OutCodeDataOutBuf="mov [ft_SearchMax],$ffffffff"GOSUB OutCodeDataINCR LabelNumOutBuf="jmp "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum-1)+":"GOSUB OutCodeDataOutBuf="mov ecx,[EditcpMin]"GOSUB OutCodeDataOutBuf="mov [ft_SearchMin],ecx"GOSUB OutCodeDataOutBuf="mov [ft_SearchMax],0"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="bt [FLAGS],1"GOSUB OutCodeDataINCR LabelNumOutBuf="jnc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="or ebx,FR_WHOLEWORD"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="bt [FLAGS],2"GOSUB OutCodeDataINCR LabelNumOutBuf="jnc "+"_Lbl"+STR(LabelNum)GOSUB OutCodeDataOutBuf="or ebx,FR_MATCHCASE"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum)+":"GOSUB OutCodeDataOutBuf="mov edi,!Edit"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_FINDTEXTEX,ebx,ft_SearchMin"GOSUB OutCodeDataGOSUB SetStatusOutBuf="cmp eax,$ffffffff"GOSUB OutCodeDataOutBuf="je "+"_Lbl"+STR(LabelNum-4)GOSUB OutCodeDataOutBuf="mov ebx,[ft_FoundMin]"GOSUB OutCodeDataOutBuf="mov eax,[ft_FoundMax]"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataOutBuf="_Lbl"+STR(LabelNum-4)+":"GOSUB OutCodeDataRETURNpfSetDividerLine:GOSUB GetIntOpErrRetDecArrayNdxCommaRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="1"	CASE "false"		TempStr="0"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],REM_SETDIVIDERLINE,eax,"+TempStrGOSUB OutCodeDataRETURNpfSelectAll:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,0,-1"GOSUB OutCodeDataImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpfSetFocus:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpsSetCursorPos:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,eax,eax"GOSUB OutCodeDataRETURNpgGetCursorPos:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSEL,"+GUITempName+",0"GOSUB OutCodeDataOutBuf="mov eax,["+GUITempName+"]"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpfGetSel:ediUsed=TRUEGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSEL,EditcpMin,EditcpMax"GOSUB OutCodeDataRETURNpfSetSel:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="pop ebx"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"GOSUB OutCodeDataOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SCROLLCARET,0,0"GOSUB OutCodeDataImportFcnTable(ptrSetFocus).ImportFcnUse=TRUEOutBuf="invoke SetFocus, dword ["+HandleName+"]"GOSUB OutCodeDataRETURNpfGridMoveRow:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov ebx,eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_MOVEROW,ebx,eax"GOSUB OutCodeDataRETURNpgLine:ediUsed=TRUEGOSUB GetItemNumberErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFOutBuf="mov [_IOBuffer+12],_BufSize"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETLINE,eax,["+TempStr+"]"GOSUB OutCodeDataOutBuf="mov ebx,_IOBuffer+12"GOSUB OutCodeDataOutBuf="add ebx,eax"GOSUB OutCodeDataOutBuf="dec ebx"GOSUB OutCodeDataOutBuf="mov byte [ebx],0"GOSUB OutCodeDataGUITempName=TempStrRETURNpgText:ediUsed=TRUEIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXT,_BufSize,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpgSelText:ediUsed=TRUEIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_GETSELTEXT,0,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpfInsertText:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,eax,eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataRETURNpfAppendText:IF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,-1,-1"GOSUB OutCodeDataGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataRETURNpfReplaceSel:GOSUB GetStringOpErrRetOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataRETURNpfReplaceText:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="push eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="pop ebx"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_SETSEL,ebx,eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="invoke SendMessage, dword ["+HandleName+"],EM_REPLACESEL,1,["+TempStr+"]"GOSUB OutCodeDataUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataRETURNpsText:EqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFUseIncZRank=TRUEOutBuf="call __IncZRank"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETTEXT,0,["+TSymName+"]"GOSUB OutCodeDataRETURNpsIcon:EqualRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrTypMis	RETURNENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETICON,ICON_BIG,eax"GOSUB OutCodeDataRETURNpsSTIcon:EqualRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrTypMis	RETURNENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],STM_SETIMAGE,1,eax"GOSUB OutCodeDataRETURNpsButtonIcon:EqualRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrTypMis	RETURNENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],BM_SETIMAGE,1,eax"GOSUB OutCodeDataRETURNpfSetSBIcon:GOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF TSubType<>ICON THEN	ErrNo=ErrTypMis	RETURNENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],SB_SETICON,[_ArgSafe0],eax"GOSUB OutCodeDataRETURNpsFont:EqualRetGOSUB GetIntOpErrRetIF TSubType<>FONT THEN	ErrNo=ErrTypMis	RETURNENDIFIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETFONT,eax,1"GOSUB OutCodeDataRETURNpgGridText:ediUsed=TRUEGOSUB GetRCErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_CELLCONVERT,ebx,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpsGridText:GOSUB GetRCErrRetEqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,["+TSymName+"]"GOSUB OutCodeDataRETURNpgHeaderText:ediUsed=TRUEGOSUB GetColumnErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_GETHDRTEXT,ebx,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrGOSUB OutCodeDataRETURNpsHeaderText:GOSUB GetColumnErrRetEqualRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETHDRTEXT,ebx,["+TSymName+"]"GOSUB OutCodeDataRETURNpfGridComboAddIttem:GOSUB GetIntOpErrRetOutBuf="push eax"GOSUB OutCodeDataCommaMainGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="pop eax"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_COMBOADDSTRING,eax,["+TSymName+"]"GOSUB OutCodeDataRETURNpsGridValue:GOSUB GetRCErrRetEqualRetGOSUB GetIntOpErrRetOutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,_ArgSafe1"GOSUB OutCodeDataRETURNpsGridComboIndex:GOSUB GetRCErrRetEqualRetGOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe1],eax"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],GM_SETCELLDATA,ebx,_ArgSafe1"GOSUB OutCodeDataRETURNGetColumn:GOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNENDIFIgnoreRightParen=$ffGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxOutBuf="mov ebx,eax"GOSUB OutCodeDataGOSUB NexTokenIF TokenBuf<>")" THEN	ErrNo=ErrSyntax	RETURNENDIFIgnoreRightParen=0RETURNGetItemNumber:IgnoreRightParen=$ffGOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNENDIFGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxGOSUB NexTokenIF TokenBuf<>")" THEN	ErrNo=ErrSyntax	RETURNENDIFIgnoreRightParen=0RETURNGetRC:GOSUB NexTokenIF TokenBuf<>"(" THEN	ErrNo=ErrSyntax	RETURNENDIFGUIObjFlag=0GOSUB GetGUINdxErrRetDecArrayNdxCommaRetOutBuf="mov ebx,eax"GOSUB OutCodeDataOutBuf="shl ebx,16"GOSUB OutCodeDataIgnoreRightParen=$ffGOSUB GetGUINdxErrRetDecArrayNdxOutBuf="or ebx,eax"GOSUB OutCodeDataGOSUB NexTokenIF TokenBuf<>")" THEN	ErrNo=ErrSyntax	RETURNENDIFIgnoreRightParen=0RETURNpfRAEditLoadFile:GOSUB GetStringOpErrRetImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,["+TSymName+"],GENERIC_READ,0,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataOutBuf="mov [!FileHandle],eax"GOSUB OutCodeDataOutBuf="cmp eax,-1"GOSUB OutCodeDataINCR OELabelNumOutBuf="jg _OELbl"+STR(OELabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeDataImportFcnTable(ptrGetFileSize).ImportFcnUse=TRUEOutBuf="invoke GetFileSize,[!FileHandle],0"GOSUB OutCodeDataOutBuf="inc eax"GOSUB OutCodeDataOutBuf="mov [!FilBufSiz],eax"GOSUB OutCodeDataImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUEOutBuf="invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE"GOSUB OutCodeDataOutBuf="mov [!FilBufAdr],eax"GOSUB OutCodeDataOutBuf="mov edx,[!FilBufSiz]"GOSUB OutCodeDataOutBuf="add eax,edx"GOSUB OutCodeDataOutBuf="dec eax"GOSUB OutCodeDataImportFcnTable(ptrReadFile).ImportFcnUse=TRUEOutBuf="invoke ReadFile,[!FileHandle],[!FilBufAdr],edx,!FilBufSiz,0"GOSUB OutCodeDataOutBuf="cmp eax,0"GOSUB OutCodeDataINCR OELabelNumOutBuf="jne _OELbl"+STR(OELabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeDataImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUEOutBuf="invoke CloseHandle,[!FileHandle]"GOSUB OutCodeDataIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_SETTEXT,0,[!FilBufAdr]"GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,[!FilBufAdr],0,MEM_RELEASE"GOSUB OutCodeDataRETURNpfRAEditSaveFile:GOSUB GetStringOpErrRetImportFcnTable(ptrCreateFile).ImportFcnUse=TRUEOutBuf="invoke CreateFile,["+TSymName+"],GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0"GOSUB OutCodeDataOutBuf="mov [!FileHandle],eax"GOSUB OutCodeDataOutBuf="cmp eax,-1"GOSUB OutCodeDataINCR OELabelNumOutBuf="jg _OELbl"+STR(OELabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXTLENGTH,0,0"GOSUB OutCodeDataOutBuf="mov [!FilBufSiz],eax"GOSUB OutCodeDataOutBuf="inc [!FilBufSiz]"GOSUB OutCodeDataImportFcnTable(ptrVirtualAlloc).ImportFcnUse=TRUEOutBuf="invoke  VirtualAlloc,0,[!FilBufSiz],MEM_COMMIT,PAGE_READWRITE"GOSUB OutCodeDataOutBuf="mov [!FilBufAdr],eax"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXT,[!FilBufSiz],[!FilBufAdr]"GOSUB OutCodeDataOutBuf="mov edi,[!TargetGUIDesc]"GOSUB OutCodeDataOutBuf="dec [!FilBufSiz]"GOSUB OutCodeDataImportFcnTable(ptrWriteFile).ImportFcnUse=TRUEOutBuf="invoke WriteFile,[!FileHandle],[!FilBufAdr],[!FilBufSiz],!FilBufSiz,0"GOSUB OutCodeDataOutBuf="cmp eax,0"GOSUB OutCodeDataINCR OELabelNumOutBuf="jne _OELbl"+STR(OELabelNum)GOSUB OutCodeDataImportFcnTable(ptrGetLastError).ImportFcnUse=TRUEOutBuf="invoke GetLastError"GOSUB OutCodeDataOutBuf="mov [ERR],eax"GOSUB OutCodeDataOutBuf="jmp [_ErrVec]"GOSUB OutCodeDataOutBuf="_OELbl"+STR(OELabelNum)+":"GOSUB OutCodeData;OutBuf="mov eax,[_CRLF]";GOSUB OutCodeData;OutBuf="mov [_XferAddr],eax";GOSUB OutCodeData;OutBuf="mov [XferCount],1";GOSUB OutCodeData;OutBuf="invoke WriteFile,[!FileHandle],[_XferAddr],[XferCount],XferCount,0";GOSUB OutCodeDataImportFcnTable(ptrCloseHandle).ImportFcnUse=TRUEOutBuf="invoke CloseHandle,[!FileHandle]"GOSUB OutCodeDataImportFcnTable(ptrVirtualFree).ImportFcnUse=TRUEOutBuf="invoke  VirtualFree,[!FilBufAdr],0,MEM_RELEASE"GOSUB OutCodeDataRETURNpgListBoxSelText:ediUsed=TRUEOutBuf="push edi"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETCURSEL,0,0"GOSUB OutCodeDataOutBuf="pop edi"GOSUB OutCodeDataIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTEXT,eax,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpgListBoxSelItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETCURSEL,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpgListBoxItemCount:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETCOUNT,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgComboBoxItemCount:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETCOUNT,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsListBoxSelItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_SETCURSEL,eax,0"GOSUB OutCodeDataRETURNpgListBoxTopItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTOPINDEX,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsListBoxTopItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_SETTOPINDEX,eax,0"GOSUB OutCodeDataRETURNpgComboBoxTopItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETTOPINDEX,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsComboBoxTopItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTOPINDEX,eax,0"GOSUB OutCodeDataRETURNpgComboBoxSelText:ediUsed=TRUEOutBuf="push edi"GOSUB OutCodeDataImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETCURSEL,0,0"GOSUB OutCodeDataOutBuf="pop edi"GOSUB OutCodeDataIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETLBTEXT,eax,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpgComboBoxSelItem:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETCURSEL,0,0"GOSUB OutCodeDataIncArrayNdxGOSUB StoreD0TmpRETURNpsComboBoxSelItem:EqualRetGOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SETCURSEL,eax,0"GOSUB OutCodeDataRETURNpgGetTextLength:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],WM_GETTEXTLENGTH,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpgSliderValue:ediUsed=TRUEGOSUB GetIntTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_GETPOS,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpsSliderValue:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],TBM_SETPOS,TRUE,eax"GOSUB OutCodeDataRETURNpgProgressBarValue:ediUsed=TRUERETURNpsProgressBarValue:EqualRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],PBM_SETPOS,eax,0"GOSUB OutCodeDataRETURNpgInterval:ediUsed=TRUERETURNpsInterval:RETURNpfStop:RETURNpfComboAddSorted:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_ADDSTRING,0,["+TSymName+"]"GOSUB OutCodeDataRETURNpfComboAddItem:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_INSERTSTRING,-1,["+TSymName+"]"GOSUB OutCodeDataRETURNpfComboClear:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_RESETCONTENT,0,0"GOSUB OutCodeDataRETURNpsDropped:EqualRetGOSUB NexTokenSELECT CASE TokenBuf	CASE "true"		TempStr="1"	CASE "false"		TempStr="0"	CASE ELSE		ErrNo=ErrIVType		RETURNEND SELECTImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_SHOWDROPDOWN,TokenBuf,0"GOSUB OutCodeDataRETURNpgDropped:ediUsed=TRUETDataType=BOOLVARGOSUB GetTmpErrRetGUITempName=SymTemp.SymNameImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_GETDROPPEDSTATE,0,0"GOSUB OutCodeDataGOSUB StoreD0TmpRETURNpfListBoxAddSorted:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_ADDSTRING,0,["+TSymName+"]"GOSUB OutCodeDataRETURNpfListBoxAddItem:GOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,-1,["+TSymName+"]"GOSUB OutCodeDataRETURNpfListBoxInsertItem:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,[_ArgSafe0],["+TSymName+"]"GOSUB OutCodeDataRETURNpfComboInsertItem:GOSUB GetIntOpErrRetDecArrayNdxOutBuf="mov [_ArgSafe0],eax"GOSUB OutCodeDataCommaRetGOSUB GetStringOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_INSERTSTRING,[_ArgSafe0],["+TSymName+"]"GOSUB OutCodeDataRETURNpfListBoxDeleteItem:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_DELETESTRING,eax,0"GOSUB OutCodeDataRETURNpfComboDeleteItem:GOSUB GetIntOpErrRetDecArrayNdxIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],CB_DELETESTRING,eax,0"GOSUB OutCodeDataRETURNpgListBoxText:ediUsed=TRUEGOSUB GetItemNumberErrRetIF CmpOpFlag=FALSE THEN	TempStr="_IOBuffer"ELSE	TempStr="_PrintBuf"ENDIFImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_GETTEXT,eax,["+TempStr+"]"GOSUB OutCodeDataGUITempName=TempStrRETURNpfListBoxClear:ImportFcnTable(ptrSendMessage).ImportFcnUse=TRUEOutBuf="invoke SendMessage, dword ["+HandleName+"],LB_RESETCONTENT,0,0"GOSUB OutCodeDataRETURNpgBad:ErrNo=ErrIVTypeRETURNpsBad:ErrNo=ErrIVTypeRETURNpfBad:ErrNo=ErrIVTypeRETURNMakeEvent:GOSUB SymSrchIF SymFound=TRUE THEN; Label Found	IF SymTable(SymNdx).DataType<>LABELVAR THEN		ErrNo=ErrDupSym		RETURN	ENDIF	IF SymTable(SymNdx).Detail=LabelUnresolved THEN		SymTable(SymNdx).Detail=LabelResolved	ELSE		ErrNo=ErrDupSym		RETURN	ENDIFELSE	GOSUB ClrDatTyp	TDataType=LABELVAR	SymTemp.DataType=LABELVAR	GOSUB ClrSym	SymTemp.DataMod=0	SymTemp.Detail=LabelResolved	GOSUB SymInsert	ErrRetENDIFOutBuf=TempStr+":"GOSUB OutCodeDataGOSUB FcnFlagChkErrRetEventFlag=$ffProcFcnFlag=$ffRETURNChkForIMM:TempInt=IVAL(TSymName)IF ForDataType=BYTEVAR AND TempInt>254 THEN	ErrNo=ErrOpRange	RETURNENDIFIF ForDataType=WORDVAR AND TempInt>65534 THEN	ErrNo=ErrOpRange	RETURNENDIFIF ForDataType=LONGVAR AND TempInt>$7fffffff THEN	ErrNo=ErrOpRange	RETURNENDIFRETURNSetPos:CommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+LeftOffs],eax"; LeftGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+TopOffs],eax"; TopGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+WidthOffs],eax"; WidthGOSUB OutCodeDataCommaRetGOSUB GetIntOpErrRetIF ediUsed=TRUE THEN	OutBuf="mov edi,[!TargetGUIDesc]"	GOSUB OutCodeDataENDIFOutBuf="mov dword [edi+HeightOffs],eax"; HeightGOSUB OutCodeDataRETURNSetPosFromTable:UseSetRightBottom=TRUEOutBuf="call __SetRightBottom"GOSUB OutCodeDataImportFcnTable(ptrSetWindowPos).ImportFcnUse=TRUEOutBuf="invoke SetWindowPos, dword ["+HandleName+"],HWND_TOP, dword [edi+LeftOffs], dword ["OutBuf=OutBuf+"edi+TopOffs], dword [edi+WidthOffs], dword [edi+HeightOffs],4"GOSUB OutCodeDataRETURNIncrArrayNdx:IF ArrayBase=1 THEN	OutBuf="inc eax"	GOSUB OutCodeDataENDIFRETURNDecrArrayNdx:IF ArrayBase=1 THEN	OutBuf="dec eax"	GOSUB OutCodeDataENDIFRETURNFormatCompileTime:TempName=STR$((GETTICKCOUNT()-StartTime))SELECT CASE LEN(TempName)	CASE 4		TempStr=LEFT(TempName,1)+"."+RIGHT(TempName,3)	CASE 5		TempStr=LEFT(TempName,2)+"."+RIGHT(TempName,3)	CASE ELSE		TempStr="."+TempNameEND SELECTTempName=TempStr+" Seconds"RETURNShowError:WARNINGBOX "Error",TempStr,MB_OKFOR I=1 TO InpFilPtr	CLOSE InpFile(InpFilPtr)NEXT ICLOSE DeclareFileDELETE "_DeclareFile"CLOSE PreCodeFileDELETE "_PreCodeFile"CLOSE CodeFileDELETE "_CodeFile"CLOSE DataFileDELETE "_DataFile"CLOSE DimFileDELETE "_DimFile"CLOSE DescFileDELETE "_DescFile"CLOSE InitFileDELETE "_InitFile"CLOSE FunctionFileDELETE "_FunctionFile"CLOSE ExportFileDELETE "_ExportFile"CLOSE ResourceFileDELETE "_ResourceFile"GOSUB ShowModeIF BasicLineCtr>0 THEN	TempInt=LEN(SrcLine)	Edit.GOTO BasicLineCtr,TempIntENDIFRETURNShowMode:IF TextMode=TRUE THEN	StatusBarSafe4="Edit Text"	StatusBar.SETTEXT 4,StatusBarSafe4ELSE	StatusBarSafe4="Edit Objects"	StatusBar.SETTEXT 4,StatusBarSafe4ENDIFRETURNGetDataType:SELECT CASE TempInt	CASE 0		TempStr="CONST"	CASE 1		TempStr="BOOLEAN"	CASE 2		TempStr="BYTE"	CASE 3		TempStr="INTEGER"	CASE 4		TempStr="LONG"	CASE 5		TempStr="FLOAT"	CASE 6		TempStr="STRING"	CASE 7		TempStr="LABEL"	CASE 8		TempStr="MACRO"	CASE 9		TempStr="OPERATOR"	CASE 10		TempStr="FUNCTION"	CASE 11		TempStr="PROCESS"	CASE 12		TempStr="TYPE"	CASE 13		TempStr="VOID"	CASE 14		TempStr="STRUCTURE"	CASE 15		TempStr="BUFFER"	CASE 16		TempStr="LABEL PTR"	CASE 17		TempStr="MENU"	CASE 18		TempStr="TEXT"	CASE ELSE		TempStr="OBJECT"END SELECTRETURNFormatNumber2:MAKEUPPER TempStrTempName=TempStrTempInt=LEN(TempName)SELECT CASE TempInt	CASE 1		TempStr="0"+TempName	CASE ELSE		TempStr=TempNameEND SELECTRETURNFormatNumber4:MAKEUPPER TempStrTempName=TempStrTempInt=LEN(TempName)SELECT CASE TempInt	CASE 1		TempStr="000"+TempName	CASE 2		TempStr="00"+TempName	CASE 3		TempStr="0"+TempName	CASE ELSE		TempStr=TempNameEND SELECTRETURNFormatNumber8:MAKEUPPER TempStrTempName=TempStrTempInt=LEN(TempName)SELECT CASE TempInt	CASE 1		TempStr="0000000"+TempName	CASE 2		TempStr="000000"+TempName	CASE 3		TempStr="00000"+TempName	CASE 4		TempStr="0000"+TempName	CASE 5		TempStr="000"+TempName	CASE 6		TempStr="00"+TempName	CASE 7		TempStr="0"+TempName	CASE ELSE		TempStr=TempNameEND SELECTRETURNSymbolGrid.HEADERCLICKSymbolGrid.SORT GridCol,INVERTINGEND EVENTTimer1.TIMERTimer1.STOPEditfChanged=0StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSEDISABLEMENUITEM MainMenu,mnuSaveButton(3).ICON=SaveIcon2END EVENTOBMain.SYSTEMSELECT CASE STATUS	CASE $f060		IF Changed=TRUE THEN			TempName=SaveFileName+" Not Saved"			TempStr="Save?"			WARNINGBOX TempName,TempStr,MB_YESNOCANCEL			IF STATUS=IDYES THEN				IF FileName="Untitled" THEN					GOSUB SaveAs					IF STATUS=0 THEN						RETURN					ENDIF					GOTO Quit				ELSE					Edit.SAVEFILE SaveFileName					DISABLEMENUITEM MainMenu,mnuSave					Button(3).ICON=SaveIcon2					StatusBarSafe5="Not Changed"					StatusBar.SETTEXT 5,StatusBarSafe5					Changed=FALSE					GOTO Quit				ENDIF			ELSE				IF STATUS=IDNO THEN					PASSSYSTEMEVENT				ELSE					RETURN				ENDIF			ENDIF		ELSE			PASSSYSTEMEVENT		ENDIF	CASE ELSE		PASSSYSTEMEVENTEND SELECTEND EVENTAssemble:SHELL "fasm "+AsmFileName+">_Fasm"GOSUB FormatCompileTime				OPEN StatusFile,"_fasm":READREAD StatusFile,TempStrREAD StatusFile,TempStrCLOSE StatusFileMSGBOX TempName,TempStr,MB_OKGOSUB ShowModeRETURNCompileToExe:ExpFlag=FALSEAsmOutFlag=FALSEHaltFlag=FALSEDLLFlag=FALSENoGen=FALSEIF Extension=".asm" THEN	IF Changed=TRUE THEN		WARNINGBOX "File Not Saved","Save?",MB_YESNO		IF STATUS=IDYES THEN			IF FileName="Untitled" THEN				GOSUB SaveAs			ELSE				Edit.SAVEFILE SaveFileName				DISABLEMENUITEM MainMenu,mnuSave				Button(3).ICON=SaveIcon2				Changed=FALSE				StatusBarSafe5="Not Changed"				StatusBar.SETTEXT 5,StatusBarSafe5			ENDIF		ELSE			RETURN		ENDIF	ENDIF	AsmFileName=BareFileName+Extension	StartTime=GETTICKCOUNT()	StatusBarSafe4="Compiling"	StatusBar.SETTEXT 4,StatusBarSafe4	GOSUB Assemble	RETURNENDIFStatusBarSafe4="Compiling"StatusBar.SETTEXT 4,StatusBarSafe4GOSUB CompileRETURNCompileToAsm:ExpFlag=FALSEAsmOutFlag=TRUEHaltFlag=FALSEDLLFlag=FALSENoGen=FALSEStatusBarSafe4="Compiling"StatusBar.SETTEXT 4,StatusBarSafe4GOSUB CompileRETURNTestCompile:ExpFlag=FALSEAsmOutFlag=FALSEHaltFlag=FALSEDLLFlag=FALSENoGen=TRUEStatusBarSafe4="Compiling"StatusBar.SETTEXT 4,StatusBarSafe4GOSUB CompileRETURNPostCompile:IF TextMode=TRUE THEN	Edit.SETFOCUSENDIFRETURNQuit:invoke DeleteObject, dword [RAFont]invoke DeleteObject, dword [RAFont+4]invoke DeleteObject, dword [RAFont+8]ENDNewCmd:IF Changed=TRUE THEN	TempName=SaveFileName+" Not Saved"	TempStr="Save?"	WARNINGBOX TempName,TempStr,MB_YESNOCANCEL	IF STATUS=IDYES THEN		IF FileName="Untitled" THEN			GOSUB SaveAs		ELSE			Edit.SAVEFILE SaveFileName			DISABLEMENUITEM MainMenu,mnuSave			Button(3).ICON=SaveIcon2			StatusBarSafe5="Not Changed"			StatusBar.SETTEXT 5,StatusBarSafe5			Changed=FALSE		ENDIF	ELSE		IF STATUS=IDCANCEL THEN			RETURN		ENDIF	ENDIFENDIFEdit.TEXT=""TempStr=ProgramName+"    [Untitled]" OBMain.TEXT=TempStrFileName="Untitled"IF NewWindowConstructed=FALSE THEN	CONSTRUCT NewWindow,100,100,350,100	NewWindow.TEXT="New"	NewWindowConstructed=TRUE	CONSTRUCT ProjectButton,10,20,100,20 IN NewWindow	ProjectButton.TEXT="Project"	CONSTRUCT WindowPgmButton,120,20,100,20 IN NewWindow	WindowPgmButton.TEXT="Windows Pgm"	CONSTRUCT ConsolePgmButton,230,20,100,20 IN NewWindow	ConsolePgmButton.TEXT="Console Pgm"ELSE	NewWindow.VISIBLE=TRUEENDIFOBMain.ENABLED=FALSERETURNProjectButton.COMMANDEdit.APPENDTEXT "; Dimension Variables"Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT "OBMain.CREATE"Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT "END EVENT"Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT CHR$($0d)Edit.SETDIVIDERLINE 6,TRUEEdit.GOTO 4GOSUB NewDoneEND EVENTWindowPgmButton.COMMANDEdit.APPENDTEXT "; Dimension Variables"Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT "OBMain.CREATE"Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT "END EVENT"Edit.GOTO 4GOSUB NewDoneEND EVENTConsolePgmButton.COMMANDEdit.APPENDTEXT "; Dimension Variables"Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT CHR$($0d)Edit.APPENDTEXT "; Code Section"Edit.APPENDTEXT CHR$($0d)Edit.GOTO 4GOSUB NewDoneEND EVENTNewDone:Edit.EMPTYUNDOBUFFERDISABLEMENUITEM MainMenu,mnuSaveButton(3).ICON=SaveIcon2StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSEOBMain.ENABLED=TRUENewWindow.VISIBLE=FALSEEdit.SETFOCUSRETURNOpenCmd:IF Changed=TRUE THEN	TempName=SaveFileName+" Not Saved"	TempStr="Save?"	WARNINGBOX TempName,TempStr,MB_YESNOCANCEL	IF STATUS=IDYES THEN		IF FileName="Untitled" THEN			GOSUB SaveAs		ELSE			Edit.SAVEFILE SaveFileName			DISABLEMENUITEM MainMenu,mnuSave			Button(3).ICON=SaveIcon2			StatusBarSafe5="Not Changed"			StatusBar.SETTEXT 5,StatusBarSafe5			Changed=FALSE		ENDIF	ELSE		IF STATUS=IDCANCEL THEN			RETURN		ENDIF	ENDIFENDIFFileName=""OPENDIALOG FileName,FileFilter,InitDir IF STATUS<>0 THEN	Edit.EMPTYUNDOBUFFER	Edit.LOADFILE FileName	SaveFileName=FileName	BareFileName=LEFT(FileName,LEN(FileName)-4)	Extension=RIGHT(FileName,4)	TempStr=ProgramName+"     ["+FileName+"]"	OBMain.TEXT=TempStr	Timer1.INTERVAL=50	StatusBarSafe5="Not Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=FALSEENDIFEdit.SETFOCUSRETURNSaveCmd:IF FileName="Untitled" THEN	GOSUB SaveAsELSE	Edit.EMPTYUNDOBUFFER	Edit.SAVEFILE SaveFileName	DISABLEMENUITEM MainMenu,mnuSave	Button(3).ICON=SaveIcon2	StatusBarSafe5="Not Changed"	StatusBar.SETTEXT 5,StatusBarSafe5	Changed=FALSEENDIFEdit.SETFOCUSRETURNSaveAsCmd:GOSUB SaveAsEditfChanged=0StatusBarSafe5="Not Changed"StatusBar.SETTEXT 5,StatusBarSafe5Changed=FALSEDISABLEMENUITEM MainMenu,mnuSaveButton(3).ICON=SaveIcon2Edit.SETFOCUSRETURNFindText.CHANGETempStr=FindText.TEXTIF LEN(TempStr)>0 THEN	FindNext.ENABLED=TRUEELSE	FindNext.ENABLED=FALSEENDIFEND EVENTFRFindText.CHANGETempStr=FRFindText.TEXTIF LEN(TempStr)>0 THEN	FRFindNext.ENABLED=TRUE	FRReplace.ENABLED=TRUE	FRReplaceAll.ENABLED=TRUEELSE	FRFindNext.ENABLED=FALSE	FRReplace.ENABLED=FALSE	FRReplaceAll.ENABLED=FALSEENDIFEND EVENTFindNext.COMMANDFindStr=FindText.TEXTfr_lpstrFindWhat=ADDR(FindStr)FLAGS=$08IF DownButton.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,0)ENDIFIF MatchWholeWord.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,1)ENDIFIF MatchCase.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,2)ENDIFEdit.FINDFindStr=FindStr+" Not Found"IF STATUS=-1 then	MSGBOX "Find",FindStr,MB_OK	RETURNENDIFEND EVENTFRFindNext.COMMANDGOSUB GetTextToReplaceEND EVENTFRReplace.COMMANDSelectStr=Edit.SELTEXTFindStr=SelectStrIF TextFound=FALSE OR FindStr<>SelectStr THEN	GOSUB GetTextToReplace	IF TextFound=FALSE THEN		RETURN	ENDIFENDIF	TempStr=FRReplaceText.TEXTEdit.REPLACESEL TempStrFindStr=FRFindText.TEXTfr_lpstrFindWhat=ADDR(FindStr)FLAGS=$08FLAGS=BITSET(FLAGS,0); Forces downward searchIF FRMatchWholeWord.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,1)ENDIFIF FRMatchCase.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,2)ENDIFEdit.FINDIF STATUS=-1 THEN	TextFound=FALSEELSE	TextFound=TRUEENDIFEND EVENTFRReplaceAll.COMMANDREPEAT	SelectStr=Edit.SELTEXT	FindStr=SelectStr	IF TextFound=FALSE OR FindStr<>SelectStr THEN		GOSUB GetTextToReplace		IF TextFound=FALSE THEN			RETURN		ENDIF	ENDIF	TempStr=FRReplaceText.TEXT	Edit.REPLACESEL TempStr	FindStr=FRFindText.TEXT	fr_lpstrFindWhat=ADDR(FindStr)	FLAGS=$08	FLAGS=BITSET(FLAGS,0); Forces downward search	IF FRMatchWholeWord.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,1)	ENDIF	IF FRMatchCase.CHECKED=TRUE THEN		FLAGS=BITSET(FLAGS,2)	ENDIFEdit.FINDUNTIL STATUS=-1TextFound=FALSEEND EVENTCancel.COMMANDFindWindow.VISIBLE=FALSEFindWindowActive=FALSEEND EVENTFindWindow.SYSTEMFindWindow.VISIBLE=FALSEFindWindowActive=FALSEEND EVENTFRCancel.COMMANDFindReplaceWindow.VISIBLE=FALSEEND EVENTFindReplaceWindow.SYSTEMFindReplaceWindow.VISIBLE=FALSEEND EVENTGetFindDialog:IF FindWindowConstructed=FALSE THEN	FindWindowConstructed=TRUE	CONSTRUCT FindWindow,400,300,360,125 APPWINDOW CHILD	FindWindow.TEXT="Find"	CONSTRUCT UpDown,160,45,100,45 IN FindWindow	UpDown.FONT=Font1	UpDown.Text="Direction"	CONSTRUCT UpButton,5,20,40,15 IN UpDown	UpButton.FONT=Font1	UpButton.TEXT="&Up"	CONSTRUCT DownButton,45,20,50,15 IN UpDown	DownButton.FONT=Font1	DownButton.TEXT="&Down"	CONSTRUCT FindText,70,5,190,20 IN FindWindow	FindText.FONT=Font1	CONSTRUCT FindWhat,5,8,50,15 IN FindWindow	FindWhat.FONT=Font1	FindWhat.TEXT="Fi&nd what:"	CONSTRUCT MatchWholeWord,5,50,130,15 IN FindWindow	MatchWholeWord.FONT=Font1	MatchWholeWord.TEXT="Match &whole word only"	CONSTRUCT MatchCase,5,75,75,15 IN FindWindow	MatchCase.FONT=Font1	MatchCase.TEXT="Match &case"	CONSTRUCT FindNext,270,5,75,25 IN FindWindow	FindNext.FONT=Font1	FindNext.TEXT="&Find Next" IN FindWindow	CONSTRUCT Cancel,270,35,75,25 IN FindWindow	Cancel.FONT=Font1	Cancel.TEXT="Cancel"	FindText.TEXT=""	DownButton.CHECKED=TRUE	UpButton.CHECKED=FALSE	MatchWholeWord.CHECKED=FALSE	MatchCase.CHECKED=FALSE	FindNext.ENABLED=FALSEELSE	FindWindow.VISIBLE=TRUEENDIFFindWindowActive=TRUEFindText.SETFOCUSRETURNGetFindReplaceDialog:IF FRWindowConstructed=FALSE THEN	FRWindowConstructed=TRUE	CONSTRUCT FindReplaceWindow,400,300,360,150 APPWINDOW CHILD	FindReplaceWindow.TEXT="Replace"	CONSTRUCT FRFindText,70,5,190,20 IN FindReplaceWindow	FRFindText.FONT=Font1	CONSTRUCT FRFindWhat,5,8,60,15 IN FindReplaceWindow	FRFindWhat.FONT=Font1	FRFindWhat.TEXT="Fi&nd what:"	CONSTRUCT FRReplaceText,70,35,190,20 IN FindReplaceWindow	FRReplaceText.FONT=Font1	CONSTRUCT FRReplaceWith,5,38,60,15 IN FindReplaceWindow	FRReplaceWith.FONT=Font1	FRReplaceWith.TEXT="Re&place with:"	CONSTRUCT FRMatchWholeWord,5,75,130,15 IN FindReplaceWindow	FRMatchWholeWord.FONT=Font1	FRMatchWholeWord.TEXT="Match &whole word only"	CONSTRUCT FRMatchCase,5,100,75,15 IN FindReplaceWindow	FRMatchCase.FONT=Font1	FRMatchCase.TEXT="Match &case"	CONSTRUCT FRFindNext,270,5,75,25 IN FindReplaceWindow	FRFindNext.FONT=Font1	FRFindNext.TEXT="&Find Next" IN FindReplaceWindow	CONSTRUCT FRReplace,270,35,75,25 IN FindReplaceWindow	FRReplace.FONT=Font1	FRReplace.TEXT="&Replace"	CONSTRUCT FRReplaceAll,270,65,75,25 IN FindReplaceWindow	FRReplaceAll.FONT=Font1	FRReplaceAll.TEXT="Replace &All"		CONSTRUCT FRCancel,270,95,75,25 IN FindReplaceWindow	FRCancel.FONT=Font1	FRCancel.TEXT="Cancel"	FRFindText.TEXT=""	FRFindNext.ENABLED=FALSE	FRReplace.ENABLED=FALSE	FRReplaceAll.ENABLED=FALSEELSE	FindReplaceWindow.VISIBLE=TRUEENDIFFRWindowActive=TRUEFRFindText.SETFOCUSRETURNGetTextToReplace:FindStr=FRFindText.TEXTfr_lpstrFindWhat=ADDR(FindStr)FLAGS=$08FLAGS=BITSET(FLAGS,0); Forces downward searchIF FRMatchWholeWord.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,1)ENDIFIF FRMatchCase.CHECKED=TRUE THEN	FLAGS=BITSET(FLAGS,2)ENDIFEdit.FINDIF STATUS=-1 THEN	TextFound=FALSE	FindStr=FindStr+" Not Found"	MSGBOX "Replace",FindStr,MB_OK	RETURNELSE	TextFound=TRUEENDIFRETURNFindStyle:I=0BEGIN LOOP	INCR I	IF StyleArray(I).StyleName="%" THEN		ErrNo=ErrIVProp		RETURN	ENDIF		IF StyleArray(I).StyleName=TempStr AND StyleArray(I).StyleType=STYLE THEN		RETURN	ENDIFEND LOOPRETURNEdit.CONTEXTMENUSHOWPOPUP EditPopUp,CursorPosX,CursorPosYEND EVENTFormWindow.RBUTTONUPGETCURSORPOSITIONSHOWPOPUP FormPopUp,CursorPosX,CursorPosYEND EVENTFormWindow.LBUTTONDOWNFormWindow.text="left down"MouseDown=TRUEIF ControlPosValid<>0 THEN	ControlCombo.TEXT=ControlArray(ControlPosNdx).PuppetName	'''ENDIFEND EVENTFormWindow.LBUTTONUPFormWindow.text="left up"MouseDown=FALSEEND EVENTFormWindow.MOUSEMOVEGETCURSORPOSITIONFormWindow.text="OBMain"TempStr=STR(CursorPosX)StatusBar.SETTEXT 1,TempStrTempStr=STR(CursorPosY)StatusBar.SETTEXT 2,TempStrIF CursorPosX<ControlArray(1).PuppetLeft OR CursorPosX>ControlArray(1).PuppetLeft+ControlArray(1).PuppetWidth OR CursorPosY<ControlArray(1).PuppetTop+20 OR CursorPosY>ControlArray(1).PuppetTop+ControlArray(1).PuppetHeight THEN	RELEASECAPTURE	StatusBar.SETTEXT 5,"Released"ELSE	SETCAPTURE FormWindow	StatusBar.SETTEXT 5,"Captured"ENDIFSCREENTOCLIENT FormWindowTempStr=STR(CursorPosX)StatusBar.SETTEXT 3,TempStrTempStr=STR(CursorPosY)StatusBar.SETTEXT 4,TempStrGOSUB FindControlByPositionIF ControlFound=True THEN	FormWindow.text=ControlArray(ControlPosNdx).PuppetNameELSE	FormWindow.text="Form"ENDIFEND EVENTFindControlByPosition:ControlFound=FALSEFOR ControlPosNdx=2 TO 500	IF CursorPosX>=ControlArray(ControlPosNdx).PuppetLeft AND CursorPosX<=ControlArray(ControlPosNdx).PuppetLeft+ControlArray(ControlPosNdx).PuppetWidth AND CursorPosY>=ControlArray(ControlPosNdx).PuppetTop AND CursorPosY<=ControlArray(ControlPosNdx).PuppetTop+ControlArray(ControlPosNdx).PuppetHeight THEN		ControlFound=TRUE		ControlPosValid=ControlPosNdx		RETURN	ENDIFNEXT ControlPosNdxControlPosValid=0RETURNToolButton.COMMANDToolButtonNdx=ArrayIndexGOSUB PopulateToolBoxEND EVENTPopulateToolBox:PropGrid.GRIDCLEARSETVEC PropArray=[ToolPropMap(ToolButtonNdx).PropMapPropTable]FOR I=1 TO 14	PropGrid.ADDROW	TempStr=UCASE(PropArray(I).PropName)	PropGrid.TEXT(I,1)=TempStr	IF PropArray(I).PropValid=TRUE THEN		PropValidTable(I)=TRUE	ELSE		PropValidTable(I)=FALSE		PropGrid.TEXT(I,2)="**********"	ENDIFNEXT IStyleGrid.GRIDCLEARSETVEC StyleArray=[ToolPropMap(ToolButtonNdx).PropMapStyleTable]TempStr="Styles        "+ToolPropMap(ToolButtonNdx).PropMapNameI=2StyleGridRow=0DisplayStyleLoop:INCR IIF StyleArray(I).StyleName="%" THEN ToolButtonActionStyleGrid.ADDROWINCR StyleGridRowTempStr=UCASE(StyleArray(I).StyleName)IF StyleArray(I).StyleDefault=TRUE THEN	StyleGrid.VALUE(StyleGridRow,2)=1ENDIFStyleGrid.TEXT(StyleGridRow,1)=TempStrSELECT CASE LEN(HEX(StyleArray(I).StyleValue))	CASE 1		TempStr="   $0000000"	CASE 2		TempStr="   $000000"	CASE 3		TempStr="   $00000"	CASE 4		TempStr="   $0000"	CASE 5		TempStr="   $000"	CASE 6		TempStr="   $00"	CASE 7		TempStr="   $0"	CASE 8		TempStr="   $"	END SELECTTempStr=TempStr+HEX(StyleArray(I).StyleValue)StyleGrid.TEXT(StyleGridRow,3)=TempStrGOTO DisplayStyleLoopToolButtonAction:INCR ControlCountIF ControlCount>500 THEN	DECR ControlCount	WARNINGBOX "OmniBasic","Out of Control Space",MB_OK	RETURNENDIFSELECT CASE ToolButtonNdx	CASE 1; Form		IF FormWindowConstructed=FALSE THEN			CONSTRUCT FormWindow,400,260,400,300 CHILD			FormWindowConstructed=TRUE			ControlNdx=1			ControlArray(ControlNdx).PuppetName="OBMain"			FOR I=1 TO 9				;CONSTRUCT Spider(I),10,10,10,10,DEFAULT+BLACKFRAME IN FormWindow			NEXT I			FormCombo.CLEAR			ControlCombo.CLEAR				ELSE			GOSUB FindEmptyControlSlot			ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1			SETPOSITION FormWindow,400,260,400,300 CHILD					ControlArray(ControlNdx).PuppetName="Form"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)		ENDIF		;ControlArray(ControlNdx).PuppetHandle=FormWindow.HANDLE		ControlArray(ControlNdx).PuppetHandle=$ffffffff		FormWindow.TEXT=ControlArray(ControlNdx).PuppetName		ControlArray(ControlNdx).PuppetText=ControlArray(ControlNdx).PuppetName		FormCombo.ADDITEMSORTED ControlArray(ControlNdx).PuppetText		FormCombo.TEXT=ControlArray(ControlNdx).PuppetText		ControlCombo.ADDITEMSORTED ControlArray(ControlNdx).PuppetText		ControlCombo.TEXT=ControlArray(ControlNdx).PuppetText		ControlArray(ControlNdx).PuppetArray=-1		ControlArray(ControlNdx).PuppetLeft=400		ControlArray(ControlNdx).PuppetTop=260		ControlArray(ControlNdx).PuppetWidth=400		ControlArray(ControlNdx).PuppetHeight=300		GOSUB ControlArrayToToolBox	CASE 2; ToolWindow		CASE 3; BUTTON		GOSUB FindEmptyControlSlot		ToolPropMap(ToolButtonNdx).PropMapCount=ToolPropMap(ToolButtonNdx).PropMapCount+1				ControlArray(ControlNdx).PuppetName="Button"+STR(ToolPropMap(ToolButtonNdx).PropMapCount)		ControlArray(ControlNdx).PuppetText=ControlArray(ControlNdx).PuppetName		FormWindow.TEXT=ControlArray(ControlNdx).PuppetName		TempInt=ToolPropMap(ToolButtonNdx).PropMapCount+500		ControlArray(ControlNdx).PuppetID=TempInt		ControlArray(ControlNdx).PuppetArray=-1		ControlArray(ControlNdx).PuppetLeft=10		ControlArray(ControlNdx).PuppetTop=10		ControlArray(ControlNdx).PuppetWidth=100		ControlArray(ControlNdx).PuppetHeight=20		invoke CreateWindowEx,0,!ControlType27,NULL,$50000040,10,10,100,20, dword [!FormWindow],dword [TempInt],[!hinstance],!Button		mov [TempInt],eax		ControlArray(ControlNdx).PuppetHandle=TempInt		FormWindow.TEXT=ControlArray(ControlNdx).PuppetName		ControlCombo.ADDITEMSORTED ControlArray(ControlNdx).PuppetText		ControlCombo.TEXT=ControlArray(ControlNdx).PuppetText		;TempStr=ControlArray(ControlNdx).PuppetName		TempStr="Havis"		invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]		;invoke SetWindowPos,[TempInt],HWND_TOP,50,50,20,20,4		GOSUB ControlArrayToToolBoxEND SELECTRETURNFindEmptyControlSlot:FOR ControlNdx=1 TO 500	IF ControlArray(ControlNdx).PuppetHandle=0 THEN		RETURN	ENDIFNEXT ControlNdx=1RETURNFormWindow.MOVEControlNdx=1GetWindowRect FormWindowControlArray(ControlNdx).PuppetLeft=RectLeftControlArray(ControlNdx).PuppetTop=RectTopControlCombo.TEXT=FormCombo.TEXTGOSUB ControlArrayToToolBoxEND EVENTFormWindow.RESIZEControlNdx=1GetWindowRect FormWindowControlArray(ControlNdx).PuppetWidth=RectRight-RectLeftControlArray(ControlNdx).PuppetHeight=RectBottom-RectTopControlCombo.TEXT=FormCombo.TEXTGOSUB ControlArrayToToolBoxEND EVENTCleanControl:ControlArray(ControlNdx).PuppetHandle=0ControlArray(ControlNdx).PuppetID=0ControlArray(ControlNdx).PuppetOwner=0ControlArray(ControlNdx).PuppetArray=-1ControlArray(ControlNdx).PuppetLeft=0ControlArray(ControlNdx).PuppetTop=0ControlArray(ControlNdx).PuppetWidth=0ControlArray(ControlNdx).PuppetHeight=0ControlArray(ControlNdx).PuppetBackColor=0ControlArray(ControlNdx).PuppetForeColor=0ControlArray(ControlNdx).PuppetType=0ControlArray(ControlNdx).PuppetStatus=0ControlArray(ControlNdx).PuppetFont=0ControlArray(ControlNdx).PuppetIcon=0ControlArray(ControlNdx).PuppetText=""ControlArray(ControlNdx).PuppetName=""RETURNControlArrayToToolBox:PropGrid.TEXT(3,2)="TRUE"PropGrid.TEXT(4,2)="TRUE"PropGrid.TEXT(5,2)=STR(ControlArray(ControlNdx).PuppetLeft)PropGrid.TEXT(6,2)=STR(ControlArray(ControlNdx).PuppetTop)PropGrid.TEXT(7,2)=STR(ControlArray(ControlNdx).PuppetWidth)PropGrid.TEXT(8,2)=STR(ControlArray(ControlNdx).PuppetHeight)RETURNControlArrayToControl:RETURNPropGrid.AFTERUPDATEToolBox.text=str(ControlNdx)IF GridCol=2 THEN	; Need to check here if form or control ***********************	SELECT CASE GridRow		CASE 1			TempStr=PropGrid.text(1,2)		CASE 2			TempStr=PropGrid.text(2,2)		CASE 3			TempStr=PropGrid.text(3,2)		CASE 4			TempStr=PropGrid.text(4,2)		CASE 5			GOSUB UpdatePosition		CASE 6			GOSUB UpdatePosition		CASE 7			GOSUB UpdatePosition		CASE 8			GOSUB UpdatePosition		CASE 9			TempStr=PropGrid.text(9,2)		CASE 10			TempStr=PropGrid.text(10,2)		CASE 11			TempStr=PropGrid.text(11,2)		CASE 12			TempStr=PropGrid.text(12,2)		CASE 13			TempStr=PropGrid.text(13,2)		CASE 14			TempStr=PropGrid.text(14,2)		END SELECTENDIFEND EVENTUpdatePosition:TempStr=PropGrid.text(5,2)TempLeft=VAL(TempStr)ControlArray(ControlNdx).PuppetLeft=TempLeftTempStr=PropGrid.text(6,2)TempTop=VAL(TempStr)ControlArray(ControlNdx).PuppetTop=TempTopTempStr=PropGrid.text(7,2)TempWidth=VAL(TempStr)ControlArray(ControlNdx).PuppetWidth=TempWidthTempStr=PropGrid.text(8,2)TempHeight=VAL(TempStr)ControlArray(ControlNdx).PuppetHeight=TempHeightTempHandle=ControlArray(ControlNdx).PuppetHandleinvoke SetWindowPos,[TempHandle],HWND_TOP,[TempLeft],[TempTop],[TempWidth],[TempHeight],4RETURNMinMax.COMMANDIF MinMaxFlag=FALSE THEN	GOSUB MakeMaxELSE	GOSUB MakeMinENDIFMinMaxFlag=NOT(MinMaxFlag)END EVENTMakeMax:SETPOSITION ToolBox,3,85,300,631SETPOSITION FormCombo,0,184,245,160SETPOSITION MinMax,245,184,46,24SETPOSITION ControlCombo,0,210,290,160;ToolBox.HEIGHT=605;FormCombo.TOP=184;MinMax.TOP=184FOR I=1 TO 30	ToolButton(I).VISIBLE=TRUENEXT IMinMax.TEXT="Min"RETURNMakeMin:SETPOSITION ToolBox,3,85,300,77SETPOSITION FormCombo,0,0,245,160SETPOSITION MinMax,245,0,46,24SETPOSITION ControlCombo,0,26,290,160;ToolBox.HEIGHT=50;FormCombo.TOP=0;MinMax.TOP=0FOR I=1 TO 30	ToolButton(I).VISIBLE=FALSENEXT IMinMax.TEXT="Max"RETURNControlCombo.SELECTTimer2.INTERVAL=50END EVENTTimer2.TIMERTimer2.STOPControlName=ControlCombo.TEXTGOSUB FindControlByNameIF ControlFound=FALSE THEN	RETURNENDIFTempInt=ControlArray(ControlNdx).PuppetHandleTempStr="Havis"invoke SendMessage,[TempInt],WM_SETTEXT,0,[TempStr]END EVENTFindControlByName:ControlFound=FALSEFOR ControlNdx=1 TO 500	IF ControlArray(ControlNdx).PuppetName=ControlName THEN		ControlFound=TRUE		GOSUB ControlArrayToToolBox		RETURN	ENDIFNEXT ControlNdx=1RETURNControlCombo.CHANGEControlName=ControlCombo.TEXTGOSUB FindControlByNameEND EVENT