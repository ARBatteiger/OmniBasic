; FX-100 Fluorometer
; Copyright 2004 Romer Labs, Inc.
;

; Constant Assignments
CONST ChanMux=$7007
CONST NumDigits=$0003
CONST DPDigits=$0001
CONST VialBit=$0020
CONST GainX1=$0007
CONST GainX10=$0006
CONST GainX100=$0004
CONST GainX1000=$0000
CONST RefChan=$0090
CONST SigChan=$0050
CONST LampIntensity=$0030
CONST AGnd=$0000
CONST AcqrIO=$7002
CONST RunMode=$0000
CONST TestMode=$0060
CONST OSMode=$0020
CONST StartAcqr=$0080
CONST LampReset
CONST LampDataRdy=$0040
CONST NumGTries=$0032
CONST GLimit=$03E8
Const QueSize=$0064
Const RAMEnd=$1FFF
Const RAMBegin=$0000
CONST RTCSeconds=$0000
CONST RTCMinutes=$0002
CONST RTCHours=$0004
CONST RTCDay=$0007
CONST RTCMonth=$0008
CONST RTCYear=$0009
CONST UIPReg=$000A
CONST UIPBit=$0080
CONST ClkSet=$000B
CONST SetBit=$0080
CONST RegA=$000A
CONST RegB=$000B
CONST RegC=$000C
CONST RegD=$000D
CONST AInit=$0023
CONST BInit=$000C
CONST Day0=$000E
CONST VTRBit=$0080
CONST MSBSampleNum=$000F
CONST LSBSampleNum=$0010
CONST RunDlyP=$003D
CONST TestByteP=$003F
CONST MDelay=$0000
CONST MUnits=$0002
CONST MFormat=$0004
CONST HiCalValue=$0006
CONST LoCalValue=$000C
CONST MDate=$0012
CONST MChecksum=$001A
CONST MDefault=$8546
CONST VBoot=$0556
CONST ExtIRQ=$BFFC
CONST ExtSWI=$BFF6
CONST ExtNMI=$BFFA
CONST ExtRST=$BFFA
CONST ExtROM=$BFFE
CONST DP0=$C01E
CONST XFence=$C01C
CONST WarmStart=$FFFF
CONST PPushBA=$FFEC
CONST XPushBA=$C032
CONST XPCEmit=$DF10
CONST XPCKey=$D3FC
CONST XPEdit=$D0FD
CONST XPAssember=$D0EA
CONST XPForth=$DF46
CONST JSTTB=$E08C

; Variable Assignments
DIM RunHour AS BYTE
DIM RunMinute AS BYTE
DIM RunSecond AS BYTE
DIM MSTimer AS BYTE
DIM GainLimit AS INTEGER
DIM BlankData(16) AS INTEGER
DIM TestRtn AS INTEGER
DIM CalFlag AS INTEGER
DIM CalOK AS BOOLEAN
DIM TestR0 AS INTEGER
DIM AbortFlag AS BOOLEAN
DIM ClkBuf(30) AS INTEGER
DIM MuxSet AS INTEGER
DIM MuxStat AS INTEGER
DIM FDisplay AS INTEGER
DIM FVial AS INTEGER
DIM Results(12) AS INTEGER
DIM NFResult AS INTEGER
DIM Over990Err AS INTEGER
DIM QAFlag AS BOOLEAN
DIM FMenu AS INTEGER
DIM MinX AS INTEGER
DIM MaxX AS INTEGER
DIM InitValue(2) AS LONG
DIM Havis1 AS INTEGER
DIM FSgn AS INTEGER
DIM FDPok AS INTEGER
DIM FDP AS INTEGER
DIM FDP0 AS INTEGER
DIM OutBuf(40) AS INTEGER
DIM Remm AS INTEGER
DIM RSgn AS INTEGER
DIM TwoDigitResult(6) AS INTEGER
DIM NumLen AS INTEGER
DIM ACQCntl AS INTEGER
DIM LampStat AS INTEGER
DIM BTest AS INTEGER
DIM ADData AS INTEGER
DIM GainValue AS INTEGER
DIM GainExp AS INTEGER
DIM AcqrMode AS INTEGER
DIM LampErr AS BOOLEAN
DIM FLampErr AS INTEGER
DIM LampErrors AS INTEGER
DIM TrigErr AS INTEGER
DIM TrigDly AS INTEGER
DIM RtQ AS INTEGER
DIM TmpX AS INTEGER
DIM SigOffset AS INTEGER
DIM SVStat AS INTEGER
DIM GetSigVar AS INTEGER
DIM NumPrimes AS INTEGER
DIM Temp AS INTEGER
DIM rtn AS INTEGER
DIM DltaGains(20) AS INTEGER
DIM S0 AS INTEGER
DIM CycleN AS INTEGER
DIM MinSampleNum AS INTEGER
DIM RHi AS INTEGER
DIM RLo AS INTEGER
DIM Dlta AS INTEGER
DIM SumRn AS LONG
DIM RDlta AS LONG
DIM OverLimit AS BOOLEAN
DIM FOffset AS INTEGER
DIM FGErr AS INTEGER
DIM AverSigRef AS LONG
DIM SigAver AS LONG
DIM RefAver AS LONG
DIM SigRefAver AS LONG
DIM SigQue(200) AS INTEGER
DIM RefQue(200) AS INTEGER
DIM SigRefQue(200) AS INTEGER
DIM NumSamples AS INTEGER
DIM NumOutlyers AS INTEGER
DIM SampleNum AS INTEGER
DIM SampleTotal AS INTEGER
DIM SampleNdx AS INTEGER
DIM NdxLimit AS INTEGER
DIM FirstTest AS INTEGER
DIM Assembly AS INTEGER
DIM SampleTable(8) AS INTEGER
DIM OutlyerTable(8) AS INTEGER
DIM MaxSample AS INTEGER
DIM MaxNdx AS INTEGER
DIM MinSample AS INTEGER
DIM MinNdx AS INTEGER
DIM PctDif AS INTEGER
DIM SRJst AS INTEGER
DIM SigOK AS INTEGER
DIM RefOK AS INTEGER
DIM NumBadPnts AS INTEGER
DIM FMinus AS INTEGER
DIM DataLine AS INTEGER
DIM XPtr AS INTEGER
DIM XRd AS INTEGER
DIM XWrt AS INTEGER
DIM FFail AS INTEGER
DIM TmpHours AS INTEGER
DIM ClkErrCnt AS INTEGER
DIM PMFlag AS BOOLEAN
DIM PrintBuf1 AS STRING*41
DIM PrintBuf2 AS STRING*41
DIM NMIOffFlag AS BOOLEAN
DIM J1 AS INTEGER
DIM J2 AS INTEGER
DIM Sgn1 AS INTEGER
DIM Sgn2 AS INTEGER
DIM J1 AS INTEGER
DIM J2 AS INTEGER
DIM n AS INTEGER
DIM CalcErr AS INTEGER
DIM n1(6) AS INTEGER
DIM n2(6) AS INTEGER
DIM n3 AS INTEGER
DIM FSgn AS INTEGER
DIM DelayVal AS INTEGER
DIM TempInt AS INTEGER
DIM Tries AS INTEGER
DIM VialIn AS BOOLEAN

; Loop Variables
DIM I AS INTEGER
DIM J AS INTEGER
DIM K AS INTEGER

; Vectors
DIM RTCDataReq AS BYTE VECTOR
SETVEC RTCDataReq=$6010 
DIM RTCDataReg AS BYTE VECTOR
SETVEC RTCDataReg=$6011
DIM ADHiByte AS BYTE VECTOR
SETVEC ADHiByte=$7002
DIM ADLoByte AS BYTE VECTOR
SETVEC ADLoByte=$7001
DIM ADStatus AS BYTE VECTOR
SETVEC ADStatus=$7002

FireLamp:
LampErr=0
FLampErr=$FFFF
REPEAT
	GOSUB TriggerLamp
	Tries=0
	REPEAT
		INCR Tries
		TempInt=LXOR(ADStatus,$FF)
		TempInt=LAND(TempInt,LampDataRdy)
		IF TempInt=0 OR VialIn=FALSE OR Trys>10 THEN
			LampErr=TRUE
			AbortFlag=TRUE
		ELSE
			LampErr=FALSE
			AbortFlag=FALSE
		ENDIF		
	UNTIL Tries=10	
UNTIL
IF LampErr=TRUE THEN
	PRINT " DATA READY ERROR(s) "
ENDIF
RETURN

GetVialStatus:
IF LAND(ADStatus,VialBit)<>0 THEN
	VialIn=TRUE
ELSE
	VialIn=FALSE
ENDIF
RETURN	

LampCheck:
NumPrimes=16
GOSUB PrimeLampControl
TrigDly=50
LampErrors=0
FOR I=1 to 10
	GOSUB FireTest
        GOSUB GetRef
	IF FLampErr<>0 THEN
		INCR LampErrors
	ENDIF
NEXT I
RETURN

TriggerLamp:
AcqrIO=LAND(LampStat,LampReset)
IF TrigDly>50 THEN
	DelayVal=TrigDly
ELSE
	DelayVal=50
ENDIF
GOSUB DelayMS
LampStat=LOR(LampStat,StartAcqr)
AcqrIO=LampStat
RETURN

SetOffset:
SVStat=LampStat
LampStat=LAND(LampStat,$9F)
LampStat=LOR(LampStat,$20)
RETURN

SetNormal:
LampStat=SVStat
RETURN

SetInitValue:
InitValue(1)=0
InitValue(2)=0
RETURN

PrimeLampControl:
FOR K=1 TO NumPrimes
	GOSUB TriggerLamp
NEXT K
RETURN

; Sum of 8 readings
TestSig:
TempInt=0
FOR K=1 TO 8
	GOSUB Firelamp
        GOSUB ADConvert
	TempInt=TempInt+ADData
NEXT K
IF Temp>RHi THEN
	RHi=TempInt
ENDIF
IF Temp<RLo THEN
	RLo=TempInt
ENDIF
RETURN

InitSigFilter:
SumRn=0
RHi=0
Rlo=0
CycleN=0
RETURN


ChkGainOK
IF RDlta<>0 THEM
	

RETURN

InitMeasureData:
AverSigRef=0
SigAver=0
RefAver=0
SigRefAver=0
RETURN

RejectOutlyer:
MaxSample=0
MinSample=32767
MaxNdx=-1
MinNdx=-1
IF NumOutlyers>0 THEN
	FOR K=1 TO NdxLimit
		IF SigRefQue(K)>=0 THEN
			GOSUB ChkMinMax; Only used here
		ENDIF
	NEXT K
	IF MaxNdx>=0 AND MaxNdx<NdxLimit THEN
		SigRefQue(1)=-1???
	ENDIF
	IF MinNdx>=0 AND MaxNdx<NdxLimit THEN
		SigRefQue(1)=-2???
	ENDIF 		
RETURN

ChkMinMax:


RETURN

CalcGains:
FGErr=0

RETURN

EvalGain:


RETURN

ScaleGain:


RETURN

DelayMS:


RETURN


