DIM ImmFlag AS BOOLEANDIM PCRegSet AS BOOLEANDIM RunFlag AS BOOLEANDIM TargetMem(65536) AS BYTEDIM I AS LONGDIM CycleCtr AS LONGDIM TempInt AS LONGDIM TempByte AS BYTEDIM TempStr AS STRING*256DIM TempHexData AS STRING*256DIM HexData AS STRING*256DIM TempLabel AS LABELDIM BinFile AS FILEDIM InstReg AS BYTEDIM OperandReg AS LONGDIM StoreData AS BYTEDIM IFlag AS BOOLEANDIM NFlag AS BOOLEANDIM ZFlag AS BOOLEANDIM VFlag AS BOOLEANDIM CFlag AS BOOLEANDIM CPUBackground AS RECTANGLEDIM ResetButton AS BUTTONDIM RunButton AS BUTTONDIM StepButton AS BUTTONDIM LoadButton AS BUTTONDIM AddrReg AS LONGDIM AddrRegDisplay AS TEXTBOXDIM AddrRegLabel AS STATICTEXTDIM DecAddr AS BUTTONDIM IncAddr AS BUTTONDIM DataReg AS BYTEDIM DataRegDisplay AS TEXTBOXDIM DataRegLabel AS STATICTEXTDIM SetData AS BUTTONDIM PCReg AS LONGDIM PCRegDisplay AS TEXTBOXDIM PCRegLabel AS STATICTEXTDIM SetPCReg AS BUTTONDIM SPReg AS LONGDIM SPRegDisplay AS TEXTBOXDIM SPRegLabel AS STATICTEXTDIM SetSPReg AS BUTTONDIM IndexReg AS LONGDIM IndexRegDisplay AS TEXTBOXDIM IndexRegLabel AS STATICTEXTDIM SetIndexReg AS BUTTONDIM AccA AS BYTEDIM AccADisplay AS TEXTBOXDIM AccALabel AS STATICTEXTDIM SetAccA AS BUTTONDIM AccB AS BYTEDIM AccBDisplay AS TEXTBOXDIM AccBLabel AS STATICTEXTDIM SetAccB AS BUTTONDIM CCReg AS BYTEDIM BPReg AS LONGDIM BPRegDisplay AS TEXTBOXDIM BPRegLabel AS STATICTEXTDIM SetBPReg AS BUTTONDIM IRQButton AS BUTTONDIM NMIButton AS BUTTONDIM NextInst AS STATICTEXTDIM TimerFlag AS BOOLEANDIM TimerLight AS STATICTEXTDIM ILight AS STATICTEXTDIM NLight AS STATICTEXTDIM ZLight AS STATICTEXTDIM VLight AS STATICTEXTDIM CLight AS STATICTEXTDIM RunLight AS STATICTEXTDIM KbdBackground AS RECTANGLEDIM Line1 AS RECTANGLEDIM Line2 AS RECTANGLEDIM Key(16) AS BUTTONDIM IOBackground AS RECTANGLEENUM 0 TRAPMODE INHERENTMODE IMM1MODE IMM2MODE DIRECTMODE INDEXEDMODE EXTENDEDMODE RELATIVEMODEEND ENUMTYPE OpCodeData	OpInstDispatch AS LABEL	OpModeDispatch AS LABEL	OpMode AS LONG	OpName AS STRING*8END TYPETABLE OpCode AS OpCodeData TrapX,TrapX,TRAPMODE,"Trap" NopX,InherentX,INHERENTMODE,"NOP" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TapX,InherentX,INHERENTMODE,"TAP" TpaX,InherentX,INHERENTMODE,"TPA" InxX,InherentX,INHERENTMODE,"INX" DexX,InherentX,INHERENTMODE,"DEX" ClvX,InherentX,INHERENTMODE,"CLV" SevX,InherentX,INHERENTMODE,"SEV" ClcX,InherentX,INHERENTMODE,"CLC" SecX,InherentX,INHERENTMODE,"SEC" CliX,InherentX,INHERENTMODE,"CLI" SeiX,InherentX,INHERENTMODE,"SEI" SbaX,InherentX,INHERENTMODE,"SBA" CbaX,InherentX,INHERENTMODE,"CBA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TabX,InherentX,INHERENTMODE,"TAB" TbaX,InherentX,INHERENTMODE,"TBA" TrapX,TrapX,TRAPMODE,"Trap" DaaX,InherentX,INHERENTMODE,"DAA" TrapX,TrapX,TRAPMODE,"Trap" AbaX,InherentX,INHERENTMODE,"ABA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" BraX,RelX,RELATIVEMODE,"BRA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" BlsX,RelX,RELATIVEMODE,"BLS" BccX,RelX,RELATIVEMODE,"BCC" BcsX,RelX,RELATIVEMODE,"BCS" BneX,RelX,RELATIVEMODE,"BNE" BeqX,RelX,RELATIVEMODE,"BEQ" BvcX,RelX,RELATIVEMODE,"BVC" BvsX,RelX,RELATIVEMODE,"BVS" BplX,RelX,RELATIVEMODE,"BPL" BmiX,RelX,RELATIVEMODE,"BMI" BgeX,RelX,RELATIVEMODE,"BGE" BltX,RelX,RELATIVEMODE,"BLT" BgtX,RelX,RELATIVEMODE,"BGT" BleX,RelX,RELATIVEMODE,"BLE" TsxX,InherentX,INHERENTMODE,"TSX" InsX,InherentX,INHERENTMODE,"INS" PulaX,InherentX,INHERENTMODE,"PULA" PulbX,InherentX,INHERENTMODE,"PULB" DesX,InherentX,INHERENTMODE,"DES" TxsX,InherentX,INHERENTMODE,"TSX" PshaX,InherentX,INHERENTMODE,"PSHA" PshbX,InherentX,INHERENTMODE,"PSHB" TrapX,TrapX,TRAPMODE,"Trap" RtsX,InherentX,INHERENTMODE,"RTS" TrapX,TrapX,TRAPMODE,"Trap" RtiX,InherentX,INHERENTMODE,"RTI" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" WaiX,InherentX,INHERENTMODE,"WAI" SwiX,InherentX,INHERENTMODE,"SWI" NegaX,InherentX,INHERENTMODE,"NEGA" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComaX,InherentX,INHERENTMODE,"COMA" LsraX,InherentX,INHERENTMODE,"LSRA" TrapX,TrapX,TRAPMODE,"Trap" RoraX,InherentX,INHERENTMODE,"RORA" AsraX,InherentX,INHERENTMODE,"ASRA" AslaX,InherentX,INHERENTMODE,"ASLA" RolaX,InherentX,INHERENTMODE,"ROLA" DecaX,InherentX,INHERENTMODE,"DECA" TrapX,TrapX,TRAPMODE,"Trap" IncaX,InherentX,INHERENTMODE,"INCA" TstaX,InherentX,INHERENTMODE,"TSTA" TrapX,TrapX,TRAPMODE,"Trap" ClraX,InherentX,INHERENTMODE,"CLRA" NegbX,InherentX,INHERENTMODE,"NEGB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" CombX,InherentX,INHERENTMODE,"COMB" LsrbX,InherentX,INHERENTMODE,"LSRB" TrapX,TrapX,TRAPMODE,"Trap" RorbX,InherentX,INHERENTMODE,"RORB" AsrbX,InherentX,INHERENTMODE,"ASRB" AslbX,InherentX,INHERENTMODE,"ASLB" RolbX,InherentX,INHERENTMODE,"ROLB" DecbX,InherentX,INHERENTMODE,"DECB" TrapX,TrapX,TRAPMODE,"Trap" IncbX,InherentX,INHERENTMODE,"INCB" TstbX,InherentX,INHERENTMODE,"TSTB" TrapX,TrapX,TRAPMODE,"Trap" ClrbX,InherentX,INHERENTMODE,"CLRB" NegX,IndexX,INDEXEDMODE,"NEGB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComX,IndexX,INDEXEDMODE,"COM" LsrX,IndexX,INDEXEDMODE,"LSR" TrapX,TrapX,TRAPMODE,"Trap" RorX,IndexX,INDEXEDMODE,"ROR" AsrX,IndexX,INDEXEDMODE,"ASR" AslX,IndexX,INDEXEDMODE,"ASL" RolX,IndexX,INDEXEDMODE,"ROL" DecX,IndexX,INDEXEDMODE,"DEC" TrapX,TrapX,TRAPMODE,"Trap" IncX,IndexX,INDEXEDMODE,"INC" TstX,IndexX,INDEXEDMODE,"TST" JmpX,IndexX,INDEXEDMODE,"JMP" ClrX,IndexX,INDEXEDMODE,"CLR" NegX,ExtX,EXTENDEDMODE,"NEG" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" ComX,ExtX,EXTENDEDMODE,"COM" LsrX,ExtX,EXTENDEDMODE,"LSR" TrapX,TrapX,TRAPMODE,"Trap" RorX,ExtX,EXTENDEDMODE,"ROR" TrapX,TrapX,TRAPMODE,"Trap" AslX,ExtX,EXTENDEDMODE,"ASL" RolX,ExtX,EXTENDEDMODE,"ROL" DecX,ExtX,EXTENDEDMODE,"DEC" TrapX,TrapX,TRAPMODE,"Trap" IncX,ExtX,EXTENDEDMODE,"INC" TstX,ExtX,EXTENDEDMODE,"TST" JmpX,ExtX,EXTENDEDMODE,"JMP" ClrX,ExtX,EXTENDEDMODE,"CLR" SubaX,Imm1X,IMM1MODE,"SUBA" CmpaX,Imm1X,IMM1MODE,"CMPA" SbcaX,Imm1X,IMM1MODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,Imm1X,IMM1MODE,"ANDA" BitaX,Imm1X,IMM1MODE,"BITA" LdaaX,Imm1X,IMM1MODE,"LDAA" TrapX,TrapX,TRAPMODE,"Trap" EoraX,Imm1X,IMM1MODE,"EORA" AdcaX,Imm1X,IMM1MODE,"ADCA" OraaX,Imm1X,IMM1MODE,"ORAA" AddaX,Imm1X,IMM1MODE,"ADDA" CpxX,Imm2X,IMM2MODE,"CPX" BsrX,RelX,RELATIVEMODE,"BSR" LdsX,Imm2X,IMM2MODE,"LDS" TrapX,TrapX,TRAPMODE,"Trap" SubaX,DirX,DIRECTMODE,"SUBA" CmpaX,DirX,DIRECTMODE,"CMPA" SbcaX,DirX,DIRECTMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,DirX,DIRECTMODE,"ANDA" BitaX,DirX,DIRECTMODE,"BITA" LdaaX,DirX,DIRECTMODE,"LDAA" StaaX,DirX,DIRECTMODE,"STAA" EoraX,DirX,DIRECTMODE,"EORA" AdcaX,DirX,DIRECTMODE,"ADCA" OraaX,DirX,DIRECTMODE,"ORAA" AddaX,DirX,DIRECTMODE,"ADDA" CpxX,DirX,DIRECTMODE,"CPX" StsX,DirX,DIRECTMODE,"STS" LdsX,DirX,DIRECTMODE,"LDS" TrapX,TrapX,TRAPMODE,"Trap" SubaX,IndexX,INDEXEDMODE,"SUBA" CmpaX,IndexX,INDEXEDMODE,"CMPA" SbcaX,IndexX,INDEXEDMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,IndexX,INDEXEDMODE,"ANDA" BitaX,IndexX,INDEXEDMODE,"BITA" LdaaX,IndexX,INDEXEDMODE,"LDAA" StaaX,IndexX,INDEXEDMODE,"STAA" EoraX,IndexX,INDEXEDMODE,"EORA" AdcaX,IndexX,INDEXEDMODE,"ADCA" OraaX,IndexX,INDEXEDMODE,"ORAA" AddaX,IndexX,INDEXEDMODE,"ADDA" CpxX,IndexX,INDEXEDMODE,"CPX" JsrX,IndexX,INDEXEDMODE,"JSR" LdsX,IndexX,INDEXEDMODE,"LDS" StsX,IndexX,INDEXEDMODE,"STS" SubaX,ExtX,EXTENDEDMODE,"SUBA" CmpaX,ExtX,EXTENDEDMODE,"CMPX" SbcaX,ExtX,EXTENDEDMODE,"SBCA" TrapX,TrapX,TRAPMODE,"Trap" AndaX,ExtX,EXTENDEDMODE,"ANDA" BitaX,ExtX,EXTENDEDMODE,"BITA" LdaaX,ExtX,EXTENDEDMODE,"LDAA" StaaX,ExtX,EXTENDEDMODE,"STAA" EoraX,ExtX,EXTENDEDMODE,"EORA" AdcaX,ExtX,EXTENDEDMODE,"ADCA" OraaX,ExtX,EXTENDEDMODE,"ORAA" AddaX,ExtX,EXTENDEDMODE,"ADDA" CpxX,ExtX,EXTENDEDMODE,"CPX" JsrX,ExtX,EXTENDEDMODE,"JSR" LdsX,ExtX,EXTENDEDMODE,"LDS" StsX,ExtX,EXTENDEDMODE,"STS" SubbX,Imm1X,IMM1MODE,"SUBB" CmpbX,Imm1X,IMM1MODE,"CMPB" SbcbX,Imm1X,IMM1MODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,Imm1X,IMM1MODE,"ANDB" BitbX,Imm1X,IMM1MODE,"BITB" LdabX,Imm1X,IMM1MODE,"LDAB" TrapX,TrapX,TRAPMODE,"Trap" EorbX,Imm1X,IMM1MODE,"EORB" AdcbX,Imm1X,IMM1MODE,"ADCB" OrabX,Imm1X,IMM1MODE,"ORAB" AddbX,Imm1X,IMM1MODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,Imm2X,IMM2MODE,"LDX" TrapX,TrapX,TRAPMODE,"Trap" SubbX,DirX,DIRECTMODE,"SUBB" CmpbX,DirX,DIRECTMODE,"CMPB" SbcbX,DirX,DIRECTMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,DirX,DIRECTMODE,"ANDB" BitbX,DirX,DIRECTMODE,"BITB" LdabX,DirX,DIRECTMODE,"LDAB" StabX,DirX,DIRECTMODE,"STAB" EorbX,DirX,DIRECTMODE,"EORB" AdcbX,DirX,DIRECTMODE,"ADCB" OrabX,DirX,DIRECTMODE,"ORAB" AddbX,DirX,DIRECTMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,DirX,DIRECTMODE,"LDX" StxX,DirX,DIRECTMODE,"STX" SubbX,IndexX,INDEXEDMODE,"SUBB" CmpbX,IndexX,INDEXEDMODE,"CMPB" SbcbX,IndexX,INDEXEDMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,IndexX,INDEXEDMODE,"ANDB" BitbX,IndexX,INDEXEDMODE,"BITB" LdabX,IndexX,INDEXEDMODE,"LDAB" StabX,IndexX,INDEXEDMODE,"STAB" EorbX,IndexX,INDEXEDMODE,"EORB" AdcbX,IndexX,INDEXEDMODE,"ADCB" OrabX,IndexX,INDEXEDMODE,"ORAB" AddbX,IndexX,INDEXEDMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,IndexX,INDEXEDMODE,"LDX" StxX,IndexX,INDEXEDMODE,"STX" SubbX,ExtX,EXTENDEDMODE,"SUBB" CmpbX,ExtX,EXTENDEDMODE,"CMPB" SbcbX,ExtX,EXTENDEDMODE,"SBCB" TrapX,TrapX,TRAPMODE,"Trap" AndbX,ExtX,EXTENDEDMODE,"ANDB" BitbX,ExtX,EXTENDEDMODE,"BITB" LdabX,ExtX,EXTENDEDMODE,"LDAB" StabX,ExtX,EXTENDEDMODE,"STAB" EorbX,ExtX,EXTENDEDMODE,"EORB" AdcbX,ExtX,EXTENDEDMODE,"ADCB" OrabX,ExtX,EXTENDEDMODE,"ORAB" AddbX,ExtX,EXTENDEDMODE,"ADDB" TrapX,TrapX,TRAPMODE,"Trap" TrapX,TrapX,TRAPMODE,"Trap" LdxX,ExtX,EXTENDEDMODE,"LDX" StxX,ExtX,EXTENDEDMODE,"STX"END TABLEOBMain.createSETPOSITION OBMain,0,0,1024,740OBMain.TEXT="6800 Emulator"PCRegSet=FALSERunFlag=FALSEIndexReg=0BPReg=0AccA=0AccB=0SPReg=0BPReg=0CONSTRUCT CPUBackground,5,280,280,400CPUBackground.BACKCOLOR=$ff0000CONSTRUCT ResetButton,10,650,60,20ResetButton.TEXT="RESET"CONSTRUCT RunButton,80,650,60,20RunButton.TEXT="RUN"CONSTRUCT StepButton,150,650,60,20StepButton.TEXT="STEP"CONSTRUCT LoadButton,220,650,60,20LoadButton.TEXT="LOAD"CONSTRUCT NextInst,10,620,270,20NextInst.BACKCOLOR=$ffffffCONSTRUCT DecAddr,120,580,15,20DecAddr.TEXT="<"CONSTRUCT IncAddr,135,580,15,20IncAddr.TEXT=">"CONSTRUCT AddrRegLabel,50,600,60,20CONSTRUCT AddrRegDisplay,50,580,60,20AddrRegLabel.TEXT="Addr"AddrRegLabel.BACKCOLOR=$ff0000AddrRegLabel.FORECOLOR=$ffffffCONSTRUCT IRQButton,170,580,60,20IRQButton.TEXT="IRQ"CONSTRUCT NMIButton,170,540,60,20NMIButton.TEXT="NMI"CONSTRUCT TimerLight,170,500,60,20TimerLight.BACKCOLOR=$ffTimerLight.FORECOLOR=$ffffTimerLight.TEXT="TIMER"CONSTRUCT ILight,170,460,60,20ILight.BACKCOLOR=$ffILight.FORECOLOR=$ffffILight.TEXT="INT"CONSTRUCT NLight,170,420,60,20NLight.BACKCOLOR=$ffNLight.FORECOLOR=$ffffNLight.TEXT="NEG"CONSTRUCT ZLight,170,380,60,20ZLight.BACKCOLOR=$ffZLight.FORECOLOR=$ffffZLight.TEXT="ZERO"CONSTRUCT VLight,170,340,60,20VLight.BACKCOLOR=$ffVLight.FORECOLOR=$ffffVLight.TEXT="OVF"CONSTRUCT CLight,170,300,60,20CLight.BACKCOLOR=$ffCLight.FORECOLOR=$ffffCLight.TEXT="CARRY"CONSTRUCT RunLight,245,300,30,20RunLight.BACKCOLOR=$ffRunLight.FORECOLOR=$ffffRunLight.TEXT="RUN"CONSTRUCT DataRegLabel,50,560,60,20CONSTRUCT DataRegDisplay,50,540,60,20DataRegLabel.TEXT="Data"DataRegLabel.BACKCOLOR=$ff0000DataRegLabel.FORECOLOR=$ffffffCONSTRUCT SetData,120,540,30,20SetData.TEXT="Set"CONSTRUCT PCRegLabel,50,520,60,20CONSTRUCT PCRegDisplay,50,500,60,20PCRegLabel.TEXT="Pgm Ctr"PCRegLabel.BACKCOLOR=$ff0000PCRegLabel.FORECOLOR=$ffffffCONSTRUCT SetPCReg,120,500,30,20SetPCReg.TEXT="Set"CONSTRUCT IndexRegLabel,50,480,60,20CONSTRUCT IndexRegDisplay,50,460,60,20IndexRegLabel.TEXT="Ndx Reg"IndexRegLabel.BACKCOLOR=$ff0000IndexRegLabel.FORECOLOR=$ffffffCONSTRUCT SetIndexReg,120,460,30,20SetIndexReg.TEXT="Set"CONSTRUCT AccALabel,50,440,60,20CONSTRUCT AccADisplay,50,420,60,20AccALabel.TEXT="Acc A"AccALabel.BACKCOLOR=$ff0000AccALabel.FORECOLOR=$ffffffCONSTRUCT SetAccA,120,420,30,20SetAccA.TEXT="Set"CONSTRUCT AccBLabel,50,400,60,20CONSTRUCT AccBDisplay,50,380,60,20AccBLabel.TEXT="Acc B"AccBLabel.BACKCOLOR=$ff0000AccBLabel.FORECOLOR=$ffffffCONSTRUCT SetAccB,120,380,30,20SetAccB.TEXT="Set"CONSTRUCT BPRegLabel,50,360,60,20CONSTRUCT BPRegDisplay,50,340,60,20BPRegLabel.TEXT="BP Reg"BPRegLabel.BACKCOLOR=$ff0000BPRegLabel.FORECOLOR=$ffffffBPRegDisplay.TEXT="0000"CONSTRUCT SetBPReg,120,340,30,20SetBPReg.TEXT="Set"CONSTRUCT SPRegLabel,50,320,60,20CONSTRUCT SPRegDisplay,50,300,60,20SPRegLabel.TEXT="SP Reg"SPRegLabel.BACKCOLOR=$ff0000SPRegLabel.FORECOLOR=$ffffffCONSTRUCT SetSPReg,120,300,30,20SetSPReg.TEXT="Set"CONSTRUCT BPRegLabel,170,320,60,20CONSTRUCT BPRegDisplay,170,300,60,20CONSTRUCT KbdBackground,730,280,280,400KbdBackground.BACKCOLOR=$808080CONSTRUCT Line1,740,290,260,20Line1.BACKCOLOR=$c0c0c0CONSTRUCT Line2,740,310,260,20Line2.BACKCOLOR=$c0c0c0CONSTRUCT Key(1),740,350,75,20Key(1).TEXT="^"CONSTRUCT Key(2),832,350,75,20Key(2).TEXT="^"CONSTRUCT Key(3),924,350,75,20Key(3).TEXT="^"CONSTRUCT Key(4),740,380,75,20Key(4).TEXT="1"CONSTRUCT Key(5),832,380,75,20Key(5).TEXT="2"CONSTRUCT Key(6),924,380,75,20Key(6).TEXT="3"CONSTRUCT Key(7),740,410,75,20Key(7).TEXT="4"CONSTRUCT Key(8),832,410,75,20Key(8).TEXT="5"CONSTRUCT Key(9),924,410,75,20Key(9).TEXT="6"CONSTRUCT Key(10),740,440,75,20Key(10).TEXT="7"CONSTRUCT Key(11),832,440,75,20Key(11).TEXT="8"CONSTRUCT Key(12),924,440,75,20Key(12).TEXT="9"CONSTRUCT Key(13),740,470,75,20Key(13).TEXT="-"CONSTRUCT Key(14),832,470,75,20Key(14).TEXT="0"CONSTRUCT Key(15),924,470,75,20Key(15).TEXT="."CONSTRUCT Key(16),740,500,260,20Key(16).TEXT="ENTER"CONSTRUCT IOBackground,300,280,415,400IOBackground.BACKCOLOR=$ffff00GOSUB LoadBinEND EVENTAbaX:mov bl,[AccA]add bl,[AccB]mov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAddaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]add bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAddbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]add bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAdcaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]add bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAdcbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]add bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNAndaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]and bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSEsete [ZFlag]RETURNAndbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]and bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNBitaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]and bl,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNBitbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]and bl,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNClrX:TargetMem(OperandReg+1)=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNClraX:AccA=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNClrbX:AccB=0ZFlag=TRUENFlag=FALSECFlag=FALSEVFlag=FALSERETURNCmpaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]sub bl,alsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNCmpbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]sub bl,alsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNCbaX:mov bl,[AccA]sub bl,[AccB]setc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNComX:TempByte=TargetMem(OperandReg+1)not alsets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteCFlag=TRUEVFlag=FALSERETURNComaX:mov al,[AccA]not alsets [NFlag]sete [ZFlag]mov [AccA], alCFlag=TRUEVFlag=FALSERETURNCombX:mov al,[AccB]not alsets [NFlag]sete [ZFlag]mov [AccB], alCFlag=TRUEVFlag=FALSERETURNNegX:TempByte=TargetMem(OperandReg+1)neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNNegaX:mov al,[AccA]neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [AccA], alRETURNNegbX:mov al,[AccB]neg alsets [NFlag]sete [ZFlag]setc [CFlag]mov [AccB], alRETURNDaaX:; Don't needRETURNDecX:TempByte=TargetMem(OperandReg+1)sub al,1sets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNDecaX:mov al,[AccA]sub al,1sets [NFlag]sete [ZFlag]mov [AccA], alRETURNDecbX:mov al,[AccB]sub al,1sets [NFlag]sete [ZFlag]mov [AccB], alRETURNEoraX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]xor bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNEorbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]xor bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNIncX:TempByte=TargetMem(OperandReg+1)add al,1sets [NFlag]sete [ZFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNIncaX:mov al,[AccA]add al,1sets [NFlag]sete [ZFlag]mov [AccA], alRETURNIncbX:mov al,[AccB]add al,1sets [NFlag]sete [ZFlag]mov [AccB], alRETURNLdaaX:IF ImmFlag=False THEN	AccA=TargetMem(OperandReg+1)ELSE	AccA=OperandRegENDIFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNLdabX:IF ImmFlag=False THEN	AccB=TargetMem(OperandReg+1)ELSE	AccB=OperandRegENDIFor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNOraaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]or bl,almov [AccA],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNOrabX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]or bl,almov [AccB],blsets [NFlag]sete [ZFlag]VFlag=FALSERETURNPshaX:TargetMem(SPReg+1)=AccADECR SPRegRETURNPshbX:TargetMem(SPReg+1)=AccBDECR SPRegRETURNPulaX:INCR SPRegAccA=TargetMem(SPReg+1)RETURNPulbX:INCR SPRegAccB=TargetMem(SPReg+1)RETURNRolX:IF CFlag=FALSE THEN	clcELSE	stcENDIFTempByte=TargetMem(OperandReg+1)rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNRolaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNRolbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]rcl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNRorX:IF CFlag=FALSE THEN	clcELSE	stcENDIFTempByte=TargetMem(OperandReg+1)rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNRoraX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNRorbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]rcr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNAslX:TempByte=TargetMem(OperandReg+1)shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNAslaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNAslbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]shl al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNAsrX:TempByte=TargetMem(OperandReg+1)sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNAsraX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNAsrbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]sar al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNLsrX:TempByte=TargetMem(OperandReg+1)shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [TempByte], alTargetMem(OperandReg+1)=TempByteRETURNLsraX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccA]shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccA], alRETURNLsrbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFmov al,[AccB]shr al,1sets [NFlag]sete [ZFlag]setc [CFlag]seto [VFlag]mov [AccB], alRETURNStaaX:TargetMem(OperandReg+1)=AccAor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNStabX:TargetMem(OperandReg+1)=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNSubaX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]sub bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSubbX:IF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]sub bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbaX:mov bl,[AccA]sub bl,[AccB]mov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbcaX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccA]sub bl,almov [AccA],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNSbcbX:IF CFlag=FALSE THEN	clcELSE	stcENDIFIF ImmFlag=False THEN	TempByte=TargetMem(OperandReg+1)ELSE	TempByte=OperandRegENDIFmov bl,[AccB]sub bl,almov [AccB],blsetc [CFlag]seto [VFlag]sets [NFlag]sete [ZFlag]RETURNTabX:AccB=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNTbaX:AccA=AccBor al,alsets [NFlag]sete [ZFlag]VFlag=FALSERETURNTstX:TempByte=OperandRegor al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNTstaX:mov al,[AccA]or al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNTstbX:mov al,[AccB]or al,alsets [NFlag]sete [ZFlag]CFlag=FALSEVFlag=FALSERETURNCpxX:IF ImmFlag=False THEN	GOSUB GetData2ENDIFIF IndexReg=OperandReg THEN	ZFlag=TRUEELSE	ZFlag=FALSEENDIFVFlag=FALSENFlag=FALSECFlag=FALSE	RETURNDexX:DECR IndexRegsete [ZFlag]CFlag=FALSEVFlag=FALSENFlag=FALSERETURNDesX:DECR SPRegRETURNInxX:INCR IndexRegsete [ZFlag]CFlag=FALSEVFlag=FALSENFlag=FALSERETURNInsX:INCR SPRegRETURNLdxX:IF ImmFlag=False THEN	GOSUB GetData2	IndexReg=OperandRegELSE	IndexReg=OperandRegENDIFVFlag=FALSERETURNLdsX:IF ImmFlag=False THEN	GOSUB GetData2	SPReg=OperandRegELSE	SPReg=OperandRegENDIFVFlag=FALSERETURNStxX:StoreData=IndexReg/256or al,alsets [NFlag]mov [TempByte],alTargetMem(OperandReg+1)=StoreDataStoreData=IndexRegadd al,[TempByte]sete [ZFlag]TargetMem(OperandReg+2)=StoreDataRETURNStsX:StoreData=SPReg/256or al,alsets [NFlag]mov [TempByte],alTargetMem(OperandReg+1)=StoreDataStoreData=IndexRegadd al,[TempByte]sete [ZFlag]TargetMem(OperandReg+2)=StoreDataRETURNTxsX:SPReg=IndexRegRETURNTsxX:IndexReg=SPRegRETURNBraX:PCReg=OperandRegRETURNBccX:IF CFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBcsX:IF CFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBeqX:IF ZFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBgeX:IF NFlag=TRUE AND VFlag=TRUE THEN	PCReg=OperandRegENDIFIF NFlag=FALSE AND VFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBgtX:RETURNBhiX:IF ZFlag=TRUE AND CFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBleX:RETURNBlsX:IF ZFlag=TRUE OR CFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBltX:IF NFlag=TRUE AND VFlag=TRUE THEN	RETURNENDIFIF NFlag=FALSE AND VFlag=FALSE THEN	RETURNENDIFRETURNBmiX:IF NFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBneX:IF ZFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBvcX:IF VFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNBvsX:IF VFlag=TRUE THEN	PCReg=OperandRegENDIFRETURNBplX:IF NFlag=FALSE THEN	PCReg=OperandRegENDIFRETURNJmpX:PCReg=OperandReg+1RETURNBsrX:DECR PCRegStoreData=PCReg/256TargetMem(SPReg)=StoreDataStoreData=PCRegTargetMem(SPReg+1)=StoreDataPCReg=OperandRegSPReg=SPReg-2RETURNJsrX:DECR PCRegStoreData=PCReg/256TargetMem(SPReg)=StoreDataStoreData=PCRegTargetMem(SPReg+1)=StoreDataPCReg=OperandReg+1SPReg=SPReg-2RETURNNopX:; Do NothingRETURNRtiX:RETURNRtsX:SPReg=SPReg+2TempInt=TargetMem(SPReg)*256OperandReg=TempInt+TargetMem(SPReg+1)PCReg=OperandReg+1RETURNSwiX:RETURNWaiX:RETURNClcX:CFlag=FALSERETURNCliX:IFlag=FALSERETURNClvX:VFlag=FALSERETURNSecX:CFlag=TRUERETURNSeiX:IFlag=TRUERETURNSevX:VFlag=TRUERETURNTapX:; Don't needRETURNTpaX:; Don't needRETURNImm1X:ImmFlag=TRUEGOSUB GetOp1PCReg=PCReg+2RETURNImm2X:ImmFlag=TRUEGOSUB GetImmOp2PCReg=PCReg+3RETURNDirX:ImmFlag=FALSEGOSUB GetOp1PCReg=PCReg+2RETURNExtX:ImmFlag=FALSEGOSUB GetOp2PCReg=PCReg+3RETURNIndexX:ImmFlag=FALSEGOSUB GetOp1OperandReg=OperandReg+IndexRegPCReg=PCReg+2RETURNInherentX:ImmFlag=FALSEINCR PCRegRETURNRelX:ImmFlag=FALSEGOSUB GetOp1IF OperandReg<128 THEN; Branch Forward	OperandReg=OperandReg+2+PCRegELSE	TempByte=$fe-OperandReg; Branch Backward	OperandReg=PCReg-TempByteENDIFPCReg=PCReg+2RETURNTrapX:ImmFlag=FALSEINCR PCRegRETURNTimerLight.COMMANDIF TimerFlag=FALSE THEN	TimerLight.BACKCOLOR=$ff00ELSE	TimerLight.BACKCOLOR=$ffENDIFTimerFlag=NOT(TimerFlag)END EVENTVLight.COMMANDIF VFlag=FALSE THEN	VLight.BACKCOLOR=$ff00ELSE	VLight.BACKCOLOR=$ffENDIFVFlag=NOT(VFlag)END EVENTILight.COMMANDIF IFlag=FALSE THEN	ILight.BACKCOLOR=$ff00ELSE	ILight.BACKCOLOR=$ffENDIFIFlag=NOT(IFlag)END EVENTNLight.COMMANDIF NFlag=FALSE THEN	NLight.BACKCOLOR=$ff00ELSE	NLight.BACKCOLOR=$ffENDIFNFlag=NOT(NFlag)END EVENTZLight.COMMANDIF ZFlag=FALSE THEN	ZLight.BACKCOLOR=$ff00ELSE	ZLight.BACKCOLOR=$ffENDIFZFlag=NOT(ZFlag)END EVENTCLight.COMMANDIF CFlag=FALSE THEN	CLight.BACKCOLOR=$ff00ELSE	CLight.BACKCOLOR=$ffENDIFCFlag=NOT(CFlag)END EVENTRunButton.COMMANDIF RunFlag=FALSE THEN	RunFlag=TRUE	RunLight.BACKCOLOR=$ff00	RunButton.TEXT="HALT"	Timer1.INTERVAL=1ELSE	Timer1.STOP	RunFlag=FALSE	RunLight.BACKCOLOR=$ff	RunButton.TEXT="RUN"	GOSUB DisplayInst	HexData=HEX(PCReg-1)	GOSUB Pad4	PCRegDisplay.TEXT=HexDataENDIFEND EVENTTimer1.TIMERGOSUB DisplayInst;IF RunFlag=FALSE THEN	RETURNENDIFInstReg=TargetMem(PCReg)GOSUB [OpCode(InstReg+1).OpModeDispatch]GOSUB [OpCode(InstReg+1).OpInstDispatch]IF PCReg-1=BPReg THEN	Timer1.STOP		RunFlag=FALSE	RunLight.BACKCOLOR=$ff	RunButton.TEXT="RUN"	GOSUB DisplayInst	HexData=HEX(PCReg-1)	GOSUB Pad4	PCRegDisplay.TEXT=HexData	RETURN;;ENDIFEND EVENTAddrRegDisplay.CHANGEGOSUB ChangeAddrEND EVENTChangeAddr:TempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)+1TempInt=TargetMem(AddrReg)HexData=HEX(TempInt)GOSUB Pad2DataRegDisplay.TEXT=HexDataRETURNSetPCReg.COMMANDPCRegSet=TRUETempStr=PCRegDisplay.TEXTHexData="$"+TempStrPCReg=VAL(HexData)+1HexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetData.COMMANDTempStr=DataRegDisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)TargetMem(AddrReg)=DataRegGOSUB ChangeAddrEND EVENTSetAccA.COMMANDTempStr=AccADisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)AccA=DataRegEND EVENTSetAccB.COMMANDTempStr=AccBDisplay.TEXTHexData="$"+TempStrDataReg=VAL(HexData)AccB=DataRegEND EVENTSetIndexReg.COMMANDTempStr=IndexRegDisplay.TEXTHexData="$"+TempStrIndexReg=VAL(HexData)HexData=HEX(IndexReg)GOSUB Pad4IndexRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetBPReg.COMMANDTempStr=BPRegDisplay.TEXTHexData="$"+TempStrBPReg=VAL(HexData)HexData=HEX(BPReg)GOSUB Pad4BPRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTSetSPReg.COMMANDTempStr=SPRegDisplay.TEXTHexData="$"+TempStrSPReg=VAL(HexData)HexData=HEX(SPReg)GOSUB Pad4SPRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENTPad2:IF LEN(HexData)=1 THEN	TempHexData="0"+HexData	HexData=TempHexDataENDIFRETURNPad4:TempInt=LEN(HexData)SELECT CASE TempInt	CASE 1		TempHexData="000"+HexData	CASE 2		TempHexData="00"+HexData	CASE 3		TempHexData="0"+HexData	CASE 4		TempHexData=HexDataEND SELECTHexData=TempHexDataRETURNIncAddr.COMMANDTempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)INCR AddrRegHexData=HEX(AddrReg)GOSUB Pad4AddrRegDisplay.TEXT=HexDataEND EVENTDecAddr.COMMANDTempStr=AddrRegDisplay.TEXTHexData="$"+TempStrAddrReg=VAL(HexData)DECR AddrRegHexData=HEX(AddrReg)GOSUB Pad4AddrRegDisplay.TEXT=HexDataEND EVENTKey.COMMANDTempStr=str(ArrayIndex)RunButton.text=TempStrEND EVENTLoadButton.COMMANDGOSUB LoadBinEND EVENTLoadBin:OPEN BinFile,"Romer.bin":READGET BinFile,TargetMemCLOSE BinFileRETURNDisplayInst:InstReg=TargetMem(PCReg)TempStr=OpCode(InstReg+1).OpNameTempInt=OpCode(InstReg+1).OpModeSELECT CASE TempInt	CASE TRAPMODE	CASE INHERENTMODE		CASE IMM1MODE		GOSUB GetOp1		HexData=HEX(OperandReg)		GOSUB Pad2		TempStr=TempStr+" #$"+HexData	CASE IMM2MODE		GOSUB GetOp2		HexData=HEX(OperandReg)		GOSUB Pad4		TempStr=TempStr+" #$"+HexData	CASE DIRECTMODE		GOSUB GetOp1		HexData=HEX(OperandReg)		GOSUB Pad2		TempStr=TempStr+" $00"+HexData	CASE INDEXEDMODE		GOSUB GetOp1		HexData=HEX(OperandReg)		GOSUB Pad2		TempStr=TempStr+"  $"+HexData+",X"		CASE EXTENDEDMODE		GOSUB GetOp2		HexData=HEX(OperandReg)		GOSUB Pad4		TempStr=TempStr+" $"+HexData		CASE RELATIVEMODE		GOSUB GetOp1		IF OperandReg<128 THEN; Branch Forward			OperandReg=OperandReg+1+PCReg		ELSE			TempByte=$ff-OperandReg			OperandReg=PCReg-TempByte		ENDIF		HexData=HEX(OperandReg)		GOSUB Pad2		TempStr=TempStr+" $"+HexDataEND SELECTNextInst.TEXT=TempStrHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataHexData=HEX(IndexReg)GOSUB Pad4IndexRegDisplay.TEXT=HexDataHexData=HEX(SPReg)GOSUB Pad4SPRegDisplay.TEXT=HexDataHexData=HEX(AccA)GOSUB Pad2AccADisplay.TEXT=HexDataHexData=HEX(AccB)GOSUB Pad2AccBDisplay.TEXT=HexDataIF IFlag=FALSE THEN	ILight.BACKCOLOR=$ffELSE	ILight.BACKCOLOR=$ff00ENDIFIF NFlag=FALSE THEN	NLight.BACKCOLOR=$ffELSE	NLight.BACKCOLOR=$ff00ENDIFIF ZFlag=FALSE THEN	ZLight.BACKCOLOR=$ffELSE	ZLight.BACKCOLOR=$ff00ENDIFIF VFlag=FALSE THEN	VLight.BACKCOLOR=$ffELSE	VLight.BACKCOLOR=$ff00ENDIFIF CFlag=FALSE THEN	CLight.BACKCOLOR=$ffELSE	CLight.BACKCOLOR=$ff00ENDIFRETURNGetOp1:OperandReg=TargetMem(PCReg+1)RETURNGetOp2:OperandReg=TargetMem(PCReg+1)*256OperandReg=OperandReg+TargetMem(PCReg+2)RETURNGetImmOp2:OperandReg=TargetMem(PCReg+1)*256or ax,axsets [NFlag]OperandReg=OperandReg+TargetMem(PCReg+2)or ax,axsete [ZFlag]RETURNGetData2:TempInt=TargetMem(OperandReg+1)*256or ax,axsets [NFlag]OperandReg=TempInt+TargetMem(OperandReg+2)or ax,axsete [ZFlag]RETURNGetData2a:TempInt=TargetMem(OperandReg+1)*256OperandReg=TempInt+TargetMem(OperandReg+2)RETURNStepButton.COMMANDIF PCRegSet=False THEN	WARNINGBOX "Program Counter Not Set",TempStr,MB_OK	RETURNENDIFGOSUB StepCodeEND EVENTStepCode:InstReg=TargetMem(PCReg)GOSUB [OpCode(InstReg+1).OpModeDispatch]GOSUB [OpCode(InstReg+1).OpInstDispatch]GOSUB DisplayInstHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataRETURNResetButton.COMMANDPCRegSet=TRUEPCReg=TargetMem($ffff)*256PCReg=PCReg+TargetMem($10000)INCR PCRegHexData=HEX(PCReg-1)GOSUB Pad4PCRegDisplay.TEXT=HexDataGOSUB DisplayInstEND EVENT